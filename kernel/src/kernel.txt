
kernel32.elf:     file format elf32-i386


Disassembly of section .text:

c0102000 <INIT_SCHEDULER>:

/**
 * Initiate the scheduler module
 */
void INIT_SCHEDULER(void)
{
c0102000:	55                   	push   %ebp
c0102001:	89 e5                	mov    %esp,%ebp
c0102003:	83 ec 28             	sub    $0x28,%esp
	set_GDT_entry(5, (uint32_t) &tss, sizeof(tss), 0x89, 0x8);
c0102006:	b8 00 f0 10 c0       	mov    $0xc010f000,%eax
c010200b:	c7 44 24 10 08 00 00 	movl   $0x8,0x10(%esp)
c0102012:	00 
c0102013:	c7 44 24 0c 89 00 00 	movl   $0x89,0xc(%esp)
c010201a:	00 
c010201b:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
c0102022:	00 
c0102023:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102027:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c010202e:	e8 89 4b 00 00       	call   c0106bbc <set_GDT_entry>
	load_gdt(5);
c0102033:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c010203a:	e8 fe 4b 00 00       	call   c0106c3d <load_gdt>
	asm volatile("ltr %%ax" : : "a" (5 << 3));
c010203f:	b8 28 00 00 00       	mov    $0x28,%eax
c0102044:	0f 00 d8             	ltr    %ax
	kernelstack = malloc(KERNEL_STACK_SIZE) + KERNEL_STACK_SIZE;
c0102047:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
c010204e:	e8 71 65 00 00       	call   c01085c4 <malloc>
c0102053:	05 00 10 00 00       	add    $0x1000,%eax
c0102058:	a3 00 30 11 c0       	mov    %eax,0xc0113000
	tss.esp0 = (uint32_t)kernelstack;
c010205d:	a1 00 30 11 c0       	mov    0xc0113000,%eax
c0102062:	a3 04 f0 10 c0       	mov    %eax,0xc010f004

    running_threads = list_create();
c0102067:	e8 f4 6b 00 00       	call   c0108c60 <list_create>
c010206c:	a3 0c 30 11 c0       	mov    %eax,0xc011300c
    process_list = list_create();
c0102071:	e8 ea 6b 00 00       	call   c0108c60 <list_create>
c0102076:	a3 44 19 11 c0       	mov    %eax,0xc0111944
    zombie_list = list_create();
c010207b:	e8 e0 6b 00 00       	call   c0108c60 <list_create>
c0102080:	a3 48 19 11 c0       	mov    %eax,0xc0111948
    kernel_state = process_create("Kernel INIT", "initiate system", PROCESS_ACTIVE, NULL);
c0102085:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010208c:	00 
c010208d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0102094:	00 
c0102095:	c7 44 24 04 00 b0 10 	movl   $0xc010b000,0x4(%esp)
c010209c:	c0 
c010209d:	c7 04 24 10 b0 10 c0 	movl   $0xc010b010,(%esp)
c01020a4:	e8 ec 5c 00 00       	call   c0107d95 <process_create>
c01020a9:	a3 04 30 11 c0       	mov    %eax,0xc0113004
    current_thread = thread_create(kernel_state, KERNELMODE, 0, NULL, 0, 0,0);
c01020ae:	a1 04 30 11 c0       	mov    0xc0113004,%eax
c01020b3:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c01020ba:	00 
c01020bb:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c01020c2:	00 
c01020c3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c01020ca:	00 
c01020cb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c01020d2:	00 
c01020d3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c01020da:	00 
c01020db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01020e2:	00 
c01020e3:	89 04 24             	mov    %eax,(%esp)
c01020e6:	e8 db 37 00 00       	call   c01058c6 <thread_create>
c01020eb:	a3 08 30 11 c0       	mov    %eax,0xc0113008
}
c01020f0:	c9                   	leave  
c01020f1:	c3                   	ret    

c01020f2 <task_schedule>:
/**
 * performs context switches
 * @param process pointer to the process state
 */
struct cpu_state *task_schedule(struct cpu_state *cpu)
{
c01020f2:	55                   	push   %ebp
c01020f3:	89 e5                	mov    %esp,%ebp
c01020f5:	57                   	push   %edi
c01020f6:	56                   	push   %esi
c01020f7:	53                   	push   %ebx
c01020f8:	83 ec 1c             	sub    $0x1c,%esp
    *current_thread->state = *cpu;
c01020fb:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102100:	8b 10                	mov    (%eax),%edx
c0102102:	8b 45 08             	mov    0x8(%ebp),%eax
c0102105:	89 c3                	mov    %eax,%ebx
c0102107:	b8 12 00 00 00       	mov    $0x12,%eax
c010210c:	89 d7                	mov    %edx,%edi
c010210e:	89 de                	mov    %ebx,%esi
c0102110:	89 c1                	mov    %eax,%ecx
c0102112:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    if(current_thread->flags & THREAD_ZOMBIE)
c0102114:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102119:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c010211d:	0f b7 c0             	movzwl %ax,%eax
c0102120:	83 e0 08             	and    $0x8,%eax
c0102123:	85 c0                	test   %eax,%eax
c0102125:	0f 84 84 00 00 00    	je     c01021af <task_schedule+0xbd>
    {
        thread_kill_sub(current_thread);
c010212b:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102130:	89 04 24             	mov    %eax,(%esp)
c0102133:	e8 f0 39 00 00       	call   c0105b28 <thread_kill_sub>
        if(list_is_empty(running_threads))
c0102138:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c010213d:	89 04 24             	mov    %eax,(%esp)
c0102140:	e8 cc 6e 00 00       	call   c0109011 <list_is_empty>
c0102145:	85 c0                	test   %eax,%eax
c0102147:	74 14                	je     c010215d <task_schedule+0x6b>
        {
            asm volatile("sti");
c0102149:	fb                   	sti    
            while(list_is_empty(running_threads)){}
c010214a:	90                   	nop
c010214b:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c0102150:	89 04 24             	mov    %eax,(%esp)
c0102153:	e8 b9 6e 00 00       	call   c0109011 <list_is_empty>
c0102158:	85 c0                	test   %eax,%eax
c010215a:	75 ef                	jne    c010214b <task_schedule+0x59>
            asm volatile("cli");
c010215c:	fa                   	cli    
        }

        list_set_first(running_threads);
c010215d:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c0102162:	89 04 24             	mov    %eax,(%esp)
c0102165:	e8 7c 6e 00 00       	call   c0108fe6 <list_set_first>
        current_thread = list_get_current(running_threads);
c010216a:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c010216f:	89 04 24             	mov    %eax,(%esp)
c0102172:	e8 1c 6e 00 00       	call   c0108f93 <list_get_current>
c0102177:	a3 08 30 11 c0       	mov    %eax,0xc0113008
        vmm_switch_context(current_thread->context);
c010217c:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102181:	8b 40 08             	mov    0x8(%eax),%eax
c0102184:	89 04 24             	mov    %eax,(%esp)
c0102187:	e8 70 4e 00 00       	call   c0106ffc <vmm_switch_context>
        memcpy(cpu, current_thread->state, sizeof(struct cpu_state));
c010218c:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102191:	8b 00                	mov    (%eax),%eax
c0102193:	c7 44 24 08 48 00 00 	movl   $0x48,0x8(%esp)
c010219a:	00 
c010219b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010219f:	8b 45 08             	mov    0x8(%ebp),%eax
c01021a2:	89 04 24             	mov    %eax,(%esp)
c01021a5:	e8 82 7e 00 00       	call   c010a02c <memcpy>
c01021aa:	e9 93 00 00 00       	jmp    c0102242 <task_schedule+0x150>
    }
    else if(current_thread->ticks == 0)
c01021af:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01021b4:	8b 40 0c             	mov    0xc(%eax),%eax
c01021b7:	85 c0                	test   %eax,%eax
c01021b9:	75 79                	jne    c0102234 <task_schedule+0x142>
    {
        current_thread->ticks = 10;
c01021bb:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01021c0:	c7 40 0c 0a 00 00 00 	movl   $0xa,0xc(%eax)
        list_next(running_threads);
c01021c7:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c01021cc:	89 04 24             	mov    %eax,(%esp)
c01021cf:	e8 cd 6d 00 00       	call   c0108fa1 <list_next>
        if(list_is_last(running_threads))
c01021d4:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c01021d9:	89 04 24             	mov    %eax,(%esp)
c01021dc:	e8 ed 6d 00 00       	call   c0108fce <list_is_last>
c01021e1:	85 c0                	test   %eax,%eax
c01021e3:	74 0d                	je     c01021f2 <task_schedule+0x100>
            list_set_first(running_threads);
c01021e5:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c01021ea:	89 04 24             	mov    %eax,(%esp)
c01021ed:	e8 f4 6d 00 00       	call   c0108fe6 <list_set_first>
        current_thread = list_get_current(running_threads);
c01021f2:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c01021f7:	89 04 24             	mov    %eax,(%esp)
c01021fa:	e8 94 6d 00 00       	call   c0108f93 <list_get_current>
c01021ff:	a3 08 30 11 c0       	mov    %eax,0xc0113008
        vmm_switch_context(current_thread->context);
c0102204:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102209:	8b 40 08             	mov    0x8(%eax),%eax
c010220c:	89 04 24             	mov    %eax,(%esp)
c010220f:	e8 e8 4d 00 00       	call   c0106ffc <vmm_switch_context>
        memcpy(cpu, current_thread->state, sizeof(struct cpu_state));
c0102214:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102219:	8b 00                	mov    (%eax),%eax
c010221b:	c7 44 24 08 48 00 00 	movl   $0x48,0x8(%esp)
c0102222:	00 
c0102223:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102227:	8b 45 08             	mov    0x8(%ebp),%eax
c010222a:	89 04 24             	mov    %eax,(%esp)
c010222d:	e8 fa 7d 00 00       	call   c010a02c <memcpy>
c0102232:	eb 0e                	jmp    c0102242 <task_schedule+0x150>
    }
    else
    {
        current_thread->ticks--;
c0102234:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0102239:	8b 50 0c             	mov    0xc(%eax),%edx
c010223c:	83 ea 01             	sub    $0x1,%edx
c010223f:	89 50 0c             	mov    %edx,0xc(%eax)
    }
	EOI(0);
c0102242:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0102249:	e8 68 1f 00 00       	call   c01041b6 <EOI>
	return cpu;
c010224e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0102251:	83 c4 1c             	add    $0x1c,%esp
c0102254:	5b                   	pop    %ebx
c0102255:	5e                   	pop    %esi
c0102256:	5f                   	pop    %edi
c0102257:	5d                   	pop    %ebp
c0102258:	c3                   	ret    
c0102259:	66 90                	xchg   %ax,%ax
c010225b:	90                   	nop

c010225c <pd_dump>:
 * Only works wehne every PD is mapped in in kernelspace Area
 * @param pointer to the phys. pd frame
 * @return void
 **/

void pd_dump(arch_vmm_context_t *context){
c010225c:	55                   	push   %ebp
c010225d:	89 e5                	mov    %esp,%ebp
c010225f:	83 ec 48             	sub    $0x48,%esp
    int pdi, pti, phys_base, virt_base, size, sec = 0;
c0102262:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    uint32_t *pt;
    uint32_t *pd = context->entries;
c0102269:	8b 45 08             	mov    0x8(%ebp),%eax
c010226c:	8b 00                	mov    (%eax),%eax
c010226e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    for( pdi = 0; pdi < PD_LENGTH; pdi++ ){
c0102271:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0102278:	e9 27 02 00 00       	jmp    c01024a4 <pd_dump+0x248>
        if(sec && (pd[pdi] & 1) == 0){
c010227d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0102281:	74 63                	je     c01022e6 <pd_dump+0x8a>
c0102283:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102286:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010228d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0102290:	01 d0                	add    %edx,%eax
c0102292:	8b 00                	mov    (%eax),%eax
c0102294:	83 e0 01             	and    $0x1,%eax
c0102297:	85 c0                	test   %eax,%eax
c0102299:	75 4b                	jne    c01022e6 <pd_dump+0x8a>
            printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c010229b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010229e:	89 c2                	mov    %eax,%edx
c01022a0:	c1 e2 0c             	shl    $0xc,%edx
c01022a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01022a6:	01 d0                	add    %edx,%eax
c01022a8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01022ab:	89 d1                	mov    %edx,%ecx
c01022ad:	c1 e1 0c             	shl    $0xc,%ecx
c01022b0:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01022b3:	01 ca                	add    %ecx,%edx
c01022b5:	89 44 24 10          	mov    %eax,0x10(%esp)
c01022b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01022bc:	89 44 24 0c          	mov    %eax,0xc(%esp)
c01022c0:	89 54 24 08          	mov    %edx,0x8(%esp)
c01022c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01022c7:	89 44 24 04          	mov    %eax,0x4(%esp)
c01022cb:	c7 04 24 1c b0 10 c0 	movl   $0xc010b01c,(%esp)
c01022d2:	e8 a5 30 00 00       	call   c010537c <printf>
            sec = 0;
c01022d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        }

        while( (pd[pdi] & 1) == 0 ){
c01022de:	eb 06                	jmp    c01022e6 <pd_dump+0x8a>
            pdi++;
c01022e0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01022e4:	eb 01                	jmp    c01022e7 <pd_dump+0x8b>
        if(sec && (pd[pdi] & 1) == 0){
            printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
            sec = 0;
        }

        while( (pd[pdi] & 1) == 0 ){
c01022e6:	90                   	nop
c01022e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01022ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01022f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01022f4:	01 d0                	add    %edx,%eax
c01022f6:	8b 00                	mov    (%eax),%eax
c01022f8:	83 e0 01             	and    $0x1,%eax
c01022fb:	85 c0                	test   %eax,%eax
c01022fd:	74 e1                	je     c01022e0 <pd_dump+0x84>
            pdi++;
        }

        pt = pt_get(context, pdi, 0);
c01022ff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0102306:	00 
c0102307:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010230a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010230e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102311:	89 04 24             	mov    %eax,(%esp)
c0102314:	e8 20 3d 00 00       	call   c0106039 <pt_get>
c0102319:	89 45 d8             	mov    %eax,-0x28(%ebp)

        for( pti = 0; pti < PT_LENGTH; pti++ ){
c010231c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0102323:	e9 6b 01 00 00       	jmp    c0102493 <pd_dump+0x237>
            if(sec && (pt[pti] & 1) == 0){
c0102328:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010232c:	74 63                	je     c0102391 <pd_dump+0x135>
c010232e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102331:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0102338:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010233b:	01 d0                	add    %edx,%eax
c010233d:	8b 00                	mov    (%eax),%eax
c010233f:	83 e0 01             	and    $0x1,%eax
c0102342:	85 c0                	test   %eax,%eax
c0102344:	75 4b                	jne    c0102391 <pd_dump+0x135>
                printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c0102346:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0102349:	89 c2                	mov    %eax,%edx
c010234b:	c1 e2 0c             	shl    $0xc,%edx
c010234e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0102351:	01 d0                	add    %edx,%eax
c0102353:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0102356:	89 d1                	mov    %edx,%ecx
c0102358:	c1 e1 0c             	shl    $0xc,%ecx
c010235b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010235e:	01 ca                	add    %ecx,%edx
c0102360:	89 44 24 10          	mov    %eax,0x10(%esp)
c0102364:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0102367:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010236b:	89 54 24 08          	mov    %edx,0x8(%esp)
c010236f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102372:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102376:	c7 04 24 1c b0 10 c0 	movl   $0xc010b01c,(%esp)
c010237d:	e8 fa 2f 00 00       	call   c010537c <printf>
                sec = 0;
c0102382:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
            }

            while( (pt[pti] & 1) == 0 ){
c0102389:	eb 06                	jmp    c0102391 <pd_dump+0x135>
                pti++;
c010238b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010238f:	eb 01                	jmp    c0102392 <pd_dump+0x136>
            if(sec && (pt[pti] & 1) == 0){
                printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
                sec = 0;
            }

            while( (pt[pti] & 1) == 0 ){
c0102391:	90                   	nop
c0102392:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102395:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010239c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010239f:	01 d0                	add    %edx,%eax
c01023a1:	8b 00                	mov    (%eax),%eax
c01023a3:	83 e0 01             	and    $0x1,%eax
c01023a6:	85 c0                	test   %eax,%eax
c01023a8:	74 e1                	je     c010238b <pd_dump+0x12f>
                pti++;
            }
            if(sec == 0){
c01023aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c01023ae:	75 3f                	jne    c01023ef <pd_dump+0x193>
                sec = 1;
c01023b0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
                phys_base = ((pt[pti] | 0xfff) ^ 0xfff);
c01023b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01023ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01023c1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01023c4:	01 d0                	add    %edx,%eax
c01023c6:	8b 00                	mov    (%eax),%eax
c01023c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01023cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
                virt_base = (pdi << 22) | (pti << 12);
c01023d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01023d3:	89 c2                	mov    %eax,%edx
c01023d5:	c1 e2 16             	shl    $0x16,%edx
c01023d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01023db:	c1 e0 0c             	shl    $0xc,%eax
c01023de:	09 d0                	or     %edx,%eax
c01023e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
                size = 0;
c01023e3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c01023ea:	e9 a0 00 00 00       	jmp    c010248f <pd_dump+0x233>

            }else{
                if( (phys_base + (4096 * (size+1) )) == ( (pt[pti] | 0xfff) ^ 0xfff) ){
c01023ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01023f2:	83 c0 01             	add    $0x1,%eax
c01023f5:	89 c2                	mov    %eax,%edx
c01023f7:	c1 e2 0c             	shl    $0xc,%edx
c01023fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01023fd:	01 d0                	add    %edx,%eax
c01023ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0102402:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c0102409:	8b 55 d8             	mov    -0x28(%ebp),%edx
c010240c:	01 ca                	add    %ecx,%edx
c010240e:	8b 12                	mov    (%edx),%edx
c0102410:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0102416:	39 d0                	cmp    %edx,%eax
c0102418:	75 06                	jne    c0102420 <pd_dump+0x1c4>
                    size++;
c010241a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010241e:	eb 6f                	jmp    c010248f <pd_dump+0x233>
                }else{
                    printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c0102420:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0102423:	89 c2                	mov    %eax,%edx
c0102425:	c1 e2 0c             	shl    $0xc,%edx
c0102428:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010242b:	01 d0                	add    %edx,%eax
c010242d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0102430:	89 d1                	mov    %edx,%ecx
c0102432:	c1 e1 0c             	shl    $0xc,%ecx
c0102435:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0102438:	01 ca                	add    %ecx,%edx
c010243a:	89 44 24 10          	mov    %eax,0x10(%esp)
c010243e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0102441:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0102445:	89 54 24 08          	mov    %edx,0x8(%esp)
c0102449:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010244c:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102450:	c7 04 24 1c b0 10 c0 	movl   $0xc010b01c,(%esp)
c0102457:	e8 20 2f 00 00       	call   c010537c <printf>
                    phys_base = ((pt[pti] | 0xfff) ^ 0xfff);
c010245c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010245f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0102466:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0102469:	01 d0                	add    %edx,%eax
c010246b:	8b 00                	mov    (%eax),%eax
c010246d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0102472:	89 45 ec             	mov    %eax,-0x14(%ebp)
                    virt_base = (pdi << 22) | (pti << 12);
c0102475:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102478:	89 c2                	mov    %eax,%edx
c010247a:	c1 e2 16             	shl    $0x16,%edx
c010247d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102480:	c1 e0 0c             	shl    $0xc,%eax
c0102483:	09 d0                	or     %edx,%eax
c0102485:	89 45 e8             	mov    %eax,-0x18(%ebp)
                    size = 0;
c0102488:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            pdi++;
        }

        pt = pt_get(context, pdi, 0);

        for( pti = 0; pti < PT_LENGTH; pti++ ){
c010248f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0102493:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010249a:	0f 8e 88 fe ff ff    	jle    c0102328 <pd_dump+0xcc>

void pd_dump(arch_vmm_context_t *context){
    int pdi, pti, phys_base, virt_base, size, sec = 0;
    uint32_t *pt;
    uint32_t *pd = context->entries;
    for( pdi = 0; pdi < PD_LENGTH; pdi++ ){
c01024a0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01024a4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c01024ab:	0f 8e cc fd ff ff    	jle    c010227d <pd_dump+0x21>
            }
        }

    }

    if(sec){
c01024b1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c01024b5:	74 3c                	je     c01024f3 <pd_dump+0x297>
        printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c01024b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01024ba:	89 c2                	mov    %eax,%edx
c01024bc:	c1 e2 0c             	shl    $0xc,%edx
c01024bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01024c2:	01 d0                	add    %edx,%eax
c01024c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01024c7:	89 d1                	mov    %edx,%ecx
c01024c9:	c1 e1 0c             	shl    $0xc,%ecx
c01024cc:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01024cf:	01 ca                	add    %ecx,%edx
c01024d1:	89 44 24 10          	mov    %eax,0x10(%esp)
c01024d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01024d8:	89 44 24 0c          	mov    %eax,0xc(%esp)
c01024dc:	89 54 24 08          	mov    %edx,0x8(%esp)
c01024e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01024e3:	89 44 24 04          	mov    %eax,0x4(%esp)
c01024e7:	c7 04 24 1c b0 10 c0 	movl   $0xc010b01c,(%esp)
c01024ee:	e8 89 2e 00 00       	call   c010537c <printf>
    }
}
c01024f3:	c9                   	leave  
c01024f4:	c3                   	ret    
c01024f5:	66 90                	xchg   %ax,%ax
c01024f7:	90                   	nop

c01024f8 <inb>:
*/

#include <stdint.h>


static inline uint8_t inb(uint16_t port) {
c01024f8:	55                   	push   %ebp
c01024f9:	89 e5                	mov    %esp,%ebp
c01024fb:	53                   	push   %ebx
c01024fc:	83 ec 14             	sub    $0x14,%esp
c01024ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0102502:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	uint8_t result;
	asm volatile("inb %1, %0" : "=a" (result) : "Nd" (port));
c0102506:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c010250a:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c010250e:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c0102512:	ec                   	in     (%dx),%al
c0102513:	89 c3                	mov    %eax,%ebx
c0102515:	88 5d fb             	mov    %bl,-0x5(%ebp)
	return result;
c0102518:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
}
c010251c:	83 c4 14             	add    $0x14,%esp
c010251f:	5b                   	pop    %ebx
c0102520:	5d                   	pop    %ebp
c0102521:	c3                   	ret    

c0102522 <outb>:
	uint32_t result;
	asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
	return result;
}

static inline void outb(uint16_t port, uint8_t value) {
c0102522:	55                   	push   %ebp
c0102523:	89 e5                	mov    %esp,%ebp
c0102525:	83 ec 08             	sub    $0x8,%esp
c0102528:	8b 55 08             	mov    0x8(%ebp),%edx
c010252b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010252e:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0102532:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c0102535:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0102539:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c010253d:	ee                   	out    %al,(%dx)
}
c010253e:	c9                   	leave  
c010253f:	c3                   	ret    

c0102540 <send_kbc_command>:
 * @param port Port for the Command
 * @param command Command for the KBC
 *
 * @return void
 */
void send_kbc_command(uint8_t port, uint8_t command) {
c0102540:	55                   	push   %ebp
c0102541:	89 e5                	mov    %esp,%ebp
c0102543:	83 ec 10             	sub    $0x10,%esp
c0102546:	8b 55 08             	mov    0x8(%ebp),%edx
c0102549:	8b 45 0c             	mov    0xc(%ebp),%eax
c010254c:	88 55 fc             	mov    %dl,-0x4(%ebp)
c010254f:	88 45 f8             	mov    %al,-0x8(%ebp)
  	while (inb(0x64) & 0x2);//Warten bis Eigabepuffer leer ist
c0102552:	90                   	nop
c0102553:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
c010255a:	e8 99 ff ff ff       	call   c01024f8 <inb>
c010255f:	0f b6 c0             	movzbl %al,%eax
c0102562:	83 e0 02             	and    $0x2,%eax
c0102565:	85 c0                	test   %eax,%eax
c0102567:	75 ea                	jne    c0102553 <send_kbc_command+0x13>
  	outb(port, command);//KBC-Befehl senden
c0102569:	0f b6 55 f8          	movzbl -0x8(%ebp),%edx
c010256d:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0102571:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102575:	89 04 24             	mov    %eax,(%esp)
c0102578:	e8 a5 ff ff ff       	call   c0102522 <outb>
  	while (inb(0x60) != 0xFA);
c010257d:	90                   	nop
c010257e:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
c0102585:	e8 6e ff ff ff       	call   c01024f8 <inb>
c010258a:	3c fa                	cmp    $0xfa,%al
c010258c:	75 f0                	jne    c010257e <send_kbc_command+0x3e>
}
c010258e:	c9                   	leave  
c010258f:	c3                   	ret    

c0102590 <send_kbd_command>:
 *
 * @param command Command for the Keyboard
 *
 * @return void
 */
inline void send_kbd_command(uint8_t command) {
c0102590:	55                   	push   %ebp
c0102591:	89 e5                	mov    %esp,%ebp
c0102593:	83 ec 0c             	sub    $0xc,%esp
c0102596:	8b 45 08             	mov    0x8(%ebp),%eax
c0102599:	88 45 fc             	mov    %al,-0x4(%ebp)
	send_kbc_command(0x60, command);
c010259c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c01025a0:	89 44 24 04          	mov    %eax,0x4(%esp)
c01025a4:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
c01025ab:	e8 90 ff ff ff       	call   c0102540 <send_kbc_command>
}
c01025b0:	c9                   	leave  
c01025b1:	c3                   	ret    

c01025b2 <INIT_KEYBOARD>:
 * Initalize the Keyboard
 *
 * @param void
 * @return void
 */
void INIT_KEYBOARD(void) {
c01025b2:	55                   	push   %ebp
c01025b3:	89 e5                	mov    %esp,%ebp
c01025b5:	83 ec 18             	sub    $0x18,%esp
	install_irq(0x1, &kbd_irq_handler);
c01025b8:	c7 44 24 04 15 26 10 	movl   $0xc0102615,0x4(%esp)
c01025bf:	c0 
c01025c0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c01025c7:	e8 ba 1c 00 00       	call   c0104286 <install_irq>

  	while (!(inb(0x64) & 0x4));
c01025cc:	90                   	nop
c01025cd:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
c01025d4:	e8 1f ff ff ff       	call   c01024f8 <inb>
c01025d9:	0f b6 c0             	movzbl %al,%eax
c01025dc:	83 e0 04             	and    $0x4,%eax
c01025df:	85 c0                	test   %eax,%eax
c01025e1:	74 ea                	je     c01025cd <INIT_KEYBOARD+0x1b>
  	// Puffer leeren
  	while (inb(0x64) & 0x1) {
c01025e3:	eb 0c                	jmp    c01025f1 <INIT_KEYBOARD+0x3f>
  		inb(0x60);
c01025e5:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
c01025ec:	e8 07 ff ff ff       	call   c01024f8 <inb>
void INIT_KEYBOARD(void) {
	install_irq(0x1, &kbd_irq_handler);

  	while (!(inb(0x64) & 0x4));
  	// Puffer leeren
  	while (inb(0x64) & 0x1) {
c01025f1:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
c01025f8:	e8 fb fe ff ff       	call   c01024f8 <inb>
c01025fd:	0f b6 c0             	movzbl %al,%eax
c0102600:	83 e0 01             	and    $0x1,%eax
c0102603:	85 c0                	test   %eax,%eax
c0102605:	75 de                	jne    c01025e5 <INIT_KEYBOARD+0x33>
  		inb(0x60);
  	}

  	send_kbd_command(0xF4);// Tastatur aktivieren
c0102607:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp)
c010260e:	e8 7d ff ff ff       	call   c0102590 <send_kbd_command>
}
c0102613:	c9                   	leave  
c0102614:	c3                   	ret    

c0102615 <kbd_irq_handler>:
 * IRQ handler for the Keyboard
 *
 * @param void
 * @return void
 */
void kbd_irq_handler(void) {
c0102615:	55                   	push   %ebp
c0102616:	89 e5                	mov    %esp,%ebp
c0102618:	83 ec 28             	sub    $0x28,%esp
	uint8_t input = 0, ASCII = 0;
c010261b:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
c010261f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	while (inb(0x64)&1) {
c0102623:	e9 f6 00 00 00       	jmp    c010271e <kbd_irq_handler+0x109>
		input = inb(0x60);
c0102628:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
c010262f:	e8 c4 fe ff ff       	call   c01024f8 <inb>
c0102634:	88 45 f6             	mov    %al,-0xa(%ebp)

		if (input==0xC5) { //pressed numlock
c0102637:	80 7d f6 c5          	cmpb   $0xc5,-0xa(%ebp)
c010263b:	75 17                	jne    c0102654 <kbd_irq_handler+0x3f>
			numlock = !numlock;
c010263d:	a1 04 10 11 c0       	mov    0xc0111004,%eax
c0102642:	85 c0                	test   %eax,%eax
c0102644:	0f 94 c0             	sete   %al
c0102647:	0f b6 c0             	movzbl %al,%eax
c010264a:	a3 04 10 11 c0       	mov    %eax,0xc0111004
			continue;
c010264f:	e9 ca 00 00 00       	jmp    c010271e <kbd_irq_handler+0x109>
		}

		if (input==0x3A) { //pressed capslock
c0102654:	80 7d f6 3a          	cmpb   $0x3a,-0xa(%ebp)
c0102658:	75 17                	jne    c0102671 <kbd_irq_handler+0x5c>
			caps = !caps;
c010265a:	a1 08 10 11 c0       	mov    0xc0111008,%eax
c010265f:	85 c0                	test   %eax,%eax
c0102661:	0f 94 c0             	sete   %al
c0102664:	0f b6 c0             	movzbl %al,%eax
c0102667:	a3 08 10 11 c0       	mov    %eax,0xc0111008
			continue;
c010266c:	e9 ad 00 00 00       	jmp    c010271e <kbd_irq_handler+0x109>
		}


		if ((input & 0x80) == 0x80) { //release Key
c0102671:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0102675:	84 c0                	test   %al,%al
c0102677:	79 23                	jns    c010269c <kbd_irq_handler+0x87>
		    input &= 0x7F;
c0102679:	80 65 f6 7f          	andb   $0x7f,-0xa(%ebp)

		    if (input == 0x2A || input == 0x36) { //released shift key
c010267d:	80 7d f6 2a          	cmpb   $0x2a,-0xa(%ebp)
c0102681:	74 0a                	je     c010268d <kbd_irq_handler+0x78>
c0102683:	80 7d f6 36          	cmpb   $0x36,-0xa(%ebp)
c0102687:	0f 85 90 00 00 00    	jne    c010271d <kbd_irq_handler+0x108>
		        shift = false;
c010268d:	c7 05 00 10 11 c0 00 	movl   $0x0,0xc0111000
c0102694:	00 00 00 
		    }
			continue;
c0102697:	e9 81 00 00 00       	jmp    c010271d <kbd_irq_handler+0x108>
		}

		if (input == 0x2A || input == 0x36) { //pressed shift
c010269c:	80 7d f6 2a          	cmpb   $0x2a,-0xa(%ebp)
c01026a0:	74 06                	je     c01026a8 <kbd_irq_handler+0x93>
c01026a2:	80 7d f6 36          	cmpb   $0x36,-0xa(%ebp)
c01026a6:	75 0c                	jne    c01026b4 <kbd_irq_handler+0x9f>
			shift = true;
c01026a8:	c7 05 00 10 11 c0 01 	movl   $0x1,0xc0111000
c01026af:	00 00 00 
			continue;
c01026b2:	eb 6a                	jmp    c010271e <kbd_irq_handler+0x109>
		}

		if (input > 0x46 && input < 0x55 && input != 0x4A && input != 0x4C && input != 0x4E && numlock) { //Numblock Key
c01026b4:	80 7d f6 46          	cmpb   $0x46,-0xa(%ebp)
c01026b8:	76 31                	jbe    c01026eb <kbd_irq_handler+0xd6>
c01026ba:	80 7d f6 54          	cmpb   $0x54,-0xa(%ebp)
c01026be:	77 2b                	ja     c01026eb <kbd_irq_handler+0xd6>
c01026c0:	80 7d f6 4a          	cmpb   $0x4a,-0xa(%ebp)
c01026c4:	74 25                	je     c01026eb <kbd_irq_handler+0xd6>
c01026c6:	80 7d f6 4c          	cmpb   $0x4c,-0xa(%ebp)
c01026ca:	74 1f                	je     c01026eb <kbd_irq_handler+0xd6>
c01026cc:	80 7d f6 4e          	cmpb   $0x4e,-0xa(%ebp)
c01026d0:	74 19                	je     c01026eb <kbd_irq_handler+0xd6>
c01026d2:	a1 04 10 11 c0       	mov    0xc0111004,%eax
c01026d7:	85 c0                	test   %eax,%eax
c01026d9:	74 10                	je     c01026eb <kbd_irq_handler+0xd6>
			ASCII = asciishift[input];
c01026db:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c01026df:	0f b6 80 e0 f0 10 c0 	movzbl -0x3fef0f20(%eax),%eax
c01026e6:	88 45 f7             	mov    %al,-0x9(%ebp)
c01026e9:	eb 33                	jmp    c010271e <kbd_irq_handler+0x109>
		}

		else if (shift || caps) { //Common Key
c01026eb:	a1 00 10 11 c0       	mov    0xc0111000,%eax
c01026f0:	85 c0                	test   %eax,%eax
c01026f2:	75 09                	jne    c01026fd <kbd_irq_handler+0xe8>
c01026f4:	a1 08 10 11 c0       	mov    0xc0111008,%eax
c01026f9:	85 c0                	test   %eax,%eax
c01026fb:	74 10                	je     c010270d <kbd_irq_handler+0xf8>
			ASCII = asciishift[input];
c01026fd:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0102701:	0f b6 80 e0 f0 10 c0 	movzbl -0x3fef0f20(%eax),%eax
c0102708:	88 45 f7             	mov    %al,-0x9(%ebp)
c010270b:	eb 11                	jmp    c010271e <kbd_irq_handler+0x109>
		} else {
			ASCII = asciinormal[input];
c010270d:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0102711:	0f b6 80 80 f0 10 c0 	movzbl -0x3fef0f80(%eax),%eax
c0102718:	88 45 f7             	mov    %al,-0x9(%ebp)
c010271b:	eb 01                	jmp    c010271e <kbd_irq_handler+0x109>
		    input &= 0x7F;

		    if (input == 0x2A || input == 0x36) { //released shift key
		        shift = false;
		    }
			continue;
c010271d:	90                   	nop
 * @param void
 * @return void
 */
void kbd_irq_handler(void) {
	uint8_t input = 0, ASCII = 0;
	while (inb(0x64)&1) {
c010271e:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
c0102725:	e8 ce fd ff ff       	call   c01024f8 <inb>
c010272a:	0f b6 c0             	movzbl %al,%eax
c010272d:	83 e0 01             	and    $0x1,%eax
c0102730:	85 c0                	test   %eax,%eax
c0102732:	0f 85 f0 fe ff ff    	jne    c0102628 <kbd_irq_handler+0x13>
		} else {
			ASCII = asciinormal[input];
		}

	}
	printf("x");
c0102738:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
c010273f:	e8 b4 00 00 00       	call   c01027f8 <putchar>
	if (ASCII) {
c0102744:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0102748:	74 60                	je     c01027aa <kbd_irq_handler+0x195>
		*tail = ASCII;
c010274a:	a1 40 f1 10 c0       	mov    0xc010f140,%eax
c010274f:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0102753:	88 10                	mov    %dl,(%eax)
		tail++;
c0102755:	a1 40 f1 10 c0       	mov    0xc010f140,%eax
c010275a:	83 c0 01             	add    $0x1,%eax
c010275d:	a3 40 f1 10 c0       	mov    %eax,0xc010f140
		if (tail == keybuffer + 512) {
c0102762:	a1 40 f1 10 c0       	mov    0xc010f140,%eax
c0102767:	3d 20 32 11 c0       	cmp    $0xc0113220,%eax
c010276c:	75 0a                	jne    c0102778 <kbd_irq_handler+0x163>
			tail = keybuffer;
c010276e:	c7 05 40 f1 10 c0 20 	movl   $0xc0113020,0xc010f140
c0102775:	30 11 c0 
		}
		if (head == keybuffer + 512) {
c0102778:	a1 3c f1 10 c0       	mov    0xc010f13c,%eax
c010277d:	3d 20 32 11 c0       	cmp    $0xc0113220,%eax
c0102782:	75 0a                	jne    c010278e <kbd_irq_handler+0x179>
			head = keybuffer;
c0102784:	c7 05 3c f1 10 c0 20 	movl   $0xc0113020,0xc010f13c
c010278b:	30 11 c0 
		}
		if (tail == head) {
c010278e:	8b 15 40 f1 10 c0    	mov    0xc010f140,%edx
c0102794:	a1 3c f1 10 c0       	mov    0xc010f13c,%eax
c0102799:	39 c2                	cmp    %eax,%edx
c010279b:	75 0d                	jne    c01027aa <kbd_irq_handler+0x195>
			head++;
c010279d:	a1 3c f1 10 c0       	mov    0xc010f13c,%eax
c01027a2:	83 c0 01             	add    $0x1,%eax
c01027a5:	a3 3c f1 10 c0       	mov    %eax,0xc010f13c
		}
	}

}
c01027aa:	c9                   	leave  
c01027ab:	c3                   	ret    

c01027ac <input>:
 * get chars from the Keyboard buffer
 *
 * @param void
 * @return character
 **/
uint8_t input(void) {
c01027ac:	55                   	push   %ebp
c01027ad:	89 e5                	mov    %esp,%ebp
	if (head == keybuffer+512) {
c01027af:	a1 3c f1 10 c0       	mov    0xc010f13c,%eax
c01027b4:	3d 20 32 11 c0       	cmp    $0xc0113220,%eax
c01027b9:	75 0a                	jne    c01027c5 <input+0x19>
		head = keybuffer;
c01027bb:	c7 05 3c f1 10 c0 20 	movl   $0xc0113020,0xc010f13c
c01027c2:	30 11 c0 
	}
	while (head == tail) {}
c01027c5:	90                   	nop
c01027c6:	8b 15 3c f1 10 c0    	mov    0xc010f13c,%edx
c01027cc:	a1 40 f1 10 c0       	mov    0xc010f140,%eax
c01027d1:	39 c2                	cmp    %eax,%edx
c01027d3:	74 f1                	je     c01027c6 <input+0x1a>
	return *(head++);
c01027d5:	a1 3c f1 10 c0       	mov    0xc010f13c,%eax
c01027da:	0f b6 10             	movzbl (%eax),%edx
c01027dd:	83 c0 01             	add    $0x1,%eax
c01027e0:	a3 3c f1 10 c0       	mov    %eax,0xc010f13c
c01027e5:	89 d0                	mov    %edx,%eax
}
c01027e7:	5d                   	pop    %ebp
c01027e8:	c3                   	ret    

c01027e9 <seek_head>:
 * set head to tail
 *
 * @param void
 * @return void
 **/
void seek_head(void) {
c01027e9:	55                   	push   %ebp
c01027ea:	89 e5                	mov    %esp,%ebp
	head = tail;
c01027ec:	a1 40 f1 10 c0       	mov    0xc010f140,%eax
c01027f1:	a3 3c f1 10 c0       	mov    %eax,0xc010f13c
}
c01027f6:	5d                   	pop    %ebp
c01027f7:	c3                   	ret    

c01027f8 <putchar>:

static color_t color = CYAN | BLACK << 4;
static char *video_mem = (char *)0xc00b8000;

int putchar(int c)
{
c01027f8:	55                   	push   %ebp
c01027f9:	89 e5                	mov    %esp,%ebp
c01027fb:	83 ec 18             	sub    $0x18,%esp
	if (c == '\b') {
c01027fe:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
c0102802:	0f 85 8a 00 00 00    	jne    c0102892 <putchar+0x9a>
		if (x > 0) {
c0102808:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c010280d:	85 c0                	test   %eax,%eax
c010280f:	7e 2b                	jle    c010283c <putchar+0x44>
			gotoxy(--x, y);
c0102811:	a1 10 10 11 c0       	mov    0xc0111010,%eax
c0102816:	0f b6 d0             	movzbl %al,%edx
c0102819:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c010281e:	83 e8 01             	sub    $0x1,%eax
c0102821:	a3 0c 10 11 c0       	mov    %eax,0xc011100c
c0102826:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c010282b:	0f b6 c0             	movzbl %al,%eax
c010282e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102832:	89 04 24             	mov    %eax,(%esp)
c0102835:	e8 1b 02 00 00       	call   c0102a55 <gotoxy>
c010283a:	eb 2c                	jmp    c0102868 <putchar+0x70>
		} else {
			gotoxy(columns - 1, --y);
c010283c:	a1 10 10 11 c0       	mov    0xc0111010,%eax
c0102841:	83 e8 01             	sub    $0x1,%eax
c0102844:	a3 10 10 11 c0       	mov    %eax,0xc0111010
c0102849:	a1 10 10 11 c0       	mov    0xc0111010,%eax
c010284e:	0f b6 d0             	movzbl %al,%edx
c0102851:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102856:	83 e8 01             	sub    $0x1,%eax
c0102859:	0f b6 c0             	movzbl %al,%eax
c010285c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102860:	89 04 24             	mov    %eax,(%esp)
c0102863:	e8 ed 01 00 00       	call   c0102a55 <gotoxy>
		}

		video_mem[2 * (y * columns + x)] = 0;
c0102868:	8b 15 50 f1 10 c0    	mov    0xc010f150,%edx
c010286e:	8b 0d 10 10 11 c0    	mov    0xc0111010,%ecx
c0102874:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102879:	0f af c8             	imul   %eax,%ecx
c010287c:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c0102881:	01 c8                	add    %ecx,%eax
c0102883:	01 c0                	add    %eax,%eax
c0102885:	01 d0                	add    %edx,%eax
c0102887:	c6 00 00             	movb   $0x0,(%eax)

		return c;
c010288a:	8b 45 08             	mov    0x8(%ebp),%eax
c010288d:	e9 c3 00 00 00       	jmp    c0102955 <putchar+0x15d>
	}

	if ((x > columns - 1) || (c == '\n')) {
c0102892:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102897:	8d 50 ff             	lea    -0x1(%eax),%edx
c010289a:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c010289f:	39 c2                	cmp    %eax,%edx
c01028a1:	7c 06                	jl     c01028a9 <putchar+0xb1>
c01028a3:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c01028a7:	75 30                	jne    c01028d9 <putchar+0xe1>
		gotoxy(0, ++y);
c01028a9:	a1 10 10 11 c0       	mov    0xc0111010,%eax
c01028ae:	83 c0 01             	add    $0x1,%eax
c01028b1:	a3 10 10 11 c0       	mov    %eax,0xc0111010
c01028b6:	a1 10 10 11 c0       	mov    0xc0111010,%eax
c01028bb:	0f b6 c0             	movzbl %al,%eax
c01028be:	89 44 24 04          	mov    %eax,0x4(%esp)
c01028c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c01028c9:	e8 87 01 00 00       	call   c0102a55 <gotoxy>

		if (c == '\n') {
c01028ce:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c01028d2:	75 05                	jne    c01028d9 <putchar+0xe1>
			return c;
c01028d4:	8b 45 08             	mov    0x8(%ebp),%eax
c01028d7:	eb 7c                	jmp    c0102955 <putchar+0x15d>
		}
	}

	video_mem[2 * (y * columns + x)] = c;
c01028d9:	8b 15 50 f1 10 c0    	mov    0xc010f150,%edx
c01028df:	8b 0d 10 10 11 c0    	mov    0xc0111010,%ecx
c01028e5:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c01028ea:	0f af c8             	imul   %eax,%ecx
c01028ed:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c01028f2:	01 c8                	add    %ecx,%eax
c01028f4:	01 c0                	add    %eax,%eax
c01028f6:	01 c2                	add    %eax,%edx
c01028f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01028fb:	88 02                	mov    %al,(%edx)
	video_mem[2 * (y * columns + x) + 1] = color;
c01028fd:	a1 50 f1 10 c0       	mov    0xc010f150,%eax
c0102902:	8b 0d 10 10 11 c0    	mov    0xc0111010,%ecx
c0102908:	8b 15 48 f1 10 c0    	mov    0xc010f148,%edx
c010290e:	0f af ca             	imul   %edx,%ecx
c0102911:	8b 15 0c 10 11 c0    	mov    0xc011100c,%edx
c0102917:	01 ca                	add    %ecx,%edx
c0102919:	01 d2                	add    %edx,%edx
c010291b:	83 c2 01             	add    $0x1,%edx
c010291e:	01 c2                	add    %eax,%edx
c0102920:	0f b6 05 4c f1 10 c0 	movzbl 0xc010f14c,%eax
c0102927:	88 02                	mov    %al,(%edx)

	gotoxy(++x, y);
c0102929:	a1 10 10 11 c0       	mov    0xc0111010,%eax
c010292e:	0f b6 d0             	movzbl %al,%edx
c0102931:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c0102936:	83 c0 01             	add    $0x1,%eax
c0102939:	a3 0c 10 11 c0       	mov    %eax,0xc011100c
c010293e:	a1 0c 10 11 c0       	mov    0xc011100c,%eax
c0102943:	0f b6 c0             	movzbl %al,%eax
c0102946:	89 54 24 04          	mov    %edx,0x4(%esp)
c010294a:	89 04 24             	mov    %eax,(%esp)
c010294d:	e8 03 01 00 00       	call   c0102a55 <gotoxy>

	return c;
c0102952:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0102955:	c9                   	leave  
c0102956:	c3                   	ret    

c0102957 <puts>:

int puts(const char* s)
{
c0102957:	55                   	push   %ebp
c0102958:	89 e5                	mov    %esp,%ebp
c010295a:	83 ec 28             	sub    $0x28,%esp
	int printed = 1;
c010295d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	while (*s) {
c0102964:	eb 19                	jmp    c010297f <puts+0x28>
		putchar(*s++);
c0102966:	8b 45 08             	mov    0x8(%ebp),%eax
c0102969:	0f b6 00             	movzbl (%eax),%eax
c010296c:	0f be c0             	movsbl %al,%eax
c010296f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0102973:	89 04 24             	mov    %eax,(%esp)
c0102976:	e8 7d fe ff ff       	call   c01027f8 <putchar>
		++printed;
c010297b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)

int puts(const char* s)
{
	int printed = 1;

	while (*s) {
c010297f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102982:	0f b6 00             	movzbl (%eax),%eax
c0102985:	84 c0                	test   %al,%al
c0102987:	75 dd                	jne    c0102966 <puts+0xf>
		putchar(*s++);
		++printed;
	}
	putchar('\n');
c0102989:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0102990:	e8 63 fe ff ff       	call   c01027f8 <putchar>

	return printed;
c0102995:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0102998:	c9                   	leave  
c0102999:	c3                   	ret    

c010299a <fputs>:

int fputs(const char* s, int fd)
{
c010299a:	55                   	push   %ebp
c010299b:	89 e5                	mov    %esp,%ebp
c010299d:	83 ec 18             	sub    $0x18,%esp
	if (fd == STDOUT) {
c01029a0:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c01029a4:	75 21                	jne    c01029c7 <fputs+0x2d>
		while (*s) {
c01029a6:	eb 15                	jmp    c01029bd <fputs+0x23>
			putchar(*s++);
c01029a8:	8b 45 08             	mov    0x8(%ebp),%eax
c01029ab:	0f b6 00             	movzbl (%eax),%eax
c01029ae:	0f be c0             	movsbl %al,%eax
c01029b1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c01029b5:	89 04 24             	mov    %eax,(%esp)
c01029b8:	e8 3b fe ff ff       	call   c01027f8 <putchar>
}

int fputs(const char* s, int fd)
{
	if (fd == STDOUT) {
		while (*s) {
c01029bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01029c0:	0f b6 00             	movzbl (%eax),%eax
c01029c3:	84 c0                	test   %al,%al
c01029c5:	75 e1                	jne    c01029a8 <fputs+0xe>
			putchar(*s++);
		}
	}

	return 0;
c01029c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01029cc:	c9                   	leave  
c01029cd:	c3                   	ret    

c01029ce <clear_screen>:

void clear_screen(void)
{
c01029ce:	55                   	push   %ebp
c01029cf:	89 e5                	mov    %esp,%ebp
c01029d1:	83 ec 28             	sub    $0x28,%esp
	int i;
	for (i = 0; i < lines * columns; i++) {
c01029d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01029db:	eb 2c                	jmp    c0102a09 <clear_screen+0x3b>
		video_mem[2 * i] = 0;
c01029dd:	8b 15 50 f1 10 c0    	mov    0xc010f150,%edx
c01029e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01029e6:	01 c0                	add    %eax,%eax
c01029e8:	01 d0                	add    %edx,%eax
c01029ea:	c6 00 00             	movb   $0x0,(%eax)
		video_mem[2 * i + 1] = color;
c01029ed:	a1 50 f1 10 c0       	mov    0xc010f150,%eax
c01029f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01029f5:	01 d2                	add    %edx,%edx
c01029f7:	83 c2 01             	add    $0x1,%edx
c01029fa:	01 c2                	add    %eax,%edx
c01029fc:	0f b6 05 4c f1 10 c0 	movzbl 0xc010f14c,%eax
c0102a03:	88 02                	mov    %al,(%edx)
}

void clear_screen(void)
{
	int i;
	for (i = 0; i < lines * columns; i++) {
c0102a05:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0102a09:	8b 15 44 f1 10 c0    	mov    0xc010f144,%edx
c0102a0f:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102a14:	0f af c2             	imul   %edx,%eax
c0102a17:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0102a1a:	7f c1                	jg     c01029dd <clear_screen+0xf>
		video_mem[2 * i] = 0;
		video_mem[2 * i + 1] = color;
	}

	gotoxy(0, 0);
c0102a1c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0102a23:	00 
c0102a24:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0102a2b:	e8 25 00 00 00       	call   c0102a55 <gotoxy>
}
c0102a30:	c9                   	leave  
c0102a31:	c3                   	ret    

c0102a32 <set_color>:

void set_color(color_t _color)
{
c0102a32:	55                   	push   %ebp
c0102a33:	89 e5                	mov    %esp,%ebp
c0102a35:	83 ec 04             	sub    $0x4,%esp
c0102a38:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a3b:	88 45 fc             	mov    %al,-0x4(%ebp)
	color = _color;
c0102a3e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0102a42:	a2 4c f1 10 c0       	mov    %al,0xc010f14c
}
c0102a47:	c9                   	leave  
c0102a48:	c3                   	ret    

c0102a49 <get_color>:

color_t get_color(void)
{
c0102a49:	55                   	push   %ebp
c0102a4a:	89 e5                	mov    %esp,%ebp
	return color;
c0102a4c:	0f b6 05 4c f1 10 c0 	movzbl 0xc010f14c,%eax
}
c0102a53:	5d                   	pop    %ebp
c0102a54:	c3                   	ret    

c0102a55 <gotoxy>:

void gotoxy(uint8_t _x, uint8_t _y)
{
c0102a55:	55                   	push   %ebp
c0102a56:	89 e5                	mov    %esp,%ebp
c0102a58:	53                   	push   %ebx
c0102a59:	83 ec 34             	sub    $0x34,%esp
c0102a5c:	8b 55 08             	mov    0x8(%ebp),%edx
c0102a5f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102a62:	88 55 e4             	mov    %dl,-0x1c(%ebp)
c0102a65:	88 45 e0             	mov    %al,-0x20(%ebp)
	uint16_t offset;

	if ((_y * columns + _x) >= (columns * lines)) { /* scroll if neccessary */
c0102a68:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
c0102a6c:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102a71:	0f af d0             	imul   %eax,%edx
c0102a74:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0102a78:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0102a7b:	8b 15 48 f1 10 c0    	mov    0xc010f148,%edx
c0102a81:	a1 44 f1 10 c0       	mov    0xc010f144,%eax
c0102a86:	0f af c2             	imul   %edx,%eax
c0102a89:	39 c1                	cmp    %eax,%ecx
c0102a8b:	7c 6f                	jl     c0102afc <gotoxy+0xa7>
		memmove(video_mem, video_mem + 2 * columns, 2 * lines * columns);
c0102a8d:	a1 44 f1 10 c0       	mov    0xc010f144,%eax
c0102a92:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0102a95:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102a9a:	0f af c2             	imul   %edx,%eax
c0102a9d:	89 c2                	mov    %eax,%edx
c0102a9f:	8b 0d 50 f1 10 c0    	mov    0xc010f150,%ecx
c0102aa5:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102aaa:	01 c0                	add    %eax,%eax
c0102aac:	01 c1                	add    %eax,%ecx
c0102aae:	a1 50 f1 10 c0       	mov    0xc010f150,%eax
c0102ab3:	89 54 24 08          	mov    %edx,0x8(%esp)
c0102ab7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c0102abb:	89 04 24             	mov    %eax,(%esp)
c0102abe:	e8 aa 75 00 00       	call   c010a06d <memmove>
		memset(video_mem + 2 * lines * columns, 0, 2 * columns);
c0102ac3:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102ac8:	01 c0                	add    %eax,%eax
c0102aca:	8b 0d 50 f1 10 c0    	mov    0xc010f150,%ecx
c0102ad0:	8b 15 44 f1 10 c0    	mov    0xc010f144,%edx
c0102ad6:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
c0102ad9:	8b 15 48 f1 10 c0    	mov    0xc010f148,%edx
c0102adf:	0f af d3             	imul   %ebx,%edx
c0102ae2:	01 ca                	add    %ecx,%edx
c0102ae4:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102ae8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0102aef:	00 
c0102af0:	89 14 24             	mov    %edx,(%esp)
c0102af3:	e8 fd 76 00 00       	call   c010a1f5 <memset>
		--_y;
c0102af8:	80 6d e0 01          	subb   $0x1,-0x20(%ebp)
	}

	x = _x; y = _y;
c0102afc:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0102b00:	a3 0c 10 11 c0       	mov    %eax,0xc011100c
c0102b05:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c0102b09:	a3 10 10 11 c0       	mov    %eax,0xc0111010
	offset = _y * columns + _x;
c0102b0e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
c0102b12:	a1 48 f1 10 c0       	mov    0xc010f148,%eax
c0102b17:	0f af d0             	imul   %eax,%edx
c0102b1a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0102b1e:	01 d0                	add    %edx,%eax
c0102b20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

	if (video_mem[2 * offset] == 0) {
c0102b24:	8b 15 50 f1 10 c0    	mov    0xc010f150,%edx
c0102b2a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0102b2e:	01 c0                	add    %eax,%eax
c0102b30:	01 d0                	add    %edx,%eax
c0102b32:	0f b6 00             	movzbl (%eax),%eax
c0102b35:	84 c0                	test   %al,%al
c0102b37:	75 19                	jne    c0102b52 <gotoxy+0xfd>
		video_mem[2 * offset + 1] = color;
c0102b39:	a1 50 f1 10 c0       	mov    0xc010f150,%eax
c0102b3e:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0102b42:	01 d2                	add    %edx,%edx
c0102b44:	83 c2 01             	add    $0x1,%edx
c0102b47:	01 c2                	add    %eax,%edx
c0102b49:	0f b6 05 4c f1 10 c0 	movzbl 0xc010f14c,%eax
c0102b50:	88 02                	mov    %al,(%edx)
	}

	crtc_write(CRTC_CURSOR_LOCATION_HIGH, (uint8_t)(offset >> 8));
c0102b52:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0102b56:	66 c1 e8 08          	shr    $0x8,%ax
c0102b5a:	0f b6 c0             	movzbl %al,%eax
c0102b5d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102b61:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c0102b68:	e8 bd 15 00 00       	call   c010412a <crtc_write>
	crtc_write(CRTC_CURSOR_LOCATION_LOW, (uint8_t)offset);
c0102b6d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0102b71:	0f b6 c0             	movzbl %al,%eax
c0102b74:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102b78:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c0102b7f:	e8 a6 15 00 00       	call   c010412a <crtc_write>
}
c0102b84:	83 c4 34             	add    $0x34,%esp
c0102b87:	5b                   	pop    %ebx
c0102b88:	5d                   	pop    %ebp
c0102b89:	c3                   	ret    
c0102b8a:	66 90                	xchg   %ax,%ax

c0102b8c <inl>:
	uint16_t result;
	asm volatile("inw %1, %0" : "=a" (result) : "Nd" (port));
	return result;
}

static inline uint32_t inl(uint16_t port) {
c0102b8c:	55                   	push   %ebp
c0102b8d:	89 e5                	mov    %esp,%ebp
c0102b8f:	53                   	push   %ebx
c0102b90:	83 ec 14             	sub    $0x14,%esp
c0102b93:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b96:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	uint32_t result;
	asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
c0102b9a:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0102b9e:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c0102ba2:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c0102ba6:	ed                   	in     (%dx),%eax
c0102ba7:	89 c3                	mov    %eax,%ebx
c0102ba9:	89 5d f8             	mov    %ebx,-0x8(%ebp)
	return result;
c0102bac:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0102baf:	83 c4 14             	add    $0x14,%esp
c0102bb2:	5b                   	pop    %ebx
c0102bb3:	5d                   	pop    %ebp
c0102bb4:	c3                   	ret    

c0102bb5 <outb>:

static inline void outb(uint16_t port, uint8_t value) {
c0102bb5:	55                   	push   %ebp
c0102bb6:	89 e5                	mov    %esp,%ebp
c0102bb8:	83 ec 08             	sub    $0x8,%esp
c0102bbb:	8b 55 08             	mov    0x8(%ebp),%edx
c0102bbe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102bc1:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0102bc5:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c0102bc8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0102bcc:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0102bd0:	ee                   	out    %al,(%dx)
}
c0102bd1:	c9                   	leave  
c0102bd2:	c3                   	ret    

c0102bd3 <outw>:

static inline void outw(uint16_t port, uint16_t value) {
c0102bd3:	55                   	push   %ebp
c0102bd4:	89 e5                	mov    %esp,%ebp
c0102bd6:	83 ec 08             	sub    $0x8,%esp
c0102bd9:	8b 55 08             	mov    0x8(%ebp),%edx
c0102bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102bdf:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0102be3:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
	asm volatile("outw %1, %0" : : "Nd" (port), "a" (value));
c0102be7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0102beb:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0102bef:	66 ef                	out    %ax,(%dx)
}
c0102bf1:	c9                   	leave  
c0102bf2:	c3                   	ret    

c0102bf3 <outl>:

static inline void outl(uint16_t port, uint32_t value) {
c0102bf3:	55                   	push   %ebp
c0102bf4:	89 e5                	mov    %esp,%ebp
c0102bf6:	83 ec 04             	sub    $0x4,%esp
c0102bf9:	8b 45 08             	mov    0x8(%ebp),%eax
c0102bfc:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	asm volatile("outl %1, %0" : : "Nd" (port), "a" (value));
c0102c00:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0102c04:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102c07:	ef                   	out    %eax,(%dx)
}
c0102c08:	c9                   	leave  
c0102c09:	c3                   	ret    

c0102c0a <pci_read>:
#include <printf.h>
#include <heap.h>
#include <idt.h>

uint32_t pci_read(uint8_t bus,uint8_t dev,uint8_t func,uint8_t offset)
{
c0102c0a:	55                   	push   %ebp
c0102c0b:	89 e5                	mov    %esp,%ebp
c0102c0d:	53                   	push   %ebx
c0102c0e:	83 ec 18             	sub    $0x18,%esp
c0102c11:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0102c14:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102c17:	8b 55 10             	mov    0x10(%ebp),%edx
c0102c1a:	8b 45 14             	mov    0x14(%ebp),%eax
c0102c1d:	88 5d f8             	mov    %bl,-0x8(%ebp)
c0102c20:	88 4d f4             	mov    %cl,-0xc(%ebp)
c0102c23:	88 55 f0             	mov    %dl,-0x10(%ebp)
c0102c26:	88 45 ec             	mov    %al,-0x14(%ebp)
    outl(PCI_CONFIG_ADDRESS,0x80000000 | (bus << 16) | (dev << 11) |( func << 8) | (offset & 0xFC));
c0102c29:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0102c2d:	c1 e0 10             	shl    $0x10,%eax
c0102c30:	89 c2                	mov    %eax,%edx
c0102c32:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0102c36:	c1 e0 0b             	shl    $0xb,%eax
c0102c39:	09 c2                	or     %eax,%edx
c0102c3b:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0102c3f:	c1 e0 08             	shl    $0x8,%eax
c0102c42:	09 c2                	or     %eax,%edx
c0102c44:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0102c48:	25 fc 00 00 00       	and    $0xfc,%eax
c0102c4d:	09 d0                	or     %edx,%eax
c0102c4f:	0d 00 00 00 80       	or     $0x80000000,%eax
c0102c54:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102c58:	c7 04 24 f8 0c 00 00 	movl   $0xcf8,(%esp)
c0102c5f:	e8 8f ff ff ff       	call   c0102bf3 <outl>
    return inl(PCI_CONFIG_DATA) >> (8 * (offset % 4));
c0102c64:	c7 04 24 fc 0c 00 00 	movl   $0xcfc,(%esp)
c0102c6b:	e8 1c ff ff ff       	call   c0102b8c <inl>
c0102c70:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0102c74:	83 e2 03             	and    $0x3,%edx
c0102c77:	c1 e2 03             	shl    $0x3,%edx
c0102c7a:	89 d1                	mov    %edx,%ecx
c0102c7c:	d3 e8                	shr    %cl,%eax
}
c0102c7e:	83 c4 18             	add    $0x18,%esp
c0102c81:	5b                   	pop    %ebx
c0102c82:	5d                   	pop    %ebp
c0102c83:	c3                   	ret    

c0102c84 <pci_readb>:
 * @param function
 * @param Offset
 * @return value from the input adress
 */
uint8_t pci_readb(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset)
{
c0102c84:	55                   	push   %ebp
c0102c85:	89 e5                	mov    %esp,%ebp
c0102c87:	53                   	push   %ebx
c0102c88:	83 ec 20             	sub    $0x20,%esp
c0102c8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0102c8e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102c91:	8b 55 10             	mov    0x10(%ebp),%edx
c0102c94:	8b 45 14             	mov    0x14(%ebp),%eax
c0102c97:	88 5d f8             	mov    %bl,-0x8(%ebp)
c0102c9a:	88 4d f4             	mov    %cl,-0xc(%ebp)
c0102c9d:	88 55 f0             	mov    %dl,-0x10(%ebp)
c0102ca0:	88 45 ec             	mov    %al,-0x14(%ebp)
    return pci_read(bus, dev, func, offset) & 0xff;
c0102ca3:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
c0102ca7:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
c0102cab:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0102caf:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0102cb3:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0102cb7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0102cbb:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102cbf:	89 04 24             	mov    %eax,(%esp)
c0102cc2:	e8 43 ff ff ff       	call   c0102c0a <pci_read>
}
c0102cc7:	83 c4 20             	add    $0x20,%esp
c0102cca:	5b                   	pop    %ebx
c0102ccb:	5d                   	pop    %ebp
c0102ccc:	c3                   	ret    

c0102ccd <pci_readw>:
 * @param function
 * @param Offset
 * @return value from the input adress
 */
inline uint16_t pci_readw(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset)
{
c0102ccd:	55                   	push   %ebp
c0102cce:	89 e5                	mov    %esp,%ebp
c0102cd0:	53                   	push   %ebx
c0102cd1:	83 ec 20             	sub    $0x20,%esp
c0102cd4:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0102cd7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102cda:	8b 55 10             	mov    0x10(%ebp),%edx
c0102cdd:	8b 45 14             	mov    0x14(%ebp),%eax
c0102ce0:	88 5d f8             	mov    %bl,-0x8(%ebp)
c0102ce3:	88 4d f4             	mov    %cl,-0xc(%ebp)
c0102ce6:	88 55 f0             	mov    %dl,-0x10(%ebp)
c0102ce9:	88 45 ec             	mov    %al,-0x14(%ebp)
    return pci_read(bus, dev, func, offset) & 0xffff;
c0102cec:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
c0102cf0:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
c0102cf4:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0102cf8:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0102cfc:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0102d00:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0102d04:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102d08:	89 04 24             	mov    %eax,(%esp)
c0102d0b:	e8 fa fe ff ff       	call   c0102c0a <pci_read>
}
c0102d10:	83 c4 20             	add    $0x20,%esp
c0102d13:	5b                   	pop    %ebx
c0102d14:	5d                   	pop    %ebp
c0102d15:	c3                   	ret    

c0102d16 <pci_readl>:
 * @param function
 * @param Offset
 * @return value from the input adress
 */
inline uint32_t pci_readl(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset)
{
c0102d16:	55                   	push   %ebp
c0102d17:	89 e5                	mov    %esp,%ebp
c0102d19:	53                   	push   %ebx
c0102d1a:	83 ec 20             	sub    $0x20,%esp
c0102d1d:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0102d20:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102d23:	8b 55 10             	mov    0x10(%ebp),%edx
c0102d26:	8b 45 14             	mov    0x14(%ebp),%eax
c0102d29:	88 5d f8             	mov    %bl,-0x8(%ebp)
c0102d2c:	88 4d f4             	mov    %cl,-0xc(%ebp)
c0102d2f:	88 55 f0             	mov    %dl,-0x10(%ebp)
c0102d32:	88 45 ec             	mov    %al,-0x14(%ebp)
    return pci_read(bus, dev, func, offset);
c0102d35:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
c0102d39:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
c0102d3d:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0102d41:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0102d45:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0102d49:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0102d4d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102d51:	89 04 24             	mov    %eax,(%esp)
c0102d54:	e8 b1 fe ff ff       	call   c0102c0a <pci_read>
}
c0102d59:	83 c4 20             	add    $0x20,%esp
c0102d5c:	5b                   	pop    %ebx
c0102d5d:	5d                   	pop    %ebp
c0102d5e:	c3                   	ret    

c0102d5f <pci_writeb>:
 * @param function
 * @param Offset
 * @param Value
 */
inline void pci_writeb(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset, uint8_t value)
{
c0102d5f:	55                   	push   %ebp
c0102d60:	89 e5                	mov    %esp,%ebp
c0102d62:	56                   	push   %esi
c0102d63:	53                   	push   %ebx
c0102d64:	83 ec 20             	sub    $0x20,%esp
c0102d67:	8b 75 08             	mov    0x8(%ebp),%esi
c0102d6a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0102d6d:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0102d70:	8b 55 14             	mov    0x14(%ebp),%edx
c0102d73:	8b 45 18             	mov    0x18(%ebp),%eax
c0102d76:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0102d79:	89 f0                	mov    %esi,%eax
c0102d7b:	88 45 f4             	mov    %al,-0xc(%ebp)
c0102d7e:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0102d81:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0102d84:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0102d87:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c0102d8b:	88 45 e4             	mov    %al,-0x1c(%ebp)
    outl(PCI_CONFIG_ADDRESS,0x80000000 | (bus << 16) | (dev << 11 ) | (func << 8) | (offset & 0xFC));
c0102d8e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0102d92:	c1 e0 10             	shl    $0x10,%eax
c0102d95:	89 c2                	mov    %eax,%edx
c0102d97:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0102d9b:	c1 e0 0b             	shl    $0xb,%eax
c0102d9e:	09 c2                	or     %eax,%edx
c0102da0:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0102da4:	c1 e0 08             	shl    $0x8,%eax
c0102da7:	09 c2                	or     %eax,%edx
c0102da9:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0102dad:	25 fc 00 00 00       	and    $0xfc,%eax
c0102db2:	09 d0                	or     %edx,%eax
c0102db4:	0d 00 00 00 80       	or     $0x80000000,%eax
c0102db9:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102dbd:	c7 04 24 f8 0c 00 00 	movl   $0xcf8,(%esp)
c0102dc4:	e8 2a fe ff ff       	call   c0102bf3 <outl>
    outb(PCI_CONFIG_DATA + (offset & 3), value);
c0102dc9:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0102dcd:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0102dd1:	83 e0 03             	and    $0x3,%eax
c0102dd4:	66 05 fc 0c          	add    $0xcfc,%ax
c0102dd8:	0f b7 c0             	movzwl %ax,%eax
c0102ddb:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102ddf:	89 04 24             	mov    %eax,(%esp)
c0102de2:	e8 ce fd ff ff       	call   c0102bb5 <outb>
}
c0102de7:	83 c4 20             	add    $0x20,%esp
c0102dea:	5b                   	pop    %ebx
c0102deb:	5e                   	pop    %esi
c0102dec:	5d                   	pop    %ebp
c0102ded:	c3                   	ret    

c0102dee <pci_writew>:
 * @param function
 * @param Offset
 * @param Value
 */
inline void pci_writew(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset, uint16_t value)
{
c0102dee:	55                   	push   %ebp
c0102def:	89 e5                	mov    %esp,%ebp
c0102df1:	56                   	push   %esi
c0102df2:	53                   	push   %ebx
c0102df3:	83 ec 20             	sub    $0x20,%esp
c0102df6:	8b 75 08             	mov    0x8(%ebp),%esi
c0102df9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0102dfc:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0102dff:	8b 55 14             	mov    0x14(%ebp),%edx
c0102e02:	8b 45 18             	mov    0x18(%ebp),%eax
c0102e05:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0102e08:	89 f0                	mov    %esi,%eax
c0102e0a:	88 45 f4             	mov    %al,-0xc(%ebp)
c0102e0d:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0102e10:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0102e13:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0102e16:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0102e1a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    outl(PCI_CONFIG_ADDRESS, 0x80000000 | (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xFC));
c0102e1e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0102e22:	c1 e0 10             	shl    $0x10,%eax
c0102e25:	89 c2                	mov    %eax,%edx
c0102e27:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0102e2b:	c1 e0 0b             	shl    $0xb,%eax
c0102e2e:	09 c2                	or     %eax,%edx
c0102e30:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0102e34:	c1 e0 08             	shl    $0x8,%eax
c0102e37:	09 c2                	or     %eax,%edx
c0102e39:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0102e3d:	25 fc 00 00 00       	and    $0xfc,%eax
c0102e42:	09 d0                	or     %edx,%eax
c0102e44:	0d 00 00 00 80       	or     $0x80000000,%eax
c0102e49:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102e4d:	c7 04 24 f8 0c 00 00 	movl   $0xcf8,(%esp)
c0102e54:	e8 9a fd ff ff       	call   c0102bf3 <outl>
    outw(PCI_CONFIG_DATA + (offset & 2), value);
c0102e59:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
c0102e5d:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0102e61:	83 e0 02             	and    $0x2,%eax
c0102e64:	66 05 fc 0c          	add    $0xcfc,%ax
c0102e68:	0f b7 c0             	movzwl %ax,%eax
c0102e6b:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102e6f:	89 04 24             	mov    %eax,(%esp)
c0102e72:	e8 5c fd ff ff       	call   c0102bd3 <outw>
}
c0102e77:	83 c4 20             	add    $0x20,%esp
c0102e7a:	5b                   	pop    %ebx
c0102e7b:	5e                   	pop    %esi
c0102e7c:	5d                   	pop    %ebp
c0102e7d:	c3                   	ret    

c0102e7e <pci_writel>:
 * @param function
 * @param Offset
 * @param Value
 */
inline void pci_writel(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset, uint32_t value)
{
c0102e7e:	55                   	push   %ebp
c0102e7f:	89 e5                	mov    %esp,%ebp
c0102e81:	53                   	push   %ebx
c0102e82:	83 ec 18             	sub    $0x18,%esp
c0102e85:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0102e88:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102e8b:	8b 55 10             	mov    0x10(%ebp),%edx
c0102e8e:	8b 45 14             	mov    0x14(%ebp),%eax
c0102e91:	88 5d f8             	mov    %bl,-0x8(%ebp)
c0102e94:	88 4d f4             	mov    %cl,-0xc(%ebp)
c0102e97:	88 55 f0             	mov    %dl,-0x10(%ebp)
c0102e9a:	88 45 ec             	mov    %al,-0x14(%ebp)
    outl(PCI_CONFIG_ADDRESS, 0x80000000 | (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xFC));
c0102e9d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0102ea1:	c1 e0 10             	shl    $0x10,%eax
c0102ea4:	89 c2                	mov    %eax,%edx
c0102ea6:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0102eaa:	c1 e0 0b             	shl    $0xb,%eax
c0102ead:	09 c2                	or     %eax,%edx
c0102eaf:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0102eb3:	c1 e0 08             	shl    $0x8,%eax
c0102eb6:	09 c2                	or     %eax,%edx
c0102eb8:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0102ebc:	25 fc 00 00 00       	and    $0xfc,%eax
c0102ec1:	09 d0                	or     %edx,%eax
c0102ec3:	0d 00 00 00 80       	or     $0x80000000,%eax
c0102ec8:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102ecc:	c7 04 24 f8 0c 00 00 	movl   $0xcf8,(%esp)
c0102ed3:	e8 1b fd ff ff       	call   c0102bf3 <outl>
    outl(PCI_CONFIG_DATA, value);
c0102ed8:	8b 45 18             	mov    0x18(%ebp),%eax
c0102edb:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102edf:	c7 04 24 fc 0c 00 00 	movl   $0xcfc,(%esp)
c0102ee6:	e8 08 fd ff ff       	call   c0102bf3 <outl>
}
c0102eeb:	83 c4 18             	add    $0x18,%esp
c0102eee:	5b                   	pop    %ebx
c0102eef:	5d                   	pop    %ebp
c0102ef0:	c3                   	ret    

c0102ef1 <pci_dev_exist>:
 *  @param Bus
 *  @param Device/Slot
 *  @return true (device exists) or false (device does not exist)
 */
bool pci_dev_exist(uint8_t bus, uint8_t dev, uint8_t func)
{
c0102ef1:	55                   	push   %ebp
c0102ef2:	89 e5                	mov    %esp,%ebp
c0102ef4:	83 ec 2c             	sub    $0x2c,%esp
c0102ef7:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0102efa:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102efd:	8b 45 10             	mov    0x10(%ebp),%eax
c0102f00:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0102f03:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0102f06:	88 45 e4             	mov    %al,-0x1c(%ebp)
    uint16_t vendor_ID = pci_readw(bus, dev, func, 0);
c0102f09:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c0102f0d:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
c0102f11:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0102f15:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0102f1c:	00 
c0102f1d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0102f21:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102f25:	89 04 24             	mov    %eax,(%esp)
c0102f28:	e8 a0 fd ff ff       	call   c0102ccd <pci_readw>
c0102f2d:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    if(vendor_ID == 0 || vendor_ID == 0xFFFF)
c0102f31:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%ebp)
c0102f36:	74 07                	je     c0102f3f <pci_dev_exist+0x4e>
c0102f38:	66 83 7d fe ff       	cmpw   $0xffff,-0x2(%ebp)
c0102f3d:	75 07                	jne    c0102f46 <pci_dev_exist+0x55>
        return false;
c0102f3f:	b8 00 00 00 00       	mov    $0x0,%eax
c0102f44:	eb 05                	jmp    c0102f4b <pci_dev_exist+0x5a>
    return true;
c0102f46:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0102f4b:	c9                   	leave  
c0102f4c:	c3                   	ret    

c0102f4d <search_device>:
 * @param device devicde- ID of the device
 * @param num pointer to a counter integer
 * @return NULL if there is no more device of the specified type or the adress auf the PCI device struct
 */
struct pci_dev *search_device(list_t *device_list, uint16_t vendor, uint16_t device, int *num)
{
c0102f4d:	55                   	push   %ebp
c0102f4e:	89 e5                	mov    %esp,%ebp
c0102f50:	83 ec 38             	sub    $0x38,%esp
c0102f53:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102f56:	8b 45 10             	mov    0x10(%ebp),%eax
c0102f59:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
c0102f5d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    int devnum = *num;
c0102f61:	8b 45 14             	mov    0x14(%ebp),%eax
c0102f64:	8b 00                	mov    (%eax),%eax
c0102f66:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(device_list->lock){}
c0102f69:	90                   	nop
c0102f6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f6d:	8b 40 08             	mov    0x8(%eax),%eax
c0102f70:	85 c0                	test   %eax,%eax
c0102f72:	75 f6                	jne    c0102f6a <search_device+0x1d>
    device_list->lock = true;
c0102f74:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f77:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
        list_set_first(device_list);
c0102f7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f81:	89 04 24             	mov    %eax,(%esp)
c0102f84:	e8 5d 60 00 00       	call   c0108fe6 <list_set_first>
        while(!list_is_last(device_list))
c0102f89:	eb 73                	jmp    c0102ffe <search_device+0xb1>
        {
            struct pci_dev *current_dev = list_get_current(device_list);
c0102f8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f8e:	89 04 24             	mov    %eax,(%esp)
c0102f91:	e8 fd 5f 00 00       	call   c0108f93 <list_get_current>
c0102f96:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if(devnum == 0 && current_dev->device_ID == device && current_dev->vendor_ID == vendor)
c0102f99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0102f9d:	75 36                	jne    c0102fd5 <search_device+0x88>
c0102f9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102fa2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0102fa6:	66 3b 45 e0          	cmp    -0x20(%ebp),%ax
c0102faa:	75 29                	jne    c0102fd5 <search_device+0x88>
c0102fac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102faf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
c0102fb3:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
c0102fb7:	75 1c                	jne    c0102fd5 <search_device+0x88>
            {
                *num += 1;
c0102fb9:	8b 45 14             	mov    0x14(%ebp),%eax
c0102fbc:	8b 00                	mov    (%eax),%eax
c0102fbe:	8d 50 01             	lea    0x1(%eax),%edx
c0102fc1:	8b 45 14             	mov    0x14(%ebp),%eax
c0102fc4:	89 10                	mov    %edx,(%eax)
                device_list->lock = false;
c0102fc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0102fc9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
                return current_dev;
c0102fd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102fd3:	eb 4b                	jmp    c0103020 <search_device+0xd3>
            }
            else if(current_dev->device_ID == device && current_dev->vendor_ID == vendor)
c0102fd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102fd8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0102fdc:	66 3b 45 e0          	cmp    -0x20(%ebp),%ax
c0102fe0:	75 11                	jne    c0102ff3 <search_device+0xa6>
c0102fe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102fe5:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
c0102fe9:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
c0102fed:	75 04                	jne    c0102ff3 <search_device+0xa6>
            {
                devnum--;
c0102fef:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
            }
            list_next(device_list);
c0102ff3:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ff6:	89 04 24             	mov    %eax,(%esp)
c0102ff9:	e8 a3 5f 00 00       	call   c0108fa1 <list_next>
{
    int devnum = *num;
    while(device_list->lock){}
    device_list->lock = true;
        list_set_first(device_list);
        while(!list_is_last(device_list))
c0102ffe:	8b 45 08             	mov    0x8(%ebp),%eax
c0103001:	89 04 24             	mov    %eax,(%esp)
c0103004:	e8 c5 5f 00 00       	call   c0108fce <list_is_last>
c0103009:	85 c0                	test   %eax,%eax
c010300b:	0f 84 7a ff ff ff    	je     c0102f8b <search_device+0x3e>
            {
                devnum--;
            }
            list_next(device_list);
        }
    device_list->lock = false;
c0103011:	8b 45 08             	mov    0x8(%ebp),%eax
c0103014:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return NULL;
c010301b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103020:	c9                   	leave  
c0103021:	c3                   	ret    

c0103022 <install_pci_isr>:
 * installs a isr handler for a specific pci device
 * @param isr interrupt service routine
 * @param dev pci device
 */
void install_pci_isr(void (*isr)(struct pci_dev *dev), struct pci_dev *dev)
{
c0103022:	55                   	push   %ebp
c0103023:	89 e5                	mov    %esp,%ebp
c0103025:	83 ec 28             	sub    $0x28,%esp
    while(pci_irq_handles->lock){}
c0103028:	90                   	nop
c0103029:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c010302e:	8b 40 08             	mov    0x8(%eax),%eax
c0103031:	85 c0                	test   %eax,%eax
c0103033:	75 f4                	jne    c0103029 <install_pci_isr+0x7>
    pci_irq_handles->lock = true;
c0103035:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c010303a:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
        struct pci_isr *new_pci_isr = malloc(sizeof(struct pci_isr));
c0103041:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0103048:	e8 77 55 00 00       	call   c01085c4 <malloc>
c010304d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        new_pci_isr->isr = isr;
c0103050:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103053:	8b 55 08             	mov    0x8(%ebp),%edx
c0103056:	89 10                	mov    %edx,(%eax)
        new_pci_isr->dev = dev;
c0103058:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010305b:	8b 55 0c             	mov    0xc(%ebp),%edx
c010305e:	89 50 04             	mov    %edx,0x4(%eax)
        list_push_front(pci_irq_handles,new_pci_isr);
c0103061:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c0103066:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103069:	89 54 24 04          	mov    %edx,0x4(%esp)
c010306d:	89 04 24             	mov    %eax,(%esp)
c0103070:	e8 35 5d 00 00       	call   c0108daa <list_push_front>
    pci_irq_handles->lock = false;
c0103075:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c010307a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
c0103081:	c9                   	leave  
c0103082:	c3                   	ret    

c0103083 <deinstall_pci_isr>:
 * deinstalls a isr handler for a specific pci device
 * @param isr interrupt service routine
 * @param dev pci device
 */
int deinstall_pci_isr(void (*isr)(struct pci_dev *dev), struct pci_dev *dev)
{
c0103083:	55                   	push   %ebp
c0103084:	89 e5                	mov    %esp,%ebp
c0103086:	83 ec 28             	sub    $0x28,%esp
    while(pci_irq_handles->lock){}
c0103089:	90                   	nop
c010308a:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c010308f:	8b 40 08             	mov    0x8(%eax),%eax
c0103092:	85 c0                	test   %eax,%eax
c0103094:	75 f4                	jne    c010308a <deinstall_pci_isr+0x7>
    pci_irq_handles->lock = true;
c0103096:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c010309b:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
        int num = 0;
c01030a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        list_set_first(pci_irq_handles);
c01030a9:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01030ae:	89 04 24             	mov    %eax,(%esp)
c01030b1:	e8 30 5f 00 00       	call   c0108fe6 <list_set_first>
        while(!list_is_last(pci_irq_handles))
c01030b6:	eb 52                	jmp    c010310a <deinstall_pci_isr+0x87>
        {
            struct pci_isr *current_isr = list_get_current(pci_irq_handles);
c01030b8:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01030bd:	89 04 24             	mov    %eax,(%esp)
c01030c0:	e8 ce 5e 00 00       	call   c0108f93 <list_get_current>
c01030c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if(current_isr->isr == isr && current_isr->dev == dev)
c01030c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01030cb:	8b 00                	mov    (%eax),%eax
c01030cd:	3b 45 08             	cmp    0x8(%ebp),%eax
c01030d0:	75 2b                	jne    c01030fd <deinstall_pci_isr+0x7a>
c01030d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01030d5:	8b 40 04             	mov    0x4(%eax),%eax
c01030d8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c01030db:	75 20                	jne    c01030fd <deinstall_pci_isr+0x7a>
            {
                list_remove(pci_irq_handles);
c01030dd:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01030e2:	89 04 24             	mov    %eax,(%esp)
c01030e5:	e8 27 5e 00 00       	call   c0108f11 <list_remove>
                list_set_first(pci_irq_handles);
c01030ea:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01030ef:	89 04 24             	mov    %eax,(%esp)
c01030f2:	e8 ef 5e 00 00       	call   c0108fe6 <list_set_first>
                num++;
c01030f7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01030fb:	eb 0d                	jmp    c010310a <deinstall_pci_isr+0x87>
            }
            else
                list_next(pci_irq_handles);
c01030fd:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c0103102:	89 04 24             	mov    %eax,(%esp)
c0103105:	e8 97 5e 00 00       	call   c0108fa1 <list_next>
{
    while(pci_irq_handles->lock){}
    pci_irq_handles->lock = true;
        int num = 0;
        list_set_first(pci_irq_handles);
        while(!list_is_last(pci_irq_handles))
c010310a:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c010310f:	89 04 24             	mov    %eax,(%esp)
c0103112:	e8 b7 5e 00 00       	call   c0108fce <list_is_last>
c0103117:	85 c0                	test   %eax,%eax
c0103119:	74 9d                	je     c01030b8 <deinstall_pci_isr+0x35>
                num++;
            }
            else
                list_next(pci_irq_handles);
        }
    pci_irq_handles->lock = false;
c010311b:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c0103120:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return num;
c0103127:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010312a:	c9                   	leave  
c010312b:	c3                   	ret    

c010312c <pci_irq_handler>:

/**
 * handels pci irqs
 */
void pci_irq_handler(void)
{
c010312c:	55                   	push   %ebp
c010312d:	89 e5                	mov    %esp,%ebp
c010312f:	53                   	push   %ebx
c0103130:	83 ec 34             	sub    $0x34,%esp
    struct list_node *backup = pci_dev_list->head;
c0103133:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c0103138:	8b 00                	mov    (%eax),%eax
c010313a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    list_set_first(pci_dev_list);
c010313d:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c0103142:	89 04 24             	mov    %eax,(%esp)
c0103145:	e8 9c 5e 00 00       	call   c0108fe6 <list_set_first>
    while(!list_is_last(pci_dev_list))
c010314a:	e9 fd 00 00 00       	jmp    c010324c <pci_irq_handler+0x120>
    {
        struct pci_dev * current_dev = list_get_current(pci_dev_list);
c010314f:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c0103154:	89 04 24             	mov    %eax,(%esp)
c0103157:	e8 37 5e 00 00       	call   c0108f93 <list_get_current>
c010315c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        uint16_t status = pci_readw(current_dev->bus, current_dev->dev, current_dev->func, PCI_STATUS);
c010315f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103162:	0f b6 40 02          	movzbl 0x2(%eax),%eax
c0103166:	0f b6 c8             	movzbl %al,%ecx
c0103169:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010316c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
c0103170:	0f b6 d0             	movzbl %al,%edx
c0103173:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103176:	0f b6 00             	movzbl (%eax),%eax
c0103179:	0f b6 c0             	movzbl %al,%eax
c010317c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c0103183:	00 
c0103184:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0103188:	89 54 24 04          	mov    %edx,0x4(%esp)
c010318c:	89 04 24             	mov    %eax,(%esp)
c010318f:	e8 39 fb ff ff       	call   c0102ccd <pci_readw>
c0103194:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
        if(status & PCI_STATUS_INT)
c0103198:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
c010319c:	83 e0 08             	and    $0x8,%eax
c010319f:	85 c0                	test   %eax,%eax
c01031a1:	0f 84 98 00 00 00    	je     c010323f <pci_irq_handler+0x113>
        {
            list_set_first(pci_irq_handles);
c01031a7:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01031ac:	89 04 24             	mov    %eax,(%esp)
c01031af:	e8 32 5e 00 00       	call   c0108fe6 <list_set_first>
            while(!list_is_last(pci_irq_handles))
c01031b4:	eb 35                	jmp    c01031eb <pci_irq_handler+0xbf>
            {
                struct pci_isr *current_isr = list_get_current(pci_irq_handles);
c01031b6:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01031bb:	89 04 24             	mov    %eax,(%esp)
c01031be:	e8 d0 5d 00 00       	call   c0108f93 <list_get_current>
c01031c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
                if(current_isr->dev == current_dev)
c01031c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01031c9:	8b 40 04             	mov    0x4(%eax),%eax
c01031cc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c01031cf:	75 0d                	jne    c01031de <pci_irq_handler+0xb2>
                    current_isr->isr(current_dev);
c01031d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01031d4:	8b 00                	mov    (%eax),%eax
c01031d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01031d9:	89 14 24             	mov    %edx,(%esp)
c01031dc:	ff d0                	call   *%eax
                list_next(pci_irq_handles);
c01031de:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01031e3:	89 04 24             	mov    %eax,(%esp)
c01031e6:	e8 b6 5d 00 00       	call   c0108fa1 <list_next>
        struct pci_dev * current_dev = list_get_current(pci_dev_list);
        uint16_t status = pci_readw(current_dev->bus, current_dev->dev, current_dev->func, PCI_STATUS);
        if(status & PCI_STATUS_INT)
        {
            list_set_first(pci_irq_handles);
            while(!list_is_last(pci_irq_handles))
c01031eb:	a1 20 32 11 c0       	mov    0xc0113220,%eax
c01031f0:	89 04 24             	mov    %eax,(%esp)
c01031f3:	e8 d6 5d 00 00       	call   c0108fce <list_is_last>
c01031f8:	85 c0                	test   %eax,%eax
c01031fa:	74 ba                	je     c01031b6 <pci_irq_handler+0x8a>
                struct pci_isr *current_isr = list_get_current(pci_irq_handles);
                if(current_isr->dev == current_dev)
                    current_isr->isr(current_dev);
                list_next(pci_irq_handles);
            }
            pci_writel(current_dev->bus, current_dev->dev, current_dev->func, PCI_STATUS, status ^ 1);
c01031fc:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
c0103200:	83 f0 01             	xor    $0x1,%eax
c0103203:	0f b7 d8             	movzwl %ax,%ebx
c0103206:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103209:	0f b6 40 02          	movzbl 0x2(%eax),%eax
c010320d:	0f b6 c8             	movzbl %al,%ecx
c0103210:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103213:	0f b6 40 01          	movzbl 0x1(%eax),%eax
c0103217:	0f b6 d0             	movzbl %al,%edx
c010321a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010321d:	0f b6 00             	movzbl (%eax),%eax
c0103220:	0f b6 c0             	movzbl %al,%eax
c0103223:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c0103227:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010322e:	00 
c010322f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0103233:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103237:	89 04 24             	mov    %eax,(%esp)
c010323a:	e8 3f fc ff ff       	call   c0102e7e <pci_writel>
        }
        list_next(pci_dev_list);
c010323f:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c0103244:	89 04 24             	mov    %eax,(%esp)
c0103247:	e8 55 5d 00 00       	call   c0108fa1 <list_next>
 */
void pci_irq_handler(void)
{
    struct list_node *backup = pci_dev_list->head;
    list_set_first(pci_dev_list);
    while(!list_is_last(pci_dev_list))
c010324c:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c0103251:	89 04 24             	mov    %eax,(%esp)
c0103254:	e8 75 5d 00 00       	call   c0108fce <list_is_last>
c0103259:	85 c0                	test   %eax,%eax
c010325b:	0f 84 ee fe ff ff    	je     c010314f <pci_irq_handler+0x23>
            }
            pci_writel(current_dev->bus, current_dev->dev, current_dev->func, PCI_STATUS, status ^ 1);
        }
        list_next(pci_dev_list);
    }
    printf("PCI-IRQ!\n");
c0103261:	c7 04 24 29 b2 10 c0 	movl   $0xc010b229,(%esp)
c0103268:	e8 ea f6 ff ff       	call   c0102957 <puts>
    pci_dev_list->head = backup;
c010326d:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c0103272:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103275:	89 10                	mov    %edx,(%eax)
}
c0103277:	83 c4 34             	add    $0x34,%esp
c010327a:	5b                   	pop    %ebx
c010327b:	5d                   	pop    %ebp
c010327c:	c3                   	ret    

c010327d <INIT_PCI>:

#define PRINT_DEV_LIST


void INIT_PCI()
{
c010327d:	55                   	push   %ebp
c010327e:	89 e5                	mov    %esp,%ebp
c0103280:	57                   	push   %edi
c0103281:	56                   	push   %esi
c0103282:	53                   	push   %ebx
c0103283:	83 ec 5c             	sub    $0x5c,%esp
    #ifdef PRINT_DEV_LIST
        printf("PCI-devices:\n");
c0103286:	c7 04 24 32 b2 10 c0 	movl   $0xc010b232,(%esp)
c010328d:	e8 c5 f6 ff ff       	call   c0102957 <puts>
    #endif
    pci_dev_list = list_create();
c0103292:	e8 c9 59 00 00       	call   c0108c60 <list_create>
c0103297:	a3 24 32 11 c0       	mov    %eax,0xc0113224
    pci_irq_handles = list_create();
c010329c:	e8 bf 59 00 00       	call   c0108c60 <list_create>
c01032a1:	a3 20 32 11 c0       	mov    %eax,0xc0113220
    pci_dev_list->lock = true;
c01032a6:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c01032ab:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

    int dev,bus,func;

    for(bus = 0; bus < 8; bus++)
c01032b2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c01032b9:	e9 68 05 00 00       	jmp    c0103826 <INIT_PCI+0x5a9>
    {

        for(dev = 0; dev < 32; dev++)
c01032be:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c01032c5:	e9 4e 05 00 00       	jmp    c0103818 <INIT_PCI+0x59b>
        {

            for(func = 0; func < 8; func ++)
c01032ca:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c01032d1:	e9 34 05 00 00       	jmp    c010380a <INIT_PCI+0x58d>
            {

                if(pci_dev_exist(bus, dev, func))
c01032d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01032d9:	0f b6 c8             	movzbl %al,%ecx
c01032dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01032df:	0f b6 d0             	movzbl %al,%edx
c01032e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01032e5:	0f b6 c0             	movzbl %al,%eax
c01032e8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c01032ec:	89 54 24 04          	mov    %edx,0x4(%esp)
c01032f0:	89 04 24             	mov    %eax,(%esp)
c01032f3:	e8 f9 fb ff ff       	call   c0102ef1 <pci_dev_exist>
c01032f8:	85 c0                	test   %eax,%eax
c01032fa:	0f 84 06 05 00 00    	je     c0103806 <INIT_PCI+0x589>
                {
                    bool multifunc = (pci_readb(bus, dev, func,PCI_HEADERTYPE) & 0x80) >> 7;
c0103300:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103303:	0f b6 c8             	movzbl %al,%ecx
c0103306:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103309:	0f b6 d0             	movzbl %al,%edx
c010330c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010330f:	0f b6 c0             	movzbl %al,%eax
c0103312:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
c0103319:	00 
c010331a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010331e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103322:	89 04 24             	mov    %eax,(%esp)
c0103325:	e8 5a f9 ff ff       	call   c0102c84 <pci_readb>
c010332a:	c0 e8 07             	shr    $0x7,%al
c010332d:	0f b6 c0             	movzbl %al,%eax
c0103330:	89 45 d0             	mov    %eax,-0x30(%ebp)

                    if(func && ! multifunc)
c0103333:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0103337:	74 0a                	je     c0103343 <INIT_PCI+0xc6>
c0103339:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c010333d:	0f 84 c2 04 00 00    	je     c0103805 <INIT_PCI+0x588>
                        continue;

                    struct pci_dev *current_dev = malloc(sizeof(struct pci_dev));
c0103343:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
c010334a:	e8 75 52 00 00       	call   c01085c4 <malloc>
c010334f:	89 45 cc             	mov    %eax,-0x34(%ebp)

                    current_dev->bus = bus;
c0103352:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103355:	89 c2                	mov    %eax,%edx
c0103357:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010335a:	88 10                	mov    %dl,(%eax)
                    current_dev->dev = dev;
c010335c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010335f:	89 c2                	mov    %eax,%edx
c0103361:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103364:	88 50 01             	mov    %dl,0x1(%eax)
                    current_dev->func = func;
c0103367:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010336a:	89 c2                	mov    %eax,%edx
c010336c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010336f:	88 50 02             	mov    %dl,0x2(%eax)

                    uint32_t classcode = pci_readl(bus, dev, 0, PCI_REVISION);
c0103372:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103375:	0f b6 d0             	movzbl %al,%edx
c0103378:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010337b:	0f b6 c0             	movzbl %al,%eax
c010337e:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
c0103385:	00 
c0103386:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010338d:	00 
c010338e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103392:	89 04 24             	mov    %eax,(%esp)
c0103395:	e8 7c f9 ff ff       	call   c0102d16 <pci_readl>
c010339a:	89 45 c8             	mov    %eax,-0x38(%ebp)

                    current_dev->reversion_ID = (uint8_t)classcode;
c010339d:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01033a0:	89 c2                	mov    %eax,%edx
c01033a2:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01033a5:	88 50 0c             	mov    %dl,0xc(%eax)
                    current_dev->programming_interface = (uint8_t) (classcode >> 8);
c01033a8:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01033ab:	c1 e8 08             	shr    $0x8,%eax
c01033ae:	89 c2                	mov    %eax,%edx
c01033b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01033b3:	88 50 0f             	mov    %dl,0xf(%eax)
                    current_dev->sub_class = (uint8_t) (classcode >> 16);
c01033b6:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01033b9:	c1 e8 10             	shr    $0x10,%eax
c01033bc:	89 c2                	mov    %eax,%edx
c01033be:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01033c1:	88 50 0e             	mov    %dl,0xe(%eax)
                    current_dev->base_class = (uint8_t) (classcode >> 24);
c01033c4:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01033c7:	c1 e8 18             	shr    $0x18,%eax
c01033ca:	89 c2                	mov    %eax,%edx
c01033cc:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01033cf:	88 50 0d             	mov    %dl,0xd(%eax)

                    current_dev->device_ID = pci_readw(bus, dev, func, PCI_DEVICE_ID);
c01033d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01033d5:	0f b6 c8             	movzbl %al,%ecx
c01033d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01033db:	0f b6 d0             	movzbl %al,%edx
c01033de:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01033e1:	0f b6 c0             	movzbl %al,%eax
c01033e4:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c01033eb:	00 
c01033ec:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c01033f0:	89 54 24 04          	mov    %edx,0x4(%esp)
c01033f4:	89 04 24             	mov    %eax,(%esp)
c01033f7:	e8 d1 f8 ff ff       	call   c0102ccd <pci_readw>
c01033fc:	8b 55 cc             	mov    -0x34(%ebp),%edx
c01033ff:	66 89 42 08          	mov    %ax,0x8(%edx)
                    current_dev->vendor_ID = pci_readw(bus, dev, func, PCI_VENDOR_ID);
c0103403:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103406:	0f b6 c8             	movzbl %al,%ecx
c0103409:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010340c:	0f b6 d0             	movzbl %al,%edx
c010340f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103412:	0f b6 c0             	movzbl %al,%eax
c0103415:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010341c:	00 
c010341d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0103421:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103425:	89 04 24             	mov    %eax,(%esp)
c0103428:	e8 a0 f8 ff ff       	call   c0102ccd <pci_readw>
c010342d:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0103430:	66 89 42 0a          	mov    %ax,0xa(%edx)
                    current_dev->header_type = (pci_readb(bus, dev ,0, PCI_HEADERTYPE) | 0x80)^0x80;
c0103434:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103437:	0f b6 d0             	movzbl %al,%edx
c010343a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010343d:	0f b6 c0             	movzbl %al,%eax
c0103440:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
c0103447:	00 
c0103448:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010344f:	00 
c0103450:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103454:	89 04 24             	mov    %eax,(%esp)
c0103457:	e8 28 f8 ff ff       	call   c0102c84 <pci_readb>
c010345c:	89 c2                	mov    %eax,%edx
c010345e:	83 e2 7f             	and    $0x7f,%edx
c0103461:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103464:	88 50 14             	mov    %dl,0x14(%eax)
                    current_dev->multifunc = multifunc;
c0103467:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010346a:	8b 55 d0             	mov    -0x30(%ebp),%edx
c010346d:	89 50 10             	mov    %edx,0x10(%eax)

                    uint32_t irq_info = pci_readl(bus, dev, func, PCI_INTERRUPT);
c0103470:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103473:	0f b6 c8             	movzbl %al,%ecx
c0103476:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103479:	0f b6 d0             	movzbl %al,%edx
c010347c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010347f:	0f b6 c0             	movzbl %al,%eax
c0103482:	c7 44 24 0c 3c 00 00 	movl   $0x3c,0xc(%esp)
c0103489:	00 
c010348a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010348e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103492:	89 04 24             	mov    %eax,(%esp)
c0103495:	e8 7c f8 ff ff       	call   c0102d16 <pci_readl>
c010349a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
                    current_dev->irq_num = (uint8_t) irq_info;
c010349d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c01034a0:	89 c2                	mov    %eax,%edx
c01034a2:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034a5:	88 50 15             	mov    %dl,0x15(%eax)
                    current_dev->irq_pin = (uint8_t) (irq_info >> 8);
c01034a8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c01034ab:	c1 e8 08             	shr    $0x8,%eax
c01034ae:	89 c2                	mov    %eax,%edx
c01034b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034b3:	88 50 16             	mov    %dl,0x16(%eax)
                    current_dev->locked = false;
c01034b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034b9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)


                    #ifdef PRINT_DEV_LIST
                        printf("device ID: %04X  vendor ID: %04X  bus: %d  port: %d  function: %d interrupt:%d\n",current_dev->device_ID, current_dev->vendor_ID, current_dev->bus, current_dev->dev, current_dev->func, current_dev->irq_num);
c01034c0:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034c3:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c01034c7:	0f b6 f8             	movzbl %al,%edi
c01034ca:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034cd:	0f b6 40 02          	movzbl 0x2(%eax),%eax
c01034d1:	0f b6 f0             	movzbl %al,%esi
c01034d4:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034d7:	0f b6 40 01          	movzbl 0x1(%eax),%eax
c01034db:	0f b6 d8             	movzbl %al,%ebx
c01034de:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034e1:	0f b6 00             	movzbl (%eax),%eax
c01034e4:	0f b6 c8             	movzbl %al,%ecx
c01034e7:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034ea:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
c01034ee:	0f b7 d0             	movzwl %ax,%edx
c01034f1:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01034f4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c01034f8:	0f b7 c0             	movzwl %ax,%eax
c01034fb:	89 7c 24 18          	mov    %edi,0x18(%esp)
c01034ff:	89 74 24 14          	mov    %esi,0x14(%esp)
c0103503:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c0103507:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c010350b:	89 54 24 08          	mov    %edx,0x8(%esp)
c010350f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103513:	c7 04 24 40 b2 10 c0 	movl   $0xc010b240,(%esp)
c010351a:	e8 5d 1e 00 00       	call   c010537c <printf>
                    #endif

                    if(current_dev->irq_num < 16 && current_dev->irq_pin && current_dev->irq_num)
c010351f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103522:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c0103526:	3c 0f                	cmp    $0xf,%al
c0103528:	0f 87 fd 00 00 00    	ja     c010362b <INIT_PCI+0x3ae>
c010352e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103531:	0f b6 40 16          	movzbl 0x16(%eax),%eax
c0103535:	84 c0                	test   %al,%al
c0103537:	0f 84 ee 00 00 00    	je     c010362b <INIT_PCI+0x3ae>
c010353d:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103540:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c0103544:	84 c0                	test   %al,%al
c0103546:	0f 84 df 00 00 00    	je     c010362b <INIT_PCI+0x3ae>
                    {
                        if(!install_irq(current_dev->irq_num, pci_irq_handler))
c010354c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010354f:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c0103553:	0f b6 c0             	movzbl %al,%eax
c0103556:	c7 44 24 04 2c 31 10 	movl   $0xc010312c,0x4(%esp)
c010355d:	c0 
c010355e:	89 04 24             	mov    %eax,(%esp)
c0103561:	e8 20 0d 00 00       	call   c0104286 <install_irq>
c0103566:	85 c0                	test   %eax,%eax
c0103568:	0f 85 bd 00 00 00    	jne    c010362b <INIT_PCI+0x3ae>
                        {
                            set_color(RED | BLACK << 4);
c010356e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0103575:	e8 b8 f4 ff ff       	call   c0102a32 <set_color>
                            printf("WARNING: ");
c010357a:	c7 04 24 90 b2 10 c0 	movl   $0xc010b290,(%esp)
c0103581:	e8 f6 1d 00 00       	call   c010537c <printf>
                            set_color(WHITE | BLACK << 4);
c0103586:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c010358d:	e8 a0 f4 ff ff       	call   c0102a32 <set_color>
                            printf("Could not Reserver IRQ %d for PCI-DEVICE: %d:%d:%d\n", current_dev->irq_num, bus, dev, func);
c0103592:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103595:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c0103599:	0f b6 c0             	movzbl %al,%eax
c010359c:	8b 55 dc             	mov    -0x24(%ebp),%edx
c010359f:	89 54 24 10          	mov    %edx,0x10(%esp)
c01035a3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01035a6:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01035aa:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01035ad:	89 54 24 08          	mov    %edx,0x8(%esp)
c01035b1:	89 44 24 04          	mov    %eax,0x4(%esp)
c01035b5:	c7 04 24 9c b2 10 c0 	movl   $0xc010b29c,(%esp)
c01035bc:	e8 bb 1d 00 00       	call   c010537c <printf>

                            set_color(RED | BLACK << 4);
c01035c1:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c01035c8:	e8 65 f4 ff ff       	call   c0102a32 <set_color>
                            printf("WARNING: ");
c01035cd:	c7 04 24 90 b2 10 c0 	movl   $0xc010b290,(%esp)
c01035d4:	e8 a3 1d 00 00       	call   c010537c <printf>
                            set_color(WHITE | BLACK << 4);
c01035d9:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c01035e0:	e8 4d f4 ff ff       	call   c0102a32 <set_color>
                            printf("FORCING IRQ %d for the PCI-BUS\n", current_dev->irq_num);
c01035e5:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01035e8:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c01035ec:	0f b6 c0             	movzbl %al,%eax
c01035ef:	89 44 24 04          	mov    %eax,0x4(%esp)
c01035f3:	c7 04 24 d0 b2 10 c0 	movl   $0xc010b2d0,(%esp)
c01035fa:	e8 7d 1d 00 00       	call   c010537c <printf>

                            deinstall_irq(current_dev->irq_num);
c01035ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103602:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c0103606:	0f b6 c0             	movzbl %al,%eax
c0103609:	89 04 24             	mov    %eax,(%esp)
c010360c:	e8 cd 0c 00 00       	call   c01042de <deinstall_irq>
                            install_irq(current_dev->irq_num, pci_irq_handler);
c0103611:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103614:	0f b6 40 15          	movzbl 0x15(%eax),%eax
c0103618:	0f b6 c0             	movzbl %al,%eax
c010361b:	c7 44 24 04 2c 31 10 	movl   $0xc010312c,0x4(%esp)
c0103622:	c0 
c0103623:	89 04 24             	mov    %eax,(%esp)
c0103626:	e8 5b 0c 00 00       	call   c0104286 <install_irq>
                        }

                    }

                    // Standart Device
                    if(! (current_dev->header_type & 0xFF) )
c010362b:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010362e:	0f b6 40 14          	movzbl 0x14(%eax),%eax
c0103632:	84 c0                	test   %al,%al
c0103634:	0f 85 b5 01 00 00    	jne    c01037ef <INIT_PCI+0x572>
                    {
                        int base;

                        for(base = 0; base < 6; base++)
c010363a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c0103641:	e9 9f 01 00 00       	jmp    c01037e5 <INIT_PCI+0x568>
                        {
                            uint32_t current_base = pci_readl(bus, dev, func, PCI_BASE + (base * 4));
c0103646:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0103649:	83 c0 04             	add    $0x4,%eax
c010364c:	c1 e0 02             	shl    $0x2,%eax
c010364f:	0f b6 d8             	movzbl %al,%ebx
c0103652:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103655:	0f b6 c8             	movzbl %al,%ecx
c0103658:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010365b:	0f b6 d0             	movzbl %al,%edx
c010365e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103661:	0f b6 c0             	movzbl %al,%eax
c0103664:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0103668:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010366c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103670:	89 04 24             	mov    %eax,(%esp)
c0103673:	e8 9e f6 ff ff       	call   c0102d16 <pci_readl>
c0103678:	89 45 c0             	mov    %eax,-0x40(%ebp)

                            // get type
                            current_dev->base_adress[base].type = current_base & 1;
c010367b:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010367e:	89 c1                	mov    %eax,%ecx
c0103680:	83 e1 01             	and    $0x1,%ecx
c0103683:	8b 5d cc             	mov    -0x34(%ebp),%ebx
c0103686:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0103689:	89 d0                	mov    %edx,%eax
c010368b:	01 c0                	add    %eax,%eax
c010368d:	01 d0                	add    %edx,%eax
c010368f:	c1 e0 02             	shl    $0x2,%eax
c0103692:	01 d8                	add    %ebx,%eax
c0103694:	83 c0 1c             	add    $0x1c,%eax
c0103697:	89 08                	mov    %ecx,(%eax)

                            // save current adress
                            current_dev->base_adress[base].adress = (current_base | 1) ^ 1;
c0103699:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010369c:	89 c1                	mov    %eax,%ecx
c010369e:	83 e1 fe             	and    $0xfffffffe,%ecx
c01036a1:	8b 5d cc             	mov    -0x34(%ebp),%ebx
c01036a4:	8b 55 d8             	mov    -0x28(%ebp),%edx
c01036a7:	89 d0                	mov    %edx,%eax
c01036a9:	01 c0                	add    %eax,%eax
c01036ab:	01 d0                	add    %edx,%eax
c01036ad:	c1 e0 02             	shl    $0x2,%eax
c01036b0:	01 d8                	add    %ebx,%eax
c01036b2:	83 c0 18             	add    $0x18,%eax
c01036b5:	89 08                	mov    %ecx,(%eax)

                            // get reserved bits
                            pci_writel(bus, dev, func, PCI_BASE + (base * 4), 0xFFFFFFFF);
c01036b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01036ba:	83 c0 04             	add    $0x4,%eax
c01036bd:	c1 e0 02             	shl    $0x2,%eax
c01036c0:	0f b6 d8             	movzbl %al,%ebx
c01036c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01036c6:	0f b6 c8             	movzbl %al,%ecx
c01036c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01036cc:	0f b6 d0             	movzbl %al,%edx
c01036cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01036d2:	0f b6 c0             	movzbl %al,%eax
c01036d5:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
c01036dc:	ff 
c01036dd:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c01036e1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c01036e5:	89 54 24 04          	mov    %edx,0x4(%esp)
c01036e9:	89 04 24             	mov    %eax,(%esp)
c01036ec:	e8 8d f7 ff ff       	call   c0102e7e <pci_writel>
                            uint32_t temp_base = pci_readl(bus, dev, func, PCI_BASE + (base * 4));
c01036f1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01036f4:	83 c0 04             	add    $0x4,%eax
c01036f7:	c1 e0 02             	shl    $0x2,%eax
c01036fa:	0f b6 d8             	movzbl %al,%ebx
c01036fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103700:	0f b6 c8             	movzbl %al,%ecx
c0103703:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103706:	0f b6 d0             	movzbl %al,%edx
c0103709:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010370c:	0f b6 c0             	movzbl %al,%eax
c010370f:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0103713:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0103717:	89 54 24 04          	mov    %edx,0x4(%esp)
c010371b:	89 04 24             	mov    %eax,(%esp)
c010371e:	e8 f3 f5 ff ff       	call   c0102d16 <pci_readl>
c0103723:	89 45 bc             	mov    %eax,-0x44(%ebp)

                            temp_base = (~temp_base) | 1;
c0103726:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0103729:	f7 d0                	not    %eax
c010372b:	83 c8 01             	or     $0x1,%eax
c010372e:	89 45 bc             	mov    %eax,-0x44(%ebp)
                            current_dev->base_adress[base].resb = 0;
c0103731:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c0103734:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0103737:	89 d0                	mov    %edx,%eax
c0103739:	01 c0                	add    %eax,%eax
c010373b:	01 d0                	add    %edx,%eax
c010373d:	c1 e0 02             	shl    $0x2,%eax
c0103740:	01 c8                	add    %ecx,%eax
c0103742:	83 c0 10             	add    $0x10,%eax
c0103745:	c6 40 10 00          	movb   $0x0,0x10(%eax)
                            int i;
                            for(i = 0; i < 32; i++)
c0103749:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c0103750:	eb 4d                	jmp    c010379f <INIT_PCI+0x522>
                            {
                                if((temp_base & (1 << i)) != 0)
c0103752:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0103755:	ba 01 00 00 00       	mov    $0x1,%edx
c010375a:	89 d3                	mov    %edx,%ebx
c010375c:	89 c1                	mov    %eax,%ecx
c010375e:	d3 e3                	shl    %cl,%ebx
c0103760:	89 d8                	mov    %ebx,%eax
c0103762:	23 45 bc             	and    -0x44(%ebp),%eax
c0103765:	85 c0                	test   %eax,%eax
c0103767:	74 3e                	je     c01037a7 <INIT_PCI+0x52a>
                                    current_dev->base_adress[base].resb++;
c0103769:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c010376c:	8b 55 d8             	mov    -0x28(%ebp),%edx
c010376f:	89 d0                	mov    %edx,%eax
c0103771:	01 c0                	add    %eax,%eax
c0103773:	01 d0                	add    %edx,%eax
c0103775:	c1 e0 02             	shl    $0x2,%eax
c0103778:	01 c8                	add    %ecx,%eax
c010377a:	83 c0 10             	add    $0x10,%eax
c010377d:	0f b6 40 10          	movzbl 0x10(%eax),%eax
c0103781:	8d 48 01             	lea    0x1(%eax),%ecx
c0103784:	8b 5d cc             	mov    -0x34(%ebp),%ebx
c0103787:	8b 55 d8             	mov    -0x28(%ebp),%edx
c010378a:	89 d0                	mov    %edx,%eax
c010378c:	01 c0                	add    %eax,%eax
c010378e:	01 d0                	add    %edx,%eax
c0103790:	c1 e0 02             	shl    $0x2,%eax
c0103793:	01 d8                	add    %ebx,%eax
c0103795:	83 c0 10             	add    $0x10,%eax
c0103798:	88 48 10             	mov    %cl,0x10(%eax)
                            uint32_t temp_base = pci_readl(bus, dev, func, PCI_BASE + (base * 4));

                            temp_base = (~temp_base) | 1;
                            current_dev->base_adress[base].resb = 0;
                            int i;
                            for(i = 0; i < 32; i++)
c010379b:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
c010379f:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
c01037a3:	7e ad                	jle    c0103752 <INIT_PCI+0x4d5>
c01037a5:	eb 01                	jmp    c01037a8 <INIT_PCI+0x52b>
                            {
                                if((temp_base & (1 << i)) != 0)
                                    current_dev->base_adress[base].resb++;
                                else
                                    break;
c01037a7:	90                   	nop
                            }

                            //reset old state
                             pci_writel(bus, dev, func, PCI_BASE + (base * 4), current_base);
c01037a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01037ab:	83 c0 04             	add    $0x4,%eax
c01037ae:	c1 e0 02             	shl    $0x2,%eax
c01037b1:	0f b6 d8             	movzbl %al,%ebx
c01037b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01037b7:	0f b6 c8             	movzbl %al,%ecx
c01037ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01037bd:	0f b6 d0             	movzbl %al,%edx
c01037c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01037c3:	0f b6 c0             	movzbl %al,%eax
c01037c6:	8b 75 c0             	mov    -0x40(%ebp),%esi
c01037c9:	89 74 24 10          	mov    %esi,0x10(%esp)
c01037cd:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c01037d1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c01037d5:	89 54 24 04          	mov    %edx,0x4(%esp)
c01037d9:	89 04 24             	mov    %eax,(%esp)
c01037dc:	e8 9d f6 ff ff       	call   c0102e7e <pci_writel>
                    // Standart Device
                    if(! (current_dev->header_type & 0xFF) )
                    {
                        int base;

                        for(base = 0; base < 6; base++)
c01037e1:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
c01037e5:	83 7d d8 05          	cmpl   $0x5,-0x28(%ebp)
c01037e9:	0f 8e 57 fe ff ff    	jle    c0103646 <INIT_PCI+0x3c9>
                    else
                    {
                        //TODO: Write Cases for Bridges
                    }

                    list_push_front(pci_dev_list, current_dev);
c01037ef:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c01037f4:	8b 55 cc             	mov    -0x34(%ebp),%edx
c01037f7:	89 54 24 04          	mov    %edx,0x4(%esp)
c01037fb:	89 04 24             	mov    %eax,(%esp)
c01037fe:	e8 a7 55 00 00       	call   c0108daa <list_push_front>
c0103803:	eb 01                	jmp    c0103806 <INIT_PCI+0x589>
                if(pci_dev_exist(bus, dev, func))
                {
                    bool multifunc = (pci_readb(bus, dev, func,PCI_HEADERTYPE) & 0x80) >> 7;

                    if(func && ! multifunc)
                        continue;
c0103805:	90                   	nop
    {

        for(dev = 0; dev < 32; dev++)
        {

            for(func = 0; func < 8; func ++)
c0103806:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c010380a:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
c010380e:	0f 8e c2 fa ff ff    	jle    c01032d6 <INIT_PCI+0x59>
    int dev,bus,func;

    for(bus = 0; bus < 8; bus++)
    {

        for(dev = 0; dev < 32; dev++)
c0103814:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0103818:	83 7d e4 1f          	cmpl   $0x1f,-0x1c(%ebp)
c010381c:	0f 8e a8 fa ff ff    	jle    c01032ca <INIT_PCI+0x4d>
    pci_irq_handles = list_create();
    pci_dev_list->lock = true;

    int dev,bus,func;

    for(bus = 0; bus < 8; bus++)
c0103822:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c0103826:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
c010382a:	0f 8e 8e fa ff ff    	jle    c01032be <INIT_PCI+0x41>
                    list_push_front(pci_dev_list, current_dev);
                }
            }
        }
    }
    pci_dev_list->lock = false;
c0103830:	a1 24 32 11 c0       	mov    0xc0113224,%eax
c0103835:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    #ifdef PRINT_DEV_LIST
        printf("\n");
c010383c:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0103843:	e8 b0 ef ff ff       	call   c01027f8 <putchar>
    #endif
}
c0103848:	83 c4 5c             	add    $0x5c,%esp
c010384b:	5b                   	pop    %ebx
c010384c:	5e                   	pop    %esi
c010384d:	5f                   	pop    %edi
c010384e:	5d                   	pop    %ebp
c010384f:	c3                   	ret    

c0103850 <inb>:
*/

#include <stdint.h>


static inline uint8_t inb(uint16_t port) {
c0103850:	55                   	push   %ebp
c0103851:	89 e5                	mov    %esp,%ebp
c0103853:	53                   	push   %ebx
c0103854:	83 ec 14             	sub    $0x14,%esp
c0103857:	8b 45 08             	mov    0x8(%ebp),%eax
c010385a:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	uint8_t result;
	asm volatile("inb %1, %0" : "=a" (result) : "Nd" (port));
c010385e:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0103862:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c0103866:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c010386a:	ec                   	in     (%dx),%al
c010386b:	89 c3                	mov    %eax,%ebx
c010386d:	88 5d fb             	mov    %bl,-0x5(%ebp)
	return result;
c0103870:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
}
c0103874:	83 c4 14             	add    $0x14,%esp
c0103877:	5b                   	pop    %ebx
c0103878:	5d                   	pop    %ebp
c0103879:	c3                   	ret    

c010387a <outb>:
	uint32_t result;
	asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
	return result;
}

static inline void outb(uint16_t port, uint8_t value) {
c010387a:	55                   	push   %ebp
c010387b:	89 e5                	mov    %esp,%ebp
c010387d:	83 ec 08             	sub    $0x8,%esp
c0103880:	8b 55 08             	mov    0x8(%ebp),%edx
c0103883:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103886:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010388a:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c010388d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0103891:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0103895:	ee                   	out    %al,(%dx)
}
c0103896:	c9                   	leave  
c0103897:	c3                   	ret    

c0103898 <sound_on>:
	along with Universe Kernel.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <io.h>

void sound_on() {
c0103898:	55                   	push   %ebp
c0103899:	89 e5                	mov    %esp,%ebp
c010389b:	83 ec 08             	sub    $0x8,%esp
	outb(0x61, inb(0x61) | 3);
c010389e:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
c01038a5:	e8 a6 ff ff ff       	call   c0103850 <inb>
c01038aa:	83 c8 03             	or     $0x3,%eax
c01038ad:	0f b6 c0             	movzbl %al,%eax
c01038b0:	89 44 24 04          	mov    %eax,0x4(%esp)
c01038b4:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
c01038bb:	e8 ba ff ff ff       	call   c010387a <outb>
}
c01038c0:	c9                   	leave  
c01038c1:	c3                   	ret    

c01038c2 <sound_off>:

void sound_off() {
c01038c2:	55                   	push   %ebp
c01038c3:	89 e5                	mov    %esp,%ebp
c01038c5:	83 ec 08             	sub    $0x8,%esp
	outb(0x61, inb(0x61) & ~3);
c01038c8:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
c01038cf:	e8 7c ff ff ff       	call   c0103850 <inb>
c01038d4:	0f b6 c0             	movzbl %al,%eax
c01038d7:	25 fc 00 00 00       	and    $0xfc,%eax
c01038dc:	89 44 24 04          	mov    %eax,0x4(%esp)
c01038e0:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
c01038e7:	e8 8e ff ff ff       	call   c010387a <outb>
}
c01038ec:	c9                   	leave  
c01038ed:	c3                   	ret    

c01038ee <sound>:

void sound(uint32_t frequency, uint32_t time) {
c01038ee:	55                   	push   %ebp
c01038ef:	89 e5                	mov    %esp,%ebp
c01038f1:	83 ec 18             	sub    $0x18,%esp
	int i;
	uint16_t tmp;
	tmp = 1193180 / frequency;
c01038f4:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c01038f9:	ba 00 00 00 00       	mov    $0x0,%edx
c01038fe:	f7 75 08             	divl   0x8(%ebp)
c0103901:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	outb(0x43, 0xB6);
c0103905:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
c010390c:	00 
c010390d:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
c0103914:	e8 61 ff ff ff       	call   c010387a <outb>
	outb(0x42, tmp & 0xFF);
c0103919:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
c010391d:	0f b6 c0             	movzbl %al,%eax
c0103920:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103924:	c7 04 24 42 00 00 00 	movl   $0x42,(%esp)
c010392b:	e8 4a ff ff ff       	call   c010387a <outb>
	outb(0x42, tmp >> 8);
c0103930:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
c0103934:	66 c1 e8 08          	shr    $0x8,%ax
c0103938:	0f b6 c0             	movzbl %al,%eax
c010393b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010393f:	c7 04 24 42 00 00 00 	movl   $0x42,(%esp)
c0103946:	e8 2f ff ff ff       	call   c010387a <outb>
	sound_on();
c010394b:	e8 48 ff ff ff       	call   c0103898 <sound_on>
	for (i = 0; i < time * 10000; i++);
c0103950:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0103957:	eb 04                	jmp    c010395d <sound+0x6f>
c0103959:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010395d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0103960:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103963:	69 c0 10 27 00 00    	imul   $0x2710,%eax,%eax
c0103969:	39 c2                	cmp    %eax,%edx
c010396b:	72 ec                	jb     c0103959 <sound+0x6b>
	sound_off();
c010396d:	e8 50 ff ff ff       	call   c01038c2 <sound_off>
}
c0103972:	c9                   	leave  
c0103973:	c3                   	ret    

c0103974 <outb>:
	uint32_t result;
	asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
	return result;
}

static inline void outb(uint16_t port, uint8_t value) {
c0103974:	55                   	push   %ebp
c0103975:	89 e5                	mov    %esp,%ebp
c0103977:	83 ec 08             	sub    $0x8,%esp
c010397a:	8b 55 08             	mov    0x8(%ebp),%edx
c010397d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103980:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0103984:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c0103987:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c010398b:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c010398f:	ee                   	out    %al,(%dx)
}
c0103990:	c9                   	leave  
c0103991:	c3                   	ret    

c0103992 <set_pit_freq>:
 * set PIT Fequency
 *
 * @param freqency
 * @return void
 */
void set_pit_freq(int freq) {
c0103992:	55                   	push   %ebp
c0103993:	89 e5                	mov    %esp,%ebp
c0103995:	83 ec 18             	sub    $0x18,%esp
	int counter = 1193182 / freq;
c0103998:	b8 de 34 12 00       	mov    $0x1234de,%eax
c010399d:	89 c2                	mov    %eax,%edx
c010399f:	c1 fa 1f             	sar    $0x1f,%edx
c01039a2:	f7 7d 08             	idivl  0x8(%ebp)
c01039a5:	89 45 fc             	mov    %eax,-0x4(%ebp)
   	outb(0x40,counter & 0xFF);
c01039a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01039ab:	0f b6 c0             	movzbl %al,%eax
c01039ae:	89 44 24 04          	mov    %eax,0x4(%esp)
c01039b2:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
c01039b9:	e8 b6 ff ff ff       	call   c0103974 <outb>
   	outb(0x40,counter >> 8);
c01039be:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01039c1:	c1 f8 08             	sar    $0x8,%eax
c01039c4:	0f b6 c0             	movzbl %al,%eax
c01039c7:	89 44 24 04          	mov    %eax,0x4(%esp)
c01039cb:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
c01039d2:	e8 9d ff ff ff       	call   c0103974 <outb>
}
c01039d7:	c9                   	leave  
c01039d8:	c3                   	ret    

c01039d9 <INIT_PIT>:
 * Initalize the Programmable Intervall Timer
 *
 * @param frequency
 * @return void
 */
void INIT_PIT(int freq) {
c01039d9:	55                   	push   %ebp
c01039da:	89 e5                	mov    %esp,%ebp
c01039dc:	83 ec 08             	sub    $0x8,%esp
	outb(0x43, 0x34);
c01039df:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
c01039e6:	00 
c01039e7:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
c01039ee:	e8 81 ff ff ff       	call   c0103974 <outb>
	set_pit_freq(freq);
c01039f3:	8b 45 08             	mov    0x8(%ebp),%eax
c01039f6:	89 04 24             	mov    %eax,(%esp)
c01039f9:	e8 94 ff ff ff       	call   c0103992 <set_pit_freq>
}
c01039fe:	c9                   	leave  
c01039ff:	c3                   	ret    

c0103a00 <INIT_RTC>:
 * Initalize the Real Time Clock
 *
 * @param void
 * @return void
 */
void INIT_RTC(void) {
c0103a00:	55                   	push   %ebp
c0103a01:	89 e5                	mov    %esp,%ebp
c0103a03:	83 ec 18             	sub    $0x18,%esp
	install_irq(0x8, &rtc_irq_handler);
c0103a06:	c7 44 24 04 69 3a 10 	movl   $0xc0103a69,0x4(%esp)
c0103a0d:	c0 
c0103a0e:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0103a15:	e8 6c 08 00 00       	call   c0104286 <install_irq>

	cmos = get_cmos_data();
c0103a1a:	e8 37 06 00 00       	call   c0104056 <get_cmos_data>
c0103a1f:	a3 34 32 11 c0       	mov    %eax,0xc0113234
	cmos_write_byte(0x0A, (cmos->registers.register_a & 0xF0) | 0x0F);
c0103a24:	a1 34 32 11 c0       	mov    0xc0113234,%eax
c0103a29:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0103a2d:	83 c8 0f             	or     $0xf,%eax
c0103a30:	0f b6 c0             	movzbl %al,%eax
c0103a33:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103a37:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0103a3e:	e8 6b 06 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x0B, cmos->registers.register_b | 0x40);
c0103a43:	a1 34 32 11 c0       	mov    0xc0113234,%eax
c0103a48:	0f b6 40 05          	movzbl 0x5(%eax),%eax
c0103a4c:	83 c8 40             	or     $0x40,%eax
c0103a4f:	0f b6 c0             	movzbl %al,%eax
c0103a52:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103a56:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
c0103a5d:	e8 4c 06 00 00       	call   c01040ae <cmos_write_byte>

	update_time();
c0103a62:	e8 29 00 00 00       	call   c0103a90 <update_time>
}
c0103a67:	c9                   	leave  
c0103a68:	c3                   	ret    

c0103a69 <rtc_irq_handler>:
 * IRQ-handler for the RTC
 *
 * @param void
 * @return void
 */
void rtc_irq_handler(void) {
c0103a69:	55                   	push   %ebp
c0103a6a:	89 e5                	mov    %esp,%ebp
c0103a6c:	53                   	push   %ebx
c0103a6d:	83 ec 14             	sub    $0x14,%esp
	cmos->registers.register_c = cmos_read_byte(0x0C);
c0103a70:	8b 1d 34 32 11 c0    	mov    0xc0113234,%ebx
c0103a76:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0103a7d:	e8 de 05 00 00       	call   c0104060 <cmos_read_byte>
c0103a82:	88 43 06             	mov    %al,0x6(%ebx)
	update_time();
c0103a85:	e8 06 00 00 00       	call   c0103a90 <update_time>
}
c0103a8a:	83 c4 14             	add    $0x14,%esp
c0103a8d:	5b                   	pop    %ebx
c0103a8e:	5d                   	pop    %ebp
c0103a8f:	c3                   	ret    

c0103a90 <update_time>:
 * @param void
 *
 * @return success
 */
int update_time(void)
{
c0103a90:	55                   	push   %ebp
c0103a91:	89 e5                	mov    %esp,%ebp
c0103a93:	53                   	push   %ebx
c0103a94:	83 ec 14             	sub    $0x14,%esp
	current_time.second =       BCD_DECODE(cmos_read_byte(0x00));
c0103a97:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0103a9e:	e8 bd 05 00 00       	call   c0104060 <cmos_read_byte>
c0103aa3:	89 c3                	mov    %eax,%ebx
c0103aa5:	83 e3 0f             	and    $0xf,%ebx
c0103aa8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0103aaf:	e8 ac 05 00 00       	call   c0104060 <cmos_read_byte>
c0103ab4:	89 c2                	mov    %eax,%edx
c0103ab6:	c0 ea 04             	shr    $0x4,%dl
c0103ab9:	89 d0                	mov    %edx,%eax
c0103abb:	c1 e0 02             	shl    $0x2,%eax
c0103abe:	01 d0                	add    %edx,%eax
c0103ac0:	01 c0                	add    %eax,%eax
c0103ac2:	01 d8                	add    %ebx,%eax
c0103ac4:	a2 28 32 11 c0       	mov    %al,0xc0113228
	current_time.alarm_sec =    BCD_DECODE(cmos_read_byte(0x01));
c0103ac9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0103ad0:	e8 8b 05 00 00       	call   c0104060 <cmos_read_byte>
c0103ad5:	89 c3                	mov    %eax,%ebx
c0103ad7:	83 e3 0f             	and    $0xf,%ebx
c0103ada:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0103ae1:	e8 7a 05 00 00       	call   c0104060 <cmos_read_byte>
c0103ae6:	89 c2                	mov    %eax,%edx
c0103ae8:	c0 ea 04             	shr    $0x4,%dl
c0103aeb:	89 d0                	mov    %edx,%eax
c0103aed:	c1 e0 02             	shl    $0x2,%eax
c0103af0:	01 d0                	add    %edx,%eax
c0103af2:	01 c0                	add    %eax,%eax
c0103af4:	01 d8                	add    %ebx,%eax
c0103af6:	a2 29 32 11 c0       	mov    %al,0xc0113229
	current_time.minute =       BCD_DECODE(cmos_read_byte(0x02));
c0103afb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c0103b02:	e8 59 05 00 00       	call   c0104060 <cmos_read_byte>
c0103b07:	89 c3                	mov    %eax,%ebx
c0103b09:	83 e3 0f             	and    $0xf,%ebx
c0103b0c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c0103b13:	e8 48 05 00 00       	call   c0104060 <cmos_read_byte>
c0103b18:	89 c2                	mov    %eax,%edx
c0103b1a:	c0 ea 04             	shr    $0x4,%dl
c0103b1d:	89 d0                	mov    %edx,%eax
c0103b1f:	c1 e0 02             	shl    $0x2,%eax
c0103b22:	01 d0                	add    %edx,%eax
c0103b24:	01 c0                	add    %eax,%eax
c0103b26:	01 d8                	add    %ebx,%eax
c0103b28:	a2 2a 32 11 c0       	mov    %al,0xc011322a
	current_time.alarm_min =    BCD_DECODE(cmos_read_byte(0x03));
c0103b2d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0103b34:	e8 27 05 00 00       	call   c0104060 <cmos_read_byte>
c0103b39:	89 c3                	mov    %eax,%ebx
c0103b3b:	83 e3 0f             	and    $0xf,%ebx
c0103b3e:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0103b45:	e8 16 05 00 00       	call   c0104060 <cmos_read_byte>
c0103b4a:	89 c2                	mov    %eax,%edx
c0103b4c:	c0 ea 04             	shr    $0x4,%dl
c0103b4f:	89 d0                	mov    %edx,%eax
c0103b51:	c1 e0 02             	shl    $0x2,%eax
c0103b54:	01 d0                	add    %edx,%eax
c0103b56:	01 c0                	add    %eax,%eax
c0103b58:	01 d8                	add    %ebx,%eax
c0103b5a:	a2 2b 32 11 c0       	mov    %al,0xc011322b
	current_time.hour =         BCD_DECODE(cmos_read_byte(0x04));
c0103b5f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0103b66:	e8 f5 04 00 00       	call   c0104060 <cmos_read_byte>
c0103b6b:	89 c3                	mov    %eax,%ebx
c0103b6d:	83 e3 0f             	and    $0xf,%ebx
c0103b70:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0103b77:	e8 e4 04 00 00       	call   c0104060 <cmos_read_byte>
c0103b7c:	89 c2                	mov    %eax,%edx
c0103b7e:	c0 ea 04             	shr    $0x4,%dl
c0103b81:	89 d0                	mov    %edx,%eax
c0103b83:	c1 e0 02             	shl    $0x2,%eax
c0103b86:	01 d0                	add    %edx,%eax
c0103b88:	01 c0                	add    %eax,%eax
c0103b8a:	01 d8                	add    %ebx,%eax
c0103b8c:	a2 2c 32 11 c0       	mov    %al,0xc011322c
	current_time.alarm_hour =   BCD_DECODE(cmos_read_byte(0x05));
c0103b91:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c0103b98:	e8 c3 04 00 00       	call   c0104060 <cmos_read_byte>
c0103b9d:	89 c3                	mov    %eax,%ebx
c0103b9f:	83 e3 0f             	and    $0xf,%ebx
c0103ba2:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c0103ba9:	e8 b2 04 00 00       	call   c0104060 <cmos_read_byte>
c0103bae:	89 c2                	mov    %eax,%edx
c0103bb0:	c0 ea 04             	shr    $0x4,%dl
c0103bb3:	89 d0                	mov    %edx,%eax
c0103bb5:	c1 e0 02             	shl    $0x2,%eax
c0103bb8:	01 d0                	add    %edx,%eax
c0103bba:	01 c0                	add    %eax,%eax
c0103bbc:	01 d8                	add    %ebx,%eax
c0103bbe:	a2 2d 32 11 c0       	mov    %al,0xc011322d
	current_time.week_day =     BCD_DECODE(cmos_read_byte(0x06)) - 1;
c0103bc3:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c0103bca:	e8 91 04 00 00       	call   c0104060 <cmos_read_byte>
c0103bcf:	89 c3                	mov    %eax,%ebx
c0103bd1:	83 e3 0f             	and    $0xf,%ebx
c0103bd4:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c0103bdb:	e8 80 04 00 00       	call   c0104060 <cmos_read_byte>
c0103be0:	89 c2                	mov    %eax,%edx
c0103be2:	c0 ea 04             	shr    $0x4,%dl
c0103be5:	89 d0                	mov    %edx,%eax
c0103be7:	c1 e0 02             	shl    $0x2,%eax
c0103bea:	01 d0                	add    %edx,%eax
c0103bec:	01 c0                	add    %eax,%eax
c0103bee:	01 d8                	add    %ebx,%eax
c0103bf0:	83 e8 01             	sub    $0x1,%eax
c0103bf3:	a2 2e 32 11 c0       	mov    %al,0xc011322e
	current_time.day_in_month = BCD_DECODE(cmos_read_byte(0x07));
c0103bf8:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c0103bff:	e8 5c 04 00 00       	call   c0104060 <cmos_read_byte>
c0103c04:	89 c3                	mov    %eax,%ebx
c0103c06:	83 e3 0f             	and    $0xf,%ebx
c0103c09:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c0103c10:	e8 4b 04 00 00       	call   c0104060 <cmos_read_byte>
c0103c15:	89 c2                	mov    %eax,%edx
c0103c17:	c0 ea 04             	shr    $0x4,%dl
c0103c1a:	89 d0                	mov    %edx,%eax
c0103c1c:	c1 e0 02             	shl    $0x2,%eax
c0103c1f:	01 d0                	add    %edx,%eax
c0103c21:	01 c0                	add    %eax,%eax
c0103c23:	01 d8                	add    %ebx,%eax
c0103c25:	a2 2f 32 11 c0       	mov    %al,0xc011322f
	current_time.month =        BCD_DECODE(cmos_read_byte(0x08));
c0103c2a:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0103c31:	e8 2a 04 00 00       	call   c0104060 <cmos_read_byte>
c0103c36:	89 c3                	mov    %eax,%ebx
c0103c38:	83 e3 0f             	and    $0xf,%ebx
c0103c3b:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0103c42:	e8 19 04 00 00       	call   c0104060 <cmos_read_byte>
c0103c47:	89 c2                	mov    %eax,%edx
c0103c49:	c0 ea 04             	shr    $0x4,%dl
c0103c4c:	89 d0                	mov    %edx,%eax
c0103c4e:	c1 e0 02             	shl    $0x2,%eax
c0103c51:	01 d0                	add    %edx,%eax
c0103c53:	01 c0                	add    %eax,%eax
c0103c55:	01 d8                	add    %ebx,%eax
c0103c57:	a2 30 32 11 c0       	mov    %al,0xc0113230
	current_time.year =         BCD_DECODE(cmos_read_byte(0x09));
c0103c5c:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c0103c63:	e8 f8 03 00 00       	call   c0104060 <cmos_read_byte>
c0103c68:	89 c3                	mov    %eax,%ebx
c0103c6a:	83 e3 0f             	and    $0xf,%ebx
c0103c6d:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c0103c74:	e8 e7 03 00 00       	call   c0104060 <cmos_read_byte>
c0103c79:	89 c2                	mov    %eax,%edx
c0103c7b:	c0 ea 04             	shr    $0x4,%dl
c0103c7e:	89 d0                	mov    %edx,%eax
c0103c80:	c1 e0 02             	shl    $0x2,%eax
c0103c83:	01 d0                	add    %edx,%eax
c0103c85:	01 c0                	add    %eax,%eax
c0103c87:	01 d8                	add    %ebx,%eax
c0103c89:	a2 31 32 11 c0       	mov    %al,0xc0113231
	current_time.century =      BCD_DECODE(cmos_read_byte(0x32));
c0103c8e:	c7 04 24 32 00 00 00 	movl   $0x32,(%esp)
c0103c95:	e8 c6 03 00 00       	call   c0104060 <cmos_read_byte>
c0103c9a:	89 c3                	mov    %eax,%ebx
c0103c9c:	83 e3 0f             	and    $0xf,%ebx
c0103c9f:	c7 04 24 32 00 00 00 	movl   $0x32,(%esp)
c0103ca6:	e8 b5 03 00 00       	call   c0104060 <cmos_read_byte>
c0103cab:	89 c2                	mov    %eax,%edx
c0103cad:	c0 ea 04             	shr    $0x4,%dl
c0103cb0:	89 d0                	mov    %edx,%eax
c0103cb2:	c1 e0 02             	shl    $0x2,%eax
c0103cb5:	01 d0                	add    %edx,%eax
c0103cb7:	01 c0                	add    %eax,%eax
c0103cb9:	01 d8                	add    %ebx,%eax
c0103cbb:	a2 32 32 11 c0       	mov    %al,0xc0113232

	return 0;
c0103cc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103cc5:	83 c4 14             	add    $0x14,%esp
c0103cc8:	5b                   	pop    %ebx
c0103cc9:	5d                   	pop    %ebp
c0103cca:	c3                   	ret    

c0103ccb <change_time>:
 * @param time New time
 *
 * @return success
 */
/* TODO: BCD_ENCODE */
int change_time(time_t time) {
c0103ccb:	55                   	push   %ebp
c0103ccc:	89 e5                	mov    %esp,%ebp
c0103cce:	83 ec 18             	sub    $0x18,%esp
	cmos_write_byte(0x00, time.second);
c0103cd1:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
c0103cd5:	0f b6 c0             	movzbl %al,%eax
c0103cd8:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103cdc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0103ce3:	e8 c6 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x01, time.alarm_sec);
c0103ce8:	0f b6 45 09          	movzbl 0x9(%ebp),%eax
c0103cec:	0f b6 c0             	movzbl %al,%eax
c0103cef:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103cf3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0103cfa:	e8 af 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x02, time.minute);
c0103cff:	0f b6 45 0a          	movzbl 0xa(%ebp),%eax
c0103d03:	0f b6 c0             	movzbl %al,%eax
c0103d06:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d0a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c0103d11:	e8 98 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x03, time.alarm_min);
c0103d16:	0f b6 45 0b          	movzbl 0xb(%ebp),%eax
c0103d1a:	0f b6 c0             	movzbl %al,%eax
c0103d1d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d21:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0103d28:	e8 81 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x04, time.hour);
c0103d2d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
c0103d31:	0f b6 c0             	movzbl %al,%eax
c0103d34:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d38:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0103d3f:	e8 6a 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x05, time.alarm_hour);
c0103d44:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
c0103d48:	0f b6 c0             	movzbl %al,%eax
c0103d4b:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d4f:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c0103d56:	e8 53 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x06, time.week_day);
c0103d5b:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
c0103d5f:	0f b6 c0             	movzbl %al,%eax
c0103d62:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d66:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c0103d6d:	e8 3c 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x07, time.day_in_month);
c0103d72:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
c0103d76:	0f b6 c0             	movzbl %al,%eax
c0103d79:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d7d:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c0103d84:	e8 25 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x08, time.month);
c0103d89:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
c0103d8d:	0f b6 c0             	movzbl %al,%eax
c0103d90:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d94:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0103d9b:	e8 0e 03 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x09, time.year);
c0103da0:	0f b6 45 11          	movzbl 0x11(%ebp),%eax
c0103da4:	0f b6 c0             	movzbl %al,%eax
c0103da7:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103dab:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c0103db2:	e8 f7 02 00 00       	call   c01040ae <cmos_write_byte>
	cmos_write_byte(0x32, time.century);
c0103db7:	0f b6 45 12          	movzbl 0x12(%ebp),%eax
c0103dbb:	0f b6 c0             	movzbl %al,%eax
c0103dbe:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103dc2:	c7 04 24 32 00 00 00 	movl   $0x32,(%esp)
c0103dc9:	e8 e0 02 00 00       	call   c01040ae <cmos_write_byte>

	return 0;
c0103dce:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103dd3:	c9                   	leave  
c0103dd4:	c3                   	ret    

c0103dd5 <get_time>:
 *
 * @param void
 *
 * @return pointer to the current_time
 */
time_t *get_time(void) {
c0103dd5:	55                   	push   %ebp
c0103dd6:	89 e5                	mov    %esp,%ebp
	return &current_time;
c0103dd8:	b8 28 32 11 c0       	mov    $0xc0113228,%eax
}
c0103ddd:	5d                   	pop    %ebp
c0103dde:	c3                   	ret    

c0103ddf <print_time>:

/**
 * Print datetime
 */
void print_time(time_t * time)
{
c0103ddf:	55                   	push   %ebp
c0103de0:	89 e5                	mov    %esp,%ebp
c0103de2:	53                   	push   %ebx
c0103de3:	83 ec 34             	sub    $0x34,%esp
	char *day_string;
	switch (time->week_day) {
c0103de6:	8b 45 08             	mov    0x8(%ebp),%eax
c0103de9:	0f b6 40 06          	movzbl 0x6(%eax),%eax
c0103ded:	0f b6 c0             	movzbl %al,%eax
c0103df0:	83 f8 06             	cmp    $0x6,%eax
c0103df3:	77 47                	ja     c0103e3c <print_time+0x5d>
c0103df5:	8b 04 85 6c b3 10 c0 	mov    -0x3fef4c94(,%eax,4),%eax
c0103dfc:	ff e0                	jmp    *%eax
		case 0: day_string = "Sonntag";		break;
c0103dfe:	c7 45 f4 f0 b2 10 c0 	movl   $0xc010b2f0,-0xc(%ebp)
c0103e05:	eb 35                	jmp    c0103e3c <print_time+0x5d>
		case 1: day_string = "Montag";		break;
c0103e07:	c7 45 f4 f8 b2 10 c0 	movl   $0xc010b2f8,-0xc(%ebp)
c0103e0e:	eb 2c                	jmp    c0103e3c <print_time+0x5d>
		case 2: day_string = "Dienstag";	break;
c0103e10:	c7 45 f4 ff b2 10 c0 	movl   $0xc010b2ff,-0xc(%ebp)
c0103e17:	eb 23                	jmp    c0103e3c <print_time+0x5d>
		case 3: day_string = "Mittwoch";	break;
c0103e19:	c7 45 f4 08 b3 10 c0 	movl   $0xc010b308,-0xc(%ebp)
c0103e20:	eb 1a                	jmp    c0103e3c <print_time+0x5d>
		case 4: day_string = "Donnerstag";	break;
c0103e22:	c7 45 f4 11 b3 10 c0 	movl   $0xc010b311,-0xc(%ebp)
c0103e29:	eb 11                	jmp    c0103e3c <print_time+0x5d>
		case 5: day_string = "Freitag";		break;
c0103e2b:	c7 45 f4 1c b3 10 c0 	movl   $0xc010b31c,-0xc(%ebp)
c0103e32:	eb 08                	jmp    c0103e3c <print_time+0x5d>
		case 6: day_string = "Samstag";		break;
c0103e34:	c7 45 f4 24 b3 10 c0 	movl   $0xc010b324,-0xc(%ebp)
c0103e3b:	90                   	nop
	}

	printf("System Date: %02d/%02d/%02d (%s)\n", time->day_in_month, time->month, time->year, day_string);
c0103e3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e3f:	0f b6 40 09          	movzbl 0x9(%eax),%eax
c0103e43:	0f b6 c8             	movzbl %al,%ecx
c0103e46:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e49:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c0103e4d:	0f b6 d0             	movzbl %al,%edx
c0103e50:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e53:	0f b6 40 07          	movzbl 0x7(%eax),%eax
c0103e57:	0f b6 c0             	movzbl %al,%eax
c0103e5a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0103e5d:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c0103e61:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0103e65:	89 54 24 08          	mov    %edx,0x8(%esp)
c0103e69:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103e6d:	c7 04 24 2c b3 10 c0 	movl   $0xc010b32c,(%esp)
c0103e74:	e8 03 15 00 00       	call   c010537c <printf>
	printf("System Time: %02d:%02d:%02d\n", time->hour, time->minute, time->second);
c0103e79:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e7c:	0f b6 00             	movzbl (%eax),%eax
c0103e7f:	0f b6 c8             	movzbl %al,%ecx
c0103e82:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e85:	0f b6 40 02          	movzbl 0x2(%eax),%eax
c0103e89:	0f b6 d0             	movzbl %al,%edx
c0103e8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e8f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0103e93:	0f b6 c0             	movzbl %al,%eax
c0103e96:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0103e9a:	89 54 24 08          	mov    %edx,0x8(%esp)
c0103e9e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103ea2:	c7 04 24 4e b3 10 c0 	movl   $0xc010b34e,(%esp)
c0103ea9:	e8 ce 14 00 00       	call   c010537c <printf>
}
c0103eae:	83 c4 34             	add    $0x34,%esp
c0103eb1:	5b                   	pop    %ebx
c0103eb2:	5d                   	pop    %ebp
c0103eb3:	c3                   	ret    

c0103eb4 <inb>:
*/

#include <stdint.h>


static inline uint8_t inb(uint16_t port) {
c0103eb4:	55                   	push   %ebp
c0103eb5:	89 e5                	mov    %esp,%ebp
c0103eb7:	53                   	push   %ebx
c0103eb8:	83 ec 14             	sub    $0x14,%esp
c0103ebb:	8b 45 08             	mov    0x8(%ebp),%eax
c0103ebe:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	uint8_t result;
	asm volatile("inb %1, %0" : "=a" (result) : "Nd" (port));
c0103ec2:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0103ec6:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c0103eca:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c0103ece:	ec                   	in     (%dx),%al
c0103ecf:	89 c3                	mov    %eax,%ebx
c0103ed1:	88 5d fb             	mov    %bl,-0x5(%ebp)
	return result;
c0103ed4:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
}
c0103ed8:	83 c4 14             	add    $0x14,%esp
c0103edb:	5b                   	pop    %ebx
c0103edc:	5d                   	pop    %ebp
c0103edd:	c3                   	ret    

c0103ede <outb>:
	uint32_t result;
	asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
	return result;
}

static inline void outb(uint16_t port, uint8_t value) {
c0103ede:	55                   	push   %ebp
c0103edf:	89 e5                	mov    %esp,%ebp
c0103ee1:	83 ec 08             	sub    $0x8,%esp
c0103ee4:	8b 55 08             	mov    0x8(%ebp),%edx
c0103ee7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103eea:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0103eee:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c0103ef1:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0103ef5:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0103ef9:	ee                   	out    %al,(%dx)
}
c0103efa:	c9                   	leave  
c0103efb:	c3                   	ret    

c0103efc <INIT_CMOS>:
 * Reads the Values from Complementary Metal Oxide Semiconductor
 *
 * @param void
 * @return void
 */
void INIT_CMOS(void) {
c0103efc:	55                   	push   %ebp
c0103efd:	89 e5                	mov    %esp,%ebp
c0103eff:	83 ec 18             	sub    $0x18,%esp
	cmos.registers.register_a = cmos_read_byte(0x0A);
c0103f02:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0103f09:	e8 52 01 00 00       	call   c0104060 <cmos_read_byte>
c0103f0e:	a2 38 32 11 c0       	mov    %al,0xc0113238
	cmos.registers.register_b = cmos_read_byte(0x0B);
c0103f13:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
c0103f1a:	e8 41 01 00 00       	call   c0104060 <cmos_read_byte>
c0103f1f:	a2 39 32 11 c0       	mov    %al,0xc0113239
	cmos.registers.register_c = cmos_read_byte(0x0C);
c0103f24:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0103f2b:	e8 30 01 00 00       	call   c0104060 <cmos_read_byte>
c0103f30:	a2 3a 32 11 c0       	mov    %al,0xc011323a
	cmos.registers.register_d = cmos_read_byte(0x0D);
c0103f35:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
c0103f3c:	e8 1f 01 00 00       	call   c0104060 <cmos_read_byte>
c0103f41:	a2 3b 32 11 c0       	mov    %al,0xc011323b

	INIT_RTC();
c0103f46:	e8 b5 fa ff ff       	call   c0103a00 <INIT_RTC>
	cmos.time = get_time();
c0103f4b:	e8 85 fe ff ff       	call   c0103dd5 <get_time>
c0103f50:	a3 34 32 11 c0       	mov    %eax,0xc0113234

	cmos.hardware.post_diagnostig_status_byte = cmos_read_byte(0x0E);
c0103f55:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c0103f5c:	e8 ff 00 00 00       	call   c0104060 <cmos_read_byte>
c0103f61:	a2 3c 32 11 c0       	mov    %al,0xc011323c
	cmos.hardware.shutdown_status_byte =        cmos_read_byte(0x0F);
c0103f66:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c0103f6d:	e8 ee 00 00 00       	call   c0104060 <cmos_read_byte>
c0103f72:	a2 3d 32 11 c0       	mov    %al,0xc011323d
	cmos.hardware.floppy_disk_type =            cmos_read_byte(0x10);
c0103f77:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c0103f7e:	e8 dd 00 00 00       	call   c0104060 <cmos_read_byte>
c0103f83:	a2 3e 32 11 c0       	mov    %al,0xc011323e
	cmos.hardware.hd_type =                     cmos_read_byte(0x12);
c0103f88:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
c0103f8f:	e8 cc 00 00 00       	call   c0104060 <cmos_read_byte>
c0103f94:	a2 3f 32 11 c0       	mov    %al,0xc011323f
	cmos.hardware.device_byte =                 cmos_read_byte(0x14);
c0103f99:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0103fa0:	e8 bb 00 00 00       	call   c0104060 <cmos_read_byte>
c0103fa5:	a2 40 32 11 c0       	mov    %al,0xc0113240
	
	cmos.hardware.basememory_size_low =         cmos_read_byte(0x15);
c0103faa:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c0103fb1:	e8 aa 00 00 00       	call   c0104060 <cmos_read_byte>
c0103fb6:	a2 41 32 11 c0       	mov    %al,0xc0113241
	cmos.hardware.basememory_size_high =        cmos_read_byte(0x16);
c0103fbb:	c7 04 24 16 00 00 00 	movl   $0x16,(%esp)
c0103fc2:	e8 99 00 00 00       	call   c0104060 <cmos_read_byte>
c0103fc7:	a2 42 32 11 c0       	mov    %al,0xc0113242
	cmos.hardware.expandablememory_size_low =   cmos_read_byte(0x17);
c0103fcc:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
c0103fd3:	e8 88 00 00 00       	call   c0104060 <cmos_read_byte>
c0103fd8:	a2 43 32 11 c0       	mov    %al,0xc0113243
	cmos.hardware.expandablememory_size_high =  cmos_read_byte(0x18);
c0103fdd:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
c0103fe4:	e8 77 00 00 00       	call   c0104060 <cmos_read_byte>
c0103fe9:	a2 44 32 11 c0       	mov    %al,0xc0113244
	cmos.hardware.extension_byte_hd1 =          cmos_read_byte(0x19);
c0103fee:	c7 04 24 19 00 00 00 	movl   $0x19,(%esp)
c0103ff5:	e8 66 00 00 00       	call   c0104060 <cmos_read_byte>
c0103ffa:	a2 45 32 11 c0       	mov    %al,0xc0113245
	cmos.hardware.extension_byte_hd2 =          cmos_read_byte(0x1A);
c0103fff:	c7 04 24 1a 00 00 00 	movl   $0x1a,(%esp)
c0104006:	e8 55 00 00 00       	call   c0104060 <cmos_read_byte>
c010400b:	a2 46 32 11 c0       	mov    %al,0xc0113246
	
	cmos.hardware.cmos_magic_low =              cmos_read_byte(0x2E);
c0104010:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
c0104017:	e8 44 00 00 00       	call   c0104060 <cmos_read_byte>
c010401c:	a2 47 32 11 c0       	mov    %al,0xc0113247
	cmos.hardware.cmos_magic_high =             cmos_read_byte(0x2F);
c0104021:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
c0104028:	e8 33 00 00 00       	call   c0104060 <cmos_read_byte>
c010402d:	a2 48 32 11 c0       	mov    %al,0xc0113248
	
	cmos.hardware.extendedmemory_low =          cmos_read_byte(0x30);
c0104032:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
c0104039:	e8 22 00 00 00       	call   c0104060 <cmos_read_byte>
c010403e:	a2 49 32 11 c0       	mov    %al,0xc0113249
	cmos.hardware.extendedmenory_high =         cmos_read_byte(0x31);
c0104043:	c7 04 24 31 00 00 00 	movl   $0x31,(%esp)
c010404a:	e8 11 00 00 00       	call   c0104060 <cmos_read_byte>
c010404f:	a2 4a 32 11 c0       	mov    %al,0xc011324a
}
c0104054:	c9                   	leave  
c0104055:	c3                   	ret    

c0104056 <get_cmos_data>:
 * 
 * @param void
 *
 * @return pointer to the cmos-struct
 */
cmos_data_t* get_cmos_data(void) {
c0104056:	55                   	push   %ebp
c0104057:	89 e5                	mov    %esp,%ebp
	return &cmos;
c0104059:	b8 34 32 11 c0       	mov    $0xc0113234,%eax
}
c010405e:	5d                   	pop    %ebp
c010405f:	c3                   	ret    

c0104060 <cmos_read_byte>:
 * Reads a byte from CMOS
 * @param offset Offset in the CMOS
 * 
 * @return Read value from CMOS
 */
uint8_t cmos_read_byte(uint8_t offset) {
c0104060:	55                   	push   %ebp
c0104061:	89 e5                	mov    %esp,%ebp
c0104063:	83 ec 1c             	sub    $0x1c,%esp
c0104066:	8b 45 08             	mov    0x8(%ebp),%eax
c0104069:	88 45 ec             	mov    %al,-0x14(%ebp)
	uint8_t tmp = inb(0x70);
c010406c:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c0104073:	e8 3c fe ff ff       	call   c0103eb4 <inb>
c0104078:	88 45 ff             	mov    %al,-0x1(%ebp)
	outb(0x70, (tmp & 0x80) | (offset & 0x7F));
c010407b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c010407f:	89 c2                	mov    %eax,%edx
c0104081:	83 e2 80             	and    $0xffffff80,%edx
c0104084:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0104088:	83 e0 7f             	and    $0x7f,%eax
c010408b:	09 d0                	or     %edx,%eax
c010408d:	0f b6 c0             	movzbl %al,%eax
c0104090:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104094:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c010409b:	e8 3e fe ff ff       	call   c0103ede <outb>
	return inb(0x71);
c01040a0:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
c01040a7:	e8 08 fe ff ff       	call   c0103eb4 <inb>
}
c01040ac:	c9                   	leave  
c01040ad:	c3                   	ret    

c01040ae <cmos_write_byte>:
 * @param offset Offset in the CMOS
 * @param value Value which is written into the CMOS
 *
 * @return void
 */
void cmos_write_byte(uint8_t offset, uint8_t value) {
c01040ae:	55                   	push   %ebp
c01040af:	89 e5                	mov    %esp,%ebp
c01040b1:	83 ec 20             	sub    $0x20,%esp
c01040b4:	8b 55 08             	mov    0x8(%ebp),%edx
c01040b7:	8b 45 0c             	mov    0xc(%ebp),%eax
c01040ba:	88 55 ec             	mov    %dl,-0x14(%ebp)
c01040bd:	88 45 e8             	mov    %al,-0x18(%ebp)
	uint8_t tmp = inb(0x70);
c01040c0:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c01040c7:	e8 e8 fd ff ff       	call   c0103eb4 <inb>
c01040cc:	88 45 ff             	mov    %al,-0x1(%ebp)
	outb(0x70, (tmp & 0x80) | (offset & 0x7F));
c01040cf:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c01040d3:	89 c2                	mov    %eax,%edx
c01040d5:	83 e2 80             	and    $0xffffff80,%edx
c01040d8:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c01040dc:	83 e0 7f             	and    $0x7f,%eax
c01040df:	09 d0                	or     %edx,%eax
c01040e1:	0f b6 c0             	movzbl %al,%eax
c01040e4:	89 44 24 04          	mov    %eax,0x4(%esp)
c01040e8:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c01040ef:	e8 ea fd ff ff       	call   c0103ede <outb>
	outb(0x71,value);
c01040f4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c01040f8:	89 44 24 04          	mov    %eax,0x4(%esp)
c01040fc:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
c0104103:	e8 d6 fd ff ff       	call   c0103ede <outb>
}
c0104108:	c9                   	leave  
c0104109:	c3                   	ret    
c010410a:	66 90                	xchg   %ax,%ax

c010410c <outb>:
	uint32_t result;
	asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
	return result;
}

static inline void outb(uint16_t port, uint8_t value) {
c010410c:	55                   	push   %ebp
c010410d:	89 e5                	mov    %esp,%ebp
c010410f:	83 ec 08             	sub    $0x8,%esp
c0104112:	8b 55 08             	mov    0x8(%ebp),%edx
c0104115:	8b 45 0c             	mov    0xc(%ebp),%eax
c0104118:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010411c:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c010411f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0104123:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0104127:	ee                   	out    %al,(%dx)
}
c0104128:	c9                   	leave  
c0104129:	c3                   	ret    

c010412a <crtc_write>:

#include <drivers/crtc.h>
#include <io.h>

void crtc_write(uint8_t index, uint8_t value)
{
c010412a:	55                   	push   %ebp
c010412b:	89 e5                	mov    %esp,%ebp
c010412d:	83 ec 10             	sub    $0x10,%esp
c0104130:	8b 55 08             	mov    0x8(%ebp),%edx
c0104133:	8b 45 0c             	mov    0xc(%ebp),%eax
c0104136:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0104139:	88 45 f8             	mov    %al,-0x8(%ebp)
	outb(CRTC_INDEX_PORT, index);
c010413c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0104140:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104144:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
c010414b:	e8 bc ff ff ff       	call   c010410c <outb>
	outb(CRTC_DATA_PORT, value);
c0104150:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0104154:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104158:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
c010415f:	e8 a8 ff ff ff       	call   c010410c <outb>
}
c0104164:	c9                   	leave  
c0104165:	c3                   	ret    
c0104166:	66 90                	xchg   %ax,%ax

c0104168 <outb>:
	uint32_t result;
	asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
	return result;
}

static inline void outb(uint16_t port, uint8_t value) {
c0104168:	55                   	push   %ebp
c0104169:	89 e5                	mov    %esp,%ebp
c010416b:	83 ec 08             	sub    $0x8,%esp
c010416e:	8b 55 08             	mov    0x8(%ebp),%edx
c0104171:	8b 45 0c             	mov    0xc(%ebp),%eax
c0104174:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0104178:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c010417b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c010417f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0104183:	ee                   	out    %al,(%dx)
}
c0104184:	c9                   	leave  
c0104185:	c3                   	ret    

c0104186 <lidt>:
 * Load IDT
 * @param nuber of the last defined Descriptor
 * @return void
 **/
void lidt(uint16_t irq)
{
c0104186:	55                   	push   %ebp
c0104187:	89 e5                	mov    %esp,%ebp
c0104189:	83 ec 04             	sub    $0x4,%esp
c010418c:	8b 45 08             	mov    0x8(%ebp),%eax
c010418f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	idtp.limit = (8 * irq)-1;
c0104193:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c0104197:	c1 e0 03             	shl    $0x3,%eax
c010419a:	83 e8 01             	sub    $0x1,%eax
c010419d:	66 a3 20 18 11 c0    	mov    %ax,0xc0111820
	idtp.base = IDT;
c01041a3:	c7 05 22 18 11 c0 20 	movl   $0xc0111020,0xc0111822
c01041aa:	10 11 c0 
	asm volatile("lidt %0" : : "m" (idtp));
c01041ad:	0f 01 1d 20 18 11 c0 	lidtl  0xc0111820
}
c01041b4:	c9                   	leave  
c01041b5:	c3                   	ret    

c01041b6 <EOI>:
 * Send End of Interrupt Signal to the PIC
 * @param number of the runnig interrupt
 * @return void
 **/
void EOI(int irq)
{
c01041b6:	55                   	push   %ebp
c01041b7:	89 e5                	mov    %esp,%ebp
c01041b9:	83 ec 08             	sub    $0x8,%esp
	outb(0x20, 0x20);
c01041bc:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c01041c3:	00 
c01041c4:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c01041cb:	e8 98 ff ff ff       	call   c0104168 <outb>
	if (irq >= 8) {
c01041d0:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c01041d4:	7e 14                	jle    c01041ea <EOI+0x34>
		outb(0xA0, 0x20);
c01041d6:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c01041dd:	00 
c01041de:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
c01041e5:	e8 7e ff ff ff       	call   c0104168 <outb>
	}
}
c01041ea:	c9                   	leave  
c01041eb:	c3                   	ret    

c01041ec <pic_mask_irqs>:
 * block hardware IRQs
 * @param number of the IRQ which should be blocked
 * @return void
 **/
void pic_mask_irqs(uint16_t mask)
{
c01041ec:	55                   	push   %ebp
c01041ed:	89 e5                	mov    %esp,%ebp
c01041ef:	83 ec 0c             	sub    $0xc,%esp
c01041f2:	8b 45 08             	mov    0x8(%ebp),%eax
c01041f5:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
   outb(0x21, (uint8_t) mask);
c01041f9:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c01041fd:	0f b6 c0             	movzbl %al,%eax
c0104200:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104204:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010420b:	e8 58 ff ff ff       	call   c0104168 <outb>
   outb(0xA1, (uint8_t) mask >> 8);
c0104210:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c0104214:	0f b6 c0             	movzbl %al,%eax
c0104217:	c1 f8 08             	sar    $0x8,%eax
c010421a:	0f b6 c0             	movzbl %al,%eax
c010421d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104221:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c0104228:	e8 3b ff ff ff       	call   c0104168 <outb>
}
c010422d:	c9                   	leave  
c010422e:	c3                   	ret    

c010422f <Set_IDT_Entry>:
 * @param 2 Baseadress of the ISR function
 * @param 3 Flags
 * @return void
 **/
void Set_IDT_Entry(uint32_t intnr, uint16_t selector,uint32_t Base, uint16_t flags)
{
c010422f:	55                   	push   %ebp
c0104230:	89 e5                	mov    %esp,%ebp
c0104232:	83 ec 08             	sub    $0x8,%esp
c0104235:	8b 55 0c             	mov    0xc(%ebp),%edx
c0104238:	8b 45 14             	mov    0x14(%ebp),%eax
c010423b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010423f:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
	IDT[intnr].Base_low = (uint16_t)Base;
c0104243:	8b 45 10             	mov    0x10(%ebp),%eax
c0104246:	89 c2                	mov    %eax,%edx
c0104248:	8b 45 08             	mov    0x8(%ebp),%eax
c010424b:	66 89 14 c5 20 10 11 	mov    %dx,-0x3feeefe0(,%eax,8)
c0104252:	c0 
	IDT[intnr].selector = selector;
c0104253:	8b 45 08             	mov    0x8(%ebp),%eax
c0104256:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c010425a:	66 89 14 c5 22 10 11 	mov    %dx,-0x3feeefde(,%eax,8)
c0104261:	c0 
	IDT[intnr].flags = flags;
c0104262:	8b 45 08             	mov    0x8(%ebp),%eax
c0104265:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
c0104269:	66 89 14 c5 24 10 11 	mov    %dx,-0x3feeefdc(,%eax,8)
c0104270:	c0 
	IDT[intnr].Base_hi = (uint16_t)(Base>>16);
c0104271:	8b 45 10             	mov    0x10(%ebp),%eax
c0104274:	c1 e8 10             	shr    $0x10,%eax
c0104277:	89 c2                	mov    %eax,%edx
c0104279:	8b 45 08             	mov    0x8(%ebp),%eax
c010427c:	66 89 14 c5 26 10 11 	mov    %dx,-0x3feeefda(,%eax,8)
c0104283:	c0 
}
c0104284:	c9                   	leave  
c0104285:	c3                   	ret    

c0104286 <install_irq>:
 * @param 1 pointer to the handler function
 * @return false  -> Handler is already seted-up
 * @return true -> Handler sucessfully installed
 **/
int install_irq(int intr,void *handler)
{
c0104286:	55                   	push   %ebp
c0104287:	89 e5                	mov    %esp,%ebp
	if (irq[intr] != NULL) {
c0104289:	8b 45 08             	mov    0x8(%ebp),%eax
c010428c:	8b 04 85 40 18 11 c0 	mov    -0x3feee7c0(,%eax,4),%eax
c0104293:	85 c0                	test   %eax,%eax
c0104295:	74 07                	je     c010429e <install_irq+0x18>
	    return false;
c0104297:	b8 00 00 00 00       	mov    $0x0,%eax
c010429c:	eb 12                	jmp    c01042b0 <install_irq+0x2a>
	}

	irq[intr] = handler;
c010429e:	8b 55 0c             	mov    0xc(%ebp),%edx
c01042a1:	8b 45 08             	mov    0x8(%ebp),%eax
c01042a4:	89 14 85 40 18 11 c0 	mov    %edx,-0x3feee7c0(,%eax,4)
	return true;
c01042ab:	b8 01 00 00 00       	mov    $0x1,%eax
}
c01042b0:	5d                   	pop    %ebp
c01042b1:	c3                   	ret    

c01042b2 <install_exc>:
 * @param 1 pointer to the handler function
 * @return true  -> Handler is already seted-up
 * @return false -> Handler sucessfully installed
 **/
int install_exc(int excnum, void *handler)
{
c01042b2:	55                   	push   %ebp
c01042b3:	89 e5                	mov    %esp,%ebp
	if (exc[excnum] != NULL) {
c01042b5:	8b 45 08             	mov    0x8(%ebp),%eax
c01042b8:	8b 04 85 80 18 11 c0 	mov    -0x3feee780(,%eax,4),%eax
c01042bf:	85 c0                	test   %eax,%eax
c01042c1:	74 07                	je     c01042ca <install_exc+0x18>
	    return false;
c01042c3:	b8 00 00 00 00       	mov    $0x0,%eax
c01042c8:	eb 12                	jmp    c01042dc <install_exc+0x2a>
	}

	exc[excnum] = handler;
c01042ca:	8b 55 0c             	mov    0xc(%ebp),%edx
c01042cd:	8b 45 08             	mov    0x8(%ebp),%eax
c01042d0:	89 14 85 80 18 11 c0 	mov    %edx,-0x3feee780(,%eax,4)
	return true;
c01042d7:	b8 01 00 00 00       	mov    $0x1,%eax
}
c01042dc:	5d                   	pop    %ebp
c01042dd:	c3                   	ret    

c01042de <deinstall_irq>:
 * deinstall IRQ handlder
 * @param interrupt number
 * @return void
**/
void deinstall_irq(int intr)
{
c01042de:	55                   	push   %ebp
c01042df:	89 e5                	mov    %esp,%ebp
	irq[intr] = NULL;
c01042e1:	8b 45 08             	mov    0x8(%ebp),%eax
c01042e4:	c7 04 85 40 18 11 c0 	movl   $0x0,-0x3feee7c0(,%eax,4)
c01042eb:	00 00 00 00 
}
c01042ef:	5d                   	pop    %ebp
c01042f0:	c3                   	ret    

c01042f1 <deinstall_exc>:
 * deinstall exception handlder
 * @param exception number
 * @return void
**/
void deinstall_exc(int excnum)
{
c01042f1:	55                   	push   %ebp
c01042f2:	89 e5                	mov    %esp,%ebp
	exc[excnum] = NULL;
c01042f4:	8b 45 08             	mov    0x8(%ebp),%eax
c01042f7:	c7 04 85 80 18 11 c0 	movl   $0x0,-0x3feee780(,%eax,4)
c01042fe:	00 00 00 00 
}
c0104302:	5d                   	pop    %ebp
c0104303:	c3                   	ret    

c0104304 <irq_handler>:
 * General IRQ Handler
 * @param pointer to cpu_state struct of the interrupted Process
 * @return pointer to cpu_state struct of the interrupted Process
 **/
struct cpu_state* irq_handler(struct cpu_state* cpu)
{
c0104304:	55                   	push   %ebp
c0104305:	89 e5                	mov    %esp,%ebp
c0104307:	83 ec 28             	sub    $0x28,%esp
	//Exceptions
	if (cpu->intr < 32)
c010430a:	8b 45 08             	mov    0x8(%ebp),%eax
c010430d:	8b 40 2c             	mov    0x2c(%eax),%eax
c0104310:	83 f8 1f             	cmp    $0x1f,%eax
c0104313:	77 3e                	ja     c0104353 <irq_handler+0x4f>
	{
		if (exc[cpu->intr] != NULL)
c0104315:	8b 45 08             	mov    0x8(%ebp),%eax
c0104318:	8b 40 2c             	mov    0x2c(%eax),%eax
c010431b:	8b 04 85 80 18 11 c0 	mov    -0x3feee780(,%eax,4),%eax
c0104322:	85 c0                	test   %eax,%eax
c0104324:	74 1d                	je     c0104343 <irq_handler+0x3f>
		{
			exc[cpu->intr](&cpu);
c0104326:	8b 45 08             	mov    0x8(%ebp),%eax
c0104329:	8b 40 2c             	mov    0x2c(%eax),%eax
c010432c:	8b 04 85 80 18 11 c0 	mov    -0x3feee780(,%eax,4),%eax
c0104333:	8d 55 08             	lea    0x8(%ebp),%edx
c0104336:	89 14 24             	mov    %edx,(%esp)
c0104339:	ff d0                	call   *%eax
			return cpu;
c010433b:	8b 45 08             	mov    0x8(%ebp),%eax
c010433e:	e9 c8 00 00 00       	jmp    c010440b <irq_handler+0x107>
		}
		else
		{
			exc_panic(cpu);
c0104343:	8b 45 08             	mov    0x8(%ebp),%eax
c0104346:	89 04 24             	mov    %eax,(%esp)
c0104349:	e8 62 34 00 00       	call   c01077b0 <exc_panic>
c010434e:	e9 b5 00 00 00       	jmp    c0104408 <irq_handler+0x104>
		}
	}
	//Taskscheduler
	else if(cpu->intr == 32)
c0104353:	8b 45 08             	mov    0x8(%ebp),%eax
c0104356:	8b 40 2c             	mov    0x2c(%eax),%eax
c0104359:	83 f8 20             	cmp    $0x20,%eax
c010435c:	75 13                	jne    c0104371 <irq_handler+0x6d>
	{
        cpu = task_schedule(cpu);
c010435e:	8b 45 08             	mov    0x8(%ebp),%eax
c0104361:	89 04 24             	mov    %eax,(%esp)
c0104364:	e8 89 dd ff ff       	call   c01020f2 <task_schedule>
c0104369:	89 45 08             	mov    %eax,0x8(%ebp)
c010436c:	e9 97 00 00 00       	jmp    c0104408 <irq_handler+0x104>
	}
	//IRQs
	else if (cpu->intr < 46)
c0104371:	8b 45 08             	mov    0x8(%ebp),%eax
c0104374:	8b 40 2c             	mov    0x2c(%eax),%eax
c0104377:	83 f8 2d             	cmp    $0x2d,%eax
c010437a:	77 3c                	ja     c01043b8 <irq_handler+0xb4>
	{
	    int irqnum = cpu->intr - 32;
c010437c:	8b 45 08             	mov    0x8(%ebp),%eax
c010437f:	8b 40 2c             	mov    0x2c(%eax),%eax
c0104382:	83 e8 20             	sub    $0x20,%eax
c0104385:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (irq[irqnum] != NULL)
c0104388:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010438b:	8b 04 85 40 18 11 c0 	mov    -0x3feee7c0(,%eax,4),%eax
c0104392:	85 c0                	test   %eax,%eax
c0104394:	74 12                	je     c01043a8 <irq_handler+0xa4>
		{
			irq[irqnum](&cpu);
c0104396:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104399:	8b 04 85 40 18 11 c0 	mov    -0x3feee7c0(,%eax,4),%eax
c01043a0:	8d 55 08             	lea    0x8(%ebp),%edx
c01043a3:	89 14 24             	mov    %edx,(%esp)
c01043a6:	ff d0                	call   *%eax
		}
		EOI(irqnum);
c01043a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01043ab:	89 04 24             	mov    %eax,(%esp)
c01043ae:	e8 03 fe ff ff       	call   c01041b6 <EOI>
		return cpu;
c01043b3:	8b 45 08             	mov    0x8(%ebp),%eax
c01043b6:	eb 53                	jmp    c010440b <irq_handler+0x107>
	}
	//universe syscall
	else if(cpu->intr == 0x70)
c01043b8:	8b 45 08             	mov    0x8(%ebp),%eax
c01043bb:	8b 40 2c             	mov    0x2c(%eax),%eax
c01043be:	83 f8 70             	cmp    $0x70,%eax
c01043c1:	75 0d                	jne    c01043d0 <irq_handler+0xcc>
	{
        universe_syscall_handler(&cpu);
c01043c3:	8d 45 08             	lea    0x8(%ebp),%eax
c01043c6:	89 04 24             	mov    %eax,(%esp)
c01043c9:	e8 d6 5e 00 00       	call   c010a2a4 <universe_syscall_handler>
c01043ce:	eb 38                	jmp    c0104408 <irq_handler+0x104>
	}
	//linux syscall
	else if(cpu->intr == 0x80)
c01043d0:	8b 45 08             	mov    0x8(%ebp),%eax
c01043d3:	8b 40 2c             	mov    0x2c(%eax),%eax
c01043d6:	3d 80 00 00 00       	cmp    $0x80,%eax
c01043db:	75 0d                	jne    c01043ea <irq_handler+0xe6>
	{
        linux_syscall_handler(&cpu);
c01043dd:	8d 55 08             	lea    0x8(%ebp),%edx
c01043e0:	89 14 24             	mov    %edx,(%esp)
c01043e3:	e8 7d 5e 00 00       	call   c010a265 <linux_syscall_handler>
c01043e8:	eb 1e                	jmp    c0104408 <irq_handler+0x104>
	}
	//pci IRQ
	else if(cpu->intr == 50)
c01043ea:	8b 45 08             	mov    0x8(%ebp),%eax
c01043ed:	8b 40 2c             	mov    0x2c(%eax),%eax
c01043f0:	83 f8 32             	cmp    $0x32,%eax
c01043f3:	75 07                	jne    c01043fc <irq_handler+0xf8>
	{
        pci_irq_handler();
c01043f5:	e8 32 ed ff ff       	call   c010312c <pci_irq_handler>
c01043fa:	eb 0c                	jmp    c0104408 <irq_handler+0x104>
	}
	//unspecified ISRs
	else
	{
        panic("A unspecified ISR was called.");
c01043fc:	c7 04 24 88 b3 10 c0 	movl   $0xc010b388,(%esp)
c0104403:	e8 a1 30 00 00       	call   c01074a9 <panic>
	}
	return cpu;
c0104408:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010440b:	c9                   	leave  
c010440c:	c3                   	ret    

c010440d <remap_pic>:
 * remap IRQs to irqnum 31
 * @param void
 * @return void
 **/
void remap_pic(void)
{
c010440d:	55                   	push   %ebp
c010440e:	89 e5                	mov    %esp,%ebp
c0104410:	83 ec 08             	sub    $0x8,%esp
	outb(0x20, 0x11);
c0104413:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
c010441a:	00 
c010441b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0104422:	e8 41 fd ff ff       	call   c0104168 <outb>
	outb(0xA0, 0x11);
c0104427:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
c010442e:	00 
c010442f:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
c0104436:	e8 2d fd ff ff       	call   c0104168 <outb>
	outb(0x21, 32);
c010443b:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c0104442:	00 
c0104443:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010444a:	e8 19 fd ff ff       	call   c0104168 <outb>
	outb(0xA1, 32+8);
c010444f:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
c0104456:	00 
c0104457:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c010445e:	e8 05 fd ff ff       	call   c0104168 <outb>
	outb(0x21, 0x04);
c0104463:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
c010446a:	00 
c010446b:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c0104472:	e8 f1 fc ff ff       	call   c0104168 <outb>
	outb(0xA1, 2);
c0104477:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c010447e:	00 
c010447f:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c0104486:	e8 dd fc ff ff       	call   c0104168 <outb>
	outb(0x21, 0x01);
c010448b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0104492:	00 
c0104493:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010449a:	e8 c9 fc ff ff       	call   c0104168 <outb>
	outb(0xA1, 0x01);
c010449f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c01044a6:	00 
c01044a7:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c01044ae:	e8 b5 fc ff ff       	call   c0104168 <outb>
	outb(0x21, 0x00);
c01044b3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01044ba:	00 
c01044bb:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c01044c2:	e8 a1 fc ff ff       	call   c0104168 <outb>
	outb(0xA1, 0x00);
c01044c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01044ce:	00 
c01044cf:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c01044d6:	e8 8d fc ff ff       	call   c0104168 <outb>
}
c01044db:	c9                   	leave  
c01044dc:	c3                   	ret    

c01044dd <INIT_IDT>:
 * Initialize IDT wit exceptions and basical ISRs
 * @param 0 void
 * @param 1 void
 **/
void INIT_IDT(void)
{
c01044dd:	55                   	push   %ebp
c01044de:	89 e5                	mov    %esp,%ebp
c01044e0:	83 ec 20             	sub    $0x20,%esp
	remap_pic();
c01044e3:	e8 25 ff ff ff       	call   c010440d <remap_pic>
	//Exceptions
	int i;
	for(i = 0; i < 256; i++)
c01044e8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01044ef:	eb 28                	jmp    c0104519 <INIT_IDT+0x3c>
	{
        Set_IDT_Entry(i,0x8,(uint32_t)isr_default,0xEE00);
c01044f1:	ba ff a3 10 c0       	mov    $0xc010a3ff,%edx
c01044f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01044f9:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104500:	00 
c0104501:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104505:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010450c:	00 
c010450d:	89 04 24             	mov    %eax,(%esp)
c0104510:	e8 1a fd ff ff       	call   c010422f <Set_IDT_Entry>
void INIT_IDT(void)
{
	remap_pic();
	//Exceptions
	int i;
	for(i = 0; i < 256; i++)
c0104515:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0104519:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0104520:	7e cf                	jle    c01044f1 <INIT_IDT+0x14>
	{
        Set_IDT_Entry(i,0x8,(uint32_t)isr_default,0xEE00);
	}

	Set_IDT_Entry(0,0x8,(uint32_t)isr_0,0xEE00); Set_IDT_Entry(1,0x8,(uint32_t)isr_1,0xEE00); Set_IDT_Entry(2,0x8,(uint32_t)isr_2,0xEE00);
c0104522:	b8 f0 a2 10 c0       	mov    $0xc010a2f0,%eax
c0104527:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010452e:	00 
c010452f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104533:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010453a:	00 
c010453b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0104542:	e8 e8 fc ff ff       	call   c010422f <Set_IDT_Entry>
c0104547:	b8 f9 a2 10 c0       	mov    $0xc010a2f9,%eax
c010454c:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104553:	00 
c0104554:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104558:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010455f:	00 
c0104560:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0104567:	e8 c3 fc ff ff       	call   c010422f <Set_IDT_Entry>
c010456c:	b8 02 a3 10 c0       	mov    $0xc010a302,%eax
c0104571:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104578:	00 
c0104579:	89 44 24 08          	mov    %eax,0x8(%esp)
c010457d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104584:	00 
c0104585:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c010458c:	e8 9e fc ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(3,0x8,(uint32_t)isr_3,0xEE00); Set_IDT_Entry(4,0x8,(uint32_t)isr_4,0xEE00); Set_IDT_Entry(5,0x8,(uint32_t)isr_5,0xEE00);
c0104591:	b8 0b a3 10 c0       	mov    $0xc010a30b,%eax
c0104596:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010459d:	00 
c010459e:	89 44 24 08          	mov    %eax,0x8(%esp)
c01045a2:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01045a9:	00 
c01045aa:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c01045b1:	e8 79 fc ff ff       	call   c010422f <Set_IDT_Entry>
c01045b6:	b8 14 a3 10 c0       	mov    $0xc010a314,%eax
c01045bb:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01045c2:	00 
c01045c3:	89 44 24 08          	mov    %eax,0x8(%esp)
c01045c7:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01045ce:	00 
c01045cf:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c01045d6:	e8 54 fc ff ff       	call   c010422f <Set_IDT_Entry>
c01045db:	b8 1d a3 10 c0       	mov    $0xc010a31d,%eax
c01045e0:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01045e7:	00 
c01045e8:	89 44 24 08          	mov    %eax,0x8(%esp)
c01045ec:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01045f3:	00 
c01045f4:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c01045fb:	e8 2f fc ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(6,0x8,(uint32_t)isr_6,0xEE00); Set_IDT_Entry(7,0x8,(uint32_t)isr_7,0xEE00); Set_IDT_Entry(8,0x8,(uint32_t)isr_8,0xEE00);
c0104600:	b8 26 a3 10 c0       	mov    $0xc010a326,%eax
c0104605:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010460c:	00 
c010460d:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104611:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104618:	00 
c0104619:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c0104620:	e8 0a fc ff ff       	call   c010422f <Set_IDT_Entry>
c0104625:	b8 2f a3 10 c0       	mov    $0xc010a32f,%eax
c010462a:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104631:	00 
c0104632:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104636:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010463d:	00 
c010463e:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c0104645:	e8 e5 fb ff ff       	call   c010422f <Set_IDT_Entry>
c010464a:	b8 38 a3 10 c0       	mov    $0xc010a338,%eax
c010464f:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104656:	00 
c0104657:	89 44 24 08          	mov    %eax,0x8(%esp)
c010465b:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104662:	00 
c0104663:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c010466a:	e8 c0 fb ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(9,0x8,(uint32_t)isr_9,0xEE00); Set_IDT_Entry(10,0x8,(uint32_t)isr_10,0xEE00); Set_IDT_Entry(11,0x8,(uint32_t)isr_11,0xEE00);
c010466f:	b8 3f a3 10 c0       	mov    $0xc010a33f,%eax
c0104674:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010467b:	00 
c010467c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104680:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104687:	00 
c0104688:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c010468f:	e8 9b fb ff ff       	call   c010422f <Set_IDT_Entry>
c0104694:	b8 48 a3 10 c0       	mov    $0xc010a348,%eax
c0104699:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01046a0:	00 
c01046a1:	89 44 24 08          	mov    %eax,0x8(%esp)
c01046a5:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01046ac:	00 
c01046ad:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c01046b4:	e8 76 fb ff ff       	call   c010422f <Set_IDT_Entry>
c01046b9:	b8 4f a3 10 c0       	mov    $0xc010a34f,%eax
c01046be:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01046c5:	00 
c01046c6:	89 44 24 08          	mov    %eax,0x8(%esp)
c01046ca:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01046d1:	00 
c01046d2:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
c01046d9:	e8 51 fb ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(12,0x8,(uint32_t)isr_12,0xEE00); Set_IDT_Entry(13,0x8,(uint32_t)isr_13,0xEE00); Set_IDT_Entry(14,0x8,(uint32_t)isr_14,0xEE00);
c01046de:	b8 56 a3 10 c0       	mov    $0xc010a356,%eax
c01046e3:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01046ea:	00 
c01046eb:	89 44 24 08          	mov    %eax,0x8(%esp)
c01046ef:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01046f6:	00 
c01046f7:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c01046fe:	e8 2c fb ff ff       	call   c010422f <Set_IDT_Entry>
c0104703:	b8 5d a3 10 c0       	mov    $0xc010a35d,%eax
c0104708:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010470f:	00 
c0104710:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104714:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010471b:	00 
c010471c:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
c0104723:	e8 07 fb ff ff       	call   c010422f <Set_IDT_Entry>
c0104728:	b8 64 a3 10 c0       	mov    $0xc010a364,%eax
c010472d:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104734:	00 
c0104735:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104739:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104740:	00 
c0104741:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c0104748:	e8 e2 fa ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(15,0x8,(uint32_t)isr_15,0xEE00); Set_IDT_Entry(16,0x8,(uint32_t)isr_16,0xEE00); Set_IDT_Entry(17,0x8,(uint32_t)isr_17,0xEE00);
c010474d:	b8 6b a3 10 c0       	mov    $0xc010a36b,%eax
c0104752:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104759:	00 
c010475a:	89 44 24 08          	mov    %eax,0x8(%esp)
c010475e:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104765:	00 
c0104766:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c010476d:	e8 bd fa ff ff       	call   c010422f <Set_IDT_Entry>
c0104772:	b8 74 a3 10 c0       	mov    $0xc010a374,%eax
c0104777:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010477e:	00 
c010477f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104783:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010478a:	00 
c010478b:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c0104792:	e8 98 fa ff ff       	call   c010422f <Set_IDT_Entry>
c0104797:	b8 7d a3 10 c0       	mov    $0xc010a37d,%eax
c010479c:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01047a3:	00 
c01047a4:	89 44 24 08          	mov    %eax,0x8(%esp)
c01047a8:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01047af:	00 
c01047b0:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
c01047b7:	e8 73 fa ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(18,0x8,(uint32_t)isr_18,0xEE00); Set_IDT_Entry(19,0x8,(uint32_t)isr_19,0xEE00); Set_IDT_Entry(20,0x8,(uint32_t)isr_20,0xEE00);
c01047bc:	b8 84 a3 10 c0       	mov    $0xc010a384,%eax
c01047c1:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01047c8:	00 
c01047c9:	89 44 24 08          	mov    %eax,0x8(%esp)
c01047cd:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01047d4:	00 
c01047d5:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
c01047dc:	e8 4e fa ff ff       	call   c010422f <Set_IDT_Entry>
c01047e1:	b8 8d a3 10 c0       	mov    $0xc010a38d,%eax
c01047e6:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01047ed:	00 
c01047ee:	89 44 24 08          	mov    %eax,0x8(%esp)
c01047f2:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01047f9:	00 
c01047fa:	c7 04 24 13 00 00 00 	movl   $0x13,(%esp)
c0104801:	e8 29 fa ff ff       	call   c010422f <Set_IDT_Entry>
c0104806:	b8 96 a3 10 c0       	mov    $0xc010a396,%eax
c010480b:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104812:	00 
c0104813:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104817:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010481e:	00 
c010481f:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0104826:	e8 04 fa ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(21,0x8,(uint32_t)isr_21,0xEE00); Set_IDT_Entry(22,0x8,(uint32_t)isr_22,0xEE00); Set_IDT_Entry(23,0x8,(uint32_t)isr_23,0xEE00);
c010482b:	b8 9f a3 10 c0       	mov    $0xc010a39f,%eax
c0104830:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104837:	00 
c0104838:	89 44 24 08          	mov    %eax,0x8(%esp)
c010483c:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104843:	00 
c0104844:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c010484b:	e8 df f9 ff ff       	call   c010422f <Set_IDT_Entry>
c0104850:	b8 a8 a3 10 c0       	mov    $0xc010a3a8,%eax
c0104855:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010485c:	00 
c010485d:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104861:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104868:	00 
c0104869:	c7 04 24 16 00 00 00 	movl   $0x16,(%esp)
c0104870:	e8 ba f9 ff ff       	call   c010422f <Set_IDT_Entry>
c0104875:	b8 b1 a3 10 c0       	mov    $0xc010a3b1,%eax
c010487a:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104881:	00 
c0104882:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104886:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010488d:	00 
c010488e:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
c0104895:	e8 95 f9 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(24,0x8,(uint32_t)isr_24,0xEE00); Set_IDT_Entry(25,0x8,(uint32_t)isr_25,0xEE00); Set_IDT_Entry(26,0x8,(uint32_t)isr_26,0xEE00);
c010489a:	b8 ba a3 10 c0       	mov    $0xc010a3ba,%eax
c010489f:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01048a6:	00 
c01048a7:	89 44 24 08          	mov    %eax,0x8(%esp)
c01048ab:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01048b2:	00 
c01048b3:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
c01048ba:	e8 70 f9 ff ff       	call   c010422f <Set_IDT_Entry>
c01048bf:	b8 c3 a3 10 c0       	mov    $0xc010a3c3,%eax
c01048c4:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01048cb:	00 
c01048cc:	89 44 24 08          	mov    %eax,0x8(%esp)
c01048d0:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01048d7:	00 
c01048d8:	c7 04 24 19 00 00 00 	movl   $0x19,(%esp)
c01048df:	e8 4b f9 ff ff       	call   c010422f <Set_IDT_Entry>
c01048e4:	b8 cc a3 10 c0       	mov    $0xc010a3cc,%eax
c01048e9:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01048f0:	00 
c01048f1:	89 44 24 08          	mov    %eax,0x8(%esp)
c01048f5:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01048fc:	00 
c01048fd:	c7 04 24 1a 00 00 00 	movl   $0x1a,(%esp)
c0104904:	e8 26 f9 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(27,0x8,(uint32_t)isr_27,0xEE00); Set_IDT_Entry(28,0x8,(uint32_t)isr_28,0xEE00); Set_IDT_Entry(29,0x8,(uint32_t)isr_29,0xEE00);
c0104909:	b8 d5 a3 10 c0       	mov    $0xc010a3d5,%eax
c010490e:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104915:	00 
c0104916:	89 44 24 08          	mov    %eax,0x8(%esp)
c010491a:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104921:	00 
c0104922:	c7 04 24 1b 00 00 00 	movl   $0x1b,(%esp)
c0104929:	e8 01 f9 ff ff       	call   c010422f <Set_IDT_Entry>
c010492e:	b8 de a3 10 c0       	mov    $0xc010a3de,%eax
c0104933:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010493a:	00 
c010493b:	89 44 24 08          	mov    %eax,0x8(%esp)
c010493f:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104946:	00 
c0104947:	c7 04 24 1c 00 00 00 	movl   $0x1c,(%esp)
c010494e:	e8 dc f8 ff ff       	call   c010422f <Set_IDT_Entry>
c0104953:	b8 e7 a3 10 c0       	mov    $0xc010a3e7,%eax
c0104958:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c010495f:	00 
c0104960:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104964:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c010496b:	00 
c010496c:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
c0104973:	e8 b7 f8 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(30,0x8,(uint32_t)isr_30,0xEE00); Set_IDT_Entry(31,0x8,(uint32_t)isr_31,0xEE00);
c0104978:	b8 f0 a3 10 c0       	mov    $0xc010a3f0,%eax
c010497d:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104984:	00 
c0104985:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104989:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104990:	00 
c0104991:	c7 04 24 1e 00 00 00 	movl   $0x1e,(%esp)
c0104998:	e8 92 f8 ff ff       	call   c010422f <Set_IDT_Entry>
c010499d:	b8 f9 a3 10 c0       	mov    $0xc010a3f9,%eax
c01049a2:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01049a9:	00 
c01049aa:	89 44 24 08          	mov    %eax,0x8(%esp)
c01049ae:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01049b5:	00 
c01049b6:	c7 04 24 1f 00 00 00 	movl   $0x1f,(%esp)
c01049bd:	e8 6d f8 ff ff       	call   c010422f <Set_IDT_Entry>
	//IRQs
	Set_IDT_Entry(32,0x8,(uint32_t)isr_32,0xEE00); Set_IDT_Entry(33,0x8,(uint32_t)isr_33,0xEE00);
c01049c2:	b8 05 a4 10 c0       	mov    $0xc010a405,%eax
c01049c7:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01049ce:	00 
c01049cf:	89 44 24 08          	mov    %eax,0x8(%esp)
c01049d3:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01049da:	00 
c01049db:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c01049e2:	e8 48 f8 ff ff       	call   c010422f <Set_IDT_Entry>
c01049e7:	b8 0b a4 10 c0       	mov    $0xc010a40b,%eax
c01049ec:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c01049f3:	00 
c01049f4:	89 44 24 08          	mov    %eax,0x8(%esp)
c01049f8:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c01049ff:	00 
c0104a00:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c0104a07:	e8 23 f8 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(34,0x8,(uint32_t)isr_34,0xEE00); Set_IDT_Entry(35,0x8,(uint32_t)isr_35,0xEE00);
c0104a0c:	b8 11 a4 10 c0       	mov    $0xc010a411,%eax
c0104a11:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104a18:	00 
c0104a19:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104a1d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104a24:	00 
c0104a25:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
c0104a2c:	e8 fe f7 ff ff       	call   c010422f <Set_IDT_Entry>
c0104a31:	b8 17 a4 10 c0       	mov    $0xc010a417,%eax
c0104a36:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104a3d:	00 
c0104a3e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104a42:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104a49:	00 
c0104a4a:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
c0104a51:	e8 d9 f7 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(36,0x8,(uint32_t)isr_36,0xEE00); Set_IDT_Entry(37,0x8,(uint32_t)isr_37,0xEE00);
c0104a56:	b8 1d a4 10 c0       	mov    $0xc010a41d,%eax
c0104a5b:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104a62:	00 
c0104a63:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104a67:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104a6e:	00 
c0104a6f:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
c0104a76:	e8 b4 f7 ff ff       	call   c010422f <Set_IDT_Entry>
c0104a7b:	b8 23 a4 10 c0       	mov    $0xc010a423,%eax
c0104a80:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104a87:	00 
c0104a88:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104a8c:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104a93:	00 
c0104a94:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
c0104a9b:	e8 8f f7 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(38,0x8,(uint32_t)isr_38,0xEE00); Set_IDT_Entry(39,0x8,(uint32_t)isr_39,0xEE00);
c0104aa0:	b8 29 a4 10 c0       	mov    $0xc010a429,%eax
c0104aa5:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104aac:	00 
c0104aad:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104ab1:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104ab8:	00 
c0104ab9:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
c0104ac0:	e8 6a f7 ff ff       	call   c010422f <Set_IDT_Entry>
c0104ac5:	b8 2f a4 10 c0       	mov    $0xc010a42f,%eax
c0104aca:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104ad1:	00 
c0104ad2:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104ad6:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104add:	00 
c0104ade:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
c0104ae5:	e8 45 f7 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(40,0x8,(uint32_t)isr_40,0xEE00); Set_IDT_Entry(41,0x8,(uint32_t)isr_41,0xEE00);
c0104aea:	b8 35 a4 10 c0       	mov    $0xc010a435,%eax
c0104aef:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104af6:	00 
c0104af7:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104afb:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104b02:	00 
c0104b03:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
c0104b0a:	e8 20 f7 ff ff       	call   c010422f <Set_IDT_Entry>
c0104b0f:	b8 3b a4 10 c0       	mov    $0xc010a43b,%eax
c0104b14:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104b1b:	00 
c0104b1c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104b20:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104b27:	00 
c0104b28:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0104b2f:	e8 fb f6 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(42,0x8,(uint32_t)isr_42,0xEE00); Set_IDT_Entry(43,0x8,(uint32_t)isr_43,0xEE00);
c0104b34:	b8 41 a4 10 c0       	mov    $0xc010a441,%eax
c0104b39:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104b40:	00 
c0104b41:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104b45:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104b4c:	00 
c0104b4d:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
c0104b54:	e8 d6 f6 ff ff       	call   c010422f <Set_IDT_Entry>
c0104b59:	b8 47 a4 10 c0       	mov    $0xc010a447,%eax
c0104b5e:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104b65:	00 
c0104b66:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104b6a:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104b71:	00 
c0104b72:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
c0104b79:	e8 b1 f6 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(44,0x8,(uint32_t)isr_44,0xEE00); Set_IDT_Entry(45,0x8,(uint32_t)isr_45,0xEE00);
c0104b7e:	b8 4d a4 10 c0       	mov    $0xc010a44d,%eax
c0104b83:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104b8a:	00 
c0104b8b:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104b8f:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104b96:	00 
c0104b97:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
c0104b9e:	e8 8c f6 ff ff       	call   c010422f <Set_IDT_Entry>
c0104ba3:	b8 53 a4 10 c0       	mov    $0xc010a453,%eax
c0104ba8:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104baf:	00 
c0104bb0:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104bb4:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104bbb:	00 
c0104bbc:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
c0104bc3:	e8 67 f6 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(46,0x8,(uint32_t)isr_46,0xEE00); Set_IDT_Entry(47,0x8,(uint32_t)isr_47,0xEE00);
c0104bc8:	b8 59 a4 10 c0       	mov    $0xc010a459,%eax
c0104bcd:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104bd4:	00 
c0104bd5:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104bd9:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104be0:	00 
c0104be1:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
c0104be8:	e8 42 f6 ff ff       	call   c010422f <Set_IDT_Entry>
c0104bed:	b8 5f a4 10 c0       	mov    $0xc010a45f,%eax
c0104bf2:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104bf9:	00 
c0104bfa:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104bfe:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104c05:	00 
c0104c06:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
c0104c0d:	e8 1d f6 ff ff       	call   c010422f <Set_IDT_Entry>

	Set_IDT_Entry(0x70,0x8,(uint32_t)isr_112,0xEE00); //Universe syscall interface
c0104c12:	b8 65 a4 10 c0       	mov    $0xc010a465,%eax
c0104c17:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104c1e:	00 
c0104c1f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104c23:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104c2a:	00 
c0104c2b:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c0104c32:	e8 f8 f5 ff ff       	call   c010422f <Set_IDT_Entry>
	Set_IDT_Entry(0x80,0x8,(uint32_t)isr_128,0xEE00); //Linux syscall interface
c0104c37:	b8 6b a4 10 c0       	mov    $0xc010a46b,%eax
c0104c3c:	c7 44 24 0c 00 ee 00 	movl   $0xee00,0xc(%esp)
c0104c43:	00 
c0104c44:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104c48:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0104c4f:	00 
c0104c50:	c7 04 24 80 00 00 00 	movl   $0x80,(%esp)
c0104c57:	e8 d3 f5 ff ff       	call   c010422f <Set_IDT_Entry>
	lidt(129);
c0104c5c:	c7 04 24 81 00 00 00 	movl   $0x81,(%esp)
c0104c63:	e8 1e f5 ff ff       	call   c0104186 <lidt>
}
c0104c68:	c9                   	leave  
c0104c69:	c3                   	ret    
c0104c6a:	66 90                	xchg   %ax,%ax

c0104c6c <pmm_count_free_pages>:
/**
 * Returns the number of free pages
 *
 * @return number of free pages
 */
int pmm_count_free_pages(void) {
c0104c6c:	55                   	push   %ebp
c0104c6d:	89 e5                	mov    %esp,%ebp
c0104c6f:	56                   	push   %esi
c0104c70:	53                   	push   %ebx
c0104c71:	83 ec 10             	sub    $0x10,%esp
	int free_pages = 0;
c0104c74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int i, z;

	for (i = 0; i < PMM_MMAP_SIZE; i++) {
c0104c7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0104c82:	eb 3b                	jmp    c0104cbf <pmm_count_free_pages+0x53>
		for (z = 0; z < 32; z++) {
c0104c84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0104c8b:	eb 28                	jmp    c0104cb5 <pmm_count_free_pages+0x49>
			if (pmm_mmap[i] & (1 << z)) {
c0104c8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c90:	8b 14 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%edx
c0104c97:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104c9a:	bb 01 00 00 00       	mov    $0x1,%ebx
c0104c9f:	89 de                	mov    %ebx,%esi
c0104ca1:	89 c1                	mov    %eax,%ecx
c0104ca3:	d3 e6                	shl    %cl,%esi
c0104ca5:	89 f0                	mov    %esi,%eax
c0104ca7:	21 d0                	and    %edx,%eax
c0104ca9:	85 c0                	test   %eax,%eax
c0104cab:	74 04                	je     c0104cb1 <pmm_count_free_pages+0x45>
				free_pages++;
c0104cad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
int pmm_count_free_pages(void) {
	int free_pages = 0;
	int i, z;

	for (i = 0; i < PMM_MMAP_SIZE; i++) {
		for (z = 0; z < 32; z++) {
c0104cb1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0104cb5:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
c0104cb9:	7e d2                	jle    c0104c8d <pmm_count_free_pages+0x21>
 */
int pmm_count_free_pages(void) {
	int free_pages = 0;
	int i, z;

	for (i = 0; i < PMM_MMAP_SIZE; i++) {
c0104cbb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0104cbf:	81 7d f0 ff 7f 00 00 	cmpl   $0x7fff,-0x10(%ebp)
c0104cc6:	7e bc                	jle    c0104c84 <pmm_count_free_pages+0x18>
			if (pmm_mmap[i] & (1 << z)) {
				free_pages++;
			}
		}
	}
	return free_pages;
c0104cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0104ccb:	83 c4 10             	add    $0x10,%esp
c0104cce:	5b                   	pop    %ebx
c0104ccf:	5e                   	pop    %esi
c0104cd0:	5d                   	pop    %ebp
c0104cd1:	c3                   	ret    

c0104cd2 <pmm_mark_page_as_free>:
 * Mark page als free
 *
 * @param page-pointer on the begin of the page which should be marked as free.
 */
void pmm_mark_page_as_free(paddr_t page)
{ //TODO: should that be possible from the entire kernel?
c0104cd2:	55                   	push   %ebp
c0104cd3:	89 e5                	mov    %esp,%ebp
c0104cd5:	57                   	push   %edi
c0104cd6:	56                   	push   %esi
c0104cd7:	53                   	push   %ebx
	pmm_mmap[page / PAGE_SIZE / 32] |= 1 << ((page / PAGE_SIZE) & 31);
c0104cd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0104cdb:	c1 e8 11             	shr    $0x11,%eax
c0104cde:	8b 1c 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%ebx
c0104ce5:	8b 55 08             	mov    0x8(%ebp),%edx
c0104ce8:	c1 ea 0c             	shr    $0xc,%edx
c0104ceb:	83 e2 1f             	and    $0x1f,%edx
c0104cee:	be 01 00 00 00       	mov    $0x1,%esi
c0104cf3:	89 f7                	mov    %esi,%edi
c0104cf5:	89 d1                	mov    %edx,%ecx
c0104cf7:	d3 e7                	shl    %cl,%edi
c0104cf9:	89 fa                	mov    %edi,%edx
c0104cfb:	09 da                	or     %ebx,%edx
c0104cfd:	89 14 85 60 32 11 c0 	mov    %edx,-0x3feecda0(,%eax,4)
}
c0104d04:	5b                   	pop    %ebx
c0104d05:	5e                   	pop    %esi
c0104d06:	5f                   	pop    %edi
c0104d07:	5d                   	pop    %ebp
c0104d08:	c3                   	ret    

c0104d09 <pmm_mark_page_range_as_free>:
 * Mark num pages as free
 *
 * @param page-pointer on the begin of the first page.
 * @param num of the pages which should be marked as free.
 */
void pmm_mark_page_range_as_free(paddr_t page, unsigned int num) {
c0104d09:	55                   	push   %ebp
c0104d0a:	89 e5                	mov    %esp,%ebp
c0104d0c:	83 ec 28             	sub    $0x28,%esp
	int i;

	if (!num)
c0104d0f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0104d13:	75 0c                	jne    c0104d21 <pmm_mark_page_range_as_free+0x18>
		panic("PMM: pmm_mark_page_range_as_free(): num is zero");
c0104d15:	c7 04 24 a8 b3 10 c0 	movl   $0xc010b3a8,(%esp)
c0104d1c:	e8 88 27 00 00       	call   c01074a9 <panic>

	if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
c0104d21:	8b 45 08             	mov    0x8(%ebp),%eax
c0104d24:	89 c2                	mov    %eax,%edx
c0104d26:	c1 ea 0c             	shr    $0xc,%edx
c0104d29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0104d2c:	01 d0                	add    %edx,%eax
c0104d2e:	3d 00 00 10 00       	cmp    $0x100000,%eax
c0104d33:	76 0c                	jbe    c0104d41 <pmm_mark_page_range_as_free+0x38>
			panic("PMM: pmm_mark_page_range_as_free(): marking the given\n"
c0104d35:	c7 04 24 d8 b3 10 c0 	movl   $0xc010b3d8,(%esp)
c0104d3c:	e8 68 27 00 00       	call   c01074a9 <panic>
		"pages as free would cause a buffer overrun");


	for (i = 0; i < num; i++) {
c0104d41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0104d48:	eb 19                	jmp    c0104d63 <pmm_mark_page_range_as_free+0x5a>
		pmm_mark_page_as_free(page + i * PAGE_SIZE);
c0104d4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104d4d:	c1 e0 0c             	shl    $0xc,%eax
c0104d50:	89 c2                	mov    %eax,%edx
c0104d52:	8b 45 08             	mov    0x8(%ebp),%eax
c0104d55:	01 d0                	add    %edx,%eax
c0104d57:	89 04 24             	mov    %eax,(%esp)
c0104d5a:	e8 73 ff ff ff       	call   c0104cd2 <pmm_mark_page_as_free>
	if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
			panic("PMM: pmm_mark_page_range_as_free(): marking the given\n"
		"pages as free would cause a buffer overrun");


	for (i = 0; i < num; i++) {
c0104d5f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0104d63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104d66:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0104d69:	72 df                	jb     c0104d4a <pmm_mark_page_range_as_free+0x41>
		pmm_mark_page_as_free(page + i * PAGE_SIZE);
	}
}
c0104d6b:	c9                   	leave  
c0104d6c:	c3                   	ret    

c0104d6d <pmm_mark_page_as_used>:
/**
 * mark page as used
 *
 * @param page-pointer on the begin of the first page.
 */
void pmm_mark_page_as_used(paddr_t page) {
c0104d6d:	55                   	push   %ebp
c0104d6e:	89 e5                	mov    %esp,%ebp
c0104d70:	57                   	push   %edi
c0104d71:	56                   	push   %esi
c0104d72:	53                   	push   %ebx
	pmm_mmap[page / PAGE_SIZE / 32] &= ~(1 << ((page / PAGE_SIZE) & 31));
c0104d73:	8b 45 08             	mov    0x8(%ebp),%eax
c0104d76:	c1 e8 11             	shr    $0x11,%eax
c0104d79:	8b 1c 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%ebx
c0104d80:	8b 55 08             	mov    0x8(%ebp),%edx
c0104d83:	c1 ea 0c             	shr    $0xc,%edx
c0104d86:	83 e2 1f             	and    $0x1f,%edx
c0104d89:	be 01 00 00 00       	mov    $0x1,%esi
c0104d8e:	89 f7                	mov    %esi,%edi
c0104d90:	89 d1                	mov    %edx,%ecx
c0104d92:	d3 e7                	shl    %cl,%edi
c0104d94:	89 fa                	mov    %edi,%edx
c0104d96:	f7 d2                	not    %edx
c0104d98:	21 da                	and    %ebx,%edx
c0104d9a:	89 14 85 60 32 11 c0 	mov    %edx,-0x3feecda0(,%eax,4)
}
c0104da1:	5b                   	pop    %ebx
c0104da2:	5e                   	pop    %esi
c0104da3:	5f                   	pop    %edi
c0104da4:	5d                   	pop    %ebp
c0104da5:	c3                   	ret    

c0104da6 <pmm_mark_page_range_as_used>:
 * Mark num pages as used
 *
 * @param page-pointer on the begin of the first page.
 * @param num of the pages which should be marked as free.
 */
void pmm_mark_page_range_as_used(paddr_t page, unsigned int num) {
c0104da6:	55                   	push   %ebp
c0104da7:	89 e5                	mov    %esp,%ebp
c0104da9:	83 ec 28             	sub    $0x28,%esp
	int i;

	if (!num)
c0104dac:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0104db0:	75 0c                	jne    c0104dbe <pmm_mark_page_range_as_used+0x18>
		panic("PMM: pmm_mark_page_range_as_used(): num is zero");
c0104db2:	c7 04 24 3c b4 10 c0 	movl   $0xc010b43c,(%esp)
c0104db9:	e8 eb 26 00 00       	call   c01074a9 <panic>

/*
 * PMM is broken, see comment in PMM_INIT
 */
	if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
c0104dbe:	8b 45 08             	mov    0x8(%ebp),%eax
c0104dc1:	89 c2                	mov    %eax,%edx
c0104dc3:	c1 ea 0c             	shr    $0xc,%edx
c0104dc6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0104dc9:	01 d0                	add    %edx,%eax
c0104dcb:	3d 00 00 10 00       	cmp    $0x100000,%eax
c0104dd0:	76 0c                	jbe    c0104dde <pmm_mark_page_range_as_used+0x38>
		panic("PMM: pmm_mark_page_range_as_used(): marking the given\n"
c0104dd2:	c7 04 24 6c b4 10 c0 	movl   $0xc010b46c,(%esp)
c0104dd9:	e8 cb 26 00 00       	call   c01074a9 <panic>
		    "pages as used would cause a buffer overrun");

	for (i = 0; i < num; i++) {
c0104dde:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0104de5:	eb 19                	jmp    c0104e00 <pmm_mark_page_range_as_used+0x5a>
		pmm_mark_page_as_used(page + i * PAGE_SIZE);
c0104de7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104dea:	c1 e0 0c             	shl    $0xc,%eax
c0104ded:	89 c2                	mov    %eax,%edx
c0104def:	8b 45 08             	mov    0x8(%ebp),%eax
c0104df2:	01 d0                	add    %edx,%eax
c0104df4:	89 04 24             	mov    %eax,(%esp)
c0104df7:	e8 71 ff ff ff       	call   c0104d6d <pmm_mark_page_as_used>
 */
	if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
		panic("PMM: pmm_mark_page_range_as_used(): marking the given\n"
		    "pages as used would cause a buffer overrun");

	for (i = 0; i < num; i++) {
c0104dfc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0104e00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104e03:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0104e06:	72 df                	jb     c0104de7 <pmm_mark_page_range_as_used+0x41>
		pmm_mark_page_as_used(page + i * PAGE_SIZE);
	}
}
c0104e08:	c9                   	leave  
c0104e09:	c3                   	ret    

c0104e0a <pmm_find_free_page>:
 *
 * @param lower_limit minimus size of the page.
 *
 * @return If the search is succesful this method returns a pointer on the begin on this page.
 */
paddr_t pmm_find_free_page(unsigned long lower_limit) {
c0104e0a:	55                   	push   %ebp
c0104e0b:	89 e5                	mov    %esp,%ebp
c0104e0d:	56                   	push   %esi
c0104e0e:	53                   	push   %ebx
c0104e0f:	83 ec 20             	sub    $0x20,%esp
	uint32_t i, z;
	paddr_t page = 0;
c0104e12:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	i = lower_limit / PAGE_SIZE / 32;
c0104e19:	8b 45 08             	mov    0x8(%ebp),%eax
c0104e1c:	c1 e8 11             	shr    $0x11,%eax
c0104e1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pmm_mmap[i] & (0xffffffff << (( lower_limit / PAGE_SIZE) % 32))) {
c0104e22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104e25:	8b 04 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%eax
c0104e2c:	8b 55 08             	mov    0x8(%ebp),%edx
c0104e2f:	c1 ea 0c             	shr    $0xc,%edx
c0104e32:	83 e2 1f             	and    $0x1f,%edx
c0104e35:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0104e3a:	89 de                	mov    %ebx,%esi
c0104e3c:	89 d1                	mov    %edx,%ecx
c0104e3e:	d3 e6                	shl    %cl,%esi
c0104e40:	89 f2                	mov    %esi,%edx
c0104e42:	21 d0                	and    %edx,%eax
c0104e44:	85 c0                	test   %eax,%eax
c0104e46:	74 45                	je     c0104e8d <pmm_find_free_page+0x83>
		z = bit_scan_forward(pmm_mmap[i] & (0xffffffff << ((lower_limit / PAGE_SIZE) % 32)));
c0104e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104e4b:	8b 04 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%eax
c0104e52:	8b 55 08             	mov    0x8(%ebp),%edx
c0104e55:	c1 ea 0c             	shr    $0xc,%edx
c0104e58:	83 e2 1f             	and    $0x1f,%edx
c0104e5b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0104e60:	89 de                	mov    %ebx,%esi
c0104e62:	89 d1                	mov    %edx,%ecx
c0104e64:	d3 e6                	shl    %cl,%esi
c0104e66:	89 f2                	mov    %esi,%edx
c0104e68:	21 d0                	and    %edx,%eax
c0104e6a:	89 04 24             	mov    %eax,(%esp)
c0104e6d:	e8 aa 3d 00 00       	call   c0108c1c <bit_scan_forward>
c0104e72:	89 45 ec             	mov    %eax,-0x14(%ebp)
		page = (i * 32 + z) * PAGE_SIZE;
c0104e75:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104e78:	89 c2                	mov    %eax,%edx
c0104e7a:	c1 e2 05             	shl    $0x5,%edx
c0104e7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e80:	01 d0                	add    %edx,%eax
c0104e82:	c1 e0 0c             	shl    $0xc,%eax
c0104e85:	89 45 f0             	mov    %eax,-0x10(%ebp)
		return page;
c0104e88:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104e8b:	eb 53                	jmp    c0104ee0 <pmm_find_free_page+0xd6>
	}

	for (i++; i < PMM_MMAP_SIZE; i++) {
c0104e8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0104e91:	eb 3f                	jmp    c0104ed2 <pmm_find_free_page+0xc8>
		if (pmm_mmap[i]) {
c0104e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104e96:	8b 04 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%eax
c0104e9d:	85 c0                	test   %eax,%eax
c0104e9f:	74 2d                	je     c0104ece <pmm_find_free_page+0xc4>
			z = bit_scan_forward(pmm_mmap[i]);
c0104ea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104ea4:	8b 04 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%eax
c0104eab:	89 04 24             	mov    %eax,(%esp)
c0104eae:	e8 69 3d 00 00       	call   c0108c1c <bit_scan_forward>
c0104eb3:	89 45 ec             	mov    %eax,-0x14(%ebp)
			page = (i * 32 + z) * PAGE_SIZE;
c0104eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104eb9:	89 c2                	mov    %eax,%edx
c0104ebb:	c1 e2 05             	shl    $0x5,%edx
c0104ebe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104ec1:	01 d0                	add    %edx,%eax
c0104ec3:	c1 e0 0c             	shl    $0xc,%eax
c0104ec6:	89 45 f0             	mov    %eax,-0x10(%ebp)
			return page;
c0104ec9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104ecc:	eb 12                	jmp    c0104ee0 <pmm_find_free_page+0xd6>
		z = bit_scan_forward(pmm_mmap[i] & (0xffffffff << ((lower_limit / PAGE_SIZE) % 32)));
		page = (i * 32 + z) * PAGE_SIZE;
		return page;
	}

	for (i++; i < PMM_MMAP_SIZE; i++) {
c0104ece:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0104ed2:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
c0104ed9:	76 b8                	jbe    c0104e93 <pmm_find_free_page+0x89>
			return page;
		}
	}

	/* checked in the alloc functions */
	return -1;
c0104edb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0104ee0:	83 c4 20             	add    $0x20,%esp
c0104ee3:	5b                   	pop    %ebx
c0104ee4:	5e                   	pop    %esi
c0104ee5:	5d                   	pop    %ebp
c0104ee6:	c3                   	ret    

c0104ee7 <pmm_find_free_page_range>:
 * @param num Number of pages.
 *
 * @return Pointer on begin of the first page.
 * @return If succesful this method will return a pointer on the begin of the first free page.
 */
paddr_t pmm_find_free_page_range(unsigned long lower_limit, unsigned int num) {
c0104ee7:	55                   	push   %ebp
c0104ee8:	89 e5                	mov    %esp,%ebp
c0104eea:	56                   	push   %esi
c0104eeb:	53                   	push   %ebx
c0104eec:	83 ec 20             	sub    $0x20,%esp
	uint32_t i, z;
	uint32_t found = 0;
c0104eef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	paddr_t page = 0;
c0104ef6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	if (!num)
c0104efd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0104f01:	75 0c                	jne    c0104f0f <pmm_find_free_page_range+0x28>
		panic("PMM: searching 0 pages (find_free_page_range())");
c0104f03:	c7 04 24 d0 b4 10 c0 	movl   $0xc010b4d0,(%esp)
c0104f0a:	e8 9a 25 00 00       	call   c01074a9 <panic>

	for (i = lower_limit / PAGE_SIZE / 32; i < PMM_MMAP_SIZE; i++) {
c0104f0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0104f12:	c1 e8 11             	shr    $0x11,%eax
c0104f15:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0104f18:	e9 d2 00 00 00       	jmp    c0104fef <pmm_find_free_page_range+0x108>
		printf("%i\n", i);
c0104f1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104f20:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104f24:	c7 04 24 00 b5 10 c0 	movl   $0xc010b500,(%esp)
c0104f2b:	e8 4c 04 00 00       	call   c010537c <printf>
		if (pmm_mmap[i] == 0) {
c0104f30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104f33:	8b 04 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%eax
c0104f3a:	85 c0                	test   %eax,%eax
c0104f3c:	75 0c                	jne    c0104f4a <pmm_find_free_page_range+0x63>
			found = 0;
c0104f3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			continue;
c0104f45:	e9 a1 00 00 00       	jmp    c0104feb <pmm_find_free_page_range+0x104>
		}

		if (pmm_mmap[i] == 0xffffffff) {
c0104f4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104f4d:	8b 04 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%eax
c0104f54:	83 f8 ff             	cmp    $0xffffffff,%eax
c0104f57:	75 15                	jne    c0104f6e <pmm_find_free_page_range+0x87>
			if (found == 0) {
c0104f59:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0104f5d:	75 09                	jne    c0104f68 <pmm_find_free_page_range+0x81>
				page = (i * 32) * PAGE_SIZE; //
c0104f5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104f62:	c1 e0 11             	shl    $0x11,%eax
c0104f65:	89 45 e8             	mov    %eax,-0x18(%ebp)
			}
			found += 32;
c0104f68:	83 45 ec 20          	addl   $0x20,-0x14(%ebp)
c0104f6c:	eb 70                	jmp    c0104fde <pmm_find_free_page_range+0xf7>

		} else {
			printf("bar\n");
c0104f6e:	c7 04 24 04 b5 10 c0 	movl   $0xc010b504,(%esp)
c0104f75:	e8 dd d9 ff ff       	call   c0102957 <puts>
			for (z = 0; z < 32; z++) {
c0104f7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0104f81:	eb 55                	jmp    c0104fd8 <pmm_find_free_page_range+0xf1>
				if (pmm_mmap[i] & (1 << z)) {
c0104f83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104f86:	8b 14 85 60 32 11 c0 	mov    -0x3feecda0(,%eax,4),%edx
c0104f8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104f90:	bb 01 00 00 00       	mov    $0x1,%ebx
c0104f95:	89 de                	mov    %ebx,%esi
c0104f97:	89 c1                	mov    %eax,%ecx
c0104f99:	d3 e6                	shl    %cl,%esi
c0104f9b:	89 f0                	mov    %esi,%eax
c0104f9d:	21 d0                	and    %edx,%eax
c0104f9f:	85 c0                	test   %eax,%eax
c0104fa1:	74 2a                	je     c0104fcd <pmm_find_free_page_range+0xe6>
					if (found == 0) {
c0104fa3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0104fa7:	75 13                	jne    c0104fbc <pmm_find_free_page_range+0xd5>
						page = (i * 32 + z) * PAGE_SIZE;
c0104fa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104fac:	89 c2                	mov    %eax,%edx
c0104fae:	c1 e2 05             	shl    $0x5,%edx
c0104fb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104fb4:	01 d0                	add    %edx,%eax
c0104fb6:	c1 e0 0c             	shl    $0xc,%eax
c0104fb9:	89 45 e8             	mov    %eax,-0x18(%ebp)
					}
					found++;
c0104fbc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
					if (found >= num) {
c0104fc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104fc3:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0104fc6:	72 0c                	jb     c0104fd4 <pmm_find_free_page_range+0xed>
						return page;
c0104fc8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104fcb:	eb 34                	jmp    c0105001 <pmm_find_free_page_range+0x11a>
					}
				} else {
					found = 0;
c0104fcd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			}
			found += 32;

		} else {
			printf("bar\n");
			for (z = 0; z < 32; z++) {
c0104fd4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0104fd8:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c0104fdc:	76 a5                	jbe    c0104f83 <pmm_find_free_page_range+0x9c>
					found = 0;
				}
			}
		}

		if (found >= num) {
c0104fde:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104fe1:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0104fe4:	72 05                	jb     c0104feb <pmm_find_free_page_range+0x104>
			return page;
c0104fe6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104fe9:	eb 16                	jmp    c0105001 <pmm_find_free_page_range+0x11a>
	paddr_t page = 0;

	if (!num)
		panic("PMM: searching 0 pages (find_free_page_range())");

	for (i = lower_limit / PAGE_SIZE / 32; i < PMM_MMAP_SIZE; i++) {
c0104feb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0104fef:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
c0104ff6:	0f 86 21 ff ff ff    	jbe    c0104f1d <pmm_find_free_page_range+0x36>
		if (found >= num) {
			return page;
		}
	}

	return -1; /* checked in the alloc functions */
c0104ffc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0105001:	83 c4 20             	add    $0x20,%esp
c0105004:	5b                   	pop    %ebx
c0105005:	5e                   	pop    %esi
c0105006:	5d                   	pop    %ebp
c0105007:	c3                   	ret    

c0105008 <pmm_alloc_page>:
/**
 * Reserve a page and mark this page as used.
 *
 * @return Pointer on the begin of the page.
 */
paddr_t pmm_alloc_page(void) {
c0105008:	55                   	push   %ebp
c0105009:	89 e5                	mov    %esp,%ebp
c010500b:	83 ec 28             	sub    $0x28,%esp
	paddr_t page = pmm_find_free_page(PMM_DMA_LIMIT);
c010500e:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
c0105015:	e8 f0 fd ff ff       	call   c0104e0a <pmm_find_free_page>
c010501a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (page & (PAGE_SIZE - 1)) {
c010501d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105020:	25 ff 0f 00 00       	and    $0xfff,%eax
c0105025:	85 c0                	test   %eax,%eax
c0105027:	74 0c                	je     c0105035 <pmm_alloc_page+0x2d>
		panic("PMM: pmm_alloc_page(): no pages left");
c0105029:	c7 04 24 08 b5 10 c0 	movl   $0xc010b508,(%esp)
c0105030:	e8 74 24 00 00       	call   c01074a9 <panic>
	}
	pmm_mark_page_as_used(page);
c0105035:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105038:	89 04 24             	mov    %eax,(%esp)
c010503b:	e8 2d fd ff ff       	call   c0104d6d <pmm_mark_page_as_used>

	return page;
c0105040:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0105043:	c9                   	leave  
c0105044:	c3                   	ret    

c0105045 <pmm_alloc_page_limit>:

/**
 * Reserve a page not under a entered address
 */
paddr_t pmm_alloc_page_limit(paddr_t lower_limit) {
c0105045:	55                   	push   %ebp
c0105046:	89 e5                	mov    %esp,%ebp
c0105048:	83 ec 28             	sub    $0x28,%esp
	paddr_t page = pmm_find_free_page(lower_limit);
c010504b:	8b 45 08             	mov    0x8(%ebp),%eax
c010504e:	89 04 24             	mov    %eax,(%esp)
c0105051:	e8 b4 fd ff ff       	call   c0104e0a <pmm_find_free_page>
c0105056:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (page & (PAGE_SIZE - 1)) {
c0105059:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010505c:	25 ff 0f 00 00       	and    $0xfff,%eax
c0105061:	85 c0                	test   %eax,%eax
c0105063:	74 0c                	je     c0105071 <pmm_alloc_page_limit+0x2c>
		panic("PMM: pmm_alloc_page_limit(): no pages left");
c0105065:	c7 04 24 30 b5 10 c0 	movl   $0xc010b530,(%esp)
c010506c:	e8 38 24 00 00       	call   c01074a9 <panic>
	}

	pmm_mark_page_as_used(page);
c0105071:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105074:	89 04 24             	mov    %eax,(%esp)
c0105077:	e8 f1 fc ff ff       	call   c0104d6d <pmm_mark_page_as_used>
	return page;
c010507c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010507f:	c9                   	leave  
c0105080:	c3                   	ret    

c0105081 <pmm_alloc_dma_page_range>:
/**
 * Reserve num DMA-Pages.
 *
 * @return Pointer on the begin of the first page.
 */
paddr_t pmm_alloc_dma_page_range(unsigned int num) {
c0105081:	55                   	push   %ebp
c0105082:	89 e5                	mov    %esp,%ebp
c0105084:	83 ec 28             	sub    $0x28,%esp
	if (!num)
c0105087:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010508b:	75 0c                	jne    c0105099 <pmm_alloc_dma_page_range+0x18>
		panic("PMM: pmm_alloc_dma_page_range(): num zero");
c010508d:	c7 04 24 5c b5 10 c0 	movl   $0xc010b55c,(%esp)
c0105094:	e8 10 24 00 00       	call   c01074a9 <panic>
	paddr_t page = pmm_find_free_page_range(0, num);
c0105099:	8b 45 08             	mov    0x8(%ebp),%eax
c010509c:	89 44 24 04          	mov    %eax,0x4(%esp)
c01050a0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c01050a7:	e8 3b fe ff ff       	call   c0104ee7 <pmm_find_free_page_range>
c01050ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (page & (PAGE_SIZE - 1) || page >= PMM_DMA_LIMIT) {
c01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01050b2:	25 ff 0f 00 00       	and    $0xfff,%eax
c01050b7:	85 c0                	test   %eax,%eax
c01050b9:	75 09                	jne    c01050c4 <pmm_alloc_dma_page_range+0x43>
c01050bb:	81 7d f4 ff ff ff 00 	cmpl   $0xffffff,-0xc(%ebp)
c01050c2:	76 0c                	jbe    c01050d0 <pmm_alloc_dma_page_range+0x4f>
		panic("PMM: pmm_alloc_dma_page_range(): no DMA memory left");
c01050c4:	c7 04 24 88 b5 10 c0 	movl   $0xc010b588,(%esp)
c01050cb:	e8 d9 23 00 00       	call   c01074a9 <panic>
	}
	pmm_mark_page_range_as_used(page, num);
c01050d0:	8b 45 08             	mov    0x8(%ebp),%eax
c01050d3:	89 44 24 04          	mov    %eax,0x4(%esp)
c01050d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01050da:	89 04 24             	mov    %eax,(%esp)
c01050dd:	e8 c4 fc ff ff       	call   c0104da6 <pmm_mark_page_range_as_used>
	return page;
c01050e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01050e5:	c9                   	leave  
c01050e6:	c3                   	ret    

c01050e7 <pmm_alloc_page_range>:
/**
 * Reserve num pages.
 *
 * @return Pointer on the begin of the first page.
 */
paddr_t pmm_alloc_page_range(unsigned int num) {
c01050e7:	55                   	push   %ebp
c01050e8:	89 e5                	mov    %esp,%ebp
c01050ea:	83 ec 28             	sub    $0x28,%esp
	if (!num)
c01050ed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c01050f1:	75 0c                	jne    c01050ff <pmm_alloc_page_range+0x18>
		panic("PMM: pmm_alloc_page_range(): num zero");
c01050f3:	c7 04 24 bc b5 10 c0 	movl   $0xc010b5bc,(%esp)
c01050fa:	e8 aa 23 00 00       	call   c01074a9 <panic>
	paddr_t page = pmm_find_free_page_range(PMM_DMA_LIMIT, num);
c01050ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0105102:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105106:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
c010510d:	e8 d5 fd ff ff       	call   c0104ee7 <pmm_find_free_page_range>
c0105112:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (page & (PAGE_SIZE - 1)) {
c0105115:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105118:	25 ff 0f 00 00       	and    $0xfff,%eax
c010511d:	85 c0                	test   %eax,%eax
c010511f:	74 0c                	je     c010512d <pmm_alloc_page_range+0x46>
		panic("PMM: pmm_alloc_page_range(): no memory left");
c0105121:	c7 04 24 e4 b5 10 c0 	movl   $0xc010b5e4,(%esp)
c0105128:	e8 7c 23 00 00       	call   c01074a9 <panic>
	}
	pmm_mark_page_range_as_used(page, num);
c010512d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105130:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105134:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105137:	89 04 24             	mov    %eax,(%esp)
c010513a:	e8 67 fc ff ff       	call   c0104da6 <pmm_mark_page_range_as_used>
	return page;
c010513f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0105142:	c9                   	leave  
c0105143:	c3                   	ret    

c0105144 <INIT_PMM>:

void INIT_PMM(struct multiboot_struct *mb_info) {
c0105144:	55                   	push   %ebp
c0105145:	89 e5                	mov    %esp,%ebp
c0105147:	83 ec 48             	sub    $0x48,%esp
	int i;
	for (i = 0; i < PMM_MMAP_SIZE; i++) {
c010514a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0105151:	eb 12                	jmp    c0105165 <INIT_PMM+0x21>
		pmm_mmap[i] = 0;
c0105153:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105156:	c7 04 85 60 32 11 c0 	movl   $0x0,-0x3feecda0(,%eax,4)
c010515d:	00 00 00 00 
	return page;
}

void INIT_PMM(struct multiboot_struct *mb_info) {
	int i;
	for (i = 0; i < PMM_MMAP_SIZE; i++) {
c0105161:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0105165:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
c010516c:	7e e5                	jle    c0105153 <INIT_PMM+0xf>
		pmm_mmap[i] = 0;
	}

	mb_info->mmap_addr += MEMORY_LAYOUT_KERNEL_START;
c010516e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105171:	8b 40 30             	mov    0x30(%eax),%eax
c0105174:	8d 90 00 00 00 c0    	lea    -0x40000000(%eax),%edx
c010517a:	8b 45 08             	mov    0x8(%ebp),%eax
c010517d:	89 50 30             	mov    %edx,0x30(%eax)
	mb_info->mods_addr += MEMORY_LAYOUT_KERNEL_START;
c0105180:	8b 45 08             	mov    0x8(%ebp),%eax
c0105183:	8b 40 18             	mov    0x18(%eax),%eax
c0105186:	8d 90 00 00 00 c0    	lea    -0x40000000(%eax),%edx
c010518c:	8b 45 08             	mov    0x8(%ebp),%eax
c010518f:	89 50 18             	mov    %edx,0x18(%eax)

	struct mmap_entry *mmap = (struct mmap_entry *)mb_info->mmap_addr;
c0105192:	8b 45 08             	mov    0x8(%ebp),%eax
c0105195:	8b 40 30             	mov    0x30(%eax),%eax
c0105198:	89 45 ec             	mov    %eax,-0x14(%ebp)

	int len = 0;
c010519b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for(i = 0; len < mb_info->mmap_length; i++) {
c01051a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01051a9:	e9 90 00 00 00       	jmp    c010523e <INIT_PMM+0xfa>
		len += mmap[i].size +4;
c01051ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01051b1:	89 d0                	mov    %edx,%eax
c01051b3:	01 c0                	add    %eax,%eax
c01051b5:	01 d0                	add    %edx,%eax
c01051b7:	c1 e0 03             	shl    $0x3,%eax
c01051ba:	89 c2                	mov    %eax,%edx
c01051bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01051bf:	01 d0                	add    %edx,%eax
c01051c1:	8b 10                	mov    (%eax),%edx
c01051c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01051c6:	01 d0                	add    %edx,%eax
c01051c8:	83 c0 04             	add    $0x4,%eax
c01051cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(mmap[i].Type == 1) {
c01051ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01051d1:	89 d0                	mov    %edx,%eax
c01051d3:	01 c0                	add    %eax,%eax
c01051d5:	01 d0                	add    %edx,%eax
c01051d7:	c1 e0 03             	shl    $0x3,%eax
c01051da:	89 c2                	mov    %eax,%edx
c01051dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01051df:	01 d0                	add    %edx,%eax
c01051e1:	8b 40 14             	mov    0x14(%eax),%eax
c01051e4:	83 f8 01             	cmp    $0x1,%eax
c01051e7:	75 51                	jne    c010523a <INIT_PMM+0xf6>
			uintptr_t addr = mmap[i].BaseAddr;
c01051e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01051ec:	89 d0                	mov    %edx,%eax
c01051ee:	01 c0                	add    %eax,%eax
c01051f0:	01 d0                	add    %edx,%eax
c01051f2:	c1 e0 03             	shl    $0x3,%eax
c01051f5:	89 c2                	mov    %eax,%edx
c01051f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01051fa:	01 d0                	add    %edx,%eax
c01051fc:	8b 50 08             	mov    0x8(%eax),%edx
c01051ff:	8b 40 04             	mov    0x4(%eax),%eax
c0105202:	89 45 e8             	mov    %eax,-0x18(%ebp)
			int pages = mmap[i].Length / PAGE_SIZE;
c0105205:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105208:	89 d0                	mov    %edx,%eax
c010520a:	01 c0                	add    %eax,%eax
c010520c:	01 d0                	add    %edx,%eax
c010520e:	c1 e0 03             	shl    $0x3,%eax
c0105211:	89 c2                	mov    %eax,%edx
c0105213:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105216:	01 d0                	add    %edx,%eax
c0105218:	8b 50 10             	mov    0x10(%eax),%edx
c010521b:	8b 40 0c             	mov    0xc(%eax),%eax
c010521e:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
c0105222:	c1 ea 0c             	shr    $0xc,%edx
c0105225:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			pmm_mark_page_range_as_free(addr, pages);
c0105228:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010522b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010522f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105232:	89 04 24             	mov    %eax,(%esp)
c0105235:	e8 cf fa ff ff       	call   c0104d09 <pmm_mark_page_range_as_free>
	mb_info->mods_addr += MEMORY_LAYOUT_KERNEL_START;

	struct mmap_entry *mmap = (struct mmap_entry *)mb_info->mmap_addr;

	int len = 0;
	for(i = 0; len < mb_info->mmap_length; i++) {
c010523a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010523e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0105241:	8b 45 08             	mov    0x8(%ebp),%eax
c0105244:	8b 40 2c             	mov    0x2c(%eax),%eax
c0105247:	39 c2                	cmp    %eax,%edx
c0105249:	0f 82 5f ff ff ff    	jb     c01051ae <INIT_PMM+0x6a>
			pmm_mark_page_range_as_free(addr, pages);
		}
	}

	//protect Memory structures
	pmm_mark_page_as_used(0); //IVT+BDA
c010524f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0105256:	e8 12 fb ff ff       	call   c0104d6d <pmm_mark_page_as_used>

	uint16_t* EBDA_p = (void *)0x040E;
c010525b:	c7 45 e0 0e 04 00 00 	movl   $0x40e,-0x20(%ebp)
	pmm_mark_page_as_used((paddr_t)EBDA_p[0] << 4); //EBDA
c0105262:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0105265:	0f b7 00             	movzwl (%eax),%eax
c0105268:	0f b7 c0             	movzwl %ax,%eax
c010526b:	c1 e0 04             	shl    $0x4,%eax
c010526e:	89 04 24             	mov    %eax,(%esp)
c0105271:	e8 f7 fa ff ff       	call   c0104d6d <pmm_mark_page_as_used>

	uint16_t* BDA_size = (uint16_t*)0x0413;
c0105276:	c7 45 dc 13 04 00 00 	movl   $0x413,-0x24(%ebp)
	pmm_mark_page_as_used((BDA_size[0] / 4) * 1024); //FPS (maybe)
c010527d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0105280:	0f b7 00             	movzwl (%eax),%eax
c0105283:	66 c1 e8 02          	shr    $0x2,%ax
c0105287:	0f b7 c0             	movzwl %ax,%eax
c010528a:	c1 e0 0a             	shl    $0xa,%eax
c010528d:	89 04 24             	mov    %eax,(%esp)
c0105290:	e8 d8 fa ff ff       	call   c0104d6d <pmm_mark_page_as_used>
	pmm_mark_page_range_as_used(0xA0000, 96); //0xA0000 - 0xFFFFF ROM-AREA
c0105295:	c7 44 24 04 60 00 00 	movl   $0x60,0x4(%esp)
c010529c:	00 
c010529d:	c7 04 24 00 00 0a 00 	movl   $0xa0000,(%esp)
c01052a4:	e8 fd fa ff ff       	call   c0104da6 <pmm_mark_page_range_as_used>

	//multiboot structures
	struct mods_add *mods = (void*)mb_info->mods_addr;
c01052a9:	8b 45 08             	mov    0x8(%ebp),%eax
c01052ac:	8b 40 18             	mov    0x18(%eax),%eax
c01052af:	89 45 d8             	mov    %eax,-0x28(%ebp)
	pmm_mark_page_as_used((paddr_t)mb_info - MEMORY_LAYOUT_KERNEL_START);
c01052b2:	8b 45 08             	mov    0x8(%ebp),%eax
c01052b5:	05 00 00 00 40       	add    $0x40000000,%eax
c01052ba:	89 04 24             	mov    %eax,(%esp)
c01052bd:	e8 ab fa ff ff       	call   c0104d6d <pmm_mark_page_as_used>
	pmm_mark_page_as_used((paddr_t)mods    - MEMORY_LAYOUT_KERNEL_START);
c01052c2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01052c5:	05 00 00 00 40       	add    $0x40000000,%eax
c01052ca:	89 04 24             	mov    %eax,(%esp)
c01052cd:	e8 9b fa ff ff       	call   c0104d6d <pmm_mark_page_as_used>

	//multiboot modules
	for (i = 0; i < mb_info->mods_count; i++) {
c01052d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01052d9:	eb 75                	jmp    c0105350 <INIT_PMM+0x20c>
		uint32_t size = mods[i].mod_end - mods[i].mod_start;
c01052db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01052de:	89 c2                	mov    %eax,%edx
c01052e0:	c1 e2 04             	shl    $0x4,%edx
c01052e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01052e6:	01 d0                	add    %edx,%eax
c01052e8:	8b 50 04             	mov    0x4(%eax),%edx
c01052eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01052ee:	89 c1                	mov    %eax,%ecx
c01052f0:	c1 e1 04             	shl    $0x4,%ecx
c01052f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01052f6:	01 c8                	add    %ecx,%eax
c01052f8:	8b 00                	mov    (%eax),%eax
c01052fa:	89 d1                	mov    %edx,%ecx
c01052fc:	29 c1                	sub    %eax,%ecx
c01052fe:	89 c8                	mov    %ecx,%eax
c0105300:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		int pages = NUM_PAGES(size);
c0105303:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0105306:	05 ff 0f 00 00       	add    $0xfff,%eax
c010530b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0105310:	c1 e8 0c             	shr    $0xc,%eax
c0105313:	89 45 d0             	mov    %eax,-0x30(%ebp)
		pmm_mark_page_range_as_used((paddr_t) mods[i].mod_start, pages);
c0105316:	8b 55 d0             	mov    -0x30(%ebp),%edx
c0105319:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010531c:	89 c1                	mov    %eax,%ecx
c010531e:	c1 e1 04             	shl    $0x4,%ecx
c0105321:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0105324:	01 c8                	add    %ecx,%eax
c0105326:	8b 00                	mov    (%eax),%eax
c0105328:	89 54 24 04          	mov    %edx,0x4(%esp)
c010532c:	89 04 24             	mov    %eax,(%esp)
c010532f:	e8 72 fa ff ff       	call   c0104da6 <pmm_mark_page_range_as_used>
		pmm_mark_page_as_used((paddr_t) mods[i].string);
c0105334:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105337:	89 c2                	mov    %eax,%edx
c0105339:	c1 e2 04             	shl    $0x4,%edx
c010533c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010533f:	01 d0                	add    %edx,%eax
c0105341:	8b 40 08             	mov    0x8(%eax),%eax
c0105344:	89 04 24             	mov    %eax,(%esp)
c0105347:	e8 21 fa ff ff       	call   c0104d6d <pmm_mark_page_as_used>
	struct mods_add *mods = (void*)mb_info->mods_addr;
	pmm_mark_page_as_used((paddr_t)mb_info - MEMORY_LAYOUT_KERNEL_START);
	pmm_mark_page_as_used((paddr_t)mods    - MEMORY_LAYOUT_KERNEL_START);

	//multiboot modules
	for (i = 0; i < mb_info->mods_count; i++) {
c010534c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0105350:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105353:	8b 45 08             	mov    0x8(%ebp),%eax
c0105356:	8b 40 14             	mov    0x14(%eax),%eax
c0105359:	39 c2                	cmp    %eax,%edx
c010535b:	0f 82 7a ff ff ff    	jb     c01052db <INIT_PMM+0x197>
		int pages = NUM_PAGES(size);
		pmm_mark_page_range_as_used((paddr_t) mods[i].mod_start, pages);
		pmm_mark_page_as_used((paddr_t) mods[i].string);
	}

	if (! (mb_info->flags & 0x1)){
c0105361:	8b 45 08             	mov    0x8(%ebp),%eax
c0105364:	8b 00                	mov    (%eax),%eax
c0105366:	83 e0 01             	and    $0x1,%eax
c0105369:	85 c0                	test   %eax,%eax
c010536b:	75 0c                	jne    c0105379 <INIT_PMM+0x235>
		panic("PMM_INIT: no ram info in multiboot structure");
c010536d:	c7 04 24 10 b6 10 c0 	movl   $0xc010b610,(%esp)
c0105374:	e8 30 21 00 00       	call   c01074a9 <panic>
	}
}
c0105379:	c9                   	leave  
c010537a:	c3                   	ret    
c010537b:	90                   	nop

c010537c <printf>:
#include <ctype.h>
#include <atoi.h>
#include <drivers/video.h>

int printf(const char *fmt, ...)
{
c010537c:	55                   	push   %ebp
c010537d:	89 e5                	mov    %esp,%ebp
c010537f:	81 ec 28 04 00 00    	sub    $0x428,%esp
	int size;
	char buffer[1024];
	memset(buffer, 0, 1024);
c0105385:	c7 44 24 08 00 04 00 	movl   $0x400,0x8(%esp)
c010538c:	00 
c010538d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105394:	00 
c0105395:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c010539b:	89 04 24             	mov    %eax,(%esp)
c010539e:	e8 52 4e 00 00       	call   c010a1f5 <memset>

	va_list args;
	va_start(args, fmt);
c01053a3:	8d 45 0c             	lea    0xc(%ebp),%eax
c01053a6:	89 85 f0 fb ff ff    	mov    %eax,-0x410(%ebp)

	size = vsprintf(buffer, fmt, args);
c01053ac:	8b 85 f0 fb ff ff    	mov    -0x410(%ebp),%eax
c01053b2:	89 44 24 08          	mov    %eax,0x8(%esp)
c01053b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01053b9:	89 44 24 04          	mov    %eax,0x4(%esp)
c01053bd:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c01053c3:	89 04 24             	mov    %eax,(%esp)
c01053c6:	e8 4b 00 00 00       	call   c0105416 <vsprintf>
c01053cb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	fputs(buffer, STDOUT);
c01053ce:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c01053d5:	00 
c01053d6:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c01053dc:	89 04 24             	mov    %eax,(%esp)
c01053df:	e8 b6 d5 ff ff       	call   c010299a <fputs>

	va_end(args);
	return size;
c01053e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01053e7:	c9                   	leave  
c01053e8:	c3                   	ret    

c01053e9 <sprintf>:

int sprintf(char *buf, const char *fmt, ...)
{
c01053e9:	55                   	push   %ebp
c01053ea:	89 e5                	mov    %esp,%ebp
c01053ec:	83 ec 28             	sub    $0x28,%esp
	int size;

	va_list args;
	va_start(args, fmt);
c01053ef:	8d 45 10             	lea    0x10(%ebp),%eax
c01053f2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	size = vsprintf(buf, fmt, args);
c01053f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01053f8:	89 44 24 08          	mov    %eax,0x8(%esp)
c01053fc:	8b 45 0c             	mov    0xc(%ebp),%eax
c01053ff:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105403:	8b 45 08             	mov    0x8(%ebp),%eax
c0105406:	89 04 24             	mov    %eax,(%esp)
c0105409:	e8 08 00 00 00       	call   c0105416 <vsprintf>
c010540e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_end(args);
	return size;
c0105411:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0105414:	c9                   	leave  
c0105415:	c3                   	ret    

c0105416 <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
c0105416:	55                   	push   %ebp
c0105417:	89 e5                	mov    %esp,%ebp
c0105419:	83 ec 58             	sub    $0x58,%esp
	char *str = buf;
c010541c:	8b 45 08             	mov    0x8(%ebp),%eax
c010541f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int precision;
	int qualifier;

	int base;

	for (; *fmt; ++fmt) {
c0105422:	e9 25 04 00 00       	jmp    c010584c <vsprintf+0x436>
		if (*fmt != '%') {
c0105427:	8b 45 0c             	mov    0xc(%ebp),%eax
c010542a:	0f b6 00             	movzbl (%eax),%eax
c010542d:	3c 25                	cmp    $0x25,%al
c010542f:	74 14                	je     c0105445 <vsprintf+0x2f>
			*buf++ = *fmt;
c0105431:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105434:	0f b6 10             	movzbl (%eax),%edx
c0105437:	8b 45 08             	mov    0x8(%ebp),%eax
c010543a:	88 10                	mov    %dl,(%eax)
c010543c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
			continue;
c0105440:	e9 03 04 00 00       	jmp    c0105848 <vsprintf+0x432>
		}

		/* flags */
		flags = 0;
c0105445:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		loop:
		++fmt;
c010544c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		switch (*fmt) {
c0105450:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105453:	0f b6 00             	movzbl (%eax),%eax
c0105456:	0f be c0             	movsbl %al,%eax
c0105459:	83 e8 20             	sub    $0x20,%eax
c010545c:	83 f8 10             	cmp    $0x10,%eax
c010545f:	77 27                	ja     c0105488 <vsprintf+0x72>
c0105461:	8b 04 85 44 b6 10 c0 	mov    -0x3fef49bc(,%eax,4),%eax
c0105468:	ff e0                	jmp    *%eax
		case '0':
			flags |= ZEROPAD;
c010546a:	83 4d e4 01          	orl    $0x1,-0x1c(%ebp)
			goto loop;
c010546e:	eb dc                	jmp    c010544c <vsprintf+0x36>
		case '+':
			flags |= PLUS;
c0105470:	83 4d e4 04          	orl    $0x4,-0x1c(%ebp)
			goto loop;
c0105474:	eb d6                	jmp    c010544c <vsprintf+0x36>
		case ' ':
			flags |= SPACE;
c0105476:	83 4d e4 08          	orl    $0x8,-0x1c(%ebp)
			goto loop;
c010547a:	eb d0                	jmp    c010544c <vsprintf+0x36>
		case '-':
			flags |= LEFT;
c010547c:	83 4d e4 10          	orl    $0x10,-0x1c(%ebp)
			goto loop;
c0105480:	eb ca                	jmp    c010544c <vsprintf+0x36>
		case '#':
			flags |= SPECIAL;
c0105482:	83 4d e4 40          	orl    $0x40,-0x1c(%ebp)
			goto loop;
c0105486:	eb c4                	jmp    c010544c <vsprintf+0x36>
		}

		/* width */
		width = 1;
c0105488:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (isdigit(*fmt)) {
c010548f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105492:	0f b6 00             	movzbl (%eax),%eax
c0105495:	0f be c0             	movsbl %al,%eax
c0105498:	83 e8 30             	sub    $0x30,%eax
c010549b:	83 f8 09             	cmp    $0x9,%eax
c010549e:	77 25                	ja     c01054c5 <vsprintf+0xaf>
			width = atoi(fmt);
c01054a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01054a3:	89 04 24             	mov    %eax,(%esp)
c01054a6:	e8 88 1a 00 00       	call   c0106f33 <atoi>
c01054ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
			while (isdigit(*++fmt));
c01054ae:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c01054b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01054b5:	0f b6 00             	movzbl (%eax),%eax
c01054b8:	0f be c0             	movsbl %al,%eax
c01054bb:	83 e8 30             	sub    $0x30,%eax
c01054be:	83 f8 09             	cmp    $0x9,%eax
c01054c1:	76 eb                	jbe    c01054ae <vsprintf+0x98>
c01054c3:	eb 29                	jmp    c01054ee <vsprintf+0xd8>
		} else if (*fmt == '*') {
c01054c5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01054c8:	0f b6 00             	movzbl (%eax),%eax
c01054cb:	3c 2a                	cmp    $0x2a,%al
c01054cd:	75 1f                	jne    c01054ee <vsprintf+0xd8>
			++fmt;
c01054cf:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
			width = va_arg(args, int);
c01054d3:	8b 45 10             	mov    0x10(%ebp),%eax
c01054d6:	8d 50 04             	lea    0x4(%eax),%edx
c01054d9:	89 55 10             	mov    %edx,0x10(%ebp)
c01054dc:	8b 00                	mov    (%eax),%eax
c01054de:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (width < 0) {
c01054e1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c01054e5:	79 07                	jns    c01054ee <vsprintf+0xd8>
				width = - width;
c01054e7:	f7 5d e0             	negl   -0x20(%ebp)
				flags |= LEFT;
c01054ea:	83 4d e4 10          	orl    $0x10,-0x1c(%ebp)
			}
		}

		/* precision */
		precision = -1;
c01054ee:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
		if (*fmt == '.') {
c01054f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01054f8:	0f b6 00             	movzbl (%eax),%eax
c01054fb:	3c 2e                	cmp    $0x2e,%al
c01054fd:	75 63                	jne    c0105562 <vsprintf+0x14c>
			++fmt;
c01054ff:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
			if (isdigit(*fmt)) {
c0105503:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105506:	0f b6 00             	movzbl (%eax),%eax
c0105509:	0f be c0             	movsbl %al,%eax
c010550c:	83 e8 30             	sub    $0x30,%eax
c010550f:	83 f8 09             	cmp    $0x9,%eax
c0105512:	77 25                	ja     c0105539 <vsprintf+0x123>
				precision = atoi(fmt);
c0105514:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105517:	89 04 24             	mov    %eax,(%esp)
c010551a:	e8 14 1a 00 00       	call   c0106f33 <atoi>
c010551f:	89 45 dc             	mov    %eax,-0x24(%ebp)
				while (isdigit(*++fmt));
c0105522:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0105526:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105529:	0f b6 00             	movzbl (%eax),%eax
c010552c:	0f be c0             	movsbl %al,%eax
c010552f:	83 e8 30             	sub    $0x30,%eax
c0105532:	83 f8 09             	cmp    $0x9,%eax
c0105535:	76 eb                	jbe    c0105522 <vsprintf+0x10c>
c0105537:	eb 1c                	jmp    c0105555 <vsprintf+0x13f>
			} else if (*fmt == '*') {
c0105539:	8b 45 0c             	mov    0xc(%ebp),%eax
c010553c:	0f b6 00             	movzbl (%eax),%eax
c010553f:	3c 2a                	cmp    $0x2a,%al
c0105541:	75 12                	jne    c0105555 <vsprintf+0x13f>
				++fmt;
c0105543:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
				precision = va_arg(args, int);
c0105547:	8b 45 10             	mov    0x10(%ebp),%eax
c010554a:	8d 50 04             	lea    0x4(%eax),%edx
c010554d:	89 55 10             	mov    %edx,0x10(%ebp)
c0105550:	8b 00                	mov    (%eax),%eax
c0105552:	89 45 dc             	mov    %eax,-0x24(%ebp)
			}
			if (precision < 0) {
c0105555:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0105559:	79 07                	jns    c0105562 <vsprintf+0x14c>
				precision = 0;
c010555b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			}
		}

		/* qualifier */
		qualifier = -1;
c0105562:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		if (strchr("hlL", *fmt)) {
c0105569:	8b 45 0c             	mov    0xc(%ebp),%eax
c010556c:	0f b6 00             	movzbl (%eax),%eax
c010556f:	0f be c0             	movsbl %al,%eax
c0105572:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105576:	c7 04 24 40 b6 10 c0 	movl   $0xc010b640,(%esp)
c010557d:	e8 13 49 00 00       	call   c0109e95 <strchr>
c0105582:	85 c0                	test   %eax,%eax
c0105584:	74 10                	je     c0105596 <vsprintf+0x180>
			qualifier = *fmt;
c0105586:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105589:	0f b6 00             	movzbl (%eax),%eax
c010558c:	0f be c0             	movsbl %al,%eax
c010558f:	89 45 d8             	mov    %eax,-0x28(%ebp)
			++fmt;
c0105592:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		}

		/* base */
		base = 10;
c0105596:	c7 45 d4 0a 00 00 00 	movl   $0xa,-0x2c(%ebp)

		/* specifier */
		switch (*fmt) {
c010559d:	8b 45 0c             	mov    0xc(%ebp),%eax
c01055a0:	0f b6 00             	movzbl (%eax),%eax
c01055a3:	0f be c0             	movsbl %al,%eax
c01055a6:	83 e8 25             	sub    $0x25,%eax
c01055a9:	83 f8 53             	cmp    $0x53,%eax
c01055ac:	0f 87 c7 01 00 00    	ja     c0105779 <vsprintf+0x363>
c01055b2:	8b 04 85 88 b6 10 c0 	mov    -0x3fef4978(,%eax,4),%eax
c01055b9:	ff e0                	jmp    *%eax
		case 'c':
			len = 1;
c01055bb:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)

			if (!(flags & LEFT))
c01055c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01055c5:	83 e0 10             	and    $0x10,%eax
c01055c8:	85 c0                	test   %eax,%eax
c01055ca:	75 1d                	jne    c01055e9 <vsprintf+0x1d3>
				while (len < width--)
c01055cc:	eb 0a                	jmp    c01055d8 <vsprintf+0x1c2>
					*buf++ = ' ';
c01055ce:	8b 45 08             	mov    0x8(%ebp),%eax
c01055d1:	c6 00 20             	movb   $0x20,(%eax)
c01055d4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		switch (*fmt) {
		case 'c':
			len = 1;

			if (!(flags & LEFT))
				while (len < width--)
c01055d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01055db:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c01055de:	0f 9f c0             	setg   %al
c01055e1:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c01055e5:	84 c0                	test   %al,%al
c01055e7:	75 e5                	jne    c01055ce <vsprintf+0x1b8>
					*buf++ = ' ';

			*buf++ = (unsigned char)va_arg(args, int);
c01055e9:	8b 45 10             	mov    0x10(%ebp),%eax
c01055ec:	8d 50 04             	lea    0x4(%eax),%edx
c01055ef:	89 55 10             	mov    %edx,0x10(%ebp)
c01055f2:	8b 00                	mov    (%eax),%eax
c01055f4:	89 c2                	mov    %eax,%edx
c01055f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01055f9:	88 10                	mov    %dl,(%eax)
c01055fb:	83 45 08 01          	addl   $0x1,0x8(%ebp)

			while (len < width--)
c01055ff:	eb 0a                	jmp    c010560b <vsprintf+0x1f5>
				*buf++ = ' ';
c0105601:	8b 45 08             	mov    0x8(%ebp),%eax
c0105604:	c6 00 20             	movb   $0x20,(%eax)
c0105607:	83 45 08 01          	addl   $0x1,0x8(%ebp)
				while (len < width--)
					*buf++ = ' ';

			*buf++ = (unsigned char)va_arg(args, int);

			while (len < width--)
c010560b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010560e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0105611:	0f 9f c0             	setg   %al
c0105614:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c0105618:	84 c0                	test   %al,%al
c010561a:	75 e5                	jne    c0105601 <vsprintf+0x1eb>
				*buf++ = ' ';
			continue;
c010561c:	e9 27 02 00 00       	jmp    c0105848 <vsprintf+0x432>

		case 's':
			s = va_arg(args, char *);
c0105621:	8b 45 10             	mov    0x10(%ebp),%eax
c0105624:	8d 50 04             	lea    0x4(%eax),%edx
c0105627:	89 55 10             	mov    %edx,0x10(%ebp)
c010562a:	8b 00                	mov    (%eax),%eax
c010562c:	89 45 f0             	mov    %eax,-0x10(%ebp)
			len = strnlen(s, precision);
c010562f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0105632:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105636:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105639:	89 04 24             	mov    %eax,(%esp)
c010563c:	e8 af 45 00 00       	call   c0109bf0 <strnlen>
c0105641:	89 45 d0             	mov    %eax,-0x30(%ebp)

			if (!(flags & LEFT))
c0105644:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105647:	83 e0 10             	and    $0x10,%eax
c010564a:	85 c0                	test   %eax,%eax
c010564c:	75 1d                	jne    c010566b <vsprintf+0x255>
				while (len < width--)
c010564e:	eb 0a                	jmp    c010565a <vsprintf+0x244>
					*buf++ = ' ';
c0105650:	8b 45 08             	mov    0x8(%ebp),%eax
c0105653:	c6 00 20             	movb   $0x20,(%eax)
c0105656:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		case 's':
			s = va_arg(args, char *);
			len = strnlen(s, precision);

			if (!(flags & LEFT))
				while (len < width--)
c010565a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010565d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0105660:	0f 9f c0             	setg   %al
c0105663:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c0105667:	84 c0                	test   %al,%al
c0105669:	75 e5                	jne    c0105650 <vsprintf+0x23a>
					*buf++ = ' ';

			for (i = 0; i < len; ++i)
c010566b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0105672:	eb 17                	jmp    c010568b <vsprintf+0x275>
				*buf++ = *s++;
c0105674:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105677:	0f b6 10             	movzbl (%eax),%edx
c010567a:	8b 45 08             	mov    0x8(%ebp),%eax
c010567d:	88 10                	mov    %dl,(%eax)
c010567f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0105683:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

			if (!(flags & LEFT))
				while (len < width--)
					*buf++ = ' ';

			for (i = 0; i < len; ++i)
c0105687:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c010568b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010568e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0105691:	7c e1                	jl     c0105674 <vsprintf+0x25e>
				*buf++ = *s++;

			while (len < width--)
c0105693:	eb 0a                	jmp    c010569f <vsprintf+0x289>
				*buf++ = ' ';
c0105695:	8b 45 08             	mov    0x8(%ebp),%eax
c0105698:	c6 00 20             	movb   $0x20,(%eax)
c010569b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
					*buf++ = ' ';

			for (i = 0; i < len; ++i)
				*buf++ = *s++;

			while (len < width--)
c010569f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01056a2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c01056a5:	0f 9f c0             	setg   %al
c01056a8:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c01056ac:	84 c0                	test   %al,%al
c01056ae:	75 e5                	jne    c0105695 <vsprintf+0x27f>
				*buf++ = ' ';
			continue;
c01056b0:	e9 93 01 00 00       	jmp    c0105848 <vsprintf+0x432>

		case 'p':
			if (width == -1) {
c01056b5:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
c01056b9:	75 0b                	jne    c01056c6 <vsprintf+0x2b0>
				width = 2 * sizeof(void *);
c01056bb:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
				flags |= ZEROPAD;
c01056c2:	83 4d e4 01          	orl    $0x1,-0x1c(%ebp)
			}
			flags |= SPECIAL;
c01056c6:	83 4d e4 40          	orl    $0x40,-0x1c(%ebp)
			itoa_ex((unsigned long)va_arg(args, void *), buf, 16, flags, width);
c01056ca:	8b 45 10             	mov    0x10(%ebp),%eax
c01056cd:	8d 50 04             	lea    0x4(%eax),%edx
c01056d0:	89 55 10             	mov    %edx,0x10(%ebp)
c01056d3:	8b 00                	mov    (%eax),%eax
c01056d5:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01056d8:	89 54 24 10          	mov    %edx,0x10(%esp)
c01056dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01056df:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01056e3:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
c01056ea:	00 
c01056eb:	8b 55 08             	mov    0x8(%ebp),%edx
c01056ee:	89 54 24 04          	mov    %edx,0x4(%esp)
c01056f2:	89 04 24             	mov    %eax,(%esp)
c01056f5:	e8 7e 16 00 00       	call   c0106d78 <itoa_ex>
			while (*++buf);
c01056fa:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c01056fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0105701:	0f b6 00             	movzbl (%eax),%eax
c0105704:	84 c0                	test   %al,%al
c0105706:	75 f2                	jne    c01056fa <vsprintf+0x2e4>
			continue;
c0105708:	e9 3b 01 00 00       	jmp    c0105848 <vsprintf+0x432>

		case 'n':
			if (qualifier == 'l') {
c010570d:	83 7d d8 6c          	cmpl   $0x6c,-0x28(%ebp)
c0105711:	75 20                	jne    c0105733 <vsprintf+0x31d>
				long *dest = va_arg(args, long *);
c0105713:	8b 45 10             	mov    0x10(%ebp),%eax
c0105716:	8d 50 04             	lea    0x4(%eax),%edx
c0105719:	89 55 10             	mov    %edx,0x10(%ebp)
c010571c:	8b 00                	mov    (%eax),%eax
c010571e:	89 45 cc             	mov    %eax,-0x34(%ebp)
				*dest = (buf - str);
c0105721:	8b 55 08             	mov    0x8(%ebp),%edx
c0105724:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105727:	29 c2                	sub    %eax,%edx
c0105729:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010572c:	89 10                	mov    %edx,(%eax)
			} else {
				int *dest = va_arg(args, int *);
				*dest = (buf - str);
			}
			continue;
c010572e:	e9 15 01 00 00       	jmp    c0105848 <vsprintf+0x432>
		case 'n':
			if (qualifier == 'l') {
				long *dest = va_arg(args, long *);
				*dest = (buf - str);
			} else {
				int *dest = va_arg(args, int *);
c0105733:	8b 45 10             	mov    0x10(%ebp),%eax
c0105736:	8d 50 04             	lea    0x4(%eax),%edx
c0105739:	89 55 10             	mov    %edx,0x10(%ebp)
c010573c:	8b 00                	mov    (%eax),%eax
c010573e:	89 45 c8             	mov    %eax,-0x38(%ebp)
				*dest = (buf - str);
c0105741:	8b 55 08             	mov    0x8(%ebp),%edx
c0105744:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105747:	29 c2                	sub    %eax,%edx
c0105749:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010574c:	89 10                	mov    %edx,(%eax)
			}
			continue;
c010574e:	e9 f5 00 00 00       	jmp    c0105848 <vsprintf+0x432>

		case '%':
			*buf++ = '%';
c0105753:	8b 45 08             	mov    0x8(%ebp),%eax
c0105756:	c6 00 25             	movb   $0x25,(%eax)
c0105759:	83 45 08 01          	addl   $0x1,0x8(%ebp)

		/* integers */

		case 'o':
			base = 8;
c010575d:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
			break;
c0105764:	eb 45                	jmp    c01057ab <vsprintf+0x395>

		case 'd':
		case 'i':
			flags |= SIGN;
c0105766:	83 4d e4 02          	orl    $0x2,-0x1c(%ebp)
		case 'u':
			break;
c010576a:	eb 3e                	jmp    c01057aa <vsprintf+0x394>

		case 'x':
			flags |= SMALL;
c010576c:	83 4d e4 20          	orl    $0x20,-0x1c(%ebp)
		case 'X':
			base = 16;
c0105770:	c7 45 d4 10 00 00 00 	movl   $0x10,-0x2c(%ebp)
			break;
c0105777:	eb 32                	jmp    c01057ab <vsprintf+0x395>

		default:
			*str++ = '%';
c0105779:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010577c:	c6 00 25             	movb   $0x25,(%eax)
c010577f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
			if (*fmt) {
c0105783:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105786:	0f b6 00             	movzbl (%eax),%eax
c0105789:	84 c0                	test   %al,%al
c010578b:	74 14                	je     c01057a1 <vsprintf+0x38b>
				*str++ = *fmt;
c010578d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105790:	0f b6 10             	movzbl (%eax),%edx
c0105793:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105796:	88 10                	mov    %dl,(%eax)
c0105798:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
			} else {
				--fmt;
			}
			continue;
c010579c:	e9 a7 00 00 00       	jmp    c0105848 <vsprintf+0x432>
		default:
			*str++ = '%';
			if (*fmt) {
				*str++ = *fmt;
			} else {
				--fmt;
c01057a1:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
			}
			continue;
c01057a5:	e9 9e 00 00 00       	jmp    c0105848 <vsprintf+0x432>

		case 'd':
		case 'i':
			flags |= SIGN;
		case 'u':
			break;
c01057aa:	90                   	nop
				--fmt;
			}
			continue;
		}

		if (qualifier == 'l') {
c01057ab:	83 7d d8 6c          	cmpl   $0x6c,-0x28(%ebp)
c01057af:	75 10                	jne    c01057c1 <vsprintf+0x3ab>
			num = va_arg(args, unsigned long);
c01057b1:	8b 45 10             	mov    0x10(%ebp),%eax
c01057b4:	8d 50 04             	lea    0x4(%eax),%edx
c01057b7:	89 55 10             	mov    %edx,0x10(%ebp)
c01057ba:	8b 00                	mov    (%eax),%eax
c01057bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01057bf:	eb 52                	jmp    c0105813 <vsprintf+0x3fd>
		} else if (qualifier == 'h') {
c01057c1:	83 7d d8 68          	cmpl   $0x68,-0x28(%ebp)
c01057c5:	75 24                	jne    c01057eb <vsprintf+0x3d5>
			num = (unsigned short)va_arg(args, int);
c01057c7:	8b 45 10             	mov    0x10(%ebp),%eax
c01057ca:	8d 50 04             	lea    0x4(%eax),%edx
c01057cd:	89 55 10             	mov    %edx,0x10(%ebp)
c01057d0:	8b 00                	mov    (%eax),%eax
c01057d2:	0f b7 c0             	movzwl %ax,%eax
c01057d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (flags & SIGN) {
c01057d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01057db:	83 e0 02             	and    $0x2,%eax
c01057de:	85 c0                	test   %eax,%eax
c01057e0:	74 31                	je     c0105813 <vsprintf+0x3fd>
				num = (short)num;
c01057e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01057e5:	98                   	cwtl   
c01057e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01057e9:	eb 28                	jmp    c0105813 <vsprintf+0x3fd>
			}
		} else if (flags & SIGN) {
c01057eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01057ee:	83 e0 02             	and    $0x2,%eax
c01057f1:	85 c0                	test   %eax,%eax
c01057f3:	74 10                	je     c0105805 <vsprintf+0x3ef>
			num = va_arg(args, int);
c01057f5:	8b 45 10             	mov    0x10(%ebp),%eax
c01057f8:	8d 50 04             	lea    0x4(%eax),%edx
c01057fb:	89 55 10             	mov    %edx,0x10(%ebp)
c01057fe:	8b 00                	mov    (%eax),%eax
c0105800:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0105803:	eb 0e                	jmp    c0105813 <vsprintf+0x3fd>
		} else {
			num = va_arg(args, unsigned int);
c0105805:	8b 45 10             	mov    0x10(%ebp),%eax
c0105808:	8d 50 04             	lea    0x4(%eax),%edx
c010580b:	89 55 10             	mov    %edx,0x10(%ebp)
c010580e:	8b 00                	mov    (%eax),%eax
c0105810:	89 45 e8             	mov    %eax,-0x18(%ebp)
		}

		itoa_ex(num, buf, base, flags, width);
c0105813:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105816:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0105819:	89 54 24 10          	mov    %edx,0x10(%esp)
c010581d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0105820:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0105824:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0105827:	89 54 24 08          	mov    %edx,0x8(%esp)
c010582b:	8b 55 08             	mov    0x8(%ebp),%edx
c010582e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105832:	89 04 24             	mov    %eax,(%esp)
c0105835:	e8 3e 15 00 00       	call   c0106d78 <itoa_ex>
		while (*++buf);
c010583a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c010583e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105841:	0f b6 00             	movzbl (%eax),%eax
c0105844:	84 c0                	test   %al,%al
c0105846:	75 f2                	jne    c010583a <vsprintf+0x424>
	int precision;
	int qualifier;

	int base;

	for (; *fmt; ++fmt) {
c0105848:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c010584c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010584f:	0f b6 00             	movzbl (%eax),%eax
c0105852:	84 c0                	test   %al,%al
c0105854:	0f 85 cd fb ff ff    	jne    c0105427 <vsprintf+0x11>

		itoa_ex(num, buf, base, flags, width);
		while (*++buf);
	}

	*buf = '\0';
c010585a:	8b 45 08             	mov    0x8(%ebp),%eax
c010585d:	c6 00 00             	movb   $0x0,(%eax)

	return buf - str;
c0105860:	8b 55 08             	mov    0x8(%ebp),%edx
c0105863:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105866:	89 d1                	mov    %edx,%ecx
c0105868:	29 c1                	sub    %eax,%ecx
c010586a:	89 c8                	mov    %ecx,%eax
}
c010586c:	c9                   	leave  
c010586d:	c3                   	ret    
c010586e:	66 90                	xchg   %ax,%ax

c0105870 <thread_sync_context>:
#include <pmm.h>

extern list_t *running_threads;
extern struct thread_state* current_thread;

void thread_sync_context(struct thread_state *thread) {
c0105870:	55                   	push   %ebp
c0105871:	89 e5                	mov    %esp,%ebp
c0105873:	83 ec 28             	sub    $0x28,%esp
    struct thread_state *main_thread = thread->process->main_thread;
c0105876:	8b 45 08             	mov    0x8(%ebp),%eax
c0105879:	8b 40 04             	mov    0x4(%eax),%eax
c010587c:	8b 40 24             	mov    0x24(%eax),%eax
c010587f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(thread != main_thread && main_thread != NULL && thread != NULL) {
c0105882:	8b 45 08             	mov    0x8(%ebp),%eax
c0105885:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0105888:	74 3a                	je     c01058c4 <thread_sync_context+0x54>
c010588a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010588e:	74 34                	je     c01058c4 <thread_sync_context+0x54>
c0105890:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0105894:	74 2e                	je     c01058c4 <thread_sync_context+0x54>
        int end = PDE_INDEX(0xB0000000);
c0105896:	c7 45 f0 c0 02 00 00 	movl   $0x2c0,-0x10(%ebp)
        arch_sync_pts(main_thread->context.arch_context, thread->context.arch_context, 0, end);
c010589d:	8b 45 08             	mov    0x8(%ebp),%eax
c01058a0:	8b 50 08             	mov    0x8(%eax),%edx
c01058a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01058a6:	8b 40 08             	mov    0x8(%eax),%eax
c01058a9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c01058ac:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c01058b0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c01058b7:	00 
c01058b8:	89 54 24 04          	mov    %edx,0x4(%esp)
c01058bc:	89 04 24             	mov    %eax,(%esp)
c01058bf:	e8 3b 07 00 00       	call   c0105fff <arch_sync_pts>
    }
}
c01058c4:	c9                   	leave  
c01058c5:	c3                   	ret    

c01058c6 <thread_create>:

struct thread_state *thread_create(struct process_state *process, privilege_t prev, uint32_t eip, struct cpu_state *state, int argc, void **argv, void *return_address)
{
c01058c6:	55                   	push   %ebp
c01058c7:	89 e5                	mov    %esp,%ebp
c01058c9:	83 ec 38             	sub    $0x38,%esp
    struct thread_state *new_thread = malloc(sizeof(struct thread_state));
c01058cc:	c7 04 24 1c 00 00 00 	movl   $0x1c,(%esp)
c01058d3:	e8 ec 2c 00 00       	call   c01085c4 <malloc>
c01058d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	new_thread->flags = THREAD_ACTIV;
c01058db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01058de:	66 c7 40 10 01 00    	movw   $0x1,0x10(%eax)
    new_thread->process = process;
c01058e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01058e7:	8b 55 08             	mov    0x8(%ebp),%edx
c01058ea:	89 50 04             	mov    %edx,0x4(%eax)
    vmm_create_context(&new_thread->context);
c01058ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01058f0:	83 c0 08             	add    $0x8,%eax
c01058f3:	89 04 24             	mov    %eax,(%esp)
c01058f6:	e8 d8 16 00 00       	call   c0106fd3 <vmm_create_context>
    thread_sync_context(new_thread);
c01058fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01058fe:	89 04 24             	mov    %eax,(%esp)
c0105901:	e8 6a ff ff ff       	call   c0105870 <thread_sync_context>
    new_thread->ticks = 10;
c0105906:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105909:	c7 40 0c 0a 00 00 00 	movl   $0xa,0xc(%eax)
    new_thread->return_value = 0;
c0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105913:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

    void *kernel_stack = malloc(0x1000);
c010591a:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
c0105921:	e8 9e 2c 00 00       	call   c01085c4 <malloc>
c0105926:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct cpu_state *new_state = kernel_stack + 0x1000 - sizeof(struct cpu_state);
c0105929:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010592c:	05 b8 0f 00 00       	add    $0xfb8,%eax
c0105931:	89 45 ec             	mov    %eax,-0x14(%ebp)
    new_thread->state = new_state;
c0105934:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105937:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010593a:	89 10                	mov    %edx,(%eax)

    if(process->main_thread == NULL) {
c010593c:	8b 45 08             	mov    0x8(%ebp),%eax
c010593f:	8b 40 24             	mov    0x24(%eax),%eax
c0105942:	85 c0                	test   %eax,%eax
c0105944:	75 09                	jne    c010594f <thread_create+0x89>
        process->main_thread = new_thread;
c0105946:	8b 45 08             	mov    0x8(%ebp),%eax
c0105949:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010594c:	89 50 24             	mov    %edx,0x24(%eax)
    }

    if(state != NULL)
c010594f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0105953:	74 1c                	je     c0105971 <thread_create+0xab>
    {
        memcpy(new_state, state, sizeof(struct cpu_state));
c0105955:	c7 44 24 08 48 00 00 	movl   $0x48,0x8(%esp)
c010595c:	00 
c010595d:	8b 45 14             	mov    0x14(%ebp),%eax
c0105960:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105964:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105967:	89 04 24             	mov    %eax,(%esp)
c010596a:	e8 bd 46 00 00       	call   c010a02c <memcpy>
c010596f:	eb 2e                	jmp    c010599f <thread_create+0xd9>
    }
    else
    {
        memset(new_state, 0, sizeof(struct cpu_state));
c0105971:	c7 44 24 08 48 00 00 	movl   $0x48,0x8(%esp)
c0105978:	00 
c0105979:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105980:	00 
c0105981:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105984:	89 04 24             	mov    %eax,(%esp)
c0105987:	e8 69 48 00 00       	call   c010a1f5 <memset>
        new_state->eip = eip;
c010598c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010598f:	8b 55 10             	mov    0x10(%ebp),%edx
c0105992:	89 50 34             	mov    %edx,0x34(%eax)
        new_state->eflags = 0x202;
c0105995:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105998:	c7 40 3c 02 02 00 00 	movl   $0x202,0x3c(%eax)
    }

    if(prev == KERNELMODE)
c010599f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01059a3:	75 49                	jne    c01059ee <thread_create+0x128>
    {
        new_thread->flags |= THREAD_KERNELMODE;
c01059a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01059a8:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01059ac:	89 c2                	mov    %eax,%edx
c01059ae:	83 ca 04             	or     $0x4,%edx
c01059b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01059b4:	66 89 50 10          	mov    %dx,0x10(%eax)

		new_state->cs = 0x08;
c01059b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01059bb:	c7 40 38 08 00 00 00 	movl   $0x8,0x38(%eax)
		new_state->ds = 0x10;
c01059c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01059c5:	c7 40 0c 10 00 00 00 	movl   $0x10,0xc(%eax)
		new_state->es = 0x10;
c01059cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01059cf:	c7 40 08 10 00 00 00 	movl   $0x10,0x8(%eax)
		new_state->fs = 0x10;
c01059d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01059d9:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
		new_state->gs = 0x10;
c01059e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01059e3:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
c01059e9:	e9 99 00 00 00       	jmp    c0105a87 <thread_create+0x1c1>
    }
    else
    {
        if(!state)
c01059ee:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c01059f2:	75 7f                	jne    c0105a73 <thread_create+0x1ad>
        {
            paddr_t pframe = pmm_alloc_page();
c01059f4:	e8 0f f6 ff ff       	call   c0105008 <pmm_alloc_page>
c01059f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
            vmm_map(&new_thread->context, pframe, MEMORY_LAYOUT_STACK_TOP-0x1000, VMM_PRESENT | VMM_WRITABLE | VMM_USER);
c01059fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01059ff:	8d 50 08             	lea    0x8(%eax),%edx
c0105a02:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c0105a09:	00 
c0105a0a:	c7 44 24 08 00 f0 ff 	movl   $0xbffff000,0x8(%esp)
c0105a11:	bf 
c0105a12:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105a15:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105a19:	89 14 24             	mov    %edx,(%esp)
c0105a1c:	e8 05 16 00 00       	call   c0107026 <vmm_map>
            new_state->esp = (uint32_t) MEMORY_LAYOUT_STACK_TOP - 12;
c0105a21:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105a24:	c7 40 40 f4 ff ff bf 	movl   $0xbffffff4,0x40(%eax)

            uint32_t *stack = (uint32_t *) (vmm_automap_kernel(current_context, pframe, VMM_PRESENT | VMM_WRITABLE | VMM_USER) + 0x1000);
c0105a2b:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0105a30:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
c0105a37:	00 
c0105a38:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0105a3b:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105a3f:	89 04 24             	mov    %eax,(%esp)
c0105a42:	e8 cf 16 00 00       	call   c0107116 <vmm_automap_kernel>
c0105a47:	05 00 10 00 00       	add    $0x1000,%eax
c0105a4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            *--stack = (uint32_t) argv;
c0105a4f:	83 6d e4 04          	subl   $0x4,-0x1c(%ebp)
c0105a53:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0105a56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105a59:	89 10                	mov    %edx,(%eax)
            *--stack = argc;
c0105a5b:	83 6d e4 04          	subl   $0x4,-0x1c(%ebp)
c0105a5f:	8b 55 18             	mov    0x18(%ebp),%edx
c0105a62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105a65:	89 10                	mov    %edx,(%eax)
            *--stack = (uint32_t) return_address;
c0105a67:	83 6d e4 04          	subl   $0x4,-0x1c(%ebp)
c0105a6b:	8b 55 20             	mov    0x20(%ebp),%edx
c0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105a71:	89 10                	mov    %edx,(%eax)
	}

		new_state->cs = 0x1b;
c0105a73:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105a76:	c7 40 38 1b 00 00 00 	movl   $0x1b,0x38(%eax)
		new_state->ss = 0x23;
c0105a7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105a80:	c7 40 44 23 00 00 00 	movl   $0x23,0x44(%eax)
    }

    if(list_is_empty(process->zombie_tids))
c0105a87:	8b 45 08             	mov    0x8(%ebp),%eax
c0105a8a:	8b 40 28             	mov    0x28(%eax),%eax
c0105a8d:	89 04 24             	mov    %eax,(%esp)
c0105a90:	e8 7c 35 00 00       	call   c0109011 <list_is_empty>
c0105a95:	85 c0                	test   %eax,%eax
c0105a97:	74 17                	je     c0105ab0 <thread_create+0x1ea>
        new_thread->tid = process->tid_counter++;
c0105a99:	8b 45 08             	mov    0x8(%ebp),%eax
c0105a9c:	8b 40 20             	mov    0x20(%eax),%eax
c0105a9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105aa2:	89 42 18             	mov    %eax,0x18(%edx)
c0105aa5:	8d 50 01             	lea    0x1(%eax),%edx
c0105aa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0105aab:	89 50 20             	mov    %edx,0x20(%eax)
c0105aae:	eb 16                	jmp    c0105ac6 <thread_create+0x200>
    else
        new_thread->tid = (tid_t) list_pop_back(process->zombie_tids);
c0105ab0:	8b 45 08             	mov    0x8(%ebp),%eax
c0105ab3:	8b 40 28             	mov    0x28(%eax),%eax
c0105ab6:	89 04 24             	mov    %eax,(%esp)
c0105ab9:	e8 3b 33 00 00       	call   c0108df9 <list_pop_back>
c0105abe:	89 c2                	mov    %eax,%edx
c0105ac0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105ac3:	89 50 18             	mov    %edx,0x18(%eax)


    list_push_front(process->threads,new_thread);
c0105ac6:	8b 45 08             	mov    0x8(%ebp),%eax
c0105ac9:	8b 40 1c             	mov    0x1c(%eax),%eax
c0105acc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105acf:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105ad3:	89 04 24             	mov    %eax,(%esp)
c0105ad6:	e8 cf 32 00 00       	call   c0108daa <list_push_front>
    list_push_front(running_threads, new_thread);
c0105adb:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c0105ae0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105ae3:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105ae7:	89 04 24             	mov    %eax,(%esp)
c0105aea:	e8 bb 32 00 00       	call   c0108daa <list_push_front>
    return new_thread;
c0105aef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0105af2:	c9                   	leave  
c0105af3:	c3                   	ret    

c0105af4 <thread_kill>:

void thread_kill(struct thread_state *thread)
{
c0105af4:	55                   	push   %ebp
c0105af5:	89 e5                	mov    %esp,%ebp
c0105af7:	83 ec 18             	sub    $0x18,%esp
    asm volatile("cli");
c0105afa:	fa                   	cli    
    if(current_thread == thread)
c0105afb:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0105b00:	3b 45 08             	cmp    0x8(%ebp),%eax
c0105b03:	75 15                	jne    c0105b1a <thread_kill+0x26>
        thread->flags |= THREAD_ZOMBIE;
c0105b05:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b08:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c0105b0c:	89 c2                	mov    %eax,%edx
c0105b0e:	83 ca 08             	or     $0x8,%edx
c0105b11:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b14:	66 89 50 10          	mov    %dx,0x10(%eax)
c0105b18:	eb 0b                	jmp    c0105b25 <thread_kill+0x31>
    else
    {
        thread_kill_sub(thread);
c0105b1a:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b1d:	89 04 24             	mov    %eax,(%esp)
c0105b20:	e8 03 00 00 00       	call   c0105b28 <thread_kill_sub>
    }
    asm volatile("sti");
c0105b25:	fb                   	sti    
}
c0105b26:	c9                   	leave  
c0105b27:	c3                   	ret    

c0105b28 <thread_kill_sub>:

void thread_kill_sub(struct thread_state *thread)
{
c0105b28:	55                   	push   %ebp
c0105b29:	89 e5                	mov    %esp,%ebp
c0105b2b:	83 ec 28             	sub    $0x28,%esp
    if(thread->flags & THREAD_ACTIV || thread->flags & THREAD_ZOMBIE)
c0105b2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b31:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c0105b35:	0f b7 c0             	movzwl %ax,%eax
c0105b38:	83 e0 01             	and    $0x1,%eax
c0105b3b:	85 c0                	test   %eax,%eax
c0105b3d:	75 11                	jne    c0105b50 <thread_kill_sub+0x28>
c0105b3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b42:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c0105b46:	0f b7 c0             	movzwl %ax,%eax
c0105b49:	83 e0 08             	and    $0x8,%eax
c0105b4c:	85 c0                	test   %eax,%eax
c0105b4e:	74 47                	je     c0105b97 <thread_kill_sub+0x6f>
    {
        list_set_first(running_threads);
c0105b50:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c0105b55:	89 04 24             	mov    %eax,(%esp)
c0105b58:	e8 89 34 00 00       	call   c0108fe6 <list_set_first>
        while(!list_is_last(running_threads))
c0105b5d:	eb 27                	jmp    c0105b86 <thread_kill_sub+0x5e>
        {
            struct thread_state *t = list_get_current(running_threads);
c0105b5f:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c0105b64:	89 04 24             	mov    %eax,(%esp)
c0105b67:	e8 27 34 00 00       	call   c0108f93 <list_get_current>
c0105b6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(t == thread)
c0105b6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105b72:	3b 45 08             	cmp    0x8(%ebp),%eax
c0105b75:	75 0f                	jne    c0105b86 <thread_kill_sub+0x5e>
            {
                list_remove(running_threads);
c0105b77:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c0105b7c:	89 04 24             	mov    %eax,(%esp)
c0105b7f:	e8 8d 33 00 00       	call   c0108f11 <list_remove>
                break;
c0105b84:	eb 11                	jmp    c0105b97 <thread_kill_sub+0x6f>
void thread_kill_sub(struct thread_state *thread)
{
    if(thread->flags & THREAD_ACTIV || thread->flags & THREAD_ZOMBIE)
    {
        list_set_first(running_threads);
        while(!list_is_last(running_threads))
c0105b86:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c0105b8b:	89 04 24             	mov    %eax,(%esp)
c0105b8e:	e8 3b 34 00 00       	call   c0108fce <list_is_last>
c0105b93:	85 c0                	test   %eax,%eax
c0105b95:	74 c8                	je     c0105b5f <thread_kill_sub+0x37>
                list_remove(running_threads);
                break;
            }
        }
    }
    free(thread->state);
c0105b97:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b9a:	8b 00                	mov    (%eax),%eax
c0105b9c:	89 04 24             	mov    %eax,(%esp)
c0105b9f:	e8 3b 2a 00 00       	call   c01085df <free>
    if(! (thread->process->flags & PROCESS_ZOMBIE))
c0105ba4:	8b 45 08             	mov    0x8(%ebp),%eax
c0105ba7:	8b 40 04             	mov    0x4(%eax),%eax
c0105baa:	0f b7 40 30          	movzwl 0x30(%eax),%eax
c0105bae:	0f b7 c0             	movzwl %ax,%eax
c0105bb1:	83 e0 04             	and    $0x4,%eax
c0105bb4:	85 c0                	test   %eax,%eax
c0105bb6:	0f 85 9a 00 00 00    	jne    c0105c56 <thread_kill_sub+0x12e>
    {
        list_push_front(thread->process->zombie_tids,(void *) thread->tid);
c0105bbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0105bbf:	8b 40 18             	mov    0x18(%eax),%eax
c0105bc2:	89 c2                	mov    %eax,%edx
c0105bc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0105bc7:	8b 40 04             	mov    0x4(%eax),%eax
c0105bca:	8b 40 28             	mov    0x28(%eax),%eax
c0105bcd:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105bd1:	89 04 24             	mov    %eax,(%esp)
c0105bd4:	e8 d1 31 00 00       	call   c0108daa <list_push_front>
        list_set_first(thread->process->threads);
c0105bd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0105bdc:	8b 40 04             	mov    0x4(%eax),%eax
c0105bdf:	8b 40 1c             	mov    0x1c(%eax),%eax
c0105be2:	89 04 24             	mov    %eax,(%esp)
c0105be5:	e8 fc 33 00 00       	call   c0108fe6 <list_set_first>
        while(!list_is_last(thread->process->threads))
c0105bea:	eb 52                	jmp    c0105c3e <thread_kill_sub+0x116>
        {
            struct thread_state *t = list_get_current(thread->process->threads);
c0105bec:	8b 45 08             	mov    0x8(%ebp),%eax
c0105bef:	8b 40 04             	mov    0x4(%eax),%eax
c0105bf2:	8b 40 1c             	mov    0x1c(%eax),%eax
c0105bf5:	89 04 24             	mov    %eax,(%esp)
c0105bf8:	e8 96 33 00 00       	call   c0108f93 <list_get_current>
c0105bfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if(t == thread)
c0105c00:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105c03:	3b 45 08             	cmp    0x8(%ebp),%eax
c0105c06:	75 36                	jne    c0105c3e <thread_kill_sub+0x116>
            {
                list_remove(thread->process->threads);
c0105c08:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c0b:	8b 40 04             	mov    0x4(%eax),%eax
c0105c0e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0105c11:	89 04 24             	mov    %eax,(%esp)
c0105c14:	e8 f8 32 00 00       	call   c0108f11 <list_remove>
                if(list_is_empty(thread->process->threads))
c0105c19:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c1c:	8b 40 04             	mov    0x4(%eax),%eax
c0105c1f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0105c22:	89 04 24             	mov    %eax,(%esp)
c0105c25:	e8 e7 33 00 00       	call   c0109011 <list_is_empty>
c0105c2a:	85 c0                	test   %eax,%eax
c0105c2c:	74 27                	je     c0105c55 <thread_kill_sub+0x12d>
                    process_kill(thread->process);
c0105c2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c31:	8b 40 04             	mov    0x4(%eax),%eax
c0105c34:	89 04 24             	mov    %eax,(%esp)
c0105c37:	e8 9c 24 00 00       	call   c01080d8 <process_kill>
                break;
c0105c3c:	eb 17                	jmp    c0105c55 <thread_kill_sub+0x12d>
    free(thread->state);
    if(! (thread->process->flags & PROCESS_ZOMBIE))
    {
        list_push_front(thread->process->zombie_tids,(void *) thread->tid);
        list_set_first(thread->process->threads);
        while(!list_is_last(thread->process->threads))
c0105c3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c41:	8b 40 04             	mov    0x4(%eax),%eax
c0105c44:	8b 40 1c             	mov    0x1c(%eax),%eax
c0105c47:	89 04 24             	mov    %eax,(%esp)
c0105c4a:	e8 7f 33 00 00       	call   c0108fce <list_is_last>
c0105c4f:	85 c0                	test   %eax,%eax
c0105c51:	74 99                	je     c0105bec <thread_kill_sub+0xc4>
c0105c53:	eb 01                	jmp    c0105c56 <thread_kill_sub+0x12e>
            if(t == thread)
            {
                list_remove(thread->process->threads);
                if(list_is_empty(thread->process->threads))
                    process_kill(thread->process);
                break;
c0105c55:	90                   	nop
            }
        }
    }
    free(thread);
c0105c56:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c59:	89 04 24             	mov    %eax,(%esp)
c0105c5c:	e8 7e 29 00 00       	call   c01085df <free>
}
c0105c61:	c9                   	leave  
c0105c62:	c3                   	ret    

c0105c63 <thread_exit>:

void thread_exit(struct cpu_state **cpu)
{
c0105c63:	55                   	push   %ebp
c0105c64:	89 e5                	mov    %esp,%ebp
c0105c66:	83 ec 18             	sub    $0x18,%esp
    current_thread->flags |= THREAD_ZOMBIE;
c0105c69:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0105c6e:	8b 15 08 30 11 c0    	mov    0xc0113008,%edx
c0105c74:	0f b7 52 10          	movzwl 0x10(%edx),%edx
c0105c78:	83 ca 08             	or     $0x8,%edx
c0105c7b:	66 89 50 10          	mov    %dx,0x10(%eax)
    *cpu = task_schedule(*cpu);
c0105c7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c82:	8b 00                	mov    (%eax),%eax
c0105c84:	89 04 24             	mov    %eax,(%esp)
c0105c87:	e8 66 c4 ff ff       	call   c01020f2 <task_schedule>
c0105c8c:	8b 55 08             	mov    0x8(%ebp),%edx
c0105c8f:	89 02                	mov    %eax,(%edx)
}
c0105c91:	c9                   	leave  
c0105c92:	c3                   	ret    

c0105c93 <launch_thread>:

void launch_thread(struct cpu_state **cpu)
{
c0105c93:	55                   	push   %ebp
c0105c94:	89 e5                	mov    %esp,%ebp
c0105c96:	56                   	push   %esi
c0105c97:	53                   	push   %ebx
c0105c98:	83 ec 20             	sub    $0x20,%esp
    thread_create(current_thread->process, USERMODE, (*cpu)->ebx, NULL, (*cpu)->ecx, (void**)(*cpu)->edx, (void*)(*cpu)->esi);
c0105c9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c9e:	8b 00                	mov    (%eax),%eax
c0105ca0:	8b 40 14             	mov    0x14(%eax),%eax
c0105ca3:	89 c6                	mov    %eax,%esi
c0105ca5:	8b 45 08             	mov    0x8(%ebp),%eax
c0105ca8:	8b 00                	mov    (%eax),%eax
c0105caa:	8b 40 20             	mov    0x20(%eax),%eax
c0105cad:	89 c3                	mov    %eax,%ebx
c0105caf:	8b 45 08             	mov    0x8(%ebp),%eax
c0105cb2:	8b 00                	mov    (%eax),%eax
c0105cb4:	8b 40 24             	mov    0x24(%eax),%eax
c0105cb7:	89 c1                	mov    %eax,%ecx
c0105cb9:	8b 45 08             	mov    0x8(%ebp),%eax
c0105cbc:	8b 00                	mov    (%eax),%eax
c0105cbe:	8b 50 1c             	mov    0x1c(%eax),%edx
c0105cc1:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0105cc6:	8b 40 04             	mov    0x4(%eax),%eax
c0105cc9:	89 74 24 18          	mov    %esi,0x18(%esp)
c0105ccd:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c0105cd1:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0105cd5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0105cdc:	00 
c0105cdd:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105ce1:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c0105ce8:	00 
c0105ce9:	89 04 24             	mov    %eax,(%esp)
c0105cec:	e8 d5 fb ff ff       	call   c01058c6 <thread_create>
}
c0105cf1:	83 c4 20             	add    $0x20,%esp
c0105cf4:	5b                   	pop    %ebx
c0105cf5:	5e                   	pop    %esi
c0105cf6:	5d                   	pop    %ebp
c0105cf7:	c3                   	ret    

c0105cf8 <ARCH_INIT_PAGING>:
 * Initalize paging (kernel_pd)
 *
 * @param void
 * @return void
 */
void ARCH_INIT_PAGING(struct multiboot_struct *mb_info) {
c0105cf8:	55                   	push   %ebp
c0105cf9:	89 e5                	mov    %esp,%ebp
c0105cfb:	83 ec 48             	sub    $0x48,%esp
	vmm_context_t context;
	arch_vmm_context_t arch_context;

	context.arch_context = (arch_vmm_context_t *) &arch_context;
c0105cfe:	8d 45 d8             	lea    -0x28(%ebp),%eax
c0105d01:	89 45 e0             	mov    %eax,-0x20(%ebp)

	paddr_t pframe = pmm_alloc_page_limit(0);
c0105d04:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0105d0b:	e8 35 f3 ff ff       	call   c0105045 <pmm_alloc_page_limit>
c0105d10:	89 45 ec             	mov    %eax,-0x14(%ebp)
	vaddr_t vframe = MEMORY_LAYOUT_PAGING_STRUCTURES_START;
c0105d13:	c7 45 e8 00 00 80 ff 	movl   $0xff800000,-0x18(%ebp)

	arch_context.phys_addr = pframe;
c0105d1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105d1d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	arch_context.entries = (pde_t *) pframe + MEMORY_LAYOUT_KERNEL_START;;
c0105d20:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105d23:	89 45 d8             	mov    %eax,-0x28(%ebp)
	arch_context.entries[PDE_INDEX(vframe)] = pframe | VMM_WRITABLE | VMM_PRESENT;
c0105d26:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0105d29:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0105d2c:	c1 ea 16             	shr    $0x16,%edx
c0105d2f:	c1 e2 02             	shl    $0x2,%edx
c0105d32:	01 d0                	add    %edx,%eax
c0105d34:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0105d37:	83 ca 03             	or     $0x3,%edx
c0105d3a:	89 10                	mov    %edx,(%eax)

	vmm_map_range(&context, 0, MEMORY_LAYOUT_KERNEL_START, NUM_PAGES(MEMORY_LAYOUT_DIRECT_MAPPED), VMM_WRITABLE);// kernel
c0105d3c:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
c0105d43:	00 
c0105d44:	c7 44 24 0c 00 20 00 	movl   $0x2000,0xc(%esp)
c0105d4b:	00 
c0105d4c:	c7 44 24 08 00 00 00 	movl   $0xc0000000,0x8(%esp)
c0105d53:	c0 
c0105d54:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105d5b:	00 
c0105d5c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0105d5f:	89 04 24             	mov    %eax,(%esp)
c0105d62:	e8 0c 13 00 00       	call   c0107073 <vmm_map_range>
	vmm_map(&context, 0xB8000, 0xC00B8000, VMM_WRITABLE | VMM_USER);// videomemory (0xB8000 - 0xBFFFF)
c0105d67:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c0105d6e:	00 
c0105d6f:	c7 44 24 08 00 80 0b 	movl   $0xc00b8000,0x8(%esp)
c0105d76:	c0 
c0105d77:	c7 44 24 04 00 80 0b 	movl   $0xb8000,0x4(%esp)
c0105d7e:	00 
c0105d7f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0105d82:	89 04 24             	mov    %eax,(%esp)
c0105d85:	e8 9c 12 00 00       	call   c0107026 <vmm_map>
	// multiboot
	vmm_map(&context, ((vaddr_t)mb_info & (~0xfff)) - MEMORY_LAYOUT_KERNEL_START, ((paddr_t)mb_info&(~0xfff)), VMM_WRITABLE);
c0105d8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0105d8d:	89 c2                	mov    %eax,%edx
c0105d8f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0105d95:	8b 45 08             	mov    0x8(%ebp),%eax
c0105d98:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0105d9d:	05 00 00 00 40       	add    $0x40000000,%eax
c0105da2:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c0105da9:	00 
c0105daa:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105dae:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105db2:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0105db5:	89 04 24             	mov    %eax,(%esp)
c0105db8:	e8 69 12 00 00       	call   c0107026 <vmm_map>
	vmm_map(&context, (mb_info->mods_addr & (~0xfff)) - MEMORY_LAYOUT_KERNEL_START, mb_info->mods_addr & (~0xfff), VMM_WRITABLE);
c0105dbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0105dc0:	8b 40 18             	mov    0x18(%eax),%eax
c0105dc3:	89 c2                	mov    %eax,%edx
c0105dc5:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0105dcb:	8b 45 08             	mov    0x8(%ebp),%eax
c0105dce:	8b 40 18             	mov    0x18(%eax),%eax
c0105dd1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0105dd6:	05 00 00 00 40       	add    $0x40000000,%eax
c0105ddb:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c0105de2:	00 
c0105de3:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105de7:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105deb:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0105dee:	89 04 24             	mov    %eax,(%esp)
c0105df1:	e8 30 12 00 00       	call   c0107026 <vmm_map>

	int i;
	uintptr_t addr;
	struct mods_add *modules = (void*) mb_info->mods_addr;
c0105df6:	8b 45 08             	mov    0x8(%ebp),%eax
c0105df9:	8b 40 18             	mov    0x18(%eax),%eax
c0105dfc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(i = 0; i < mb_info->mods_count; i++) {
c0105dff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0105e06:	eb 5a                	jmp    c0105e62 <ARCH_INIT_PAGING+0x16a>
		addr = modules[i].mod_start & (~0xfff);
c0105e08:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105e0b:	89 c2                	mov    %eax,%edx
c0105e0d:	c1 e2 04             	shl    $0x4,%edx
c0105e10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105e13:	01 d0                	add    %edx,%eax
c0105e15:	8b 00                	mov    (%eax),%eax
c0105e17:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0105e1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while(addr < modules[i].mod_end) {
c0105e1f:	eb 28                	jmp    c0105e49 <ARCH_INIT_PAGING+0x151>
			vmm_map(&context, addr, addr, VMM_PRESENT | VMM_WRITABLE);
c0105e21:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c0105e28:	00 
c0105e29:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105e2c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0105e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105e33:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105e37:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0105e3a:	89 04 24             	mov    %eax,(%esp)
c0105e3d:	e8 e4 11 00 00       	call   c0107026 <vmm_map>
			addr += PAGE_SIZE;
c0105e42:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	int i;
	uintptr_t addr;
	struct mods_add *modules = (void*) mb_info->mods_addr;
	for(i = 0; i < mb_info->mods_count; i++) {
		addr = modules[i].mod_start & (~0xfff);
		while(addr < modules[i].mod_end) {
c0105e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105e4c:	89 c2                	mov    %eax,%edx
c0105e4e:	c1 e2 04             	shl    $0x4,%edx
c0105e51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105e54:	01 d0                	add    %edx,%eax
c0105e56:	8b 40 04             	mov    0x4(%eax),%eax
c0105e59:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0105e5c:	77 c3                	ja     c0105e21 <ARCH_INIT_PAGING+0x129>
	vmm_map(&context, (mb_info->mods_addr & (~0xfff)) - MEMORY_LAYOUT_KERNEL_START, mb_info->mods_addr & (~0xfff), VMM_WRITABLE);

	int i;
	uintptr_t addr;
	struct mods_add *modules = (void*) mb_info->mods_addr;
	for(i = 0; i < mb_info->mods_count; i++) {
c0105e5e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0105e62:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105e65:	8b 45 08             	mov    0x8(%ebp),%eax
c0105e68:	8b 40 14             	mov    0x14(%eax),%eax
c0105e6b:	39 c2                	cmp    %eax,%edx
c0105e6d:	72 99                	jb     c0105e08 <ARCH_INIT_PAGING+0x110>
			vmm_map(&context, addr, addr, VMM_PRESENT | VMM_WRITABLE);
			addr += PAGE_SIZE;
		}
	}

	pd_dump(&arch_context);
c0105e6f:	8d 45 d8             	lea    -0x28(%ebp),%eax
c0105e72:	89 04 24             	mov    %eax,(%esp)
c0105e75:	e8 e2 c3 ff ff       	call   c010225c <pd_dump>
		while(1);
c0105e7a:	eb fe                	jmp    c0105e7a <ARCH_INIT_PAGING+0x182>

c0105e7c <arch_vmm_create_context>:
 * Create new pagedirectory
 *
 * @param void
 * @return new pagedirectory
 */
arch_vmm_context_t *arch_vmm_create_context(void) {
c0105e7c:	55                   	push   %ebp
c0105e7d:	89 e5                	mov    %esp,%ebp
c0105e7f:	83 ec 28             	sub    $0x28,%esp
	uintptr_t paddr = (uintptr_t) pmm_alloc_page();
c0105e82:	e8 81 f1 ff ff       	call   c0105008 <pmm_alloc_page>
c0105e87:	89 45 f4             	mov    %eax,-0xc(%ebp)
	arch_vmm_context_t *context = (arch_vmm_context_t *) vmm_automap_kernel(current_context, paddr, VMM_PRESENT | VMM_WRITABLE);
c0105e8a:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0105e8f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c0105e96:	00 
c0105e97:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105e9a:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105e9e:	89 04 24             	mov    %eax,(%esp)
c0105ea1:	e8 70 12 00 00       	call   c0107116 <vmm_automap_kernel>
c0105ea6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memset(context, 0, PAGE_SIZE);
c0105ea9:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c0105eb0:	00 
c0105eb1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105eb8:	00 
c0105eb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105ebc:	89 04 24             	mov    %eax,(%esp)
c0105ebf:	e8 31 43 00 00       	call   c010a1f5 <memset>

	uintptr_t entries_paddr = (uintptr_t) pmm_alloc_page();
c0105ec4:	e8 3f f1 ff ff       	call   c0105008 <pmm_alloc_page>
c0105ec9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uintptr_t entries = vmm_automap_kernel(current_context, entries_paddr, VMM_PRESENT | VMM_WRITABLE);
c0105ecc:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0105ed1:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c0105ed8:	00 
c0105ed9:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0105edc:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105ee0:	89 04 24             	mov    %eax,(%esp)
c0105ee3:	e8 2e 12 00 00       	call   c0107116 <vmm_automap_kernel>
c0105ee8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	memset((void*)entries, 0, PAGE_SIZE);
c0105eeb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105eee:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c0105ef5:	00 
c0105ef6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105efd:	00 
c0105efe:	89 04 24             	mov    %eax,(%esp)
c0105f01:	e8 ef 42 00 00       	call   c010a1f5 <memset>

	context->entries = (pde_t*) entries;
c0105f06:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0105f09:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f0c:	89 10                	mov    %edx,(%eax)
	context->phys_addr = entries_paddr;
c0105f0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f11:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0105f14:	89 50 04             	mov    %edx,0x4(%eax)

	arch_update_context(context);
c0105f17:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f1a:	89 04 24             	mov    %eax,(%esp)
c0105f1d:	e8 70 00 00 00       	call   c0105f92 <arch_update_context>
	context->entries[PDE_INDEX(MEMORY_LAYOUT_PAGING_STRUCTURES_START)] = (uint32_t) entries_paddr | VMM_PRESENT | VMM_WRITABLE;
c0105f22:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f25:	8b 00                	mov    (%eax),%eax
c0105f27:	05 f8 0f 00 00       	add    $0xff8,%eax
c0105f2c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0105f2f:	83 ca 03             	or     $0x3,%edx
c0105f32:	89 10                	mov    %edx,(%eax)

	return context;
c0105f34:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0105f37:	c9                   	leave  
c0105f38:	c3                   	ret    

c0105f39 <arch_vmm_destroy_context>:
 *

 * @param pd pagedirectory to destroy
 * @return void
 */
void arch_vmm_destroy_context(arch_vmm_context_t *context) {
c0105f39:	55                   	push   %ebp
c0105f3a:	89 e5                	mov    %esp,%ebp
c0105f3c:	83 ec 28             	sub    $0x28,%esp
	int pt;
	for (pt = 0; pt < PD_LENGTH; ++pt) {
c0105f3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0105f46:	eb 31                	jmp    c0105f79 <arch_vmm_destroy_context+0x40>
		if (context->entries[pt] & VMM_PRESENT) {
c0105f48:	8b 45 08             	mov    0x8(%ebp),%eax
c0105f4b:	8b 00                	mov    (%eax),%eax
c0105f4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105f50:	c1 e2 02             	shl    $0x2,%edx
c0105f53:	01 d0                	add    %edx,%eax
c0105f55:	8b 00                	mov    (%eax),%eax
c0105f57:	83 e0 01             	and    $0x1,%eax
c0105f5a:	85 c0                	test   %eax,%eax
c0105f5c:	74 17                	je     c0105f75 <arch_vmm_destroy_context+0x3c>
			pmm_mark_page_as_free((paddr_t)context->entries[pt]);
c0105f5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105f61:	8b 00                	mov    (%eax),%eax
c0105f63:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105f66:	c1 e2 02             	shl    $0x2,%edx
c0105f69:	01 d0                	add    %edx,%eax
c0105f6b:	8b 00                	mov    (%eax),%eax
c0105f6d:	89 04 24             	mov    %eax,(%esp)
c0105f70:	e8 5d ed ff ff       	call   c0104cd2 <pmm_mark_page_as_free>
 * @param pd pagedirectory to destroy
 * @return void
 */
void arch_vmm_destroy_context(arch_vmm_context_t *context) {
	int pt;
	for (pt = 0; pt < PD_LENGTH; ++pt) {
c0105f75:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0105f79:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0105f80:	7e c6                	jle    c0105f48 <arch_vmm_destroy_context+0xf>
		if (context->entries[pt] & VMM_PRESENT) {
			pmm_mark_page_as_free((paddr_t)context->entries[pt]);
		}
	}
	pmm_mark_page_as_free((paddr_t)context->phys_addr);
c0105f82:	8b 45 08             	mov    0x8(%ebp),%eax
c0105f85:	8b 40 04             	mov    0x4(%eax),%eax
c0105f88:	89 04 24             	mov    %eax,(%esp)
c0105f8b:	e8 42 ed ff ff       	call   c0104cd2 <pmm_mark_page_as_free>
}
c0105f90:	c9                   	leave  
c0105f91:	c3                   	ret    

c0105f92 <arch_update_context>:
 * Update the kernelspace area of a pagedir
 *
 * @param pagedir
 * @return void
 */
void arch_update_context(arch_vmm_context_t *context) {
c0105f92:	55                   	push   %ebp
c0105f93:	89 e5                	mov    %esp,%ebp
c0105f95:	83 ec 28             	sub    $0x28,%esp
	if(context != current_context) {
c0105f98:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0105f9d:	39 45 08             	cmp    %eax,0x8(%ebp)
c0105fa0:	74 5b                	je     c0105ffd <arch_update_context+0x6b>
		#define START PDE_INDEX(MEMORY_LAYOUT_KERNEL_START)
		#define END   PDE_INDEX(MEMORY_LAYOUT_KERNEL_END)
		uintptr_t upd = (uintptr_t) (context->entries + START);
c0105fa2:	8b 45 08             	mov    0x8(%ebp),%eax
c0105fa5:	8b 00                	mov    (%eax),%eax
c0105fa7:	05 00 0c 00 00       	add    $0xc00,%eax
c0105fac:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uintptr_t kpd = (uintptr_t) (current_context->arch_context->entries + START);
c0105faf:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0105fb4:	8b 00                	mov    (%eax),%eax
c0105fb6:	8b 00                	mov    (%eax),%eax
c0105fb8:	05 00 0c 00 00       	add    $0xc00,%eax
c0105fbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		size_t len = END - START;
c0105fc0:	c7 45 ec ff 00 00 00 	movl   $0xff,-0x14(%ebp)
		memcpy((void*) upd, (void*) kpd, len * sizeof(pde_t));
c0105fc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105fca:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0105fd1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0105fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105fd7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0105fdb:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105fdf:	89 04 24             	mov    %eax,(%esp)
c0105fe2:	e8 45 40 00 00       	call   c010a02c <memcpy>
		context->entries[PDE_INDEX(MEMORY_LAYOUT_PAGING_STRUCTURES_START)] = (uint32_t) context->phys_addr | VMM_PRESENT | VMM_WRITABLE;
c0105fe7:	8b 45 08             	mov    0x8(%ebp),%eax
c0105fea:	8b 00                	mov    (%eax),%eax
c0105fec:	8d 90 f8 0f 00 00    	lea    0xff8(%eax),%edx
c0105ff2:	8b 45 08             	mov    0x8(%ebp),%eax
c0105ff5:	8b 40 04             	mov    0x4(%eax),%eax
c0105ff8:	83 c8 03             	or     $0x3,%eax
c0105ffb:	89 02                	mov    %eax,(%edx)
	}
}
c0105ffd:	c9                   	leave  
c0105ffe:	c3                   	ret    

c0105fff <arch_sync_pts>:

void arch_sync_pts(arch_vmm_context_t *src, arch_vmm_context_t *dest, int index_low, int index_high) {
c0105fff:	55                   	push   %ebp
c0106000:	89 e5                	mov    %esp,%ebp
c0106002:	83 ec 10             	sub    $0x10,%esp
	int i;
        for(i = index_low; i < index_high; i++) {
c0106005:	8b 45 10             	mov    0x10(%ebp),%eax
c0106008:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010600b:	eb 22                	jmp    c010602f <arch_sync_pts+0x30>
            dest->entries[i] = src->entries[i];
c010600d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106010:	8b 00                	mov    (%eax),%eax
c0106012:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106015:	c1 e2 02             	shl    $0x2,%edx
c0106018:	01 c2                	add    %eax,%edx
c010601a:	8b 45 08             	mov    0x8(%ebp),%eax
c010601d:	8b 00                	mov    (%eax),%eax
c010601f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0106022:	c1 e1 02             	shl    $0x2,%ecx
c0106025:	01 c8                	add    %ecx,%eax
c0106027:	8b 00                	mov    (%eax),%eax
c0106029:	89 02                	mov    %eax,(%edx)
	}
}

void arch_sync_pts(arch_vmm_context_t *src, arch_vmm_context_t *dest, int index_low, int index_high) {
	int i;
        for(i = index_low; i < index_high; i++) {
c010602b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010602f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106032:	3b 45 14             	cmp    0x14(%ebp),%eax
c0106035:	7c d6                	jl     c010600d <arch_sync_pts+0xe>
            dest->entries[i] = src->entries[i];
        }
}
c0106037:	c9                   	leave  
c0106038:	c3                   	ret    

c0106039 <pt_get>:
 * @param index index
 * @param flags flags
 *
 * @return pagetable
 */
pt_t pt_get(arch_vmm_context_t *context, int index, uint8_t flags) {
c0106039:	55                   	push   %ebp
c010603a:	89 e5                	mov    %esp,%ebp
c010603c:	83 ec 38             	sub    $0x38,%esp
c010603f:	8b 45 10             	mov    0x10(%ebp),%eax
c0106042:	88 45 e4             	mov    %al,-0x1c(%ebp)
	pt_t pt;

	if(current_context != NULL) {
c0106045:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c010604a:	85 c0                	test   %eax,%eax
c010604c:	74 54                	je     c01060a2 <pt_get+0x69>
	  if(context != current_context->arch_context) {
c010604e:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0106053:	8b 00                	mov    (%eax),%eax
c0106055:	3b 45 08             	cmp    0x8(%ebp),%eax
c0106058:	74 38                	je     c0106092 <pt_get+0x59>
	    pt = (pt_t) PT_PADDR(index);
c010605a:	8b 45 08             	mov    0x8(%ebp),%eax
c010605d:	8b 00                	mov    (%eax),%eax
c010605f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106062:	c1 e2 02             	shl    $0x2,%edx
c0106065:	01 d0                	add    %edx,%eax
c0106067:	8b 00                	mov    (%eax),%eax
c0106069:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010606e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    pt = (pt_t) vmm_automap_kernel(current_context, (paddr_t) pt, flags);
c0106071:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c0106075:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106078:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c010607d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0106081:	89 54 24 04          	mov    %edx,0x4(%esp)
c0106085:	89 04 24             	mov    %eax,(%esp)
c0106088:	e8 89 10 00 00       	call   c0107116 <vmm_automap_kernel>
c010608d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0106090:	eb 27                	jmp    c01060b9 <pt_get+0x80>
	  } else {
	    pt = (pt_t) PT_VADDR(index);
c0106092:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106095:	05 00 f8 0f 00       	add    $0xff800,%eax
c010609a:	c1 e0 0c             	shl    $0xc,%eax
c010609d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01060a0:	eb 17                	jmp    c01060b9 <pt_get+0x80>
	  }
	} else {
	  pt = (pt_t) PT_PADDR(index) + MEMORY_LAYOUT_KERNEL_START;
c01060a2:	8b 45 08             	mov    0x8(%ebp),%eax
c01060a5:	8b 00                	mov    (%eax),%eax
c01060a7:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060aa:	c1 e2 02             	shl    $0x2,%edx
c01060ad:	01 d0                	add    %edx,%eax
c01060af:	8b 00                	mov    (%eax),%eax
c01060b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01060b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	return pt;
c01060b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01060bc:	c9                   	leave  
c01060bd:	c3                   	ret    

c01060be <pt_create>:
 * @param index index
 * @param flags flags
 *
 * @return pagetable
 */
pt_t pt_create(arch_vmm_context_t *context, int index, uint8_t flags) {
c01060be:	55                   	push   %ebp
c01060bf:	89 e5                	mov    %esp,%ebp
c01060c1:	83 ec 38             	sub    $0x38,%esp
c01060c4:	8b 45 10             	mov    0x10(%ebp),%eax
c01060c7:	88 45 e4             	mov    %al,-0x1c(%ebp)
	pt_t pt = (pt_t) pmm_alloc_page_limit(0);
c01060ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c01060d1:	e8 6f ef ff ff       	call   c0105045 <pmm_alloc_page_limit>
c01060d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	context->entries[index] = (pde_t) pt | flags | VMM_PRESENT;
c01060d9:	8b 45 08             	mov    0x8(%ebp),%eax
c01060dc:	8b 00                	mov    (%eax),%eax
c01060de:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060e1:	c1 e2 02             	shl    $0x2,%edx
c01060e4:	01 d0                	add    %edx,%eax
c01060e6:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c01060ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01060ed:	09 ca                	or     %ecx,%edx
c01060ef:	83 ca 01             	or     $0x1,%edx
c01060f2:	89 10                	mov    %edx,(%eax)

	pt = pt_get(context, index, flags | VMM_PRESENT);
c01060f4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c01060f8:	83 c8 01             	or     $0x1,%eax
c01060fb:	0f b6 c0             	movzbl %al,%eax
c01060fe:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106102:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106105:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106109:	8b 45 08             	mov    0x8(%ebp),%eax
c010610c:	89 04 24             	mov    %eax,(%esp)
c010610f:	e8 25 ff ff ff       	call   c0106039 <pt_get>
c0106114:	89 45 f4             	mov    %eax,-0xc(%ebp)
	memset(pt, 0, 4096);
c0106117:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010611e:	00 
c010611f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106126:	00 
c0106127:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010612a:	89 04 24             	mov    %eax,(%esp)
c010612d:	e8 c3 40 00 00       	call   c010a1f5 <memset>

	return pt;
c0106132:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106135:	c9                   	leave  
c0106136:	c3                   	ret    

c0106137 <pt_destroy>:
 * @param pd pagedirectory
 * @param index index
 *
 * @return void
 */
void pt_destroy(arch_vmm_context_t *context, int index) {
c0106137:	55                   	push   %ebp
c0106138:	89 e5                	mov    %esp,%ebp
c010613a:	83 ec 18             	sub    $0x18,%esp
	pmm_mark_page_as_free((paddr_t)context->entries[index]);
c010613d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106140:	8b 00                	mov    (%eax),%eax
c0106142:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106145:	c1 e2 02             	shl    $0x2,%edx
c0106148:	01 d0                	add    %edx,%eax
c010614a:	8b 00                	mov    (%eax),%eax
c010614c:	89 04 24             	mov    %eax,(%esp)
c010614f:	e8 7e eb ff ff       	call   c0104cd2 <pmm_mark_page_as_free>
	context->entries[index] = 0;
c0106154:	8b 45 08             	mov    0x8(%ebp),%eax
c0106157:	8b 00                	mov    (%eax),%eax
c0106159:	8b 55 0c             	mov    0xc(%ebp),%edx
c010615c:	c1 e2 02             	shl    $0x2,%edx
c010615f:	01 d0                	add    %edx,%eax
c0106161:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c0106167:	c9                   	leave  
c0106168:	c3                   	ret    

c0106169 <arch_map>:
 * @param vframe vitual adress
 * @param flags flags
 *
 * @return success
 */
int arch_map(arch_vmm_context_t *context, paddr_t pframe, vaddr_t vframe, uint8_t flags) {
c0106169:	55                   	push   %ebp
c010616a:	89 e5                	mov    %esp,%ebp
c010616c:	83 ec 38             	sub    $0x38,%esp
c010616f:	8b 45 14             	mov    0x14(%ebp),%eax
c0106172:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if( (pframe & 0xFFF) || (vframe & 0xFFF) ) {
c0106175:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106178:	25 ff 0f 00 00       	and    $0xfff,%eax
c010617d:	85 c0                	test   %eax,%eax
c010617f:	75 0c                	jne    c010618d <arch_map+0x24>
c0106181:	8b 45 10             	mov    0x10(%ebp),%eax
c0106184:	25 ff 0f 00 00       	and    $0xfff,%eax
c0106189:	85 c0                	test   %eax,%eax
c010618b:	74 24                	je     c01061b1 <arch_map+0x48>
	  printf("pd_map(): can't map 0x%x to 0x%x.", pframe, vframe);
c010618d:	8b 45 10             	mov    0x10(%ebp),%eax
c0106190:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106194:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106197:	89 44 24 04          	mov    %eax,0x4(%esp)
c010619b:	c7 04 24 d8 b7 10 c0 	movl   $0xc010b7d8,(%esp)
c01061a2:	e8 d5 f1 ff ff       	call   c010537c <printf>
	  return -1;
c01061a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01061ac:	e9 e2 00 00 00       	jmp    c0106293 <arch_map+0x12a>
	}

	uint32_t pd_index = PDE_INDEX(vframe);
c01061b1:	8b 45 10             	mov    0x10(%ebp),%eax
c01061b4:	c1 e8 16             	shr    $0x16,%eax
c01061b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t pt_index = PTE_INDEX(vframe);
c01061ba:	8b 45 10             	mov    0x10(%ebp),%eax
c01061bd:	c1 e8 0c             	shr    $0xc,%eax
c01061c0:	25 ff 03 00 00       	and    $0x3ff,%eax
c01061c5:	89 45 ec             	mov    %eax,-0x14(%ebp)

	pt_t pt = NULL;
c01061c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	pde_t pde = context->entries[pd_index];
c01061cf:	8b 45 08             	mov    0x8(%ebp),%eax
c01061d2:	8b 00                	mov    (%eax),%eax
c01061d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01061d7:	c1 e2 02             	shl    $0x2,%edx
c01061da:	01 d0                	add    %edx,%eax
c01061dc:	8b 00                	mov    (%eax),%eax
c01061de:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (pde & VMM_PRESENT) {
c01061e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01061e4:	83 e0 01             	and    $0x1,%eax
c01061e7:	85 c0                	test   %eax,%eax
c01061e9:	74 25                	je     c0106210 <arch_map+0xa7>
		pt = pt_get(context, pd_index, flags | VMM_PRESENT);
c01061eb:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c01061ef:	83 c8 01             	or     $0x1,%eax
c01061f2:	0f b6 d0             	movzbl %al,%edx
c01061f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01061f8:	89 54 24 08          	mov    %edx,0x8(%esp)
c01061fc:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106200:	8b 45 08             	mov    0x8(%ebp),%eax
c0106203:	89 04 24             	mov    %eax,(%esp)
c0106206:	e8 2e fe ff ff       	call   c0106039 <pt_get>
c010620b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010620e:	eb 23                	jmp    c0106233 <arch_map+0xca>
	} else {
		pt = pt_create(context, pd_index, flags | VMM_PRESENT);
c0106210:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0106214:	83 c8 01             	or     $0x1,%eax
c0106217:	0f b6 d0             	movzbl %al,%edx
c010621a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010621d:	89 54 24 08          	mov    %edx,0x8(%esp)
c0106221:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106225:	8b 45 08             	mov    0x8(%ebp),%eax
c0106228:	89 04 24             	mov    %eax,(%esp)
c010622b:	e8 8e fe ff ff       	call   c01060be <pt_create>
c0106230:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	pt[pt_index] = (pte_t)(pframe & ~0xFFF) | VMM_PRESENT | (flags & 0xFFF);
c0106233:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106236:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010623d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106240:	01 d0                	add    %edx,%eax
c0106242:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106245:	89 d1                	mov    %edx,%ecx
c0106247:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c010624d:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0106251:	09 ca                	or     %ecx,%edx
c0106253:	83 ca 01             	or     $0x1,%edx
c0106256:	89 10                	mov    %edx,(%eax)

	if(current_context != NULL) {
c0106258:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c010625d:	85 c0                	test   %eax,%eax
c010625f:	74 2d                	je     c010628e <arch_map+0x125>
		if(context == current_context->arch_context) {
c0106261:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0106266:	8b 00                	mov    (%eax),%eax
c0106268:	3b 45 08             	cmp    0x8(%ebp),%eax
c010626b:	75 0d                	jne    c010627a <arch_map+0x111>
			paging_flush_tlb(vframe);
c010626d:	8b 45 10             	mov    0x10(%ebp),%eax
c0106270:	89 04 24             	mov    %eax,(%esp)
c0106273:	e8 18 03 00 00       	call   c0106590 <paging_flush_tlb>
c0106278:	eb 14                	jmp    c010628e <arch_map+0x125>
		} else {
			vmm_unmap(current_context, (vaddr_t) pt);
c010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010627d:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0106282:	89 54 24 04          	mov    %edx,0x4(%esp)
c0106286:	89 04 24             	mov    %eax,(%esp)
c0106289:	e8 c9 0d 00 00       	call   c0107057 <vmm_unmap>
		}
	}

	return 0;
c010628e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106293:	c9                   	leave  
c0106294:	c3                   	ret    

c0106295 <arch_unmap>:
 * @param pd pagedirectory
 * @param frame adress to unmap
 *
 * @return void
 */
int arch_unmap(arch_vmm_context_t *context, vaddr_t frame) {
c0106295:	55                   	push   %ebp
c0106296:	89 e5                	mov    %esp,%ebp
c0106298:	83 ec 28             	sub    $0x28,%esp
	pt_t pt = pt_get(context, PDE_INDEX(frame), VMM_WRITABLE);
c010629b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010629e:	c1 e8 16             	shr    $0x16,%eax
c01062a1:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c01062a8:	00 
c01062a9:	89 44 24 04          	mov    %eax,0x4(%esp)
c01062ad:	8b 45 08             	mov    0x8(%ebp),%eax
c01062b0:	89 04 24             	mov    %eax,(%esp)
c01062b3:	e8 81 fd ff ff       	call   c0106039 <pt_get>
c01062b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	pt[PTE_INDEX(frame)] = 0;
c01062bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c01062be:	c1 e8 0c             	shr    $0xc,%eax
c01062c1:	25 ff 03 00 00       	and    $0x3ff,%eax
c01062c6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01062cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01062d0:	01 d0                	add    %edx,%eax
c01062d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	int pt_emty = 1, i;
c01062d8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for(i = 0; i < PT_LENGTH; i++) {
c01062df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c01062e6:	eb 22                	jmp    c010630a <arch_unmap+0x75>
	  if(pt[i]) {
c01062e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01062eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01062f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01062f5:	01 d0                	add    %edx,%eax
c01062f7:	8b 00                	mov    (%eax),%eax
c01062f9:	85 c0                	test   %eax,%eax
c01062fb:	74 09                	je     c0106306 <arch_unmap+0x71>
	    pt_emty = 0;
c01062fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    break;
c0106304:	eb 0d                	jmp    c0106313 <arch_unmap+0x7e>
int arch_unmap(arch_vmm_context_t *context, vaddr_t frame) {
	pt_t pt = pt_get(context, PDE_INDEX(frame), VMM_WRITABLE);
	pt[PTE_INDEX(frame)] = 0;

	int pt_emty = 1, i;
	for(i = 0; i < PT_LENGTH; i++) {
c0106306:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010630a:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c0106311:	7e d5                	jle    c01062e8 <arch_unmap+0x53>
	    pt_emty = 0;
	    break;
	  }
	}

	if(pt_emty) {
c0106313:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106317:	74 15                	je     c010632e <arch_unmap+0x99>
	  pt_destroy(context, PDE_INDEX(frame));
c0106319:	8b 45 0c             	mov    0xc(%ebp),%eax
c010631c:	c1 e8 16             	shr    $0x16,%eax
c010631f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106323:	8b 45 08             	mov    0x8(%ebp),%eax
c0106326:	89 04 24             	mov    %eax,(%esp)
c0106329:	e8 09 fe ff ff       	call   c0106137 <pt_destroy>
	}

	return 0;
c010632e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106333:	c9                   	leave  
c0106334:	c3                   	ret    

c0106335 <arch_vaddr_find>:
 * Find a free virtual adress
 *
 * @param pd pagedirectory
 * @return virtual adress
 */
vaddr_t arch_vaddr_find(arch_vmm_context_t *context, int num, vaddr_t limit_low, vaddr_t limit_high, int flags) {
c0106335:	55                   	push   %ebp
c0106336:	89 e5                	mov    %esp,%ebp
c0106338:	83 ec 48             	sub    $0x48,%esp
	  pages_found += l; \
	  if(pages_found >= num) { \
	    return vaddr; \
	  }

  vaddr_t vaddr = 0;
c010633b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  int page = 0;
c0106342:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  int pages_found = 0;
c0106349:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  uint32_t pd_index = PDE_INDEX(limit_low);
c0106350:	8b 45 10             	mov    0x10(%ebp),%eax
c0106353:	c1 e8 16             	shr    $0x16,%eax
c0106356:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t pt_index = PTE_INDEX(limit_low);
c0106359:	8b 45 10             	mov    0x10(%ebp),%eax
c010635c:	c1 e8 0c             	shr    $0xc,%eax
c010635f:	25 ff 03 00 00       	and    $0x3ff,%eax
c0106364:	89 45 e8             	mov    %eax,-0x18(%ebp)
  uint32_t pd_index_end = PDE_INDEX(limit_high);
c0106367:	8b 45 14             	mov    0x14(%ebp),%eax
c010636a:	c1 e8 16             	shr    $0x16,%eax
c010636d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  uint32_t pt_index_end = PTE_INDEX(limit_high);
c0106370:	8b 45 14             	mov    0x14(%ebp),%eax
c0106373:	c1 e8 0c             	shr    $0xc,%eax
c0106376:	25 ff 03 00 00       	and    $0x3ff,%eax
c010637b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  pt_t pt;

  while(pd_index <= pd_index_end) {
c010637e:	e9 f2 00 00 00       	jmp    c0106475 <arch_vaddr_find+0x140>
    if(context->entries[pd_index] & VMM_PRESENT) {
c0106383:	8b 45 08             	mov    0x8(%ebp),%eax
c0106386:	8b 00                	mov    (%eax),%eax
c0106388:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010638b:	c1 e2 02             	shl    $0x2,%edx
c010638e:	01 d0                	add    %edx,%eax
c0106390:	8b 00                	mov    (%eax),%eax
c0106392:	83 e0 01             	and    $0x1,%eax
c0106395:	85 c0                	test   %eax,%eax
c0106397:	0f 84 a1 00 00 00    	je     c010643e <arch_vaddr_find+0x109>
      pt = pt_get(context, pd_index, flags);
c010639d:	8b 45 18             	mov    0x18(%ebp),%eax
c01063a0:	0f b6 d0             	movzbl %al,%edx
c01063a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01063a6:	89 54 24 08          	mov    %edx,0x8(%esp)
c01063aa:	89 44 24 04          	mov    %eax,0x4(%esp)
c01063ae:	8b 45 08             	mov    0x8(%ebp),%eax
c01063b1:	89 04 24             	mov    %eax,(%esp)
c01063b4:	e8 80 fc ff ff       	call   c0106039 <pt_get>
c01063b9:	89 45 d8             	mov    %eax,-0x28(%ebp)

      uint32_t pt_end = (pd_index == pd_index_end) ? pt_index_end : PT_LENGTH; // last pd entry
c01063bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01063bf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c01063c2:	75 05                	jne    c01063c9 <arch_vaddr_find+0x94>
c01063c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01063c7:	eb 05                	jmp    c01063ce <arch_vaddr_find+0x99>
c01063c9:	b8 00 04 00 00       	mov    $0x400,%eax
c01063ce:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      for(; pt_index < pt_end; pt_index++) {
c01063d1:	eb 5a                	jmp    c010642d <arch_vaddr_find+0xf8>
	if(! ((uint32_t)pt[pt_index] & VMM_PRESENT) ) {
c01063d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01063d6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01063dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01063e0:	01 d0                	add    %edx,%eax
c01063e2:	8b 00                	mov    (%eax),%eax
c01063e4:	83 e0 01             	and    $0x1,%eax
c01063e7:	85 c0                	test   %eax,%eax
c01063e9:	75 30                	jne    c010641b <arch_vaddr_find+0xe6>
	  PAGES_FOUND(1);
c01063eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01063ef:	75 19                	jne    c010640a <arch_vaddr_find+0xd5>
c01063f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01063f4:	89 c2                	mov    %eax,%edx
c01063f6:	c1 e2 0a             	shl    $0xa,%edx
c01063f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01063fc:	01 d0                	add    %edx,%eax
c01063fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0106401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106404:	c1 e0 0c             	shl    $0xc,%eax
c0106407:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010640a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010640e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106411:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0106414:	7c 13                	jl     c0106429 <arch_vaddr_find+0xf4>
c0106416:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106419:	eb 6b                	jmp    c0106486 <arch_vaddr_find+0x151>
	} else {
	  pages_found = 0;
c010641b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	  vaddr = (uintptr_t)NULL;
c0106422:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(pd_index <= pd_index_end) {
    if(context->entries[pd_index] & VMM_PRESENT) {
      pt = pt_get(context, pd_index, flags);

      uint32_t pt_end = (pd_index == pd_index_end) ? pt_index_end : PT_LENGTH; // last pd entry
      for(; pt_index < pt_end; pt_index++) {
c0106429:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010642d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106430:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
c0106433:	72 9e                	jb     c01063d3 <arch_vaddr_find+0x9e>
	} else {
	  pages_found = 0;
	  vaddr = (uintptr_t)NULL;
	}
      }
      pt_index = 0;
c0106435:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c010643c:	eb 33                	jmp    c0106471 <arch_vaddr_find+0x13c>
    } else {
      PAGES_FOUND(PT_LENGTH);
c010643e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106442:	75 19                	jne    c010645d <arch_vaddr_find+0x128>
c0106444:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106447:	89 c2                	mov    %eax,%edx
c0106449:	c1 e2 0a             	shl    $0xa,%edx
c010644c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010644f:	01 d0                	add    %edx,%eax
c0106451:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0106454:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106457:	c1 e0 0c             	shl    $0xc,%eax
c010645a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010645d:	81 45 f0 00 04 00 00 	addl   $0x400,-0x10(%ebp)
c0106464:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106467:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010646a:	7c 05                	jl     c0106471 <arch_vaddr_find+0x13c>
c010646c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010646f:	eb 15                	jmp    c0106486 <arch_vaddr_find+0x151>
    }
    pd_index++;
c0106471:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  uint32_t pt_index = PTE_INDEX(limit_low);
  uint32_t pd_index_end = PDE_INDEX(limit_high);
  uint32_t pt_index_end = PTE_INDEX(limit_high);
  pt_t pt;

  while(pd_index <= pd_index_end) {
c0106475:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106478:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c010647b:	0f 86 02 ff ff ff    	jbe    c0106383 <arch_vaddr_find+0x4e>
      PAGES_FOUND(PT_LENGTH);
    }
    pd_index++;
  }

  return 0;
c0106481:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106486:	c9                   	leave  
c0106487:	c3                   	ret    

c0106488 <arch_vaddr2paddr>:

paddr_t arch_vaddr2paddr(arch_vmm_context_t *context, vaddr_t vaddr) {
c0106488:	55                   	push   %ebp
c0106489:	89 e5                	mov    %esp,%ebp
c010648b:	83 ec 28             	sub    $0x28,%esp
 	unsigned int pd_index = PDE_INDEX(vaddr);
c010648e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106491:	c1 e8 16             	shr    $0x16,%eax
c0106494:	89 45 f4             	mov    %eax,-0xc(%ebp)
 	unsigned int pt_index = PTE_INDEX(vaddr);
c0106497:	8b 45 0c             	mov    0xc(%ebp),%eax
c010649a:	c1 e8 0c             	shr    $0xc,%eax
c010649d:	25 ff 03 00 00       	and    $0x3ff,%eax
c01064a2:	89 45 f0             	mov    %eax,-0x10(%ebp)

 	pt_t *pt = (pt_t *)pt_get(context, pd_index, 0);
c01064a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01064a8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c01064af:	00 
c01064b0:	89 44 24 04          	mov    %eax,0x4(%esp)
c01064b4:	8b 45 08             	mov    0x8(%ebp),%eax
c01064b7:	89 04 24             	mov    %eax,(%esp)
c01064ba:	e8 7a fb ff ff       	call   c0106039 <pt_get>
c01064bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return pt[pt_index];
c01064c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01064cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01064cf:	01 d0                	add    %edx,%eax
c01064d1:	8b 00                	mov    (%eax),%eax
}
c01064d3:	c9                   	leave  
c01064d4:	c3                   	ret    

c01064d5 <arch_switch_context>:
 * @param pd pagedirectory
 * @param flags flags
 *
 * @return void
 */
void arch_switch_context(arch_vmm_context_t *context) {
c01064d5:	55                   	push   %ebp
c01064d6:	89 e5                	mov    %esp,%ebp
	asm volatile ("mov %0, %%cr3" : : "r" (context->phys_addr));
c01064d8:	8b 45 08             	mov    0x8(%ebp),%eax
c01064db:	8b 40 04             	mov    0x4(%eax),%eax
c01064de:	0f 22 d8             	mov    %eax,%cr3
}
c01064e1:	5d                   	pop    %ebp
c01064e2:	c3                   	ret    

c01064e3 <page_fault_handler>:
 *
 * @param cpu current cpu state
 * @return void
 */
void page_fault_handler(struct cpu_state **cpu_p)
{
c01064e3:	55                   	push   %ebp
c01064e4:	89 e5                	mov    %esp,%ebp
c01064e6:	53                   	push   %ebx
c01064e7:	81 ec 34 02 00 00    	sub    $0x234,%esp
    struct cpu_state *cpu = cpu_p[0];
c01064ed:	8b 45 08             	mov    0x8(%ebp),%eax
c01064f0:	8b 00                	mov    (%eax),%eax
c01064f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	char message[512];

	uint32_t addr;
	asm ("mov %%cr2, %0" : "=r" (addr));
c01064f5:	0f 20 d3             	mov    %cr2,%ebx
c01064f8:	89 5d f0             	mov    %ebx,-0x10(%ebp)

	sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X", ((cpu->error & 4) ? "user" : "kernel"),
		      ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip);
c01064fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
	char message[512];

	uint32_t addr;
	asm ("mov %%cr2, %0" : "=r" (addr));

	sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X", ((cpu->error & 4) ? "user" : "kernel"),
c01064fe:	8b 58 34             	mov    0x34(%eax),%ebx
		      ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip);
c0106501:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106504:	8b 40 30             	mov    0x30(%eax),%eax
c0106507:	83 e0 01             	and    $0x1,%eax
	char message[512];

	uint32_t addr;
	asm ("mov %%cr2, %0" : "=r" (addr));

	sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X", ((cpu->error & 4) ? "user" : "kernel"),
c010650a:	85 c0                	test   %eax,%eax
c010650c:	74 07                	je     c0106515 <page_fault_handler+0x32>
c010650e:	b9 fa b7 10 c0       	mov    $0xc010b7fa,%ecx
c0106513:	eb 05                	jmp    c010651a <page_fault_handler+0x37>
c0106515:	b9 08 b8 10 c0       	mov    $0xc010b808,%ecx
		      ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip);
c010651a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010651d:	8b 40 30             	mov    0x30(%eax),%eax
c0106520:	83 e0 02             	and    $0x2,%eax
	char message[512];

	uint32_t addr;
	asm ("mov %%cr2, %0" : "=r" (addr));

	sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X", ((cpu->error & 4) ? "user" : "kernel"),
c0106523:	85 c0                	test   %eax,%eax
c0106525:	74 07                	je     c010652e <page_fault_handler+0x4b>
c0106527:	ba 16 b8 10 c0       	mov    $0xc010b816,%edx
c010652c:	eb 05                	jmp    c0106533 <page_fault_handler+0x50>
c010652e:	ba 21 b8 10 c0       	mov    $0xc010b821,%edx
c0106533:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106536:	8b 40 30             	mov    0x30(%eax),%eax
c0106539:	83 e0 04             	and    $0x4,%eax
c010653c:	85 c0                	test   %eax,%eax
c010653e:	74 07                	je     c0106547 <page_fault_handler+0x64>
c0106540:	b8 2c b8 10 c0       	mov    $0xc010b82c,%eax
c0106545:	eb 05                	jmp    c010654c <page_fault_handler+0x69>
c0106547:	b8 31 b8 10 c0       	mov    $0xc010b831,%eax
c010654c:	89 5c 24 18          	mov    %ebx,0x18(%esp)
c0106550:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c0106554:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0106557:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c010655b:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010655f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106563:	c7 44 24 04 38 b8 10 	movl   $0xc010b838,0x4(%esp)
c010656a:	c0 
c010656b:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0106571:	89 04 24             	mov    %eax,(%esp)
c0106574:	e8 70 ee ff ff       	call   c01053e9 <sprintf>
		      ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip);

	panic(message);
c0106579:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c010657f:	89 04 24             	mov    %eax,(%esp)
c0106582:	e8 22 0f 00 00       	call   c01074a9 <panic>
}
c0106587:	81 c4 34 02 00 00    	add    $0x234,%esp
c010658d:	5b                   	pop    %ebx
c010658e:	5d                   	pop    %ebp
c010658f:	c3                   	ret    

c0106590 <paging_flush_tlb>:

static inline void paging_flush_tlb(vaddr_t addr) {
c0106590:	55                   	push   %ebp
c0106591:	89 e5                	mov    %esp,%ebp
	asm volatile ("invlpg %0" : : "m" (*(char*) addr));
c0106593:	8b 45 08             	mov    0x8(%ebp),%eax
c0106596:	0f 01 38             	invlpg (%eax)
}
c0106599:	5d                   	pop    %ebp
c010659a:	c3                   	ret    
c010659b:	90                   	nop

c010659c <cpuid>:
 * Inline function of CPUID
 * @param uint32_t cpuid function number
 * @param pointer to output register structure
 * @return sucess (0=sucess, 1=CPUID is not supported)
 */
static void cpuid(uint32_t function,struct cpuid_regs* output) {
c010659c:	55                   	push   %ebp
c010659d:	89 e5                	mov    %esp,%ebp
c010659f:	56                   	push   %esi
c01065a0:	53                   	push   %ebx
c01065a1:	83 ec 04             	sub    $0x4,%esp
	asm volatile("cpuid":"=a" (output->eax), "=b"(output->ebx),"=c"(output->ecx),"=d"(output->edx):"a"(function));
c01065a4:	8b 45 08             	mov    0x8(%ebp),%eax
c01065a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01065aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01065ad:	0f a2                	cpuid  
c01065af:	89 c6                	mov    %eax,%esi
c01065b1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01065b4:	89 30                	mov    %esi,(%eax)
c01065b6:	8b 45 0c             	mov    0xc(%ebp),%eax
c01065b9:	89 58 04             	mov    %ebx,0x4(%eax)
c01065bc:	8b 45 0c             	mov    0xc(%ebp),%eax
c01065bf:	89 48 08             	mov    %ecx,0x8(%eax)
c01065c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01065c5:	89 50 0c             	mov    %edx,0xc(%eax)
}
c01065c8:	83 c4 04             	add    $0x4,%esp
c01065cb:	5b                   	pop    %ebx
c01065cc:	5e                   	pop    %esi
c01065cd:	5d                   	pop    %ebp
c01065ce:	c3                   	ret    

c01065cf <identify_cpu>:
/*
 * Identify curret CPU
 * @param pointer to 128byte free bytes for cpu_prpoerties struct
 * @return sucess (0=sucess, 1=CPUID is not supported)
 */
int identify_cpu(struct cpu_properties *cpu) {
c01065cf:	55                   	push   %ebp
c01065d0:	89 e5                	mov    %esp,%ebp
c01065d2:	57                   	push   %edi
c01065d3:	56                   	push   %esi
c01065d4:	53                   	push   %ebx
c01065d5:	83 ec 4c             	sub    $0x4c,%esp
	int ref,eflags;
	asm volatile(
c01065d8:	9c                   	pushf  
c01065d9:	59                   	pop    %ecx
c01065da:	89 c8                	mov    %ecx,%eax
c01065dc:	35 00 00 20 00       	xor    $0x200000,%eax
c01065e1:	50                   	push   %eax
c01065e2:	9d                   	popf   
c01065e3:	9c                   	pushf  
c01065e4:	58                   	pop    %eax
c01065e5:	89 cb                	mov    %ecx,%ebx
c01065e7:	89 c6                	mov    %eax,%esi
c01065e9:	89 75 e0             	mov    %esi,-0x20(%ebp)
c01065ec:	89 5d dc             	mov    %ebx,-0x24(%ebp)
		"popfl;"
		"pushfl;"
		"pop %%eax;"
		:"=a"(eflags), "=c"(ref):
	);
	if (eflags == ref)
c01065ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01065f2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c01065f5:	75 13                	jne    c010660a <identify_cpu+0x3b>
	//cpuid is not supported
	{
	    cpu->cpuid_support = false;
c01065f7:	8b 45 08             	mov    0x8(%ebp),%eax
c01065fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    return 1;
c0106600:	b8 01 00 00 00       	mov    $0x1,%eax
c0106605:	e9 31 04 00 00       	jmp    c0106a3b <identify_cpu+0x46c>
	}

    //cpuid is supported
    cpu->cpuid_support = true;
c010660a:	8b 45 08             	mov    0x8(%ebp),%eax
c010660d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    //create struct for processor registers
	struct cpuid_regs reg;
	uint32_t i;

	//call cpuid 0
	cpuid(0, &reg);
c0106613:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0106616:	89 44 24 04          	mov    %eax,0x4(%esp)
c010661a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0106621:	e8 76 ff ff ff       	call   c010659c <cpuid>

	// copy vendor string
	strncpy(cpu->vendor_id    , (char*) &reg.ebx, 4);
c0106626:	8b 45 08             	mov    0x8(%ebp),%eax
c0106629:	83 c0 10             	add    $0x10,%eax
c010662c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
c0106633:	00 
c0106634:	8d 55 cc             	lea    -0x34(%ebp),%edx
c0106637:	83 c2 04             	add    $0x4,%edx
c010663a:	89 54 24 04          	mov    %edx,0x4(%esp)
c010663e:	89 04 24             	mov    %eax,(%esp)
c0106641:	e8 56 36 00 00       	call   c0109c9c <strncpy>
	strncpy(cpu->vendor_id + 4, (char*) &reg.edx, 4);
c0106646:	8b 45 08             	mov    0x8(%ebp),%eax
c0106649:	83 c0 14             	add    $0x14,%eax
c010664c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
c0106653:	00 
c0106654:	8d 55 cc             	lea    -0x34(%ebp),%edx
c0106657:	83 c2 0c             	add    $0xc,%edx
c010665a:	89 54 24 04          	mov    %edx,0x4(%esp)
c010665e:	89 04 24             	mov    %eax,(%esp)
c0106661:	e8 36 36 00 00       	call   c0109c9c <strncpy>
	strncpy(cpu->vendor_id + 8, (char*) &reg.ecx, 4);
c0106666:	8b 45 08             	mov    0x8(%ebp),%eax
c0106669:	83 c0 18             	add    $0x18,%eax
c010666c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
c0106673:	00 
c0106674:	8d 55 cc             	lea    -0x34(%ebp),%edx
c0106677:	83 c2 08             	add    $0x8,%edx
c010667a:	89 54 24 04          	mov    %edx,0x4(%esp)
c010667e:	89 04 24             	mov    %eax,(%esp)
c0106681:	e8 16 36 00 00       	call   c0109c9c <strncpy>

	// identify manufactory
	for (i = 0; strncmp(cpu->vendor_id, vendorID[i], 12) && i < 15; i++) {}
c0106686:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010668d:	eb 04                	jmp    c0106693 <identify_cpu+0xc4>
c010668f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0106693:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106696:	8b 04 85 80 f3 10 c0 	mov    -0x3fef0c80(,%eax,4),%eax
c010669d:	8b 55 08             	mov    0x8(%ebp),%edx
c01066a0:	83 c2 10             	add    $0x10,%edx
c01066a3:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
c01066aa:	00 
c01066ab:	89 44 24 04          	mov    %eax,0x4(%esp)
c01066af:	89 14 24             	mov    %edx,(%esp)
c01066b2:	e8 4d 37 00 00       	call   c0109e04 <strncmp>
c01066b7:	85 c0                	test   %eax,%eax
c01066b9:	74 06                	je     c01066c1 <identify_cpu+0xf2>
c01066bb:	83 7d e4 0e          	cmpl   $0xe,-0x1c(%ebp)
c01066bf:	76 ce                	jbe    c010668f <identify_cpu+0xc0>
	cpu->manufactory = i;
c01066c1:	8b 45 08             	mov    0x8(%ebp),%eax
c01066c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01066c7:	89 50 04             	mov    %edx,0x4(%eax)

	// save number of basic identify functions
	cpu->max_std_func = reg.eax;
c01066ca:	8b 55 cc             	mov    -0x34(%ebp),%edx
c01066cd:	8b 45 08             	mov    0x8(%ebp),%eax
c01066d0:	89 50 08             	mov    %edx,0x8(%eax)

	// get and save maximum numbers of extendet identify functions
	cpuid(0x80000000, &reg);
c01066d3:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01066d6:	89 44 24 04          	mov    %eax,0x4(%esp)
c01066da:	c7 04 24 00 00 00 80 	movl   $0x80000000,(%esp)
c01066e1:	e8 b6 fe ff ff       	call   c010659c <cpuid>
	cpu->max_spec_func = reg.eax;
c01066e6:	8b 55 cc             	mov    -0x34(%ebp),%edx
c01066e9:	8b 45 08             	mov    0x8(%ebp),%eax
c01066ec:	89 50 0c             	mov    %edx,0xc(%eax)


	cpuid(1, &reg);
c01066ef:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01066f2:	89 44 24 04          	mov    %eax,0x4(%esp)
c01066f6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c01066fd:	e8 9a fe ff ff       	call   c010659c <cpuid>
	// get CPU model and Family
	cpu->family     = ((reg.eax & 0x0FF00000) >> 16) | ((reg.eax & 0x00000F00) >> 8);
c0106702:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0106705:	25 00 00 f0 0f       	and    $0xff00000,%eax
c010670a:	c1 e8 10             	shr    $0x10,%eax
c010670d:	89 c2                	mov    %eax,%edx
c010670f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0106712:	25 00 0f 00 00       	and    $0xf00,%eax
c0106717:	c1 e8 08             	shr    $0x8,%eax
c010671a:	09 c2                	or     %eax,%edx
c010671c:	8b 45 08             	mov    0x8(%ebp),%eax
c010671f:	88 50 1d             	mov    %dl,0x1d(%eax)
	cpu->model      = ((reg.eax & 0x000F0000) >> 12) | ((reg.eax & 0x000000F0) >> 4);
c0106722:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0106725:	25 00 00 0f 00       	and    $0xf0000,%eax
c010672a:	c1 e8 0c             	shr    $0xc,%eax
c010672d:	89 c2                	mov    %eax,%edx
c010672f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0106732:	25 f0 00 00 00       	and    $0xf0,%eax
c0106737:	c1 e8 04             	shr    $0x4,%eax
c010673a:	09 c2                	or     %eax,%edx
c010673c:	8b 45 08             	mov    0x8(%ebp),%eax
c010673f:	88 50 1e             	mov    %dl,0x1e(%eax)
	cpu->stepping   =  reg.eax & 0x0000000F;
c0106742:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0106745:	89 c2                	mov    %eax,%edx
c0106747:	83 e2 0f             	and    $0xf,%edx
c010674a:	8b 45 08             	mov    0x8(%ebp),%eax
c010674d:	88 50 1f             	mov    %dl,0x1f(%eax)
	cpu->type       = (reg.eax & 0x00003000) >> 12;
c0106750:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0106753:	25 00 30 00 00       	and    $0x3000,%eax
c0106758:	c1 e8 0c             	shr    $0xc,%eax
c010675b:	89 c2                	mov    %eax,%edx
c010675d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106760:	88 50 20             	mov    %dl,0x20(%eax)

	cpu->brandID     = (uint8_t) reg.ebx;
c0106763:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0106766:	89 c2                	mov    %eax,%edx
c0106768:	8b 45 08             	mov    0x8(%ebp),%eax
c010676b:	88 50 21             	mov    %dl,0x21(%eax)
	cpu->clflush     = (uint8_t) (reg.ebx >> 8);
c010676e:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0106771:	c1 e8 08             	shr    $0x8,%eax
c0106774:	89 c2                	mov    %eax,%edx
c0106776:	8b 45 08             	mov    0x8(%ebp),%eax
c0106779:	88 50 22             	mov    %dl,0x22(%eax)
	cpu->logic_cores = (uint8_t) (reg.ebx >> 16);
c010677c:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010677f:	c1 e8 10             	shr    $0x10,%eax
c0106782:	89 c2                	mov    %eax,%edx
c0106784:	8b 45 08             	mov    0x8(%ebp),%eax
c0106787:	88 50 23             	mov    %dl,0x23(%eax)
	cpu->APIC_ID     = (uint8_t) (reg.ebx >> 24);
c010678a:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010678d:	c1 e8 18             	shr    $0x18,%eax
c0106790:	89 c2                	mov    %eax,%edx
c0106792:	8b 45 08             	mov    0x8(%ebp),%eax
c0106795:	88 50 2e             	mov    %dl,0x2e(%eax)



    cpu->flagblock0 = reg.ecx;
c0106798:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c010679b:	8b 45 08             	mov    0x8(%ebp),%eax
c010679e:	89 50 68             	mov    %edx,0x68(%eax)
	cpu->flagblock1 = reg.edx;
c01067a1:	8b 55 d8             	mov    -0x28(%ebp),%edx
c01067a4:	8b 45 08             	mov    0x8(%ebp),%eax
c01067a7:	89 50 6c             	mov    %edx,0x6c(%eax)

	if(cpu->max_spec_func > 0x80000000)
c01067aa:	8b 45 08             	mov    0x8(%ebp),%eax
c01067ad:	8b 40 0c             	mov    0xc(%eax),%eax
c01067b0:	3d 00 00 00 80       	cmp    $0x80000000,%eax
c01067b5:	76 39                	jbe    c01067f0 <identify_cpu+0x221>
	{
        cpuid(0x80000001, &reg);
c01067b7:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01067ba:	89 44 24 04          	mov    %eax,0x4(%esp)
c01067be:	c7 04 24 01 00 00 80 	movl   $0x80000001,(%esp)
c01067c5:	e8 d2 fd ff ff       	call   c010659c <cpuid>
        if((( reg.edx & (1 << 29) ) >> 29) && cpu->flagblock1 & PAE )
c01067ca:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01067cd:	25 00 00 00 20       	and    $0x20000000,%eax
c01067d2:	c1 e8 1d             	shr    $0x1d,%eax
c01067d5:	85 c0                	test   %eax,%eax
c01067d7:	74 17                	je     c01067f0 <identify_cpu+0x221>
c01067d9:	8b 45 08             	mov    0x8(%ebp),%eax
c01067dc:	8b 40 6c             	mov    0x6c(%eax),%eax
c01067df:	83 e0 40             	and    $0x40,%eax
c01067e2:	85 c0                	test   %eax,%eax
c01067e4:	74 0a                	je     c01067f0 <identify_cpu+0x221>
        {
            cpu->LM = true;
c01067e6:	8b 45 08             	mov    0x8(%ebp),%eax
c01067e9:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
        }
	}

    if (cpu->flagblock1 & (1 << 30))
c01067f0:	8b 45 08             	mov    0x8(%ebp),%eax
c01067f3:	8b 40 6c             	mov    0x6c(%eax),%eax
c01067f6:	25 00 00 00 40       	and    $0x40000000,%eax
c01067fb:	85 c0                	test   %eax,%eax
c01067fd:	74 22                	je     c0106821 <identify_cpu+0x252>
    {
        if(cpu->LM)
c01067ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0106802:	8b 40 24             	mov    0x24(%eax),%eax
c0106805:	85 c0                	test   %eax,%eax
c0106807:	74 0c                	je     c0106815 <identify_cpu+0x246>
            cpu->architecture = IA64;
c0106809:	8b 45 08             	mov    0x8(%ebp),%eax
c010680c:	c7 40 30 00 00 00 40 	movl   $0x40000000,0x30(%eax)
c0106813:	eb 2c                	jmp    c0106841 <identify_cpu+0x272>
        else
            cpu->architecture = IA32;
c0106815:	8b 45 08             	mov    0x8(%ebp),%eax
c0106818:	c7 40 30 02 00 00 00 	movl   $0x2,0x30(%eax)
c010681f:	eb 20                	jmp    c0106841 <identify_cpu+0x272>
	}
	else
	{
        if(cpu->LM)
c0106821:	8b 45 08             	mov    0x8(%ebp),%eax
c0106824:	8b 40 24             	mov    0x24(%eax),%eax
c0106827:	85 c0                	test   %eax,%eax
c0106829:	74 0c                	je     c0106837 <identify_cpu+0x268>
            cpu->architecture = AMD64;
c010682b:	8b 45 08             	mov    0x8(%ebp),%eax
c010682e:	c7 40 30 01 00 00 00 	movl   $0x1,0x30(%eax)
c0106835:	eb 0a                	jmp    c0106841 <identify_cpu+0x272>
        else
            cpu->architecture = I386;
c0106837:	8b 45 08             	mov    0x8(%ebp),%eax
c010683a:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)




	//Detect Dynamic Syscall
	if (cpu->flagblock1 & SEP && cpu->manufactory == 2) {
c0106841:	8b 45 08             	mov    0x8(%ebp),%eax
c0106844:	8b 40 6c             	mov    0x6c(%eax),%eax
c0106847:	25 00 08 00 00       	and    $0x800,%eax
c010684c:	85 c0                	test   %eax,%eax
c010684e:	74 17                	je     c0106867 <identify_cpu+0x298>
c0106850:	8b 45 08             	mov    0x8(%ebp),%eax
c0106853:	8b 40 04             	mov    0x4(%eax),%eax
c0106856:	83 f8 02             	cmp    $0x2,%eax
c0106859:	75 0c                	jne    c0106867 <identify_cpu+0x298>
		cpu->dsysc = sysenter;
c010685b:	8b 45 08             	mov    0x8(%ebp),%eax
c010685e:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
c0106865:	eb 50                	jmp    c01068b7 <identify_cpu+0x2e8>
	}
	else if (cpu->flagblock1 & SEP && cpu->manufactory < 2 && cpu->max_spec_func > 0x80000000)
c0106867:	8b 45 08             	mov    0x8(%ebp),%eax
c010686a:	8b 40 6c             	mov    0x6c(%eax),%eax
c010686d:	25 00 08 00 00       	and    $0x800,%eax
c0106872:	85 c0                	test   %eax,%eax
c0106874:	74 41                	je     c01068b7 <identify_cpu+0x2e8>
c0106876:	8b 45 08             	mov    0x8(%ebp),%eax
c0106879:	8b 40 04             	mov    0x4(%eax),%eax
c010687c:	83 f8 01             	cmp    $0x1,%eax
c010687f:	77 36                	ja     c01068b7 <identify_cpu+0x2e8>
c0106881:	8b 45 08             	mov    0x8(%ebp),%eax
c0106884:	8b 40 0c             	mov    0xc(%eax),%eax
c0106887:	3d 00 00 00 80       	cmp    $0x80000000,%eax
c010688c:	76 29                	jbe    c01068b7 <identify_cpu+0x2e8>
	{
		cpuid(0x80000001,&reg);
c010688e:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0106891:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106895:	c7 04 24 01 00 00 80 	movl   $0x80000001,(%esp)
c010689c:	e8 fb fc ff ff       	call   c010659c <cpuid>
		if (reg.edx & 0x1000)
c01068a1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01068a4:	25 00 10 00 00       	and    $0x1000,%eax
c01068a9:	85 c0                	test   %eax,%eax
c01068ab:	74 0a                	je     c01068b7 <identify_cpu+0x2e8>
		{
			cpu->dsysc = syscall;
c01068ad:	8b 45 08             	mov    0x8(%ebp),%eax
c01068b0:	c7 40 28 02 00 00 00 	movl   $0x2,0x28(%eax)
		}
	}

	//get extended BrandID
	if (cpu->max_spec_func > 0x80000000) {
c01068b7:	8b 45 08             	mov    0x8(%ebp),%eax
c01068ba:	8b 40 0c             	mov    0xc(%eax),%eax
c01068bd:	3d 00 00 00 80       	cmp    $0x80000000,%eax
c01068c2:	76 21                	jbe    c01068e5 <identify_cpu+0x316>
		cpuid(0x80000001, &reg);
c01068c4:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01068c7:	89 44 24 04          	mov    %eax,0x4(%esp)
c01068cb:	c7 04 24 01 00 00 80 	movl   $0x80000001,(%esp)
c01068d2:	e8 c5 fc ff ff       	call   c010659c <cpuid>
		cpu->ext_brandID = (uint16_t)reg.ebx;
c01068d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
c01068da:	89 c2                	mov    %eax,%edx
c01068dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01068df:	66 89 50 2c          	mov    %dx,0x2c(%eax)
c01068e3:	eb 09                	jmp    c01068ee <identify_cpu+0x31f>
	} else {
		cpu->ext_brandID = 0x3e;
c01068e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01068e8:	66 c7 40 2c 3e 00    	movw   $0x3e,0x2c(%eax)
	}


	//Get CPU name/series
	if (cpu->max_spec_func > 0x80000004) { // via Brand String
c01068ee:	8b 45 08             	mov    0x8(%ebp),%eax
c01068f1:	8b 40 0c             	mov    0xc(%eax),%eax
c01068f4:	3d 04 00 00 80       	cmp    $0x80000004,%eax
c01068f9:	76 5a                	jbe    c0106955 <identify_cpu+0x386>
		for (i=0x80000002;i<=0x80000004;i++)
c01068fb:	c7 45 e4 02 00 00 80 	movl   $0x80000002,-0x1c(%ebp)
c0106902:	eb 43                	jmp    c0106947 <identify_cpu+0x378>
		{
			cpuid(i,&reg);
c0106904:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0106907:	89 44 24 04          	mov    %eax,0x4(%esp)
c010690b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010690e:	89 04 24             	mov    %eax,(%esp)
c0106911:	e8 86 fc ff ff       	call   c010659c <cpuid>
			memcpy((cpu->cpu_type+(i-0x80000002)*16),((void*)&reg),16);
c0106916:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106919:	05 fe ff ff 0f       	add    $0xffffffe,%eax
c010691e:	c1 e0 04             	shl    $0x4,%eax
c0106921:	8d 50 30             	lea    0x30(%eax),%edx
c0106924:	8b 45 08             	mov    0x8(%ebp),%eax
c0106927:	01 d0                	add    %edx,%eax
c0106929:	83 c0 04             	add    $0x4,%eax
c010692c:	8b 55 cc             	mov    -0x34(%ebp),%edx
c010692f:	89 10                	mov    %edx,(%eax)
c0106931:	8b 55 d0             	mov    -0x30(%ebp),%edx
c0106934:	89 50 04             	mov    %edx,0x4(%eax)
c0106937:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c010693a:	89 50 08             	mov    %edx,0x8(%eax)
c010693d:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0106940:	89 50 0c             	mov    %edx,0xc(%eax)
	}


	//Get CPU name/series
	if (cpu->max_spec_func > 0x80000004) { // via Brand String
		for (i=0x80000002;i<=0x80000004;i++)
c0106943:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0106947:	81 7d e4 04 00 00 80 	cmpl   $0x80000004,-0x1c(%ebp)
c010694e:	76 b4                	jbe    c0106904 <identify_cpu+0x335>
c0106950:	e9 e1 00 00 00       	jmp    c0106a36 <identify_cpu+0x467>
			memcpy((cpu->cpu_type+(i-0x80000002)*16),((void*)&reg),16);
		}

	}

	else if(cpu->family == 6 && cpu->model == 3 && cpu->stepping == 3)
c0106955:	8b 45 08             	mov    0x8(%ebp),%eax
c0106958:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c010695c:	3c 06                	cmp    $0x6,%al
c010695e:	75 6d                	jne    c01069cd <identify_cpu+0x3fe>
c0106960:	8b 45 08             	mov    0x8(%ebp),%eax
c0106963:	0f b6 40 1e          	movzbl 0x1e(%eax),%eax
c0106967:	3c 03                	cmp    $0x3,%al
c0106969:	75 62                	jne    c01069cd <identify_cpu+0x3fe>
c010696b:	8b 45 08             	mov    0x8(%ebp),%eax
c010696e:	0f b6 40 1f          	movzbl 0x1f(%eax),%eax
c0106972:	3c 03                	cmp    $0x3,%al
c0106974:	75 57                	jne    c01069cd <identify_cpu+0x3fe>
	{
        strcat(cpu->cpu_type,"Quemu ");
c0106976:	8b 45 08             	mov    0x8(%ebp),%eax
c0106979:	8d 58 34             	lea    0x34(%eax),%ebx
c010697c:	89 d8                	mov    %ebx,%eax
c010697e:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,-0x3c(%ebp)
c0106985:	89 c2                	mov    %eax,%edx
c0106987:	b8 00 00 00 00       	mov    $0x0,%eax
c010698c:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
c010698f:	89 d7                	mov    %edx,%edi
c0106991:	f2 ae                	repnz scas %es:(%edi),%al
c0106993:	89 c8                	mov    %ecx,%eax
c0106995:	f7 d0                	not    %eax
c0106997:	83 e8 01             	sub    $0x1,%eax
c010699a:	01 d8                	add    %ebx,%eax
c010699c:	c7 00 51 75 65 6d    	movl   $0x6d657551,(%eax)
c01069a2:	66 c7 40 04 75 20    	movw   $0x2075,0x4(%eax)
c01069a8:	c6 40 06 00          	movb   $0x0,0x6(%eax)
        strcat(cpu->cpu_type,architecture[cpu->architecture]);
c01069ac:	8b 45 08             	mov    0x8(%ebp),%eax
c01069af:	8b 40 30             	mov    0x30(%eax),%eax
c01069b2:	8b 04 85 08 f4 10 c0 	mov    -0x3fef0bf8(,%eax,4),%eax
c01069b9:	8b 55 08             	mov    0x8(%ebp),%edx
c01069bc:	83 c2 34             	add    $0x34,%edx
c01069bf:	89 44 24 04          	mov    %eax,0x4(%esp)
c01069c3:	89 14 24             	mov    %edx,(%esp)
c01069c6:	e8 36 33 00 00       	call   c0109d01 <strcat>
c01069cb:	eb 69                	jmp    c0106a36 <identify_cpu+0x467>
	}

	else
	{ //standart name
		strcpy(cpu->cpu_type,cpu_manufactorys[cpu->manufactory]);
c01069cd:	8b 45 08             	mov    0x8(%ebp),%eax
c01069d0:	8b 40 04             	mov    0x4(%eax),%eax
c01069d3:	8b 04 85 c0 f3 10 c0 	mov    -0x3fef0c40(,%eax,4),%eax
c01069da:	8b 55 08             	mov    0x8(%ebp),%edx
c01069dd:	83 c2 34             	add    $0x34,%edx
c01069e0:	89 44 24 04          	mov    %eax,0x4(%esp)
c01069e4:	89 14 24             	mov    %edx,(%esp)
c01069e7:	e8 5f 32 00 00       	call   c0109c4b <strcpy>
		strcat(cpu->cpu_type," ");
c01069ec:	8b 45 08             	mov    0x8(%ebp),%eax
c01069ef:	8d 58 34             	lea    0x34(%eax),%ebx
c01069f2:	89 d8                	mov    %ebx,%eax
c01069f4:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,-0x3c(%ebp)
c01069fb:	89 c2                	mov    %eax,%edx
c01069fd:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a02:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
c0106a05:	89 d7                	mov    %edx,%edi
c0106a07:	f2 ae                	repnz scas %es:(%edi),%al
c0106a09:	89 c8                	mov    %ecx,%eax
c0106a0b:	f7 d0                	not    %eax
c0106a0d:	83 e8 01             	sub    $0x1,%eax
c0106a10:	01 d8                	add    %ebx,%eax
c0106a12:	66 c7 00 20 00       	movw   $0x20,(%eax)
		strcat(cpu->cpu_type,architecture[cpu->architecture]);
c0106a17:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a1a:	8b 40 30             	mov    0x30(%eax),%eax
c0106a1d:	8b 04 85 08 f4 10 c0 	mov    -0x3fef0bf8(,%eax,4),%eax
c0106a24:	8b 55 08             	mov    0x8(%ebp),%edx
c0106a27:	83 c2 34             	add    $0x34,%edx
c0106a2a:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106a2e:	89 14 24             	mov    %edx,(%esp)
c0106a31:	e8 cb 32 00 00       	call   c0109d01 <strcat>
	}

	return 0;
c0106a36:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106a3b:	83 c4 4c             	add    $0x4c,%esp
c0106a3e:	5b                   	pop    %ebx
c0106a3f:	5e                   	pop    %esi
c0106a40:	5f                   	pop    %edi
c0106a41:	5d                   	pop    %ebp
c0106a42:	c3                   	ret    

c0106a43 <CPU_info>:

/*
 * prints CPU Information (not much)
 * @return void
 */
 void CPU_info(struct cpu_properties *cpu) {
c0106a43:	55                   	push   %ebp
c0106a44:	89 e5                	mov    %esp,%ebp
c0106a46:	83 ec 18             	sub    $0x18,%esp
	if (cpu->cpuid_support==true)
c0106a49:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a4c:	8b 00                	mov    (%eax),%eax
c0106a4e:	83 f8 01             	cmp    $0x1,%eax
c0106a51:	0f 85 34 01 00 00    	jne    c0106b8b <CPU_info+0x148>
	{
		printf("CPU Manufactory: %s\n",cpu_manufactorys[cpu->manufactory]);
c0106a57:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a5a:	8b 40 04             	mov    0x4(%eax),%eax
c0106a5d:	8b 04 85 c0 f3 10 c0 	mov    -0x3fef0c40(,%eax,4),%eax
c0106a64:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106a68:	c7 04 24 c1 b9 10 c0 	movl   $0xc010b9c1,(%esp)
c0106a6f:	e8 08 e9 ff ff       	call   c010537c <printf>
		printf("Architecture: %s\n",architecture[cpu->architecture]);
c0106a74:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a77:	8b 40 30             	mov    0x30(%eax),%eax
c0106a7a:	8b 04 85 08 f4 10 c0 	mov    -0x3fef0bf8(,%eax,4),%eax
c0106a81:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106a85:	c7 04 24 d6 b9 10 c0 	movl   $0xc010b9d6,(%esp)
c0106a8c:	e8 eb e8 ff ff       	call   c010537c <printf>
		printf("CPU Model: %s\n",cpu->cpu_type);
c0106a91:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a94:	83 c0 34             	add    $0x34,%eax
c0106a97:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106a9b:	c7 04 24 e8 b9 10 c0 	movl   $0xc010b9e8,(%esp)
c0106aa2:	e8 d5 e8 ff ff       	call   c010537c <printf>
        printf("Family: %d  Model: %d  Stepping: %d\n",cpu->family,cpu->model,cpu->stepping);
c0106aa7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106aaa:	0f b6 40 1f          	movzbl 0x1f(%eax),%eax
c0106aae:	0f b6 c8             	movzbl %al,%ecx
c0106ab1:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ab4:	0f b6 40 1e          	movzbl 0x1e(%eax),%eax
c0106ab8:	0f b6 d0             	movzbl %al,%edx
c0106abb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106abe:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0106ac2:	0f b6 c0             	movzbl %al,%eax
c0106ac5:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0106ac9:	89 54 24 08          	mov    %edx,0x8(%esp)
c0106acd:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106ad1:	c7 04 24 f8 b9 10 c0 	movl   $0xc010b9f8,(%esp)
c0106ad8:	e8 9f e8 ff ff       	call   c010537c <printf>
        printf("Logical CPUs: %d\n",cpu->logic_cores);
c0106add:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ae0:	0f b6 40 23          	movzbl 0x23(%eax),%eax
c0106ae4:	0f b6 c0             	movzbl %al,%eax
c0106ae7:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106aeb:	c7 04 24 1d ba 10 c0 	movl   $0xc010ba1d,(%esp)
c0106af2:	e8 85 e8 ff ff       	call   c010537c <printf>
		printf("FB0: %#08x  FB1: %#08x\n",cpu->flagblock0, cpu->flagblock1);
c0106af7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106afa:	8b 50 6c             	mov    0x6c(%eax),%edx
c0106afd:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b00:	8b 40 68             	mov    0x68(%eax),%eax
c0106b03:	89 54 24 08          	mov    %edx,0x8(%esp)
c0106b07:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106b0b:	c7 04 24 2f ba 10 c0 	movl   $0xc010ba2f,(%esp)
c0106b12:	e8 65 e8 ff ff       	call   c010537c <printf>
		printf("Dynamic Syscall: %s\n",scall[cpu->dsysc]);
c0106b17:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b1a:	8b 40 28             	mov    0x28(%eax),%eax
c0106b1d:	8b 04 85 fc f3 10 c0 	mov    -0x3fef0c04(,%eax,4),%eax
c0106b24:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106b28:	c7 04 24 47 ba 10 c0 	movl   $0xc010ba47,(%esp)
c0106b2f:	e8 48 e8 ff ff       	call   c010537c <printf>

        if(cpu->flagblock1 & CLFLSH)
c0106b34:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b37:	8b 40 6c             	mov    0x6c(%eax),%eax
c0106b3a:	25 00 00 08 00       	and    $0x80000,%eax
c0106b3f:	85 c0                	test   %eax,%eax
c0106b41:	74 1d                	je     c0106b60 <CPU_info+0x11d>
		{
            printf("clflush size: %dB\n",cpu->clflush*8);
c0106b43:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b46:	0f b6 40 22          	movzbl 0x22(%eax),%eax
c0106b4a:	0f b6 c0             	movzbl %al,%eax
c0106b4d:	c1 e0 03             	shl    $0x3,%eax
c0106b50:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106b54:	c7 04 24 5c ba 10 c0 	movl   $0xc010ba5c,(%esp)
c0106b5b:	e8 1c e8 ff ff       	call   c010537c <printf>
		}
		if(cpu->flagblock1 & ACPI)
c0106b60:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b63:	8b 40 6c             	mov    0x6c(%eax),%eax
c0106b66:	25 00 00 40 00       	and    $0x400000,%eax
c0106b6b:	85 c0                	test   %eax,%eax
c0106b6d:	74 28                	je     c0106b97 <CPU_info+0x154>
		{
            printf("APIC ID: %d\n", cpu->APIC_ID);
c0106b6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b72:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
c0106b76:	0f b6 c0             	movzbl %al,%eax
c0106b79:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106b7d:	c7 04 24 6f ba 10 c0 	movl   $0xc010ba6f,(%esp)
c0106b84:	e8 f3 e7 ff ff       	call   c010537c <printf>
c0106b89:	eb 0c                	jmp    c0106b97 <CPU_info+0x154>
	}

	else

	{
		printf("current cpu does not support CPUID\n");
c0106b8b:	c7 04 24 7c ba 10 c0 	movl   $0xc010ba7c,(%esp)
c0106b92:	e8 c0 bd ff ff       	call   c0102957 <puts>
	}
 }
c0106b97:	c9                   	leave  
c0106b98:	c3                   	ret    

c0106b99 <INIT_CPUID>:

/*
 * Creates structures containing CPU Informations
 * @return void
 */
void INIT_CPUID(void) {
c0106b99:	55                   	push   %ebp
c0106b9a:	89 e5                	mov    %esp,%ebp
c0106b9c:	83 ec 18             	sub    $0x18,%esp
		identify_cpu((struct cpu_properties *)&current_CPU);
c0106b9f:	c7 04 24 60 32 13 c0 	movl   $0xc0133260,(%esp)
c0106ba6:	e8 24 fa ff ff       	call   c01065cf <identify_cpu>
		CPU_info((struct cpu_properties *)&current_CPU);
c0106bab:	c7 04 24 60 32 13 c0 	movl   $0xc0133260,(%esp)
c0106bb2:	e8 8c fe ff ff       	call   c0106a43 <CPU_info>
}
c0106bb7:	c9                   	leave  
c0106bb8:	c3                   	ret    
c0106bb9:	66 90                	xchg   %ax,%ax
c0106bbb:	90                   	nop

c0106bbc <set_GDT_entry>:
	@param size 	Segment size (Limit)
	@param access 	Access Settings
	@param flags	Flags
 */
void set_GDT_entry(int entry, uint32_t base, uint32_t size, uint8_t access, int8_t flags)
{
c0106bbc:	55                   	push   %ebp
c0106bbd:	89 e5                	mov    %esp,%ebp
c0106bbf:	83 ec 08             	sub    $0x8,%esp
c0106bc2:	8b 55 14             	mov    0x14(%ebp),%edx
c0106bc5:	8b 45 18             	mov    0x18(%ebp),%eax
c0106bc8:	88 55 fc             	mov    %dl,-0x4(%ebp)
c0106bcb:	88 45 f8             	mov    %al,-0x8(%ebp)
	GDT[entry].limit_low = (uint16_t)size;
c0106bce:	8b 45 10             	mov    0x10(%ebp),%eax
c0106bd1:	89 c2                	mov    %eax,%edx
c0106bd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bd6:	66 89 14 c5 00 19 11 	mov    %dx,-0x3feee700(,%eax,8)
c0106bdd:	c0 
	GDT[entry].Base_low = (uint16_t)base;
c0106bde:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106be1:	89 c2                	mov    %eax,%edx
c0106be3:	8b 45 08             	mov    0x8(%ebp),%eax
c0106be6:	66 89 14 c5 02 19 11 	mov    %dx,-0x3feee6fe(,%eax,8)
c0106bed:	c0 
	GDT[entry].Base_middle = (uint8_t)(base >> 16);
c0106bee:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106bf1:	c1 e8 10             	shr    $0x10,%eax
c0106bf4:	89 c2                	mov    %eax,%edx
c0106bf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bf9:	88 14 c5 04 19 11 c0 	mov    %dl,-0x3feee6fc(,%eax,8)
	GDT[entry].Access = access;
c0106c00:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c03:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0106c07:	88 14 c5 05 19 11 c0 	mov    %dl,-0x3feee6fb(,%eax,8)
	GDT[entry].limit_Flags= (uint8_t)((flags << 4) | (size >> 16));
c0106c0e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0106c12:	89 c2                	mov    %eax,%edx
c0106c14:	c1 e2 04             	shl    $0x4,%edx
c0106c17:	8b 45 10             	mov    0x10(%ebp),%eax
c0106c1a:	c1 e8 10             	shr    $0x10,%eax
c0106c1d:	09 c2                	or     %eax,%edx
c0106c1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c22:	88 14 c5 06 19 11 c0 	mov    %dl,-0x3feee6fa(,%eax,8)
	GDT[entry].base_high = (uint8_t)(base >> 24);
c0106c29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106c2c:	c1 e8 18             	shr    $0x18,%eax
c0106c2f:	89 c2                	mov    %eax,%edx
c0106c31:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c34:	88 14 c5 07 19 11 c0 	mov    %dl,-0x3feee6f9(,%eax,8)
}
c0106c3b:	c9                   	leave  
c0106c3c:	c3                   	ret    

c0106c3d <load_gdt>:
/**
	@brief Load GDT into register
	@param last_entry last entry
 */
void load_gdt(uint16_t last_entry)
{
c0106c3d:	55                   	push   %ebp
c0106c3e:	89 e5                	mov    %esp,%ebp
c0106c40:	83 ec 04             	sub    $0x4,%esp
c0106c43:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c46:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	gdtp.limit = ((last_entry + 1) * 8) - 1;
c0106c4a:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c0106c4e:	83 c0 01             	add    $0x1,%eax
c0106c51:	c1 e0 03             	shl    $0x3,%eax
c0106c54:	83 e8 01             	sub    $0x1,%eax
c0106c57:	66 a3 38 19 11 c0    	mov    %ax,0xc0111938
	gdtp.base = GDT;
c0106c5d:	c7 05 3a 19 11 c0 00 	movl   $0xc0111900,0xc011193a
c0106c64:	19 11 c0 
	asm volatile("lgdt %0"::"m" (gdtp));
c0106c67:	0f 01 15 38 19 11 c0 	lgdtl  0xc0111938
}
c0106c6e:	c9                   	leave  
c0106c6f:	c3                   	ret    

c0106c70 <INIT_GDT>:

void INIT_GDT(void)
{
c0106c70:	55                   	push   %ebp
c0106c71:	89 e5                	mov    %esp,%ebp
c0106c73:	83 ec 14             	sub    $0x14,%esp
	set_GDT_entry(0,0,0,0,0);
c0106c76:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0106c7d:	00 
c0106c7e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0106c85:	00 
c0106c86:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0106c8d:	00 
c0106c8e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106c95:	00 
c0106c96:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0106c9d:	e8 1a ff ff ff       	call   c0106bbc <set_GDT_entry>
	set_GDT_entry(1,0,0xFFFFF,0x9A,0xC);
c0106ca2:	c7 44 24 10 0c 00 00 	movl   $0xc,0x10(%esp)
c0106ca9:	00 
c0106caa:	c7 44 24 0c 9a 00 00 	movl   $0x9a,0xc(%esp)
c0106cb1:	00 
c0106cb2:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
c0106cb9:	00 
c0106cba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106cc1:	00 
c0106cc2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0106cc9:	e8 ee fe ff ff       	call   c0106bbc <set_GDT_entry>
	set_GDT_entry(2,0,0xFFFFF,0x92,0xC);
c0106cce:	c7 44 24 10 0c 00 00 	movl   $0xc,0x10(%esp)
c0106cd5:	00 
c0106cd6:	c7 44 24 0c 92 00 00 	movl   $0x92,0xc(%esp)
c0106cdd:	00 
c0106cde:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
c0106ce5:	00 
c0106ce6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106ced:	00 
c0106cee:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c0106cf5:	e8 c2 fe ff ff       	call   c0106bbc <set_GDT_entry>
	set_GDT_entry(3,0,0xfffff,0xFA,0xC);
c0106cfa:	c7 44 24 10 0c 00 00 	movl   $0xc,0x10(%esp)
c0106d01:	00 
c0106d02:	c7 44 24 0c fa 00 00 	movl   $0xfa,0xc(%esp)
c0106d09:	00 
c0106d0a:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
c0106d11:	00 
c0106d12:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106d19:	00 
c0106d1a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0106d21:	e8 96 fe ff ff       	call   c0106bbc <set_GDT_entry>
	set_GDT_entry(4,0,0xfffff,0xF2,0xC);
c0106d26:	c7 44 24 10 0c 00 00 	movl   $0xc,0x10(%esp)
c0106d2d:	00 
c0106d2e:	c7 44 24 0c f2 00 00 	movl   $0xf2,0xc(%esp)
c0106d35:	00 
c0106d36:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
c0106d3d:	00 
c0106d3e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106d45:	00 
c0106d46:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0106d4d:	e8 6a fe ff ff       	call   c0106bbc <set_GDT_entry>
	load_gdt(4);
c0106d52:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0106d59:	e8 df fe ff ff       	call   c0106c3d <load_gdt>
	asm volatile(
c0106d5e:	66 b8 10 00          	mov    $0x10,%ax
c0106d62:	8e d8                	mov    %eax,%ds
c0106d64:	8e c0                	mov    %eax,%es
c0106d66:	8e e0                	mov    %eax,%fs
c0106d68:	8e e8                	mov    %eax,%gs
c0106d6a:	8e d0                	mov    %eax,%ss
c0106d6c:	ea 73 6d 10 c0 08 00 	ljmp   $0x8,$0xc0106d73

c0106d73 <.1>:
		"mov %ax, %gs;"
		"mov %ax, %ss;"
		"ljmp $0x8, $.1;"
		".1:;"
	);
}
c0106d73:	c9                   	leave  
c0106d74:	c3                   	ret    
c0106d75:	66 90                	xchg   %ax,%ax
c0106d77:	90                   	nop

c0106d78 <itoa_ex>:
 *  @param width 	Field width
 *  @return pointer to buffer
 */

char * itoa_ex(unsigned int value, char * str, int base, int flags, int width)
{
c0106d78:	55                   	push   %ebp
c0106d79:	89 e5                	mov    %esp,%ebp
c0106d7b:	83 ec 48             	sub    $0x48,%esp
	char *result = str;
c0106d7e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106d81:	89 45 e8             	mov    %eax,-0x18(%ebp)
	unsigned int size;
	unsigned int len = 0;
c0106d84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	unsigned int temp = 0;
c0106d8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int negative = 0;
c0106d92:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	const char *digits = "0123456789ABCDEF";
c0106d99:	c7 45 ec 9f ba 10 c0 	movl   $0xc010ba9f,-0x14(%ebp)

	if (flags & SMALL) {
c0106da0:	8b 45 14             	mov    0x14(%ebp),%eax
c0106da3:	83 e0 20             	and    $0x20,%eax
c0106da6:	85 c0                	test   %eax,%eax
c0106da8:	74 07                	je     c0106db1 <itoa_ex+0x39>
		digits = "0123456789abcdef";
c0106daa:	c7 45 ec b0 ba 10 c0 	movl   $0xc010bab0,-0x14(%ebp)
	if (value < 0) {
		value = - value;
		++negative;
	}

	temp = value;
c0106db1:	8b 45 08             	mov    0x8(%ebp),%eax
c0106db4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	do {temp /= base; ++len;} while (temp);
c0106db7:	8b 55 10             	mov    0x10(%ebp),%edx
c0106dba:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0106dbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106dc0:	ba 00 00 00 00       	mov    $0x0,%edx
c0106dc5:	f7 75 d4             	divl   -0x2c(%ebp)
c0106dc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0106dcb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0106dcf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106dd3:	75 e2                	jne    c0106db7 <itoa_ex+0x3f>
	size = len;
c0106dd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106dd8:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (!(flags & LEFT) && !(flags & ZEROPAD))
c0106ddb:	8b 45 14             	mov    0x14(%ebp),%eax
c0106dde:	83 e0 10             	and    $0x10,%eax
c0106de1:	85 c0                	test   %eax,%eax
c0106de3:	75 27                	jne    c0106e0c <itoa_ex+0x94>
c0106de5:	8b 45 14             	mov    0x14(%ebp),%eax
c0106de8:	83 e0 01             	and    $0x1,%eax
c0106deb:	85 c0                	test   %eax,%eax
c0106ded:	75 1d                	jne    c0106e0c <itoa_ex+0x94>
		while (size < width--)
c0106def:	eb 0a                	jmp    c0106dfb <itoa_ex+0x83>
			*str++ = ' ';
c0106df1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106df4:	c6 00 20             	movb   $0x20,(%eax)
c0106df7:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	temp = value;
	do {temp /= base; ++len;} while (temp);
	size = len;

	if (!(flags & LEFT) && !(flags & ZEROPAD))
		while (size < width--)
c0106dfb:	8b 45 18             	mov    0x18(%ebp),%eax
c0106dfe:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0106e01:	0f 97 c0             	seta   %al
c0106e04:	83 6d 18 01          	subl   $0x1,0x18(%ebp)
c0106e08:	84 c0                	test   %al,%al
c0106e0a:	75 e5                	jne    c0106df1 <itoa_ex+0x79>
			*str++ = ' ';

	if (negative) {
c0106e0c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0106e10:	74 0c                	je     c0106e1e <itoa_ex+0xa6>
		*str++ = '-';
c0106e12:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106e15:	c6 00 2d             	movb   $0x2d,(%eax)
c0106e18:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0106e1c:	eb 14                	jmp    c0106e32 <itoa_ex+0xba>
	} else if (flags & PLUS) {
c0106e1e:	8b 45 14             	mov    0x14(%ebp),%eax
c0106e21:	83 e0 04             	and    $0x4,%eax
c0106e24:	85 c0                	test   %eax,%eax
c0106e26:	74 0a                	je     c0106e32 <itoa_ex+0xba>
		*str++ = '+';
c0106e28:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106e2b:	c6 00 2b             	movb   $0x2b,(%eax)
c0106e2e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	}
	if (flags & SPECIAL) {
c0106e32:	8b 45 14             	mov    0x14(%ebp),%eax
c0106e35:	83 e0 40             	and    $0x40,%eax
c0106e38:	85 c0                	test   %eax,%eax
c0106e3a:	74 18                	je     c0106e54 <itoa_ex+0xdc>
		*str++ = '0'; *str++ = 'x';
c0106e3c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106e3f:	c6 00 30             	movb   $0x30,(%eax)
c0106e42:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0106e46:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106e49:	c6 00 78             	movb   $0x78,(%eax)
c0106e4c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		width -= 2;
c0106e50:	83 6d 18 02          	subl   $0x2,0x18(%ebp)
	}

	if (!(flags & LEFT) && (flags & ZEROPAD))
c0106e54:	8b 45 14             	mov    0x14(%ebp),%eax
c0106e57:	83 e0 10             	and    $0x10,%eax
c0106e5a:	85 c0                	test   %eax,%eax
c0106e5c:	75 27                	jne    c0106e85 <itoa_ex+0x10d>
c0106e5e:	8b 45 14             	mov    0x14(%ebp),%eax
c0106e61:	83 e0 01             	and    $0x1,%eax
c0106e64:	85 c0                	test   %eax,%eax
c0106e66:	74 1d                	je     c0106e85 <itoa_ex+0x10d>
		while (size < width--)
c0106e68:	eb 0a                	jmp    c0106e74 <itoa_ex+0xfc>
			*str++ = '0';
c0106e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106e6d:	c6 00 30             	movb   $0x30,(%eax)
c0106e70:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		*str++ = '0'; *str++ = 'x';
		width -= 2;
	}

	if (!(flags & LEFT) && (flags & ZEROPAD))
		while (size < width--)
c0106e74:	8b 45 18             	mov    0x18(%ebp),%eax
c0106e77:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0106e7a:	0f 97 c0             	seta   %al
c0106e7d:	83 6d 18 01          	subl   $0x1,0x18(%ebp)
c0106e81:	84 c0                	test   %al,%al
c0106e83:	75 e5                	jne    c0106e6a <itoa_ex+0xf2>
			*str++ = '0';

	do {
		int power = powi(base, --len);
c0106e85:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0106e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106e8c:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106e90:	8b 45 10             	mov    0x10(%ebp),%eax
c0106e93:	89 04 24             	mov    %eax,(%esp)
c0106e96:	e8 fa 1c 00 00       	call   c0108b95 <powi>
c0106e9b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int digit = value / power;
c0106e9e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0106ea1:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0106ea4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ea7:	ba 00 00 00 00       	mov    $0x0,%edx
c0106eac:	f7 75 d4             	divl   -0x2c(%ebp)
c0106eaf:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*str++ = digits[digit];
c0106eb2:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0106eb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106eb8:	01 d0                	add    %edx,%eax
c0106eba:	0f b6 10             	movzbl (%eax),%edx
c0106ebd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106ec0:	88 10                	mov    %dl,(%eax)
c0106ec2:	83 45 0c 01          	addl   $0x1,0xc(%ebp)

		value -= digit * power;
c0106ec6:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106ec9:	0f af 45 dc          	imul   -0x24(%ebp),%eax
c0106ecd:	29 45 08             	sub    %eax,0x8(%ebp)
	} while (len > 0);
c0106ed0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106ed4:	75 af                	jne    c0106e85 <itoa_ex+0x10d>

	while (size < width--)
c0106ed6:	eb 0a                	jmp    c0106ee2 <itoa_ex+0x16a>
		*str++ = ' ';
c0106ed8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106edb:	c6 00 20             	movb   $0x20,(%eax)
c0106ede:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		*str++ = digits[digit];

		value -= digit * power;
	} while (len > 0);

	while (size < width--)
c0106ee2:	8b 45 18             	mov    0x18(%ebp),%eax
c0106ee5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0106ee8:	0f 97 c0             	seta   %al
c0106eeb:	83 6d 18 01          	subl   $0x1,0x18(%ebp)
c0106eef:	84 c0                	test   %al,%al
c0106ef1:	75 e5                	jne    c0106ed8 <itoa_ex+0x160>
		*str++ = ' ';

	*str++ = '\0';
c0106ef3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106ef6:	c6 00 00             	movb   $0x0,(%eax)
c0106ef9:	83 45 0c 01          	addl   $0x1,0xc(%ebp)

	return result;
c0106efd:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c0106f00:	c9                   	leave  
c0106f01:	c3                   	ret    

c0106f02 <itoa>:
 *  @param base     numerical base (10 = decimal, 16 = hexadecimal)
 *  @return pointer to buffer
 */

inline char * itoa(unsigned int value, char * str, int base)
{
c0106f02:	55                   	push   %ebp
c0106f03:	89 e5                	mov    %esp,%ebp
c0106f05:	83 ec 28             	sub    $0x28,%esp
	return itoa_ex(value, str, base, 0, 1);
c0106f08:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
c0106f0f:	00 
c0106f10:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0106f17:	00 
c0106f18:	8b 45 10             	mov    0x10(%ebp),%eax
c0106f1b:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106f1f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106f22:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106f26:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f29:	89 04 24             	mov    %eax,(%esp)
c0106f2c:	e8 47 fe ff ff       	call   c0106d78 <itoa_ex>
}
c0106f31:	c9                   	leave  
c0106f32:	c3                   	ret    

c0106f33 <atoi>:
 *  @param  str  input string
 *  @return integer value
 */

int atoi(const char *str)
{
c0106f33:	55                   	push   %ebp
c0106f34:	89 e5                	mov    %esp,%ebp
c0106f36:	83 ec 28             	sub    $0x28,%esp
	int result = 0;
c0106f39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int length = 0;
c0106f40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	while (isdigit(*str++))
c0106f47:	eb 04                	jmp    c0106f4d <atoi+0x1a>
		++length;
c0106f49:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
int atoi(const char *str)
{
	int result = 0;
	int length = 0;

	while (isdigit(*str++))
c0106f4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f50:	0f b6 00             	movzbl (%eax),%eax
c0106f53:	0f be c0             	movsbl %al,%eax
c0106f56:	83 e8 30             	sub    $0x30,%eax
c0106f59:	83 f8 09             	cmp    $0x9,%eax
c0106f5c:	0f 96 c0             	setbe  %al
c0106f5f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0106f63:	84 c0                	test   %al,%al
c0106f65:	75 e2                	jne    c0106f49 <atoi+0x16>
		++length;

	str -= length + 1;
c0106f67:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f6a:	f7 d0                	not    %eax
c0106f6c:	01 45 08             	add    %eax,0x8(%ebp)

	while (length > 0)
c0106f6f:	eb 2d                	jmp    c0106f9e <atoi+0x6b>
		result += powi(10, --length) * (*str++ - '0');
c0106f71:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0106f75:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f78:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106f7c:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0106f83:	e8 0d 1c 00 00       	call   c0108b95 <powi>
c0106f88:	8b 55 08             	mov    0x8(%ebp),%edx
c0106f8b:	0f b6 12             	movzbl (%edx),%edx
c0106f8e:	0f be d2             	movsbl %dl,%edx
c0106f91:	83 ea 30             	sub    $0x30,%edx
c0106f94:	0f af c2             	imul   %edx,%eax
c0106f97:	01 45 f4             	add    %eax,-0xc(%ebp)
c0106f9a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
	while (isdigit(*str++))
		++length;

	str -= length + 1;

	while (length > 0)
c0106f9e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106fa2:	7f cd                	jg     c0106f71 <atoi+0x3e>
		result += powi(10, --length) * (*str++ - '0');

	return result;
c0106fa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106fa7:	c9                   	leave  
c0106fa8:	c3                   	ret    
c0106fa9:	66 90                	xchg   %ax,%ax
c0106fab:	90                   	nop

c0106fac <INIT_PAGING>:
 * Initalize paging
 *
 * @param void
 * @return void
 */
void INIT_PAGING(struct multiboot_struct *mb_info) {
c0106fac:	55                   	push   %ebp
c0106fad:	89 e5                	mov    %esp,%ebp
c0106faf:	83 ec 18             	sub    $0x18,%esp
	install_exc(0xe, page_fault_handler);
c0106fb2:	c7 44 24 04 e3 64 10 	movl   $0xc01064e3,0x4(%esp)
c0106fb9:	c0 
c0106fba:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c0106fc1:	e8 ec d2 ff ff       	call   c01042b2 <install_exc>
	ARCH_INIT_PAGING(mb_info);
c0106fc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fc9:	89 04 24             	mov    %eax,(%esp)
c0106fcc:	e8 27 ed ff ff       	call   c0105cf8 <ARCH_INIT_PAGING>
}
c0106fd1:	c9                   	leave  
c0106fd2:	c3                   	ret    

c0106fd3 <vmm_create_context>:

/**
 * Create & Destroy
 */
void vmm_create_context(vmm_context_t *context) {
c0106fd3:	55                   	push   %ebp
c0106fd4:	89 e5                	mov    %esp,%ebp
c0106fd6:	83 ec 08             	sub    $0x8,%esp
	context->arch_context = arch_vmm_create_context();
c0106fd9:	e8 9e ee ff ff       	call   c0105e7c <arch_vmm_create_context>
c0106fde:	89 c2                	mov    %eax,%edx
c0106fe0:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fe3:	89 10                	mov    %edx,(%eax)
}
c0106fe5:	c9                   	leave  
c0106fe6:	c3                   	ret    

c0106fe7 <vmm_destroy_context>:

void vmm_destroy_context(vmm_context_t *context) {
c0106fe7:	55                   	push   %ebp
c0106fe8:	89 e5                	mov    %esp,%ebp
c0106fea:	83 ec 18             	sub    $0x18,%esp
	arch_vmm_destroy_context(context->arch_context);
c0106fed:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ff0:	8b 00                	mov    (%eax),%eax
c0106ff2:	89 04 24             	mov    %eax,(%esp)
c0106ff5:	e8 3f ef ff ff       	call   c0105f39 <arch_vmm_destroy_context>
}
c0106ffa:	c9                   	leave  
c0106ffb:	c3                   	ret    

c0106ffc <vmm_switch_context>:

void vmm_switch_context(vmm_context_t *context) {
c0106ffc:	55                   	push   %ebp
c0106ffd:	89 e5                	mov    %esp,%ebp
c0106fff:	83 ec 18             	sub    $0x18,%esp
	arch_update_context(context->arch_context);
c0107002:	8b 45 08             	mov    0x8(%ebp),%eax
c0107005:	8b 00                	mov    (%eax),%eax
c0107007:	89 04 24             	mov    %eax,(%esp)
c010700a:	e8 83 ef ff ff       	call   c0105f92 <arch_update_context>
	current_context = context;
c010700f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107012:	a3 40 19 11 c0       	mov    %eax,0xc0111940
	arch_switch_context(context->arch_context);
c0107017:	8b 45 08             	mov    0x8(%ebp),%eax
c010701a:	8b 00                	mov    (%eax),%eax
c010701c:	89 04 24             	mov    %eax,(%esp)
c010701f:	e8 b1 f4 ff ff       	call   c01064d5 <arch_switch_context>
}
c0107024:	c9                   	leave  
c0107025:	c3                   	ret    

c0107026 <vmm_map>:

/**
 * Map a physical address to a virtual adress
 */
int vmm_map(vmm_context_t *context, paddr_t pframe, vaddr_t vframe, uint8_t flags) {
c0107026:	55                   	push   %ebp
c0107027:	89 e5                	mov    %esp,%ebp
c0107029:	83 ec 28             	sub    $0x28,%esp
c010702c:	8b 45 14             	mov    0x14(%ebp),%eax
c010702f:	88 45 f4             	mov    %al,-0xc(%ebp)
	return arch_map(context->arch_context, pframe, vframe, flags);
c0107032:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0107036:	8b 45 08             	mov    0x8(%ebp),%eax
c0107039:	8b 00                	mov    (%eax),%eax
c010703b:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010703f:	8b 55 10             	mov    0x10(%ebp),%edx
c0107042:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107046:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107049:	89 54 24 04          	mov    %edx,0x4(%esp)
c010704d:	89 04 24             	mov    %eax,(%esp)
c0107050:	e8 14 f1 ff ff       	call   c0106169 <arch_map>
}
c0107055:	c9                   	leave  
c0107056:	c3                   	ret    

c0107057 <vmm_unmap>:

int vmm_unmap(vmm_context_t *context, vaddr_t frame) {
c0107057:	55                   	push   %ebp
c0107058:	89 e5                	mov    %esp,%ebp
c010705a:	83 ec 18             	sub    $0x18,%esp
	return arch_unmap(context->arch_context, frame);
c010705d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107060:	8b 00                	mov    (%eax),%eax
c0107062:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107065:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107069:	89 04 24             	mov    %eax,(%esp)
c010706c:	e8 24 f2 ff ff       	call   c0106295 <arch_unmap>
}
c0107071:	c9                   	leave  
c0107072:	c3                   	ret    

c0107073 <vmm_map_range>:

/**
 * Range
 */
int vmm_map_range(vmm_context_t *context, paddr_t pframe, vaddr_t vframe, int pages, uint8_t flags) {
c0107073:	55                   	push   %ebp
c0107074:	89 e5                	mov    %esp,%ebp
c0107076:	53                   	push   %ebx
c0107077:	83 ec 34             	sub    $0x34,%esp
c010707a:	8b 45 18             	mov    0x18(%ebp),%eax
c010707d:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int p;
	for (p = 0; p < pages; ++p) {
c0107080:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0107087:	eb 3c                	jmp    c01070c5 <vmm_map_range+0x52>
		vmm_map(context->arch_context, pframe + PAGE_FRAME_ADDR(p), vframe + PAGE_FRAME_ADDR(p), flags);
c0107089:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c010708d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107090:	c1 e0 0c             	shl    $0xc,%eax
c0107093:	89 c1                	mov    %eax,%ecx
c0107095:	8b 45 10             	mov    0x10(%ebp),%eax
c0107098:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
c010709b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010709e:	c1 e0 0c             	shl    $0xc,%eax
c01070a1:	89 c1                	mov    %eax,%ecx
c01070a3:	8b 45 0c             	mov    0xc(%ebp),%eax
c01070a6:	01 c1                	add    %eax,%ecx
c01070a8:	8b 45 08             	mov    0x8(%ebp),%eax
c01070ab:	8b 00                	mov    (%eax),%eax
c01070ad:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01070b1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c01070b5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c01070b9:	89 04 24             	mov    %eax,(%esp)
c01070bc:	e8 65 ff ff ff       	call   c0107026 <vmm_map>
/**
 * Range
 */
int vmm_map_range(vmm_context_t *context, paddr_t pframe, vaddr_t vframe, int pages, uint8_t flags) {
	int p;
	for (p = 0; p < pages; ++p) {
c01070c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01070c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070c8:	3b 45 14             	cmp    0x14(%ebp),%eax
c01070cb:	7c bc                	jl     c0107089 <vmm_map_range+0x16>
		vmm_map(context->arch_context, pframe + PAGE_FRAME_ADDR(p), vframe + PAGE_FRAME_ADDR(p), flags);
	}
	return 0;
c01070cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01070d2:	83 c4 34             	add    $0x34,%esp
c01070d5:	5b                   	pop    %ebx
c01070d6:	5d                   	pop    %ebp
c01070d7:	c3                   	ret    

c01070d8 <vmm_unmap_range>:

int vmm_unmap_range(vmm_context_t *context, vaddr_t frame, int pages) {
c01070d8:	55                   	push   %ebp
c01070d9:	89 e5                	mov    %esp,%ebp
c01070db:	83 ec 28             	sub    $0x28,%esp
	int p;
	for(p = 0; p < pages; p++) {
c01070de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01070e5:	eb 20                	jmp    c0107107 <vmm_unmap_range+0x2f>
		vmm_unmap(context, frame + PAGE_FRAME_ADDR(p));
c01070e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070ea:	c1 e0 0c             	shl    $0xc,%eax
c01070ed:	89 c2                	mov    %eax,%edx
c01070ef:	8b 45 0c             	mov    0xc(%ebp),%eax
c01070f2:	01 d0                	add    %edx,%eax
c01070f4:	89 44 24 04          	mov    %eax,0x4(%esp)
c01070f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01070fb:	89 04 24             	mov    %eax,(%esp)
c01070fe:	e8 54 ff ff ff       	call   c0107057 <vmm_unmap>
	return 0;
}

int vmm_unmap_range(vmm_context_t *context, vaddr_t frame, int pages) {
	int p;
	for(p = 0; p < pages; p++) {
c0107103:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0107107:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010710a:	3b 45 10             	cmp    0x10(%ebp),%eax
c010710d:	7c d8                	jl     c01070e7 <vmm_unmap_range+0xf>
		vmm_unmap(context, frame + PAGE_FRAME_ADDR(p));
	}
	return 0;
c010710f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107114:	c9                   	leave  
c0107115:	c3                   	ret    

c0107116 <vmm_automap_kernel>:

/**
 * Automap
 */
vaddr_t vmm_automap_kernel(vmm_context_t *context, paddr_t pframe, uint8_t flags) {
c0107116:	55                   	push   %ebp
c0107117:	89 e5                	mov    %esp,%ebp
c0107119:	83 ec 48             	sub    $0x48,%esp
c010711c:	8b 45 10             	mov    0x10(%ebp),%eax
c010711f:	88 45 e4             	mov    %al,-0x1c(%ebp)
	vaddr_t vframe = arch_vaddr_find(context->arch_context, 1,
c0107122:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0107126:	8b 45 08             	mov    0x8(%ebp),%eax
c0107129:	8b 00                	mov    (%eax),%eax
c010712b:	89 54 24 10          	mov    %edx,0x10(%esp)
c010712f:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c0107136:	ff 
c0107137:	c7 44 24 08 00 00 00 	movl   $0xc2000000,0x8(%esp)
c010713e:	c2 
c010713f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0107146:	00 
c0107147:	89 04 24             	mov    %eax,(%esp)
c010714a:	e8 e6 f1 ff ff       	call   c0106335 <arch_vaddr_find>
c010714f:	89 45 f4             	mov    %eax,-0xc(%ebp)
				    MEMORY_LAYOUT_RESERVED_AREA_END,
				    MEMORY_LAYOUT_KERNEL_END, flags);
	vmm_map(context, pframe, vframe, flags | VMM_PRESENT);
c0107152:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0107156:	83 c8 01             	or     $0x1,%eax
c0107159:	0f b6 c0             	movzbl %al,%eax
c010715c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0107160:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107163:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107167:	8b 45 0c             	mov    0xc(%ebp),%eax
c010716a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010716e:	8b 45 08             	mov    0x8(%ebp),%eax
c0107171:	89 04 24             	mov    %eax,(%esp)
c0107174:	e8 ad fe ff ff       	call   c0107026 <vmm_map>

	return vframe;
c0107179:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010717c:	c9                   	leave  
c010717d:	c3                   	ret    

c010717e <vmm_automap_kernel_range>:

vaddr_t vmm_automap_kernel_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags) {
c010717e:	55                   	push   %ebp
c010717f:	89 e5                	mov    %esp,%ebp
c0107181:	83 ec 48             	sub    $0x48,%esp
c0107184:	8b 45 14             	mov    0x14(%ebp),%eax
c0107187:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int i;
	vaddr_t vaddr_start = arch_vaddr_find(context->arch_context, pages, MEMORY_LAYOUT_RESERVED_AREA_END, MEMORY_LAYOUT_KERNEL_END, flags);
c010718a:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c010718e:	8b 45 08             	mov    0x8(%ebp),%eax
c0107191:	8b 00                	mov    (%eax),%eax
c0107193:	89 54 24 10          	mov    %edx,0x10(%esp)
c0107197:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c010719e:	ff 
c010719f:	c7 44 24 08 00 00 00 	movl   $0xc2000000,0x8(%esp)
c01071a6:	c2 
c01071a7:	8b 55 10             	mov    0x10(%ebp),%edx
c01071aa:	89 54 24 04          	mov    %edx,0x4(%esp)
c01071ae:	89 04 24             	mov    %eax,(%esp)
c01071b1:	e8 7f f1 ff ff       	call   c0106335 <arch_vaddr_find>
c01071b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < pages; i++) {
c01071b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01071c0:	eb 45                	jmp    c0107207 <vmm_automap_kernel_range+0x89>
		paddr_t paddr = pframe + i*PAGE_SIZE;
c01071c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01071c5:	c1 e0 0c             	shl    $0xc,%eax
c01071c8:	89 c2                	mov    %eax,%edx
c01071ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c01071cd:	01 d0                	add    %edx,%eax
c01071cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
c01071d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01071d5:	c1 e0 0c             	shl    $0xc,%eax
c01071d8:	89 c2                	mov    %eax,%edx
c01071da:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01071dd:	01 d0                	add    %edx,%eax
c01071df:	89 45 e8             	mov    %eax,-0x18(%ebp)
		vmm_map(context, paddr, vaddr, flags);
c01071e2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c01071e6:	89 44 24 0c          	mov    %eax,0xc(%esp)
c01071ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01071ed:	89 44 24 08          	mov    %eax,0x8(%esp)
c01071f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01071f4:	89 44 24 04          	mov    %eax,0x4(%esp)
c01071f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01071fb:	89 04 24             	mov    %eax,(%esp)
c01071fe:	e8 23 fe ff ff       	call   c0107026 <vmm_map>
}

vaddr_t vmm_automap_kernel_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags) {
	int i;
	vaddr_t vaddr_start = arch_vaddr_find(context->arch_context, pages, MEMORY_LAYOUT_RESERVED_AREA_END, MEMORY_LAYOUT_KERNEL_END, flags);
	for(i = 0; i < pages; i++) {
c0107203:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0107207:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010720a:	3b 45 10             	cmp    0x10(%ebp),%eax
c010720d:	7c b3                	jl     c01071c2 <vmm_automap_kernel_range+0x44>
		paddr_t paddr = pframe + i*PAGE_SIZE;
		vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
		vmm_map(context, paddr, vaddr, flags);
	}

	return vaddr_start;
c010720f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0107212:	c9                   	leave  
c0107213:	c3                   	ret    

c0107214 <vmm_automap_user>:

vaddr_t vmm_automap_user(vmm_context_t *context, paddr_t pframe, uint8_t flags) {
c0107214:	55                   	push   %ebp
c0107215:	89 e5                	mov    %esp,%ebp
c0107217:	83 ec 48             	sub    $0x48,%esp
c010721a:	8b 45 10             	mov    0x10(%ebp),%eax
c010721d:	88 45 e4             	mov    %al,-0x1c(%ebp)
	vaddr_t vframe = arch_vaddr_find(context->arch_context, 1,
c0107220:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0107224:	8b 45 08             	mov    0x8(%ebp),%eax
c0107227:	8b 00                	mov    (%eax),%eax
c0107229:	89 54 24 10          	mov    %edx,0x10(%esp)
c010722d:	c7 44 24 0c 00 00 00 	movl   $0xc0000000,0xc(%esp)
c0107234:	c0 
c0107235:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010723c:	00 
c010723d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0107244:	00 
c0107245:	89 04 24             	mov    %eax,(%esp)
c0107248:	e8 e8 f0 ff ff       	call   c0106335 <arch_vaddr_find>
c010724d:	89 45 f4             	mov    %eax,-0xc(%ebp)
				    0x0, MEMORY_LAYOUT_KERNEL_START, flags);
	vmm_map(context, pframe, vframe, flags | VMM_PRESENT);
c0107250:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0107254:	83 c8 01             	or     $0x1,%eax
c0107257:	0f b6 c0             	movzbl %al,%eax
c010725a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010725e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107261:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107265:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107268:	89 44 24 04          	mov    %eax,0x4(%esp)
c010726c:	8b 45 08             	mov    0x8(%ebp),%eax
c010726f:	89 04 24             	mov    %eax,(%esp)
c0107272:	e8 af fd ff ff       	call   c0107026 <vmm_map>

	return vframe;
c0107277:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010727a:	c9                   	leave  
c010727b:	c3                   	ret    

c010727c <vmm_automap_user_range>:

vaddr_t vmm_automap_user_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags) {
c010727c:	55                   	push   %ebp
c010727d:	89 e5                	mov    %esp,%ebp
c010727f:	83 ec 48             	sub    $0x48,%esp
c0107282:	8b 45 14             	mov    0x14(%ebp),%eax
c0107285:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int i;
	vaddr_t vaddr_start = arch_vaddr_find(context->arch_context, pages, 0x0, MEMORY_LAYOUT_KERNEL_START, flags);
c0107288:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c010728c:	8b 45 08             	mov    0x8(%ebp),%eax
c010728f:	8b 00                	mov    (%eax),%eax
c0107291:	89 54 24 10          	mov    %edx,0x10(%esp)
c0107295:	c7 44 24 0c 00 00 00 	movl   $0xc0000000,0xc(%esp)
c010729c:	c0 
c010729d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c01072a4:	00 
c01072a5:	8b 55 10             	mov    0x10(%ebp),%edx
c01072a8:	89 54 24 04          	mov    %edx,0x4(%esp)
c01072ac:	89 04 24             	mov    %eax,(%esp)
c01072af:	e8 81 f0 ff ff       	call   c0106335 <arch_vaddr_find>
c01072b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < pages; i++) {
c01072b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01072be:	eb 45                	jmp    c0107305 <vmm_automap_user_range+0x89>
		paddr_t paddr = pframe + i*PAGE_SIZE;
c01072c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072c3:	c1 e0 0c             	shl    $0xc,%eax
c01072c6:	89 c2                	mov    %eax,%edx
c01072c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c01072cb:	01 d0                	add    %edx,%eax
c01072cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
c01072d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072d3:	c1 e0 0c             	shl    $0xc,%eax
c01072d6:	89 c2                	mov    %eax,%edx
c01072d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01072db:	01 d0                	add    %edx,%eax
c01072dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		vmm_map(context, paddr, vaddr, flags);
c01072e0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c01072e4:	89 44 24 0c          	mov    %eax,0xc(%esp)
c01072e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01072eb:	89 44 24 08          	mov    %eax,0x8(%esp)
c01072ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01072f2:	89 44 24 04          	mov    %eax,0x4(%esp)
c01072f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01072f9:	89 04 24             	mov    %eax,(%esp)
c01072fc:	e8 25 fd ff ff       	call   c0107026 <vmm_map>
}

vaddr_t vmm_automap_user_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags) {
	int i;
	vaddr_t vaddr_start = arch_vaddr_find(context->arch_context, pages, 0x0, MEMORY_LAYOUT_KERNEL_START, flags);
	for(i = 0; i < pages; i++) {
c0107301:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0107305:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107308:	3b 45 10             	cmp    0x10(%ebp),%eax
c010730b:	7c b3                	jl     c01072c0 <vmm_automap_user_range+0x44>
		paddr_t paddr = pframe + i*PAGE_SIZE;
		vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
		vmm_map(context, paddr, vaddr, flags);
	}

	return vaddr_start;
c010730d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0107310:	c9                   	leave  
c0107311:	c3                   	ret    
c0107312:	66 90                	xchg   %ax,%ax

c0107314 <halt>:

#include <idt.h>
#include <cpu.h>
#include <printf.h>

void halt(void) {
c0107314:	55                   	push   %ebp
c0107315:	89 e5                	mov    %esp,%ebp
	while (1) {
		asm volatile("cli; hlt");
c0107317:	fa                   	cli    
c0107318:	f4                   	hlt    
	}
c0107319:	eb fc                	jmp    c0107317 <halt+0x3>

c010731b <cpu_dump>:
	"Reserved",                "Reserved",                      "Reserved",                  "Reserved",
	"Reserved",                "Reserved",                      "Reserved",                  "Reserved"
};

int cpu_dump(struct cpu_state* cpu, char *str)
{
c010731b:	55                   	push   %ebp
c010731c:	89 e5                	mov    %esp,%ebp
c010731e:	53                   	push   %ebx
c010731f:	83 ec 24             	sub    $0x24,%esp
	int len = 0;
c0107322:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	len += sprintf(str + len, "EAX:  %#010X    EBX:     %#010X\n",  cpu->eax, 	cpu->ebx);
c0107329:	8b 45 08             	mov    0x8(%ebp),%eax
c010732c:	8b 50 1c             	mov    0x1c(%eax),%edx
c010732f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107332:	8b 40 28             	mov    0x28(%eax),%eax
c0107335:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0107338:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010733b:	01 d9                	add    %ebx,%ecx
c010733d:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0107341:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107345:	c7 44 24 04 14 bc 10 	movl   $0xc010bc14,0x4(%esp)
c010734c:	c0 
c010734d:	89 0c 24             	mov    %ecx,(%esp)
c0107350:	e8 94 e0 ff ff       	call   c01053e9 <sprintf>
c0107355:	01 45 f4             	add    %eax,-0xc(%ebp)
	len += sprintf(str + len, "ECX:  %#010X    EDX:     %#010X\n",  cpu->ecx, 	cpu->edx);
c0107358:	8b 45 08             	mov    0x8(%ebp),%eax
c010735b:	8b 50 20             	mov    0x20(%eax),%edx
c010735e:	8b 45 08             	mov    0x8(%ebp),%eax
c0107361:	8b 40 24             	mov    0x24(%eax),%eax
c0107364:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0107367:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010736a:	01 d9                	add    %ebx,%ecx
c010736c:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0107370:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107374:	c7 44 24 04 38 bc 10 	movl   $0xc010bc38,0x4(%esp)
c010737b:	c0 
c010737c:	89 0c 24             	mov    %ecx,(%esp)
c010737f:	e8 65 e0 ff ff       	call   c01053e9 <sprintf>
c0107384:	01 45 f4             	add    %eax,-0xc(%ebp)
	len += sprintf(str + len, "ESI:  %#010X    EDI:     %#010X\n",  cpu->esi, 	cpu->edi);
c0107387:	8b 45 08             	mov    0x8(%ebp),%eax
c010738a:	8b 50 10             	mov    0x10(%eax),%edx
c010738d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107390:	8b 40 14             	mov    0x14(%eax),%eax
c0107393:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0107396:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0107399:	01 d9                	add    %ebx,%ecx
c010739b:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010739f:	89 44 24 08          	mov    %eax,0x8(%esp)
c01073a3:	c7 44 24 04 5c bc 10 	movl   $0xc010bc5c,0x4(%esp)
c01073aa:	c0 
c01073ab:	89 0c 24             	mov    %ecx,(%esp)
c01073ae:	e8 36 e0 ff ff       	call   c01053e9 <sprintf>
c01073b3:	01 45 f4             	add    %eax,-0xc(%ebp)
	len += sprintf(str + len, "ESP:  %#010X    EBP:     %#010X\n",  cpu->esp, 	cpu->ebp);
c01073b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01073b9:	8b 50 18             	mov    0x18(%eax),%edx
c01073bc:	8b 45 08             	mov    0x8(%ebp),%eax
c01073bf:	8b 40 40             	mov    0x40(%eax),%eax
c01073c2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c01073c5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c01073c8:	01 d9                	add    %ebx,%ecx
c01073ca:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01073ce:	89 44 24 08          	mov    %eax,0x8(%esp)
c01073d2:	c7 44 24 04 80 bc 10 	movl   $0xc010bc80,0x4(%esp)
c01073d9:	c0 
c01073da:	89 0c 24             	mov    %ecx,(%esp)
c01073dd:	e8 07 e0 ff ff       	call   c01053e9 <sprintf>
c01073e2:	01 45 f4             	add    %eax,-0xc(%ebp)
	len += sprintf(str + len, "CS:   %#010X    DS:      %#010X\n",  cpu->cs, 	cpu->ds);
c01073e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01073e8:	8b 50 0c             	mov    0xc(%eax),%edx
c01073eb:	8b 45 08             	mov    0x8(%ebp),%eax
c01073ee:	8b 40 38             	mov    0x38(%eax),%eax
c01073f1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c01073f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c01073f7:	01 d9                	add    %ebx,%ecx
c01073f9:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01073fd:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107401:	c7 44 24 04 a4 bc 10 	movl   $0xc010bca4,0x4(%esp)
c0107408:	c0 
c0107409:	89 0c 24             	mov    %ecx,(%esp)
c010740c:	e8 d8 df ff ff       	call   c01053e9 <sprintf>
c0107411:	01 45 f4             	add    %eax,-0xc(%ebp)
	len += sprintf(str + len, "SS:   %#010X    ES:      %#010X\n",  cpu->ss, 	cpu->es);
c0107414:	8b 45 08             	mov    0x8(%ebp),%eax
c0107417:	8b 50 08             	mov    0x8(%eax),%edx
c010741a:	8b 45 08             	mov    0x8(%ebp),%eax
c010741d:	8b 40 44             	mov    0x44(%eax),%eax
c0107420:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0107423:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0107426:	01 d9                	add    %ebx,%ecx
c0107428:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010742c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107430:	c7 44 24 04 c8 bc 10 	movl   $0xc010bcc8,0x4(%esp)
c0107437:	c0 
c0107438:	89 0c 24             	mov    %ecx,(%esp)
c010743b:	e8 a9 df ff ff       	call   c01053e9 <sprintf>
c0107440:	01 45 f4             	add    %eax,-0xc(%ebp)
	len += sprintf(str + len, "GS:   %#010X    FS:      %#010X\n",  cpu->gs, 	cpu->fs);
c0107443:	8b 45 08             	mov    0x8(%ebp),%eax
c0107446:	8b 50 04             	mov    0x4(%eax),%edx
c0107449:	8b 45 08             	mov    0x8(%ebp),%eax
c010744c:	8b 00                	mov    (%eax),%eax
c010744e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0107451:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0107454:	01 d9                	add    %ebx,%ecx
c0107456:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010745a:	89 44 24 08          	mov    %eax,0x8(%esp)
c010745e:	c7 44 24 04 ec bc 10 	movl   $0xc010bcec,0x4(%esp)
c0107465:	c0 
c0107466:	89 0c 24             	mov    %ecx,(%esp)
c0107469:	e8 7b df ff ff       	call   c01053e9 <sprintf>
c010746e:	01 45 f4             	add    %eax,-0xc(%ebp)
	len += sprintf(str + len, "EIP:  %#010X    EFLAGS:  %#010X\n",  cpu->eip, 	cpu->eflags);
c0107471:	8b 45 08             	mov    0x8(%ebp),%eax
c0107474:	8b 50 3c             	mov    0x3c(%eax),%edx
c0107477:	8b 45 08             	mov    0x8(%ebp),%eax
c010747a:	8b 40 34             	mov    0x34(%eax),%eax
c010747d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c0107480:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0107483:	01 d9                	add    %ebx,%ecx
c0107485:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0107489:	89 44 24 08          	mov    %eax,0x8(%esp)
c010748d:	c7 44 24 04 10 bd 10 	movl   $0xc010bd10,0x4(%esp)
c0107494:	c0 
c0107495:	89 0c 24             	mov    %ecx,(%esp)
c0107498:	e8 4c df ff ff       	call   c01053e9 <sprintf>
c010749d:	01 45 f4             	add    %eax,-0xc(%ebp)

	return len;
c01074a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01074a3:	83 c4 24             	add    $0x24,%esp
c01074a6:	5b                   	pop    %ebx
c01074a7:	5d                   	pop    %ebp
c01074a8:	c3                   	ret    

c01074a9 <panic>:


void panic(char *message)
{
c01074a9:	55                   	push   %ebp
c01074aa:	89 e5                	mov    %esp,%ebp
c01074ac:	57                   	push   %edi
c01074ad:	56                   	push   %esi
c01074ae:	53                   	push   %ebx
c01074af:	81 ec 2c 04 00 00    	sub    $0x42c,%esp
	char buffer[1024];
	int lines = 8;
c01074b5:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
	int len = 0;
c01074bc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	int i;
	len += sprintf(buffer + len, "      %c", 201);
c01074c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01074c6:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01074cc:	01 d0                	add    %edx,%eax
c01074ce:	c7 44 24 08 c9 00 00 	movl   $0xc9,0x8(%esp)
c01074d5:	00 
c01074d6:	c7 44 24 04 31 bd 10 	movl   $0xc010bd31,0x4(%esp)
c01074dd:	c0 
c01074de:	89 04 24             	mov    %eax,(%esp)
c01074e1:	e8 03 df ff ff       	call   c01053e9 <sprintf>
c01074e6:	01 45 e0             	add    %eax,-0x20(%ebp)
	for(i=0;i<66;i++) len += sprintf(buffer + len, "%c", 205);
c01074e9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c01074f0:	eb 2a                	jmp    c010751c <panic+0x73>
c01074f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01074f5:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01074fb:	01 d0                	add    %edx,%eax
c01074fd:	c7 44 24 08 cd 00 00 	movl   $0xcd,0x8(%esp)
c0107504:	00 
c0107505:	c7 44 24 04 3a bd 10 	movl   $0xc010bd3a,0x4(%esp)
c010750c:	c0 
c010750d:	89 04 24             	mov    %eax,(%esp)
c0107510:	e8 d4 de ff ff       	call   c01053e9 <sprintf>
c0107515:	01 45 e0             	add    %eax,-0x20(%ebp)
c0107518:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c010751c:	83 7d dc 41          	cmpl   $0x41,-0x24(%ebp)
c0107520:	7e d0                	jle    c01074f2 <panic+0x49>
	len += sprintf(buffer + len, "%c      \n", 187);
c0107522:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107525:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c010752b:	01 d0                	add    %edx,%eax
c010752d:	c7 44 24 08 bb 00 00 	movl   $0xbb,0x8(%esp)
c0107534:	00 
c0107535:	c7 44 24 04 3d bd 10 	movl   $0xc010bd3d,0x4(%esp)
c010753c:	c0 
c010753d:	89 04 24             	mov    %eax,(%esp)
c0107540:	e8 a4 de ff ff       	call   c01053e9 <sprintf>
c0107545:	01 45 e0             	add    %eax,-0x20(%ebp)

	len += sprintf(buffer + len,
c0107548:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010754b:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c0107551:	01 d0                	add    %edx,%eax
c0107553:	c7 44 24 0c ba 00 00 	movl   $0xba,0xc(%esp)
c010755a:	00 
c010755b:	c7 44 24 08 ba 00 00 	movl   $0xba,0x8(%esp)
c0107562:	00 
c0107563:	c7 44 24 04 48 bd 10 	movl   $0xc010bd48,0x4(%esp)
c010756a:	c0 
c010756b:	89 04 24             	mov    %eax,(%esp)
c010756e:	e8 76 de ff ff       	call   c01053e9 <sprintf>
c0107573:	01 45 e0             	add    %eax,-0x20(%ebp)
		       "      %c                             Universe                             %c      \n",
	       186, 186);

	len += sprintf(buffer + len, "      %c", 200);
c0107576:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107579:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c010757f:	01 d0                	add    %edx,%eax
c0107581:	c7 44 24 08 c8 00 00 	movl   $0xc8,0x8(%esp)
c0107588:	00 
c0107589:	c7 44 24 04 31 bd 10 	movl   $0xc010bd31,0x4(%esp)
c0107590:	c0 
c0107591:	89 04 24             	mov    %eax,(%esp)
c0107594:	e8 50 de ff ff       	call   c01053e9 <sprintf>
c0107599:	01 45 e0             	add    %eax,-0x20(%ebp)
	for(i=0;i<66;i++) len += sprintf(buffer + len, "%c", 205);
c010759c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c01075a3:	eb 2a                	jmp    c01075cf <panic+0x126>
c01075a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01075a8:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01075ae:	01 d0                	add    %edx,%eax
c01075b0:	c7 44 24 08 cd 00 00 	movl   $0xcd,0x8(%esp)
c01075b7:	00 
c01075b8:	c7 44 24 04 3a bd 10 	movl   $0xc010bd3a,0x4(%esp)
c01075bf:	c0 
c01075c0:	89 04 24             	mov    %eax,(%esp)
c01075c3:	e8 21 de ff ff       	call   c01053e9 <sprintf>
c01075c8:	01 45 e0             	add    %eax,-0x20(%ebp)
c01075cb:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c01075cf:	83 7d dc 41          	cmpl   $0x41,-0x24(%ebp)
c01075d3:	7e d0                	jle    c01075a5 <panic+0xfc>
	len += sprintf(buffer + len, "%c      \n", 188);
c01075d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01075d8:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01075de:	01 d0                	add    %edx,%eax
c01075e0:	c7 44 24 08 bc 00 00 	movl   $0xbc,0x8(%esp)
c01075e7:	00 
c01075e8:	c7 44 24 04 3d bd 10 	movl   $0xc010bd3d,0x4(%esp)
c01075ef:	c0 
c01075f0:	89 04 24             	mov    %eax,(%esp)
c01075f3:	e8 f1 dd ff ff       	call   c01053e9 <sprintf>
c01075f8:	01 45 e0             	add    %eax,-0x20(%ebp)

	len += sprintf(buffer + len,
c01075fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01075fe:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c0107604:	01 d0                	add    %edx,%eax
c0107606:	ba 9c bd 10 c0       	mov    $0xc010bd9c,%edx
c010760b:	bb 4e 00 00 00       	mov    $0x4e,%ebx
c0107610:	89 c1                	mov    %eax,%ecx
c0107612:	83 e1 01             	and    $0x1,%ecx
c0107615:	85 c9                	test   %ecx,%ecx
c0107617:	74 0e                	je     c0107627 <panic+0x17e>
c0107619:	0f b6 0a             	movzbl (%edx),%ecx
c010761c:	88 08                	mov    %cl,(%eax)
c010761e:	83 c0 01             	add    $0x1,%eax
c0107621:	83 c2 01             	add    $0x1,%edx
c0107624:	83 eb 01             	sub    $0x1,%ebx
c0107627:	89 c1                	mov    %eax,%ecx
c0107629:	83 e1 02             	and    $0x2,%ecx
c010762c:	85 c9                	test   %ecx,%ecx
c010762e:	74 0f                	je     c010763f <panic+0x196>
c0107630:	0f b7 0a             	movzwl (%edx),%ecx
c0107633:	66 89 08             	mov    %cx,(%eax)
c0107636:	83 c0 02             	add    $0x2,%eax
c0107639:	83 c2 02             	add    $0x2,%edx
c010763c:	83 eb 02             	sub    $0x2,%ebx
c010763f:	89 d9                	mov    %ebx,%ecx
c0107641:	c1 e9 02             	shr    $0x2,%ecx
c0107644:	89 c7                	mov    %eax,%edi
c0107646:	89 d6                	mov    %edx,%esi
c0107648:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c010764a:	89 f2                	mov    %esi,%edx
c010764c:	89 f8                	mov    %edi,%eax
c010764e:	b9 00 00 00 00       	mov    $0x0,%ecx
c0107653:	89 de                	mov    %ebx,%esi
c0107655:	83 e6 02             	and    $0x2,%esi
c0107658:	85 f6                	test   %esi,%esi
c010765a:	74 0b                	je     c0107667 <panic+0x1be>
c010765c:	0f b7 34 0a          	movzwl (%edx,%ecx,1),%esi
c0107660:	66 89 34 08          	mov    %si,(%eax,%ecx,1)
c0107664:	83 c1 02             	add    $0x2,%ecx
c0107667:	83 e3 01             	and    $0x1,%ebx
c010766a:	85 db                	test   %ebx,%ebx
c010766c:	74 07                	je     c0107675 <panic+0x1cc>
c010766e:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
c0107672:	88 14 08             	mov    %dl,(%eax,%ecx,1)
c0107675:	83 45 e0 4d          	addl   $0x4d,-0x20(%ebp)
		"      Universe has been crashed. You have to restart your computer.\n"
		"\n"
		"      "
	);

	while (*message != '\0') {
c0107679:	eb 48                	jmp    c01076c3 <panic+0x21a>
		buffer[len++] = *message;
c010767b:	8b 45 08             	mov    0x8(%ebp),%eax
c010767e:	0f b6 00             	movzbl (%eax),%eax
c0107681:	8d 8d dc fb ff ff    	lea    -0x424(%ebp),%ecx
c0107687:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010768a:	01 ca                	add    %ecx,%edx
c010768c:	88 02                	mov    %al,(%edx)
c010768e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)

		if (*message == '\n') {
c0107692:	8b 45 08             	mov    0x8(%ebp),%eax
c0107695:	0f b6 00             	movzbl (%eax),%eax
c0107698:	3c 0a                	cmp    $0xa,%al
c010769a:	75 23                	jne    c01076bf <panic+0x216>
			len += sprintf(buffer + len, "      ");
c010769c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010769f:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01076a5:	01 d0                	add    %edx,%eax
c01076a7:	c7 00 20 20 20 20    	movl   $0x20202020,(%eax)
c01076ad:	66 c7 40 04 20 20    	movw   $0x2020,0x4(%eax)
c01076b3:	c6 40 06 00          	movb   $0x0,0x6(%eax)
c01076b7:	83 45 e0 06          	addl   $0x6,-0x20(%ebp)
			++lines;
c01076bb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
		}

		++message;
c01076bf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		"      Universe has been crashed. You have to restart your computer.\n"
		"\n"
		"      "
	);

	while (*message != '\0') {
c01076c3:	8b 45 08             	mov    0x8(%ebp),%eax
c01076c6:	0f b6 00             	movzbl (%eax),%eax
c01076c9:	84 c0                	test   %al,%al
c01076cb:	75 ae                	jne    c010767b <panic+0x1d2>
		}

		++message;
	}

	len += sprintf (buffer + len,
c01076cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01076d0:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01076d6:	01 d0                	add    %edx,%eax
c01076d8:	ba ec bd 10 c0       	mov    $0xc010bdec,%edx
c01076dd:	bb 4d 00 00 00       	mov    $0x4d,%ebx
c01076e2:	89 c1                	mov    %eax,%ecx
c01076e4:	83 e1 01             	and    $0x1,%ecx
c01076e7:	85 c9                	test   %ecx,%ecx
c01076e9:	74 0e                	je     c01076f9 <panic+0x250>
c01076eb:	0f b6 0a             	movzbl (%edx),%ecx
c01076ee:	88 08                	mov    %cl,(%eax)
c01076f0:	83 c0 01             	add    $0x1,%eax
c01076f3:	83 c2 01             	add    $0x1,%edx
c01076f6:	83 eb 01             	sub    $0x1,%ebx
c01076f9:	89 c1                	mov    %eax,%ecx
c01076fb:	83 e1 02             	and    $0x2,%ecx
c01076fe:	85 c9                	test   %ecx,%ecx
c0107700:	74 0f                	je     c0107711 <panic+0x268>
c0107702:	0f b7 0a             	movzwl (%edx),%ecx
c0107705:	66 89 08             	mov    %cx,(%eax)
c0107708:	83 c0 02             	add    $0x2,%eax
c010770b:	83 c2 02             	add    $0x2,%edx
c010770e:	83 eb 02             	sub    $0x2,%ebx
c0107711:	89 d9                	mov    %ebx,%ecx
c0107713:	c1 e9 02             	shr    $0x2,%ecx
c0107716:	89 c7                	mov    %eax,%edi
c0107718:	89 d6                	mov    %edx,%esi
c010771a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c010771c:	89 f2                	mov    %esi,%edx
c010771e:	89 f8                	mov    %edi,%eax
c0107720:	b9 00 00 00 00       	mov    $0x0,%ecx
c0107725:	89 de                	mov    %ebx,%esi
c0107727:	83 e6 02             	and    $0x2,%esi
c010772a:	85 f6                	test   %esi,%esi
c010772c:	74 0b                	je     c0107739 <panic+0x290>
c010772e:	0f b7 34 0a          	movzwl (%edx,%ecx,1),%esi
c0107732:	66 89 34 08          	mov    %si,(%eax,%ecx,1)
c0107736:	83 c1 02             	add    $0x2,%ecx
c0107739:	83 e3 01             	and    $0x1,%ebx
c010773c:	85 db                	test   %ebx,%ebx
c010773e:	74 07                	je     c0107747 <panic+0x29e>
c0107740:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
c0107744:	88 14 08             	mov    %dl,(%eax,%ecx,1)
c0107747:	83 45 e0 4c          	addl   $0x4c,-0x20(%ebp)
		       "\n\n      To help us improving our systems, please report this incident to us."
	);

	set_color(WHITE | RED << 4);
c010774b:	c7 04 24 4f 00 00 00 	movl   $0x4f,(%esp)
c0107752:	e8 db b2 ff ff       	call   c0102a32 <set_color>
	clear_screen();
c0107757:	e8 72 b2 ff ff       	call   c01029ce <clear_screen>

	gotoxy(0, (25 / 2) - (lines / 2) - 1);
c010775c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010775f:	89 c2                	mov    %eax,%edx
c0107761:	c1 ea 1f             	shr    $0x1f,%edx
c0107764:	01 d0                	add    %edx,%eax
c0107766:	d1 f8                	sar    %eax
c0107768:	ba 0b 00 00 00       	mov    $0xb,%edx
c010776d:	89 d1                	mov    %edx,%ecx
c010776f:	29 c1                	sub    %eax,%ecx
c0107771:	89 c8                	mov    %ecx,%eax
c0107773:	0f b6 c0             	movzbl %al,%eax
c0107776:	89 44 24 04          	mov    %eax,0x4(%esp)
c010777a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0107781:	e8 cf b2 ff ff       	call   c0102a55 <gotoxy>
	puts(buffer);
c0107786:	8d 85 dc fb ff ff    	lea    -0x424(%ebp),%eax
c010778c:	89 04 24             	mov    %eax,(%esp)
c010778f:	e8 c3 b1 ff ff       	call   c0102957 <puts>
	printf("\n\n      ");
c0107794:	c7 04 24 39 be 10 c0 	movl   $0xc010be39,(%esp)
c010779b:	e8 dc db ff ff       	call   c010537c <printf>

	halt();
c01077a0:	e8 6f fb ff ff       	call   c0107314 <halt>
}
c01077a5:	81 c4 2c 04 00 00    	add    $0x42c,%esp
c01077ab:	5b                   	pop    %ebx
c01077ac:	5e                   	pop    %esi
c01077ad:	5f                   	pop    %edi
c01077ae:	5d                   	pop    %ebp
c01077af:	c3                   	ret    

c01077b0 <exc_panic>:

// just used in case of untreated exceptions
void exc_panic(struct cpu_state* cpu)
{
c01077b0:	55                   	push   %ebp
c01077b1:	89 e5                	mov    %esp,%ebp
c01077b3:	81 ec 28 02 00 00    	sub    $0x228,%esp
	char message[512];
	char *exception = exception_messages[cpu->intr];
c01077b9:	8b 45 08             	mov    0x8(%ebp),%eax
c01077bc:	8b 40 2c             	mov    0x2c(%eax),%eax
c01077bf:	8b 04 85 20 f4 10 c0 	mov    -0x3fef0be0(,%eax,4),%eax
c01077c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len = 0;
c01077c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	len = sprintf(message, "%s\n\n", exception);
c01077d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01077d3:	89 44 24 08          	mov    %eax,0x8(%esp)
c01077d7:	c7 44 24 04 42 be 10 	movl   $0xc010be42,0x4(%esp)
c01077de:	c0 
c01077df:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c01077e5:	89 04 24             	mov    %eax,(%esp)
c01077e8:	e8 fc db ff ff       	call   c01053e9 <sprintf>
c01077ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cpu_dump(cpu, message + len);
c01077f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01077f3:	8d 95 f0 fd ff ff    	lea    -0x210(%ebp),%edx
c01077f9:	01 d0                	add    %edx,%eax
c01077fb:	89 44 24 04          	mov    %eax,0x4(%esp)
c01077ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0107802:	89 04 24             	mov    %eax,(%esp)
c0107805:	e8 11 fb ff ff       	call   c010731b <cpu_dump>

	panic(message);
c010780a:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0107810:	89 04 24             	mov    %eax,(%esp)
c0107813:	e8 91 fc ff ff       	call   c01074a9 <panic>
}
c0107818:	c9                   	leave  
c0107819:	c3                   	ret    

c010781a <winpanic>:

/* easter egg! */
void winpanic(char *message)
{
c010781a:	55                   	push   %ebp
c010781b:	89 e5                	mov    %esp,%ebp
c010781d:	83 ec 18             	sub    $0x18,%esp
	set_color(WHITE | BLUE << 4);
c0107820:	c7 04 24 1f 00 00 00 	movl   $0x1f,(%esp)
c0107827:	e8 06 b2 ff ff       	call   c0102a32 <set_color>
	clear_screen();
c010782c:	e8 9d b1 ff ff       	call   c01029ce <clear_screen>

	gotoxy(37, 8);
c0107831:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0107838:	00 
c0107839:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
c0107840:	e8 10 b2 ff ff       	call   c0102a55 <gotoxy>
	set_color(BLUE | LIGHT_GRAY << 4);
c0107845:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
c010784c:	e8 e1 b1 ff ff       	call   c0102a32 <set_color>
	printf(" Windows");
c0107851:	c7 04 24 47 be 10 c0 	movl   $0xc010be47,(%esp)
c0107858:	e8 1f db ff ff       	call   c010537c <printf>
	set_color(WHITE | BLUE << 4);
c010785d:	c7 04 24 1f 00 00 00 	movl   $0x1f,(%esp)
c0107864:	e8 c9 b1 ff ff       	call   c0102a32 <set_color>
	printf("\n\n      ");
c0107869:	c7 04 24 39 be 10 c0 	movl   $0xc010be39,(%esp)
c0107870:	e8 07 db ff ff       	call   c010537c <printf>
	while (*message != '\0') {
c0107875:	eb 2b                	jmp    c01078a2 <winpanic+0x88>
		putchar(*message);
c0107877:	8b 45 08             	mov    0x8(%ebp),%eax
c010787a:	0f b6 00             	movzbl (%eax),%eax
c010787d:	0f be c0             	movsbl %al,%eax
c0107880:	89 04 24             	mov    %eax,(%esp)
c0107883:	e8 70 af ff ff       	call   c01027f8 <putchar>

		if (*message == '\n') {
c0107888:	8b 45 08             	mov    0x8(%ebp),%eax
c010788b:	0f b6 00             	movzbl (%eax),%eax
c010788e:	3c 0a                	cmp    $0xa,%al
c0107890:	75 0c                	jne    c010789e <winpanic+0x84>
			printf("      ");
c0107892:	c7 04 24 50 be 10 c0 	movl   $0xc010be50,(%esp)
c0107899:	e8 de da ff ff       	call   c010537c <printf>
		}

		++message;
c010789e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
	gotoxy(37, 8);
	set_color(BLUE | LIGHT_GRAY << 4);
	printf(" Windows");
	set_color(WHITE | BLUE << 4);
	printf("\n\n      ");
	while (*message != '\0') {
c01078a2:	8b 45 08             	mov    0x8(%ebp),%eax
c01078a5:	0f b6 00             	movzbl (%eax),%eax
c01078a8:	84 c0                	test   %al,%al
c01078aa:	75 cb                	jne    c0107877 <winpanic+0x5d>

		++message;
	}
	//printf("%s\n", message);

	printf("\n\n      *  Druecken Sie eine beliebige Taste, um die Anwendung abzubrechen.\n");
c01078ac:	c7 04 24 58 be 10 c0 	movl   $0xc010be58,(%esp)
c01078b3:	e8 9f b0 ff ff       	call   c0102957 <puts>
	printf("      *  Druecken Sie Strg+Alt+Entf, um den Computer neu zu\n");
c01078b8:	c7 04 24 a4 be 10 c0 	movl   $0xc010bea4,(%esp)
c01078bf:	e8 93 b0 ff ff       	call   c0102957 <puts>
	printf("      starten. nicht gespeicherte Daten gehen dabei verloren.\n");
c01078c4:	c7 04 24 e0 be 10 c0 	movl   $0xc010bee0,(%esp)
c01078cb:	e8 87 b0 ff ff       	call   c0102957 <puts>
	halt();
c01078d0:	e8 3f fa ff ff       	call   c0107314 <halt>
}
c01078d5:	c9                   	leave  
c01078d6:	c3                   	ret    
c01078d7:	90                   	nop

c01078d8 <isalnum>:
 * check if c is an alphanumeric character (A-Z, a-z and 0-9)
 * @param character c as int
 * @return true  -> c is an alphanumeric character
 * @return false -> c isn't an alphanumeric character
 **/
int isalnum(int c) {
c01078d8:	55                   	push   %ebp
c01078d9:	89 e5                	mov    %esp,%ebp
	if ( (c > 0x40 && c < 0x5B) || (c > 0x60 && c < 0x7B) || (c > 0x2F && c < 0x3A) ) {
c01078db:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c01078df:	7e 06                	jle    c01078e7 <isalnum+0xf>
c01078e1:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c01078e5:	7e 18                	jle    c01078ff <isalnum+0x27>
c01078e7:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c01078eb:	7e 06                	jle    c01078f3 <isalnum+0x1b>
c01078ed:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c01078f1:	7e 0c                	jle    c01078ff <isalnum+0x27>
c01078f3:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c01078f7:	7e 0d                	jle    c0107906 <isalnum+0x2e>
c01078f9:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c01078fd:	7f 07                	jg     c0107906 <isalnum+0x2e>
		return true;
c01078ff:	b8 01 00 00 00       	mov    $0x1,%eax
c0107904:	eb 05                	jmp    c010790b <isalnum+0x33>
	}
	return false;
c0107906:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010790b:	5d                   	pop    %ebp
c010790c:	c3                   	ret    

c010790d <isalpha>:
 * check if c is an alphabetical character (A-Z, a-z)
 * @param character c as int
 * @return true  -> c is an alphabetical character
 * @return false -> c isn't an alphabetical character
 **/
int isalpha(int c) {
c010790d:	55                   	push   %ebp
c010790e:	89 e5                	mov    %esp,%ebp
	if ( (c > 0x40 && c < 0x5B) || (c > 0x60 && c < 0x7B) ) {
c0107910:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0107914:	7e 06                	jle    c010791c <isalpha+0xf>
c0107916:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c010791a:	7e 0c                	jle    c0107928 <isalpha+0x1b>
c010791c:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c0107920:	7e 0d                	jle    c010792f <isalpha+0x22>
c0107922:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c0107926:	7f 07                	jg     c010792f <isalpha+0x22>
		return true;
c0107928:	b8 01 00 00 00       	mov    $0x1,%eax
c010792d:	eb 05                	jmp    c0107934 <isalpha+0x27>
	}
	return false;
c010792f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107934:	5d                   	pop    %ebp
c0107935:	c3                   	ret    

c0107936 <iscntrl>:
 *check if c is an control key value
 * @param character c as int
 * @return true  -> c is a control Key value
 * @return false -> c isn't a control key value
 **/
int iscntrl(int c) {
c0107936:	55                   	push   %ebp
c0107937:	89 e5                	mov    %esp,%ebp
	if ( (c >= 0x0 && c > 0x20) || c == 0x7F) {
c0107939:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010793d:	78 06                	js     c0107945 <iscntrl+0xf>
c010793f:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0107943:	7f 06                	jg     c010794b <iscntrl+0x15>
c0107945:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
c0107949:	75 07                	jne    c0107952 <iscntrl+0x1c>
		return true;
c010794b:	b8 01 00 00 00       	mov    $0x1,%eax
c0107950:	eb 05                	jmp    c0107957 <iscntrl+0x21>
	}
	return false;
c0107952:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107957:	5d                   	pop    %ebp
c0107958:	c3                   	ret    

c0107959 <isdigit>:
 * checks if c is an digit (0-9)
 * @param character c as int
 * @return true  -> c is a digit
 * @return false -> c isn't an digit
 **/
int isdigit(int c) {
c0107959:	55                   	push   %ebp
c010795a:	89 e5                	mov    %esp,%ebp
	if (c > 0x2F && c < 0x3A) {
c010795c:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0107960:	7e 0d                	jle    c010796f <isdigit+0x16>
c0107962:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0107966:	7f 07                	jg     c010796f <isdigit+0x16>
		return true;
c0107968:	b8 01 00 00 00       	mov    $0x1,%eax
c010796d:	eb 05                	jmp    c0107974 <isdigit+0x1b>
	}
	return false;
c010796f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107974:	5d                   	pop    %ebp
c0107975:	c3                   	ret    

c0107976 <isgraph>:
 * check if c is a graphical character
 * @param character c as int
 * @return true  -> c is a graphical character
 * @return false -> c isn't a graphical character
 **/
int isgraph(int c) {
c0107976:	55                   	push   %ebp
c0107977:	89 e5                	mov    %esp,%ebp
	if (c > 0x20 && c < 0x7F) {
c0107979:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c010797d:	7e 0d                	jle    c010798c <isgraph+0x16>
c010797f:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c0107983:	7f 07                	jg     c010798c <isgraph+0x16>
		return true;
c0107985:	b8 01 00 00 00       	mov    $0x1,%eax
c010798a:	eb 05                	jmp    c0107991 <isgraph+0x1b>
	}
	return false;
c010798c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107991:	5d                   	pop    %ebp
c0107992:	c3                   	ret    

c0107993 <islower>:
 * check if c is an lower alphabeticial character
 * @param character c as int
 * @return true  -> c is a lower character
 * @return false -> c isn't a lower character
 **/
int islower(int c) {
c0107993:	55                   	push   %ebp
c0107994:	89 e5                	mov    %esp,%ebp
	if (c > 0x60 && c < 0x7B) {
c0107996:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c010799a:	7e 0d                	jle    c01079a9 <islower+0x16>
c010799c:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c01079a0:	7f 07                	jg     c01079a9 <islower+0x16>
		return true;
c01079a2:	b8 01 00 00 00       	mov    $0x1,%eax
c01079a7:	eb 05                	jmp    c01079ae <islower+0x1b>
	}
	return false;
c01079a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01079ae:	5d                   	pop    %ebp
c01079af:	c3                   	ret    

c01079b0 <isprint>:
 * check if c is an normal printable character
 * @param character c as int
 * @return true  -> c is an printable character
 * @return false -> c isn't an printable character
 **/
int isprint(int c) {
c01079b0:	55                   	push   %ebp
c01079b1:	89 e5                	mov    %esp,%ebp
	if (c > 0x1F && c < 0x7F) {
c01079b3:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c01079b7:	7e 0d                	jle    c01079c6 <isprint+0x16>
c01079b9:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c01079bd:	7f 07                	jg     c01079c6 <isprint+0x16>
		return true;
c01079bf:	b8 01 00 00 00       	mov    $0x1,%eax
c01079c4:	eb 05                	jmp    c01079cb <isprint+0x1b>
	}
	return false;
c01079c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01079cb:	5d                   	pop    %ebp
c01079cc:	c3                   	ret    

c01079cd <ispunct>:
 * check if c is a visible character which is not an alphanumerical
 * @param character c as int
 * @return true  -> c is a visible character which is not an alphanumerical
 * @return false -> c isn't a visible character which is not an alphanumerical
 **/
int ispunct(int c) {
c01079cd:	55                   	push   %ebp
c01079ce:	89 e5                	mov    %esp,%ebp
	if ( (c > 0x20 && c < 0x30) || (c > 0x39 && c < 0x41) || (c > 0x5A && c < 0x61) || (c > 0x7A && c < 0x7F) ) {
c01079d0:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c01079d4:	7e 06                	jle    c01079dc <ispunct+0xf>
c01079d6:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c01079da:	7e 24                	jle    c0107a00 <ispunct+0x33>
c01079dc:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c01079e0:	7e 06                	jle    c01079e8 <ispunct+0x1b>
c01079e2:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c01079e6:	7e 18                	jle    c0107a00 <ispunct+0x33>
c01079e8:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c01079ec:	7e 06                	jle    c01079f4 <ispunct+0x27>
c01079ee:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c01079f2:	7e 0c                	jle    c0107a00 <ispunct+0x33>
c01079f4:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c01079f8:	7e 0d                	jle    c0107a07 <ispunct+0x3a>
c01079fa:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c01079fe:	7f 07                	jg     c0107a07 <ispunct+0x3a>
		return true;
c0107a00:	b8 01 00 00 00       	mov    $0x1,%eax
c0107a05:	eb 05                	jmp    c0107a0c <ispunct+0x3f>
	}
	return false;
c0107a07:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107a0c:	5d                   	pop    %ebp
c0107a0d:	c3                   	ret    

c0107a0e <isspace>:
 * check if c is a space character
 * @param character c as int
 * @return true  -> c is a space character
 * @return false -> c isn't a space character
 **/
int isspace(int c) {
c0107a0e:	55                   	push   %ebp
c0107a0f:	89 e5                	mov    %esp,%ebp
	if (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v') {
c0107a11:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0107a15:	74 1e                	je     c0107a35 <isspace+0x27>
c0107a17:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0107a1b:	74 18                	je     c0107a35 <isspace+0x27>
c0107a1d:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0107a21:	74 12                	je     c0107a35 <isspace+0x27>
c0107a23:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0107a27:	74 0c                	je     c0107a35 <isspace+0x27>
c0107a29:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0107a2d:	74 06                	je     c0107a35 <isspace+0x27>
c0107a2f:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0107a33:	75 07                	jne    c0107a3c <isspace+0x2e>
		return true;
c0107a35:	b8 01 00 00 00       	mov    $0x1,%eax
c0107a3a:	eb 05                	jmp    c0107a41 <isspace+0x33>
	}
	return false;
c0107a3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107a41:	5d                   	pop    %ebp
c0107a42:	c3                   	ret    

c0107a43 <isupper>:
 * check if c is an upper alphanbetical character
 * @param character c as int
 * @return true  -> c is an upper alphabetical character
 * @return false -> c isn't an upper alphabetical character
 **/
int isupper(int c) {
c0107a43:	55                   	push   %ebp
c0107a44:	89 e5                	mov    %esp,%ebp
	if (c > 0x40 && c < 0x5B) {
c0107a46:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0107a4a:	7e 0d                	jle    c0107a59 <isupper+0x16>
c0107a4c:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c0107a50:	7f 07                	jg     c0107a59 <isupper+0x16>
		return true;
c0107a52:	b8 01 00 00 00       	mov    $0x1,%eax
c0107a57:	eb 05                	jmp    c0107a5e <isupper+0x1b>
	}
	return false;
c0107a59:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107a5e:	5d                   	pop    %ebp
c0107a5f:	c3                   	ret    

c0107a60 <isxdigit>:
 * check if c is a hexadecimal digit
 * @param character c as int
 * @return true  -> c is a hexadecimal digit
 * @return false -> c isn't a hexadecimal digit
 **/
int isxdigit(int c) {
c0107a60:	55                   	push   %ebp
c0107a61:	89 e5                	mov    %esp,%ebp
	if ( (c > 0x2F && c < 0x3A) || (c > 0x40 && c < 0x47) || (c > 0x60 && c < 0x67) ) {
c0107a63:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0107a67:	7e 06                	jle    c0107a6f <isxdigit+0xf>
c0107a69:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0107a6d:	7e 18                	jle    c0107a87 <isxdigit+0x27>
c0107a6f:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0107a73:	7e 06                	jle    c0107a7b <isxdigit+0x1b>
c0107a75:	83 7d 08 46          	cmpl   $0x46,0x8(%ebp)
c0107a79:	7e 0c                	jle    c0107a87 <isxdigit+0x27>
c0107a7b:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c0107a7f:	7e 0d                	jle    c0107a8e <isxdigit+0x2e>
c0107a81:	83 7d 08 66          	cmpl   $0x66,0x8(%ebp)
c0107a85:	7f 07                	jg     c0107a8e <isxdigit+0x2e>
		return true;
c0107a87:	b8 01 00 00 00       	mov    $0x1,%eax
c0107a8c:	eb 05                	jmp    c0107a93 <isxdigit+0x33>
	}
	return false;
c0107a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107a93:	5d                   	pop    %ebp
c0107a94:	c3                   	ret    

c0107a95 <tolower>:
/**
 * convert upper to lower character
 * @param upper character c as int
 * @return c as lower character as int
 **/
int tolower(int c) {
c0107a95:	55                   	push   %ebp
c0107a96:	89 e5                	mov    %esp,%ebp
	c += 0x20;
c0107a98:	83 45 08 20          	addl   $0x20,0x8(%ebp)
	return c;
c0107a9c:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0107a9f:	5d                   	pop    %ebp
c0107aa0:	c3                   	ret    

c0107aa1 <toupper>:
/**
 * convert lower to upper character
 * @param lower charcter c as int
 * @return c as upper character as int
 **/
int toupper(int c) {
c0107aa1:	55                   	push   %ebp
c0107aa2:	89 e5                	mov    %esp,%ebp
	c -= 0x20;
c0107aa4:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	return c;
c0107aa8:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0107aab:	5d                   	pop    %ebp
c0107aac:	c3                   	ret    
c0107aad:	66 90                	xchg   %ax,%ax
c0107aaf:	90                   	nop

c0107ab0 <load_elf>:
#include <process.h>
#include <thread.h>
#include <printf.h>
#include <string.h>

struct process_state *load_elf(void *image) {
c0107ab0:	55                   	push   %ebp
c0107ab1:	89 e5                	mov    %esp,%ebp
c0107ab3:	83 ec 58             	sub    $0x58,%esp
	struct elf_header *header = image;
c0107ab6:	8b 45 08             	mov    0x8(%ebp),%eax
c0107ab9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct elf_program_header *ph;

	if(header->ident[EI_MAG0] == ELF_MAG0 &&
c0107abc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107abf:	0f b6 00             	movzbl (%eax),%eax
c0107ac2:	3c 7f                	cmp    $0x7f,%al
c0107ac4:	75 21                	jne    c0107ae7 <load_elf+0x37>
	   header->ident[EI_MAG1] == ELF_MAG1 &&
c0107ac6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107ac9:	0f b6 40 01          	movzbl 0x1(%eax),%eax

struct process_state *load_elf(void *image) {
	struct elf_header *header = image;
	struct elf_program_header *ph;

	if(header->ident[EI_MAG0] == ELF_MAG0 &&
c0107acd:	3c 45                	cmp    $0x45,%al
c0107acf:	75 16                	jne    c0107ae7 <load_elf+0x37>
	   header->ident[EI_MAG1] == ELF_MAG1 &&
	   header->ident[EI_MAG2] == ELF_MAG2 &&
c0107ad1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107ad4:	0f b6 40 02          	movzbl 0x2(%eax),%eax
struct process_state *load_elf(void *image) {
	struct elf_header *header = image;
	struct elf_program_header *ph;

	if(header->ident[EI_MAG0] == ELF_MAG0 &&
	   header->ident[EI_MAG1] == ELF_MAG1 &&
c0107ad8:	3c 4c                	cmp    $0x4c,%al
c0107ada:	75 0b                	jne    c0107ae7 <load_elf+0x37>
	   header->ident[EI_MAG2] == ELF_MAG2 &&
	   header->ident[EI_MAG3] == ELF_MAG3)
c0107adc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107adf:	0f b6 40 03          	movzbl 0x3(%eax),%eax
	struct elf_header *header = image;
	struct elf_program_header *ph;

	if(header->ident[EI_MAG0] == ELF_MAG0 &&
	   header->ident[EI_MAG1] == ELF_MAG1 &&
	   header->ident[EI_MAG2] == ELF_MAG2 &&
c0107ae3:	3c 46                	cmp    $0x46,%al
c0107ae5:	74 16                	je     c0107afd <load_elf+0x4d>
	   header->ident[EI_MAG3] == ELF_MAG3)
	{
	} else {
		printf("Invalid ELF-Magic!\n");
c0107ae7:	c7 04 24 1e bf 10 c0 	movl   $0xc010bf1e,(%esp)
c0107aee:	e8 64 ae ff ff       	call   c0102957 <puts>
		return NULL;
c0107af3:	b8 00 00 00 00       	mov    $0x0,%eax
c0107af8:	e9 f6 01 00 00       	jmp    c0107cf3 <load_elf+0x243>
	}

	int i,j;
	ph = (struct elf_program_header*) (image + header->ph_offset);
c0107afd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107b00:	8b 50 1c             	mov    0x1c(%eax),%edx
c0107b03:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b06:	01 d0                	add    %edx,%eax
c0107b08:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct process_state *proc = process_create("", "", PROCESS_ACTIVE, NULL);
c0107b0b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0107b12:	00 
c0107b13:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0107b1a:	00 
c0107b1b:	c7 44 24 04 31 bf 10 	movl   $0xc010bf31,0x4(%esp)
c0107b22:	c0 
c0107b23:	c7 04 24 31 bf 10 c0 	movl   $0xc010bf31,(%esp)
c0107b2a:	e8 66 02 00 00       	call   c0107d95 <process_create>
c0107b2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct thread_state *new_thread = thread_create(proc, 3, header->entry, NULL, 0, NULL, NULL);
c0107b32:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107b35:	8b 40 18             	mov    0x18(%eax),%eax
c0107b38:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0107b3f:	00 
c0107b40:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0107b47:	00 
c0107b48:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0107b4f:	00 
c0107b50:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0107b57:	00 
c0107b58:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107b5c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c0107b63:	00 
c0107b64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107b67:	89 04 24             	mov    %eax,(%esp)
c0107b6a:	e8 57 dd ff ff       	call   c01058c6 <thread_create>
c0107b6f:	89 45 e0             	mov    %eax,-0x20(%ebp)

	for(i = 0; i < header->ph_entry_count; i++, ph++) {
c0107b72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0107b79:	e9 5f 01 00 00       	jmp    c0107cdd <load_elf+0x22d>
		if(ph->type == EPT_LOAD) {
c0107b7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107b81:	8b 00                	mov    (%eax),%eax
c0107b83:	83 f8 01             	cmp    $0x1,%eax
c0107b86:	0f 85 49 01 00 00    	jne    c0107cd5 <load_elf+0x225>
			int pages = NUM_PAGES(ph->mem_size);
c0107b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107b8f:	8b 40 14             	mov    0x14(%eax),%eax
c0107b92:	05 ff 0f 00 00       	add    $0xfff,%eax
c0107b97:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107b9c:	c1 e8 0c             	shr    $0xc,%eax
c0107b9f:	89 45 dc             	mov    %eax,-0x24(%ebp)
			uintptr_t dest_start = (uintptr_t) arch_vaddr_find(current_context, pages,
c0107ba2:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0107ba7:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
c0107bae:	00 
c0107baf:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c0107bb6:	ff 
c0107bb7:	c7 44 24 08 00 00 00 	movl   $0xc0000000,0x8(%esp)
c0107bbe:	c0 
c0107bbf:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0107bc2:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107bc6:	89 04 24             	mov    %eax,(%esp)
c0107bc9:	e8 67 e7 ff ff       	call   c0106335 <arch_vaddr_find>
c0107bce:	89 45 d8             	mov    %eax,-0x28(%ebp)
						MEMORY_LAYOUT_KERNEL_START, MEMORY_LAYOUT_KERNEL_END, VMM_WRITABLE);

			for(j = 0; j < pages; j++) {
c0107bd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0107bd8:	e9 a4 00 00 00       	jmp    c0107c81 <load_elf+0x1d1>
				paddr_t paddr = (uintptr_t) pmm_alloc_page();
c0107bdd:	e8 26 d4 ff ff       	call   c0105008 <pmm_alloc_page>
c0107be2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				vaddr_t vaddr = (uintptr_t) ph->virt_addr + j*PAGE_SIZE;
c0107be5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107be8:	8b 50 08             	mov    0x8(%eax),%edx
c0107beb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107bee:	c1 e0 0c             	shl    $0xc,%eax
c0107bf1:	01 d0                	add    %edx,%eax
c0107bf3:	89 45 d0             	mov    %eax,-0x30(%ebp)
				uintptr_t src = (uintptr_t) image + ph->offset + j*PAGE_SIZE;
c0107bf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107bf9:	8b 50 04             	mov    0x4(%eax),%edx
c0107bfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0107bff:	01 c2                	add    %eax,%edx
c0107c01:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107c04:	c1 e0 0c             	shl    $0xc,%eax
c0107c07:	01 d0                	add    %edx,%eax
c0107c09:	89 45 cc             	mov    %eax,-0x34(%ebp)
				uintptr_t dest = (uintptr_t) dest_start + j*PAGE_SIZE;
c0107c0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107c0f:	c1 e0 0c             	shl    $0xc,%eax
c0107c12:	89 c2                	mov    %eax,%edx
c0107c14:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0107c17:	01 d0                	add    %edx,%eax
c0107c19:	89 45 c8             	mov    %eax,-0x38(%ebp)

				vmm_map(&new_thread->context, paddr, vaddr, VMM_WRITABLE | VMM_USER);
c0107c1c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107c1f:	8d 50 08             	lea    0x8(%eax),%edx
c0107c22:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c0107c29:	00 
c0107c2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0107c2d:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107c31:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0107c34:	89 44 24 04          	mov    %eax,0x4(%esp)
c0107c38:	89 14 24             	mov    %edx,(%esp)
c0107c3b:	e8 e6 f3 ff ff       	call   c0107026 <vmm_map>
				vmm_map(current_context, paddr, dest, VMM_WRITABLE);
c0107c40:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0107c45:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c0107c4c:	00 
c0107c4d:	8b 55 c8             	mov    -0x38(%ebp),%edx
c0107c50:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107c54:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0107c57:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107c5b:	89 04 24             	mov    %eax,(%esp)
c0107c5e:	e8 c3 f3 ff ff       	call   c0107026 <vmm_map>

        			memcpy((void*) dest, (void*) src, PAGE_SIZE);
c0107c63:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0107c66:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0107c69:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c0107c70:	00 
c0107c71:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107c75:	89 04 24             	mov    %eax,(%esp)
c0107c78:	e8 af 23 00 00       	call   c010a02c <memcpy>
		if(ph->type == EPT_LOAD) {
			int pages = NUM_PAGES(ph->mem_size);
			uintptr_t dest_start = (uintptr_t) arch_vaddr_find(current_context, pages,
						MEMORY_LAYOUT_KERNEL_START, MEMORY_LAYOUT_KERNEL_END, VMM_WRITABLE);

			for(j = 0; j < pages; j++) {
c0107c7d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0107c81:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107c84:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0107c87:	0f 8c 50 ff ff ff    	jl     c0107bdd <load_elf+0x12d>
				vmm_map(&new_thread->context, paddr, vaddr, VMM_WRITABLE | VMM_USER);
				vmm_map(current_context, paddr, dest, VMM_WRITABLE);

        			memcpy((void*) dest, (void*) src, PAGE_SIZE);
      			}
      			memset((void*)dest_start + ph->file_size, 0, ph->mem_size - ph->file_size);
c0107c8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107c90:	8b 50 14             	mov    0x14(%eax),%edx
c0107c93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107c96:	8b 40 10             	mov    0x10(%eax),%eax
c0107c99:	29 c2                	sub    %eax,%edx
c0107c9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107c9e:	8b 48 10             	mov    0x10(%eax),%ecx
c0107ca1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0107ca4:	01 c8                	add    %ecx,%eax
c0107ca6:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107caa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0107cb1:	00 
c0107cb2:	89 04 24             	mov    %eax,(%esp)
c0107cb5:	e8 3b 25 00 00       	call   c010a1f5 <memset>

      			vmm_unmap_range(current_context, dest_start, pages);
c0107cba:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0107cbf:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0107cc2:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107cc6:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0107cc9:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107ccd:	89 04 24             	mov    %eax,(%esp)
c0107cd0:	e8 03 f4 ff ff       	call   c01070d8 <vmm_unmap_range>
	ph = (struct elf_program_header*) (image + header->ph_offset);

	struct process_state *proc = process_create("", "", PROCESS_ACTIVE, NULL);
	struct thread_state *new_thread = thread_create(proc, 3, header->entry, NULL, 0, NULL, NULL);

	for(i = 0; i < header->ph_entry_count; i++, ph++) {
c0107cd5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0107cd9:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
c0107cdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107ce0:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
c0107ce4:	0f b7 c0             	movzwl %ax,%eax
c0107ce7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0107cea:	0f 8f 8e fe ff ff    	jg     c0107b7e <load_elf+0xce>

      			vmm_unmap_range(current_context, dest_start, pages);
    		}
  	}

	return proc;
c0107cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
c0107cf3:	c9                   	leave  
c0107cf4:	c3                   	ret    
c0107cf5:	66 90                	xchg   %ax,%ax
c0107cf7:	90                   	nop

c0107cf8 <print_logo>:
                 UUUUUUUUU       NNNNNNNN         NNNNNNN IIIIIIIIII           \n\
                                                                               \n\
";

static void print_logo(color_t color)
{
c0107cf8:	55                   	push   %ebp
c0107cf9:	89 e5                	mov    %esp,%ebp
c0107cfb:	83 ec 38             	sub    $0x38,%esp
c0107cfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d01:	88 45 e4             	mov    %al,-0x1c(%ebp)
	color_t color_saved = get_color();
c0107d04:	e8 40 ad ff ff       	call   c0102a49 <get_color>
c0107d09:	88 45 f7             	mov    %al,-0x9(%ebp)

	set_color(color | BLACK << 4);
c0107d0c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0107d10:	89 04 24             	mov    %eax,(%esp)
c0107d13:	e8 1a ad ff ff       	call   c0102a32 <set_color>

	puts(__logo);
c0107d18:	a1 a0 f4 10 c0       	mov    0xc010f4a0,%eax
c0107d1d:	89 04 24             	mov    %eax,(%esp)
c0107d20:	e8 32 ac ff ff       	call   c0102957 <puts>

	set_color(color_saved);
c0107d25:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0107d29:	89 04 24             	mov    %eax,(%esp)
c0107d2c:	e8 01 ad ff ff       	call   c0102a32 <set_color>
}
c0107d31:	c9                   	leave  
c0107d32:	c3                   	ret    

c0107d33 <init>:
* @return 0
*/
extern struct thread_state *current_thread;
extern struct process_state *kernel_state;

int init (struct multiboot_struct *mb_info, uint32_t magic_number) {
c0107d33:	55                   	push   %ebp
c0107d34:	89 e5                	mov    %esp,%ebp
c0107d36:	83 ec 18             	sub    $0x18,%esp
	clear_screen();
c0107d39:	e8 90 ac ff ff       	call   c01029ce <clear_screen>

	if (magic_number != 0x2BADB002) {
c0107d3e:	81 7d 0c 02 b0 ad 2b 	cmpl   $0x2badb002,0xc(%ebp)
c0107d45:	74 0c                	je     c0107d53 <init+0x20>
		panic("Incompatible Bootloader");
c0107d47:	c7 04 24 d5 c4 10 c0 	movl   $0xc010c4d5,(%esp)
c0107d4e:	e8 56 f7 ff ff       	call   c01074a9 <panic>
	}

	set_color(WHITE | BLACK << 4);
c0107d53:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c0107d5a:	e8 d3 ac ff ff       	call   c0102a32 <set_color>
	//Init Kernelmodules
	INIT_PMM(mb_info);
c0107d5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d62:	89 04 24             	mov    %eax,(%esp)
c0107d65:	e8 da d3 ff ff       	call   c0105144 <INIT_PMM>
	INIT_GDT();
c0107d6a:	e8 01 ef ff ff       	call   c0106c70 <INIT_GDT>
	INIT_IDT();
c0107d6f:	e8 69 c7 ff ff       	call   c01044dd <INIT_IDT>
	INIT_PAGING(mb_info);while(1);
c0107d74:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d77:	89 04 24             	mov    %eax,(%esp)
c0107d7a:	e8 2d f2 ff ff       	call   c0106fac <INIT_PAGING>
c0107d7f:	eb fe                	jmp    c0107d7f <init+0x4c>
c0107d81:	66 90                	xchg   %ax,%ax
c0107d83:	90                   	nop

c0107d84 <min>:
 * @param a     inputvalue
 * @param b     inputvalue
 * @return the smallest inputvalue
 */
inline int min(int a, int b)
{
c0107d84:	55                   	push   %ebp
c0107d85:	89 e5                	mov    %esp,%ebp
    return (a < b) ? a : b;
c0107d87:	8b 55 08             	mov    0x8(%ebp),%edx
c0107d8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107d8d:	39 d0                	cmp    %edx,%eax
c0107d8f:	7e 02                	jle    c0107d93 <min+0xf>
c0107d91:	89 d0                	mov    %edx,%eax
}
c0107d93:	5d                   	pop    %ebp
c0107d94:	c3                   	ret    

c0107d95 <process_create>:
 * @param flags     process flags (activ, freezed, zombies)
 * @param parent    pointer to the parent process struct (NULL: Kernel Init = parent)
 * @return
 */
struct process_state *process_create(const char *name, const char *desc, uint16_t flags,struct process_state *parent)
{
c0107d95:	55                   	push   %ebp
c0107d96:	89 e5                	mov    %esp,%ebp
c0107d98:	83 ec 58             	sub    $0x58,%esp
c0107d9b:	8b 45 10             	mov    0x10(%ebp),%eax
c0107d9e:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)

    struct process_state *state = malloc(sizeof(struct process_state));
c0107da2:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
c0107da9:	e8 16 08 00 00       	call   c01085c4 <malloc>
c0107dae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int string_len = min(strlen(name), 255);
c0107db1:	8b 45 08             	mov    0x8(%ebp),%eax
c0107db4:	89 04 24             	mov    %eax,(%esp)
c0107db7:	e8 68 1e 00 00       	call   c0109c24 <strlen>
c0107dbc:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
c0107dc3:	00 
c0107dc4:	89 04 24             	mov    %eax,(%esp)
c0107dc7:	e8 b8 ff ff ff       	call   c0107d84 <min>
c0107dcc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    state->name = (char *) malloc(string_len + 1);
c0107dcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107dd2:	83 c0 01             	add    $0x1,%eax
c0107dd5:	89 04 24             	mov    %eax,(%esp)
c0107dd8:	e8 e7 07 00 00       	call   c01085c4 <malloc>
c0107ddd:	89 c2                	mov    %eax,%edx
c0107ddf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107de2:	89 50 04             	mov    %edx,0x4(%eax)
    strncpy(state->name, name, string_len);
c0107de5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107de8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107deb:	8b 40 04             	mov    0x4(%eax),%eax
c0107dee:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107df2:	8b 55 08             	mov    0x8(%ebp),%edx
c0107df5:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107df9:	89 04 24             	mov    %eax,(%esp)
c0107dfc:	e8 9b 1e 00 00       	call   c0109c9c <strncpy>
    state->name[string_len + 1] = 0;
c0107e01:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e04:	8b 40 04             	mov    0x4(%eax),%eax
c0107e07:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107e0a:	83 c2 01             	add    $0x1,%edx
c0107e0d:	01 d0                	add    %edx,%eax
c0107e0f:	c6 00 00             	movb   $0x0,(%eax)
    string_len = min(strlen(desc), 255);
c0107e12:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107e15:	89 04 24             	mov    %eax,(%esp)
c0107e18:	e8 07 1e 00 00       	call   c0109c24 <strlen>
c0107e1d:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
c0107e24:	00 
c0107e25:	89 04 24             	mov    %eax,(%esp)
c0107e28:	e8 57 ff ff ff       	call   c0107d84 <min>
c0107e2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    state->desc = (char *) malloc(string_len + 1);
c0107e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107e33:	83 c0 01             	add    $0x1,%eax
c0107e36:	89 04 24             	mov    %eax,(%esp)
c0107e39:	e8 86 07 00 00       	call   c01085c4 <malloc>
c0107e3e:	89 c2                	mov    %eax,%edx
c0107e40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e43:	89 50 08             	mov    %edx,0x8(%eax)
    strncpy(state->desc, desc, string_len);
c0107e46:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e4c:	8b 40 08             	mov    0x8(%eax),%eax
c0107e4f:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107e53:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107e56:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107e5a:	89 04 24             	mov    %eax,(%esp)
c0107e5d:	e8 3a 1e 00 00       	call   c0109c9c <strncpy>
    state->desc[string_len + 1] = 0;
c0107e62:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e65:	8b 40 08             	mov    0x8(%eax),%eax
c0107e68:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107e6b:	83 c2 01             	add    $0x1,%edx
c0107e6e:	01 d0                	add    %edx,%eax
c0107e70:	c6 00 00             	movb   $0x0,(%eax)
    state->flags = flags;
c0107e73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e76:	0f b7 55 c4          	movzwl -0x3c(%ebp),%edx
c0107e7a:	66 89 50 30          	mov    %dx,0x30(%eax)
    state->files = list_create();
c0107e7e:	e8 dd 0d 00 00       	call   c0108c60 <list_create>
c0107e83:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107e86:	89 42 14             	mov    %eax,0x14(%edx)
    state->cwd = root;
c0107e89:	8b 15 4c 19 11 c0    	mov    0xc011194c,%edx
c0107e8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e92:	89 50 10             	mov    %edx,0x10(%eax)
    state->children = list_create();
c0107e95:	e8 c6 0d 00 00       	call   c0108c60 <list_create>
c0107e9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107e9d:	89 42 2c             	mov    %eax,0x2c(%edx)
    state->zombie_tids = list_create();
c0107ea0:	e8 bb 0d 00 00       	call   c0108c60 <list_create>
c0107ea5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107ea8:	89 42 28             	mov    %eax,0x28(%edx)
    state->threads = list_create();
c0107eab:	e8 b0 0d 00 00       	call   c0108c60 <list_create>
c0107eb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107eb3:	89 42 1c             	mov    %eax,0x1c(%edx)
    state->ports = list_create();
c0107eb6:	e8 a5 0d 00 00       	call   c0108c60 <list_create>
c0107ebb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107ebe:	89 42 18             	mov    %eax,0x18(%edx)
    state->tid_counter = 0;
c0107ec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107ec4:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

    if (parent == NULL)
c0107ecb:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0107ecf:	75 0e                	jne    c0107edf <process_create+0x14a>
        state->parent = kernel_state;
c0107ed1:	8b 15 04 30 11 c0    	mov    0xc0113004,%edx
c0107ed7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107eda:	89 50 0c             	mov    %edx,0xc(%eax)
c0107edd:	eb 09                	jmp    c0107ee8 <process_create+0x153>
    else
        state->parent = parent;
c0107edf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107ee2:	8b 55 14             	mov    0x14(%ebp),%edx
c0107ee5:	89 50 0c             	mov    %edx,0xc(%eax)

    if (list_is_empty(zombie_list))
c0107ee8:	a1 48 19 11 c0       	mov    0xc0111948,%eax
c0107eed:	89 04 24             	mov    %eax,(%esp)
c0107ef0:	e8 1c 11 00 00       	call   c0109011 <list_is_empty>
c0107ef5:	85 c0                	test   %eax,%eax
c0107ef7:	74 14                	je     c0107f0d <process_create+0x178>
    {
        state->pid = pid_counter++;
c0107ef9:	a1 a4 f4 10 c0       	mov    0xc010f4a4,%eax
c0107efe:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107f01:	89 02                	mov    %eax,(%edx)
c0107f03:	83 c0 01             	add    $0x1,%eax
c0107f06:	a3 a4 f4 10 c0       	mov    %eax,0xc010f4a4
c0107f0b:	eb 14                	jmp    c0107f21 <process_create+0x18c>
    }
    else
    {
        state->pid = (pid_t) list_pop_front(zombie_list);
c0107f0d:	a1 48 19 11 c0       	mov    0xc0111948,%eax
c0107f12:	89 04 24             	mov    %eax,(%esp)
c0107f15:	e8 fd 0e 00 00       	call   c0108e17 <list_pop_front>
c0107f1a:	89 c2                	mov    %eax,%edx
c0107f1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f1f:	89 10                	mov    %edx,(%eax)
    }


    asm volatile("cli");
c0107f21:	fa                   	cli    

        if(state->pid != 1)
c0107f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f25:	8b 00                	mov    (%eax),%eax
c0107f27:	83 f8 01             	cmp    $0x1,%eax
c0107f2a:	74 39                	je     c0107f65 <process_create+0x1d0>
        {
            struct child *new_child = malloc(sizeof(struct child));
c0107f2c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0107f33:	e8 8c 06 00 00       	call   c01085c4 <malloc>
c0107f38:	89 45 ec             	mov    %eax,-0x14(%ebp)
            new_child->process = state;
c0107f3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107f3e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107f41:	89 50 04             	mov    %edx,0x4(%eax)
            new_child->status = 0;
c0107f44:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107f47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            list_push_front(state->parent->children, new_child);
c0107f4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f50:	8b 40 0c             	mov    0xc(%eax),%eax
c0107f53:	8b 40 2c             	mov    0x2c(%eax),%eax
c0107f56:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0107f59:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107f5d:	89 04 24             	mov    %eax,(%esp)
c0107f60:	e8 45 0e 00 00       	call   c0108daa <list_push_front>
        }

        list_push_front(process_list, state);
c0107f65:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0107f6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107f6d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107f71:	89 04 24             	mov    %eax,(%esp)
c0107f74:	e8 31 0e 00 00       	call   c0108daa <list_push_front>

    asm volatile("sti");
c0107f79:	fb                   	sti    


    // create stream files
    vfs_inode_t *stdin = vfs_create_inode("stdin", 0x7ff, NULL);
c0107f7a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0107f81:	00 
c0107f82:	c7 44 24 04 ff 07 00 	movl   $0x7ff,0x4(%esp)
c0107f89:	00 
c0107f8a:	c7 04 24 ed c4 10 c0 	movl   $0xc010c4ed,(%esp)
c0107f91:	e8 51 11 00 00       	call   c01090e7 <vfs_create_inode>
c0107f96:	89 45 e8             	mov    %eax,-0x18(%ebp)
    vfs_inode_t *stdout = vfs_create_inode("stdout", 0x7ff, NULL);
c0107f99:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0107fa0:	00 
c0107fa1:	c7 44 24 04 ff 07 00 	movl   $0x7ff,0x4(%esp)
c0107fa8:	00 
c0107fa9:	c7 04 24 f3 c4 10 c0 	movl   $0xc010c4f3,(%esp)
c0107fb0:	e8 32 11 00 00       	call   c01090e7 <vfs_create_inode>
c0107fb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    vfs_inode_t *stderr = vfs_create_inode("stderr", 0x7ff, NULL);
c0107fb8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0107fbf:	00 
c0107fc0:	c7 44 24 04 ff 07 00 	movl   $0x7ff,0x4(%esp)
c0107fc7:	00 
c0107fc8:	c7 04 24 fa c4 10 c0 	movl   $0xc010c4fa,(%esp)
c0107fcf:	e8 13 11 00 00       	call   c01090e7 <vfs_create_inode>
c0107fd4:	89 45 e0             	mov    %eax,-0x20(%ebp)

    struct fd *desc0 = malloc(sizeof(struct fd));
c0107fd7:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0107fde:	e8 e1 05 00 00       	call   c01085c4 <malloc>
c0107fe3:	89 45 dc             	mov    %eax,-0x24(%ebp)
    desc0->id = 0;
c0107fe6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107fe9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    desc0->mode = 0x7ff;
c0107fef:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107ff2:	c7 40 08 ff 07 00 00 	movl   $0x7ff,0x8(%eax)
    desc0->flags = O_RDONLY;
c0107ff9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107ffc:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    desc0->pos = 0;
c0108003:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108006:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    desc0->inode = stdin;
c010800d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108010:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0108013:	89 50 04             	mov    %edx,0x4(%eax)
    list_push_back(state->files, desc0);
c0108016:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108019:	8b 40 14             	mov    0x14(%eax),%eax
c010801c:	8b 55 dc             	mov    -0x24(%ebp),%edx
c010801f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108023:	89 04 24             	mov    %eax,(%esp)
c0108026:	e8 2d 0d 00 00       	call   c0108d58 <list_push_back>

    struct fd *desc1 = malloc(sizeof(struct fd));
c010802b:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0108032:	e8 8d 05 00 00       	call   c01085c4 <malloc>
c0108037:	89 45 d8             	mov    %eax,-0x28(%ebp)
    desc1->id = 1;
c010803a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010803d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    desc1->mode = 0x7ff;
c0108043:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108046:	c7 40 08 ff 07 00 00 	movl   $0x7ff,0x8(%eax)
    desc1->flags = O_WRONLY;
c010804d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108050:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
    desc1->pos = 0;
c0108057:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010805a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    desc1->inode = stdout;
c0108061:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108064:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0108067:	89 50 04             	mov    %edx,0x4(%eax)
    list_push_back(state->files, desc1);
c010806a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010806d:	8b 40 14             	mov    0x14(%eax),%eax
c0108070:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0108073:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108077:	89 04 24             	mov    %eax,(%esp)
c010807a:	e8 d9 0c 00 00       	call   c0108d58 <list_push_back>

    struct fd *desc2 = malloc(sizeof(struct fd));
c010807f:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0108086:	e8 39 05 00 00       	call   c01085c4 <malloc>
c010808b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    desc2->id = 2;
c010808e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108091:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    desc2->mode = 0x7ff;
c0108097:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010809a:	c7 40 08 ff 07 00 00 	movl   $0x7ff,0x8(%eax)
    desc2->flags = O_WRONLY;
c01080a1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01080a4:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
    desc2->pos = 0;
c01080ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01080ae:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    desc2->inode = stderr;
c01080b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01080b8:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01080bb:	89 50 04             	mov    %edx,0x4(%eax)
    list_push_back(state->files, desc2);
c01080be:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01080c1:	8b 40 14             	mov    0x14(%eax),%eax
c01080c4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c01080c7:	89 54 24 04          	mov    %edx,0x4(%esp)
c01080cb:	89 04 24             	mov    %eax,(%esp)
c01080ce:	e8 85 0c 00 00       	call   c0108d58 <list_push_back>


    return state;
c01080d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01080d6:	c9                   	leave  
c01080d7:	c3                   	ret    

c01080d8 <process_kill>:
/**
 * kills a process
 * @param process pointer to the process state
 */
void process_kill(struct process_state *process)
{
c01080d8:	55                   	push   %ebp
c01080d9:	89 e5                	mov    %esp,%ebp
c01080db:	83 ec 28             	sub    $0x28,%esp
    asm volatile("cli");
c01080de:	fa                   	cli    
    list_set_first(process->threads);
c01080df:	8b 45 08             	mov    0x8(%ebp),%eax
c01080e2:	8b 40 1c             	mov    0x1c(%eax),%eax
c01080e5:	89 04 24             	mov    %eax,(%esp)
c01080e8:	e8 f9 0e 00 00       	call   c0108fe6 <list_set_first>

    while(!list_is_empty(process->threads))
c01080ed:	eb 51                	jmp    c0108140 <process_kill+0x68>
    {
        struct thread_state *thread = list_pop_front(process->threads);
c01080ef:	8b 45 08             	mov    0x8(%ebp),%eax
c01080f2:	8b 40 1c             	mov    0x1c(%eax),%eax
c01080f5:	89 04 24             	mov    %eax,(%esp)
c01080f8:	e8 1a 0d 00 00       	call   c0108e17 <list_pop_front>
c01080fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(thread == current_thread)
c0108100:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108105:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0108108:	75 2b                	jne    c0108135 <process_kill+0x5d>
        {
            current_thread->flags |= THREAD_ZOMBIE;
c010810a:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010810f:	8b 15 08 30 11 c0    	mov    0xc0113008,%edx
c0108115:	0f b7 52 10          	movzwl 0x10(%edx),%edx
c0108119:	83 ca 08             	or     $0x8,%edx
c010811c:	66 89 50 10          	mov    %dx,0x10(%eax)
            process->flags |= PROCESS_ZOMBIE;
c0108120:	8b 45 08             	mov    0x8(%ebp),%eax
c0108123:	0f b7 40 30          	movzwl 0x30(%eax),%eax
c0108127:	89 c2                	mov    %eax,%edx
c0108129:	83 ca 04             	or     $0x4,%edx
c010812c:	8b 45 08             	mov    0x8(%ebp),%eax
c010812f:	66 89 50 30          	mov    %dx,0x30(%eax)
c0108133:	eb 0b                	jmp    c0108140 <process_kill+0x68>
        }
        else
            thread_kill_sub(thread);
c0108135:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108138:	89 04 24             	mov    %eax,(%esp)
c010813b:	e8 e8 d9 ff ff       	call   c0105b28 <thread_kill_sub>
void process_kill(struct process_state *process)
{
    asm volatile("cli");
    list_set_first(process->threads);

    while(!list_is_empty(process->threads))
c0108140:	8b 45 08             	mov    0x8(%ebp),%eax
c0108143:	8b 40 1c             	mov    0x1c(%eax),%eax
c0108146:	89 04 24             	mov    %eax,(%esp)
c0108149:	e8 c3 0e 00 00       	call   c0109011 <list_is_empty>
c010814e:	85 c0                	test   %eax,%eax
c0108150:	74 9d                	je     c01080ef <process_kill+0x17>
        }
        else
            thread_kill_sub(thread);
    }

    list_set_first(process->children);
c0108152:	8b 45 08             	mov    0x8(%ebp),%eax
c0108155:	8b 40 2c             	mov    0x2c(%eax),%eax
c0108158:	89 04 24             	mov    %eax,(%esp)
c010815b:	e8 86 0e 00 00       	call   c0108fe6 <list_set_first>
    while(!list_is_empty(process->children))
c0108160:	eb 2a                	jmp    c010818c <process_kill+0xb4>
    {
        struct child *current_child = list_pop_front(process->children);
c0108162:	8b 45 08             	mov    0x8(%ebp),%eax
c0108165:	8b 40 2c             	mov    0x2c(%eax),%eax
c0108168:	89 04 24             	mov    %eax,(%esp)
c010816b:	e8 a7 0c 00 00       	call   c0108e17 <list_pop_front>
c0108170:	89 45 f0             	mov    %eax,-0x10(%ebp)
        process_kill(current_child->process);
c0108173:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108176:	8b 40 04             	mov    0x4(%eax),%eax
c0108179:	89 04 24             	mov    %eax,(%esp)
c010817c:	e8 57 ff ff ff       	call   c01080d8 <process_kill>
        free(current_child);
c0108181:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108184:	89 04 24             	mov    %eax,(%esp)
c0108187:	e8 53 04 00 00       	call   c01085df <free>
        else
            thread_kill_sub(thread);
    }

    list_set_first(process->children);
    while(!list_is_empty(process->children))
c010818c:	8b 45 08             	mov    0x8(%ebp),%eax
c010818f:	8b 40 2c             	mov    0x2c(%eax),%eax
c0108192:	89 04 24             	mov    %eax,(%esp)
c0108195:	e8 77 0e 00 00       	call   c0109011 <list_is_empty>
c010819a:	85 c0                	test   %eax,%eax
c010819c:	74 c4                	je     c0108162 <process_kill+0x8a>
        process_kill(current_child->process);
        free(current_child);
    }


    list_set_first(process->parent->children);
c010819e:	8b 45 08             	mov    0x8(%ebp),%eax
c01081a1:	8b 40 0c             	mov    0xc(%eax),%eax
c01081a4:	8b 40 2c             	mov    0x2c(%eax),%eax
c01081a7:	89 04 24             	mov    %eax,(%esp)
c01081aa:	e8 37 0e 00 00       	call   c0108fe6 <list_set_first>
    while(!list_is_empty(process->parent->children))
c01081af:	eb 3c                	jmp    c01081ed <process_kill+0x115>
    {
        struct child *current_child = list_get_current(process->parent->children);
c01081b1:	8b 45 08             	mov    0x8(%ebp),%eax
c01081b4:	8b 40 0c             	mov    0xc(%eax),%eax
c01081b7:	8b 40 2c             	mov    0x2c(%eax),%eax
c01081ba:	89 04 24             	mov    %eax,(%esp)
c01081bd:	e8 d1 0d 00 00       	call   c0108f93 <list_get_current>
c01081c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(current_child->process == process)
c01081c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01081c8:	8b 40 04             	mov    0x4(%eax),%eax
c01081cb:	3b 45 08             	cmp    0x8(%ebp),%eax
c01081ce:	75 0c                	jne    c01081dc <process_kill+0x104>
        {
            current_child->process = 0;
c01081d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01081d3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            break;
c01081da:	eb 26                	jmp    c0108202 <process_kill+0x12a>
        }
        list_next(process->parent->children);
c01081dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01081df:	8b 40 0c             	mov    0xc(%eax),%eax
c01081e2:	8b 40 2c             	mov    0x2c(%eax),%eax
c01081e5:	89 04 24             	mov    %eax,(%esp)
c01081e8:	e8 b4 0d 00 00       	call   c0108fa1 <list_next>
        free(current_child);
    }


    list_set_first(process->parent->children);
    while(!list_is_empty(process->parent->children))
c01081ed:	8b 45 08             	mov    0x8(%ebp),%eax
c01081f0:	8b 40 0c             	mov    0xc(%eax),%eax
c01081f3:	8b 40 2c             	mov    0x2c(%eax),%eax
c01081f6:	89 04 24             	mov    %eax,(%esp)
c01081f9:	e8 13 0e 00 00       	call   c0109011 <list_is_empty>
c01081fe:	85 c0                	test   %eax,%eax
c0108200:	74 af                	je     c01081b1 <process_kill+0xd9>
            break;
        }
        list_next(process->parent->children);
    }

    list_destroy(&process->ports);
c0108202:	8b 45 08             	mov    0x8(%ebp),%eax
c0108205:	83 c0 18             	add    $0x18,%eax
c0108208:	89 04 24             	mov    %eax,(%esp)
c010820b:	e8 af 0a 00 00       	call   c0108cbf <list_destroy>
    list_destroy(&process->zombie_tids);
c0108210:	8b 45 08             	mov    0x8(%ebp),%eax
c0108213:	83 c0 28             	add    $0x28,%eax
c0108216:	89 04 24             	mov    %eax,(%esp)
c0108219:	e8 a1 0a 00 00       	call   c0108cbf <list_destroy>

    list_set_first(process_list);
c010821e:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0108223:	89 04 24             	mov    %eax,(%esp)
c0108226:	e8 bb 0d 00 00       	call   c0108fe6 <list_set_first>

    while(!list_is_last(process_list))
c010822b:	eb 2e                	jmp    c010825b <process_kill+0x183>
    {
        if(((struct process_state *)list_get_current(process_list)) == process)
c010822d:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0108232:	89 04 24             	mov    %eax,(%esp)
c0108235:	e8 59 0d 00 00       	call   c0108f93 <list_get_current>
c010823a:	3b 45 08             	cmp    0x8(%ebp),%eax
c010823d:	75 0f                	jne    c010824e <process_kill+0x176>
        {
            list_remove(process_list);
c010823f:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0108244:	89 04 24             	mov    %eax,(%esp)
c0108247:	e8 c5 0c 00 00       	call   c0108f11 <list_remove>
            break;
c010824c:	eb 1e                	jmp    c010826c <process_kill+0x194>
        }
        list_next(process_list);
c010824e:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0108253:	89 04 24             	mov    %eax,(%esp)
c0108256:	e8 46 0d 00 00       	call   c0108fa1 <list_next>
    list_destroy(&process->ports);
    list_destroy(&process->zombie_tids);

    list_set_first(process_list);

    while(!list_is_last(process_list))
c010825b:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0108260:	89 04 24             	mov    %eax,(%esp)
c0108263:	e8 66 0d 00 00       	call   c0108fce <list_is_last>
c0108268:	85 c0                	test   %eax,%eax
c010826a:	74 c1                	je     c010822d <process_kill+0x155>
            break;
        }
        list_next(process_list);
    }

    free(process->name);
c010826c:	8b 45 08             	mov    0x8(%ebp),%eax
c010826f:	8b 40 04             	mov    0x4(%eax),%eax
c0108272:	89 04 24             	mov    %eax,(%esp)
c0108275:	e8 65 03 00 00       	call   c01085df <free>
    free(process->desc);
c010827a:	8b 45 08             	mov    0x8(%ebp),%eax
c010827d:	8b 40 08             	mov    0x8(%eax),%eax
c0108280:	89 04 24             	mov    %eax,(%esp)
c0108283:	e8 57 03 00 00       	call   c01085df <free>

    if(! (process->flags & PROCESS_ZOMBIE) )
c0108288:	8b 45 08             	mov    0x8(%ebp),%eax
c010828b:	0f b7 40 30          	movzwl 0x30(%eax),%eax
c010828f:	0f b7 c0             	movzwl %ax,%eax
c0108292:	83 e0 04             	and    $0x4,%eax
c0108295:	85 c0                	test   %eax,%eax
c0108297:	75 2a                	jne    c01082c3 <process_kill+0x1eb>
    {
        free(process);
c0108299:	8b 45 08             	mov    0x8(%ebp),%eax
c010829c:	89 04 24             	mov    %eax,(%esp)
c010829f:	e8 3b 03 00 00       	call   c01085df <free>
        list_set_first(running_threads);
c01082a4:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c01082a9:	89 04 24             	mov    %eax,(%esp)
c01082ac:	e8 35 0d 00 00       	call   c0108fe6 <list_set_first>
        current_thread = list_get_current(running_threads);
c01082b1:	a1 0c 30 11 c0       	mov    0xc011300c,%eax
c01082b6:	89 04 24             	mov    %eax,(%esp)
c01082b9:	e8 d5 0c 00 00       	call   c0108f93 <list_get_current>
c01082be:	a3 08 30 11 c0       	mov    %eax,0xc0113008
    }
    asm volatile("sti");
c01082c3:	fb                   	sti    
}
c01082c4:	c9                   	leave  
c01082c5:	c3                   	ret    

c01082c6 <process_find>:
 * finds a process by ID
 * @param pid Process ID
 * @return process state pointer or NULL if the process does not exist
 */
struct process_state *process_find(pid_t pid)
{
c01082c6:	55                   	push   %ebp
c01082c7:	89 e5                	mov    %esp,%ebp
c01082c9:	83 ec 18             	sub    $0x18,%esp
    list_set_first(process_list);
c01082cc:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c01082d1:	89 04 24             	mov    %eax,(%esp)
c01082d4:	e8 0d 0d 00 00       	call   c0108fe6 <list_set_first>
    while(!list_is_last(process_list))
c01082d9:	eb 30                	jmp    c010830b <process_find+0x45>
    {
        if(((struct process_state *)list_get_current(process_list))->pid == pid)
c01082db:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c01082e0:	89 04 24             	mov    %eax,(%esp)
c01082e3:	e8 ab 0c 00 00       	call   c0108f93 <list_get_current>
c01082e8:	8b 00                	mov    (%eax),%eax
c01082ea:	3b 45 08             	cmp    0x8(%ebp),%eax
c01082ed:	75 0f                	jne    c01082fe <process_find+0x38>
        {
            return (struct process_state *)list_get_current(process_list);
c01082ef:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c01082f4:	89 04 24             	mov    %eax,(%esp)
c01082f7:	e8 97 0c 00 00       	call   c0108f93 <list_get_current>
c01082fc:	eb 23                	jmp    c0108321 <process_find+0x5b>
        }
        list_next(process_list);
c01082fe:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0108303:	89 04 24             	mov    %eax,(%esp)
c0108306:	e8 96 0c 00 00       	call   c0108fa1 <list_next>
 * @return process state pointer or NULL if the process does not exist
 */
struct process_state *process_find(pid_t pid)
{
    list_set_first(process_list);
    while(!list_is_last(process_list))
c010830b:	a1 44 19 11 c0       	mov    0xc0111944,%eax
c0108310:	89 04 24             	mov    %eax,(%esp)
c0108313:	e8 b6 0c 00 00       	call   c0108fce <list_is_last>
c0108318:	85 c0                	test   %eax,%eax
c010831a:	74 bf                	je     c01082db <process_find+0x15>
        {
            return (struct process_state *)list_get_current(process_list);
        }
        list_next(process_list);
    }
    return 0;
c010831c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0108321:	c9                   	leave  
c0108322:	c3                   	ret    

c0108323 <sys_exit>:
/**
 * terminates the current process (linux function for the API)
 * @param cpu registers of the corrent process
 */
void sys_exit(struct cpu_state **cpu)
{
c0108323:	55                   	push   %ebp
c0108324:	89 e5                	mov    %esp,%ebp
c0108326:	83 ec 28             	sub    $0x28,%esp
    list_set_first(current_thread->process->parent->children);
c0108329:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010832e:	8b 40 04             	mov    0x4(%eax),%eax
c0108331:	8b 40 0c             	mov    0xc(%eax),%eax
c0108334:	8b 40 2c             	mov    0x2c(%eax),%eax
c0108337:	89 04 24             	mov    %eax,(%esp)
c010833a:	e8 a7 0c 00 00       	call   c0108fe6 <list_set_first>
    while(list_is_last(current_thread->process->parent->children))
c010833f:	eb 52                	jmp    c0108393 <sys_exit+0x70>
    {
        struct child *current_child = list_get_current(current_thread->process->parent->children);
c0108341:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108346:	8b 40 04             	mov    0x4(%eax),%eax
c0108349:	8b 40 0c             	mov    0xc(%eax),%eax
c010834c:	8b 40 2c             	mov    0x2c(%eax),%eax
c010834f:	89 04 24             	mov    %eax,(%esp)
c0108352:	e8 3c 0c 00 00       	call   c0108f93 <list_get_current>
c0108357:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(current_child->process == current_thread->process)
c010835a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010835d:	8b 50 04             	mov    0x4(%eax),%edx
c0108360:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108365:	8b 40 04             	mov    0x4(%eax),%eax
c0108368:	39 c2                	cmp    %eax,%edx
c010836a:	75 11                	jne    c010837d <sys_exit+0x5a>
        {
            current_child->status = (*cpu)->ebx;
c010836c:	8b 45 08             	mov    0x8(%ebp),%eax
c010836f:	8b 00                	mov    (%eax),%eax
c0108371:	8b 40 1c             	mov    0x1c(%eax),%eax
c0108374:	89 c2                	mov    %eax,%edx
c0108376:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108379:	89 10                	mov    %edx,(%eax)
            break;
c010837b:	eb 30                	jmp    c01083ad <sys_exit+0x8a>
        }
        list_next(current_thread->process->parent->children);
c010837d:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108382:	8b 40 04             	mov    0x4(%eax),%eax
c0108385:	8b 40 0c             	mov    0xc(%eax),%eax
c0108388:	8b 40 2c             	mov    0x2c(%eax),%eax
c010838b:	89 04 24             	mov    %eax,(%esp)
c010838e:	e8 0e 0c 00 00       	call   c0108fa1 <list_next>
 * @param cpu registers of the corrent process
 */
void sys_exit(struct cpu_state **cpu)
{
    list_set_first(current_thread->process->parent->children);
    while(list_is_last(current_thread->process->parent->children))
c0108393:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108398:	8b 40 04             	mov    0x4(%eax),%eax
c010839b:	8b 40 0c             	mov    0xc(%eax),%eax
c010839e:	8b 40 2c             	mov    0x2c(%eax),%eax
c01083a1:	89 04 24             	mov    %eax,(%esp)
c01083a4:	e8 25 0c 00 00       	call   c0108fce <list_is_last>
c01083a9:	85 c0                	test   %eax,%eax
c01083ab:	75 94                	jne    c0108341 <sys_exit+0x1e>
            break;
        }
        list_next(current_thread->process->parent->children);
    }

    process_kill(current_thread->process);
c01083ad:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01083b2:	8b 40 04             	mov    0x4(%eax),%eax
c01083b5:	89 04 24             	mov    %eax,(%esp)
c01083b8:	e8 1b fd ff ff       	call   c01080d8 <process_kill>
    *cpu = task_schedule(*cpu);
c01083bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01083c0:	8b 00                	mov    (%eax),%eax
c01083c2:	89 04 24             	mov    %eax,(%esp)
c01083c5:	e8 28 9d ff ff       	call   c01020f2 <task_schedule>
c01083ca:	8b 55 08             	mov    0x8(%ebp),%edx
c01083cd:	89 02                	mov    %eax,(%edx)
}
c01083cf:	c9                   	leave  
c01083d0:	c3                   	ret    

c01083d1 <sys_fork>:
/**
 * creates a new child process (linux function for the API)
 * @param cpu registers of the current process
 */
void sys_fork(struct cpu_state **cpu)
{
c01083d1:	55                   	push   %ebp
c01083d2:	89 e5                	mov    %esp,%ebp
c01083d4:	53                   	push   %ebx
c01083d5:	83 ec 44             	sub    $0x44,%esp
    struct process_state *new_process = process_create(current_thread->process->name ,current_thread->process->desc ,current_thread->process->flags ,current_thread->process);
c01083d8:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01083dd:	8b 58 04             	mov    0x4(%eax),%ebx
c01083e0:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01083e5:	8b 40 04             	mov    0x4(%eax),%eax
c01083e8:	0f b7 40 30          	movzwl 0x30(%eax),%eax
c01083ec:	0f b7 c8             	movzwl %ax,%ecx
c01083ef:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01083f4:	8b 40 04             	mov    0x4(%eax),%eax
c01083f7:	8b 50 08             	mov    0x8(%eax),%edx
c01083fa:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01083ff:	8b 40 04             	mov    0x4(%eax),%eax
c0108402:	8b 40 04             	mov    0x4(%eax),%eax
c0108405:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0108409:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010840d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108411:	89 04 24             	mov    %eax,(%esp)
c0108414:	e8 7c f9 ff ff       	call   c0107d95 <process_create>
c0108419:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct thread_state *new_thread = thread_create(new_process, !(current_thread->flags & THREAD_KERNELMODE), 0, *cpu, 0, NULL, NULL);
c010841c:	8b 45 08             	mov    0x8(%ebp),%eax
c010841f:	8b 10                	mov    (%eax),%edx
c0108421:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108426:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c010842a:	0f b7 c0             	movzwl %ax,%eax
c010842d:	83 e0 04             	and    $0x4,%eax
c0108430:	85 c0                	test   %eax,%eax
c0108432:	0f 94 c0             	sete   %al
c0108435:	0f b6 c0             	movzbl %al,%eax
c0108438:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c010843f:	00 
c0108440:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0108447:	00 
c0108448:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010844f:	00 
c0108450:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0108454:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010845b:	00 
c010845c:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108460:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108463:	89 04 24             	mov    %eax,(%esp)
c0108466:	e8 5b d4 ff ff       	call   c01058c6 <thread_create>
c010846b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int i;
    for(i = 0; i < (MEMORY_LAYOUT_KERNEL_START >> 22); i++)
c010846e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0108475:	eb 76                	jmp    c01084ed <sys_fork+0x11c>
    {
        if(current_thread->context.arch_context->entries[i]) {
c0108477:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010847c:	8b 40 08             	mov    0x8(%eax),%eax
c010847f:	8b 00                	mov    (%eax),%eax
c0108481:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108484:	c1 e2 02             	shl    $0x2,%edx
c0108487:	01 d0                	add    %edx,%eax
c0108489:	8b 00                	mov    (%eax),%eax
c010848b:	85 c0                	test   %eax,%eax
c010848d:	74 5a                	je     c01084e9 <sys_fork+0x118>
          pt_t *new_pt = (pt_t *) pt_create(new_thread->context.arch_context, i, VMM_PRESENT | VMM_USER);
c010848f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108492:	8b 40 08             	mov    0x8(%eax),%eax
c0108495:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
c010849c:	00 
c010849d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01084a0:	89 54 24 04          	mov    %edx,0x4(%esp)
c01084a4:	89 04 24             	mov    %eax,(%esp)
c01084a7:	e8 12 dc ff ff       	call   c01060be <pt_create>
c01084ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
          pt_t *pt = (pt_t *) pt_get(new_thread->context.arch_context, i, VMM_PRESENT | VMM_USER);
c01084af:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01084b2:	8b 40 08             	mov    0x8(%eax),%eax
c01084b5:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
c01084bc:	00 
c01084bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01084c0:	89 54 24 04          	mov    %edx,0x4(%esp)
c01084c4:	89 04 24             	mov    %eax,(%esp)
c01084c7:	e8 6d db ff ff       	call   c0106039 <pt_get>
c01084cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          memcpy((void*)new_pt, (void*)pt, 4096);
c01084cf:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c01084d6:	00 
c01084d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01084da:	89 44 24 04          	mov    %eax,0x4(%esp)
c01084de:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01084e1:	89 04 24             	mov    %eax,(%esp)
c01084e4:	e8 43 1b 00 00       	call   c010a02c <memcpy>
void sys_fork(struct cpu_state **cpu)
{
    struct process_state *new_process = process_create(current_thread->process->name ,current_thread->process->desc ,current_thread->process->flags ,current_thread->process);
    struct thread_state *new_thread = thread_create(new_process, !(current_thread->flags & THREAD_KERNELMODE), 0, *cpu, 0, NULL, NULL);
    int i;
    for(i = 0; i < (MEMORY_LAYOUT_KERNEL_START >> 22); i++)
c01084e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01084ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01084f0:	3d ff 02 00 00       	cmp    $0x2ff,%eax
c01084f5:	76 80                	jbe    c0108477 <sys_fork+0xa6>
          pt_t *new_pt = (pt_t *) pt_create(new_thread->context.arch_context, i, VMM_PRESENT | VMM_USER);
          pt_t *pt = (pt_t *) pt_get(new_thread->context.arch_context, i, VMM_PRESENT | VMM_USER);
          memcpy((void*)new_pt, (void*)pt, 4096);
        }
    }
    new_thread->state->eax = 0;
c01084f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01084fa:	8b 00                	mov    (%eax),%eax
c01084fc:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    current_thread->state->eax = new_process->pid;
c0108503:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108508:	8b 00                	mov    (%eax),%eax
c010850a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010850d:	8b 12                	mov    (%edx),%edx
c010850f:	89 50 28             	mov    %edx,0x28(%eax)
}
c0108512:	83 c4 44             	add    $0x44,%esp
c0108515:	5b                   	pop    %ebx
c0108516:	5d                   	pop    %ebp
c0108517:	c3                   	ret    

c0108518 <sys_waitpid>:
 *  @param cpu registers of the current process
 *  Not completed
 */

void sys_waitpid(struct cpu_state **cpu)
{
c0108518:	55                   	push   %ebp
c0108519:	89 e5                	mov    %esp,%ebp
c010851b:	83 ec 28             	sub    $0x28,%esp
    if(list_is_empty(current_thread->process->children))
c010851e:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108523:	8b 40 04             	mov    0x4(%eax),%eax
c0108526:	8b 40 2c             	mov    0x2c(%eax),%eax
c0108529:	89 04 24             	mov    %eax,(%esp)
c010852c:	e8 e0 0a 00 00       	call   c0109011 <list_is_empty>
c0108531:	85 c0                	test   %eax,%eax
c0108533:	75 76                	jne    c01085ab <sys_waitpid+0x93>


    }
    else
    {
        list_set_first(current_thread->process->children);
c0108535:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010853a:	8b 40 04             	mov    0x4(%eax),%eax
c010853d:	8b 40 2c             	mov    0x2c(%eax),%eax
c0108540:	89 04 24             	mov    %eax,(%esp)
c0108543:	e8 9e 0a 00 00       	call   c0108fe6 <list_set_first>
        while(!list_is_last(current_thread->process->children))
c0108548:	eb 4a                	jmp    c0108594 <sys_waitpid+0x7c>
        {
            struct child *current_child = list_get_current(current_thread->process->children);
c010854a:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010854f:	8b 40 04             	mov    0x4(%eax),%eax
c0108552:	8b 40 2c             	mov    0x2c(%eax),%eax
c0108555:	89 04 24             	mov    %eax,(%esp)
c0108558:	e8 36 0a 00 00       	call   c0108f93 <list_get_current>
c010855d:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(current_child->process == NULL) //Child is dead
c0108560:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108563:	8b 40 04             	mov    0x4(%eax),%eax
c0108566:	85 c0                	test   %eax,%eax
c0108568:	75 17                	jne    c0108581 <sys_waitpid+0x69>
            {
                if( ((int) (*cpu)->ebx) == -1)
c010856a:	8b 45 08             	mov    0x8(%ebp),%eax
c010856d:	8b 00                	mov    (%eax),%eax
c010856f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0108572:	83 f8 ff             	cmp    $0xffffffff,%eax
c0108575:	74 0a                	je     c0108581 <sys_waitpid+0x69>
                {


                }
                else if(((int) (*cpu)->ebx) > 0 && (*cpu)->ebx == current_thread->process->pid)
c0108577:	8b 45 08             	mov    0x8(%ebp),%eax
c010857a:	8b 00                	mov    (%eax),%eax
c010857c:	8b 40 1c             	mov    0x1c(%eax),%eax
c010857f:	85 c0                	test   %eax,%eax
                {

                }
            }
            list_next(current_thread->process->children);
c0108581:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108586:	8b 40 04             	mov    0x4(%eax),%eax
c0108589:	8b 40 2c             	mov    0x2c(%eax),%eax
c010858c:	89 04 24             	mov    %eax,(%esp)
c010858f:	e8 0d 0a 00 00       	call   c0108fa1 <list_next>

    }
    else
    {
        list_set_first(current_thread->process->children);
        while(!list_is_last(current_thread->process->children))
c0108594:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0108599:	8b 40 04             	mov    0x4(%eax),%eax
c010859c:	8b 40 2c             	mov    0x2c(%eax),%eax
c010859f:	89 04 24             	mov    %eax,(%esp)
c01085a2:	e8 27 0a 00 00       	call   c0108fce <list_is_last>
c01085a7:	85 c0                	test   %eax,%eax
c01085a9:	74 9f                	je     c010854a <sys_waitpid+0x32>
                }
            }
            list_next(current_thread->process->children);
        }
    }
}
c01085ab:	c9                   	leave  
c01085ac:	c3                   	ret    
c01085ad:	66 90                	xchg   %ax,%ax
c01085af:	90                   	nop

c01085b0 <INIT_HEAP>:
#include <paging.h>
#include <string.h>

heap_t kernel_heap;

void INIT_HEAP(void) {
c01085b0:	55                   	push   %ebp
c01085b1:	89 e5                	mov    %esp,%ebp
c01085b3:	83 ec 18             	sub    $0x18,%esp
	heap_init(&kernel_heap);
c01085b6:	c7 04 24 d0 32 13 c0 	movl   $0xc01332d0,(%esp)
c01085bd:	e8 c3 00 00 00       	call   c0108685 <heap_init>
}
c01085c2:	c9                   	leave  
c01085c3:	c3                   	ret    

c01085c4 <malloc>:

/* c standard interface. do some preparation here! */

void *malloc(size_t size) {
c01085c4:	55                   	push   %ebp
c01085c5:	89 e5                	mov    %esp,%ebp
c01085c7:	83 ec 18             	sub    $0x18,%esp
	return heap_alloc(&kernel_heap, size);
c01085ca:	8b 45 08             	mov    0x8(%ebp),%eax
c01085cd:	89 44 24 04          	mov    %eax,0x4(%esp)
c01085d1:	c7 04 24 d0 32 13 c0 	movl   $0xc01332d0,(%esp)
c01085d8:	e8 48 02 00 00       	call   c0108825 <heap_alloc>
}
c01085dd:	c9                   	leave  
c01085de:	c3                   	ret    

c01085df <free>:

void free(void * ptr) {
c01085df:	55                   	push   %ebp
c01085e0:	89 e5                	mov    %esp,%ebp
c01085e2:	83 ec 18             	sub    $0x18,%esp
	heap_free(&kernel_heap, ptr);
c01085e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01085e8:	89 44 24 04          	mov    %eax,0x4(%esp)
c01085ec:	c7 04 24 d0 32 13 c0 	movl   $0xc01332d0,(%esp)
c01085f3:	e8 fc 02 00 00       	call   c01088f4 <heap_free>
}
c01085f8:	c9                   	leave  
c01085f9:	c3                   	ret    

c01085fa <calloc>:

void *calloc(size_t num, size_t size) {
c01085fa:	55                   	push   %ebp
c01085fb:	89 e5                	mov    %esp,%ebp
c01085fd:	83 ec 28             	sub    $0x28,%esp
	void *data = heap_alloc(&kernel_heap, size);
c0108600:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108603:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108607:	c7 04 24 d0 32 13 c0 	movl   $0xc01332d0,(%esp)
c010860e:	e8 12 02 00 00       	call   c0108825 <heap_alloc>
c0108613:	89 45 f4             	mov    %eax,-0xc(%ebp)
	memset(data, 0, size);
c0108616:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108619:	89 44 24 08          	mov    %eax,0x8(%esp)
c010861d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0108624:	00 
c0108625:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108628:	89 04 24             	mov    %eax,(%esp)
c010862b:	e8 c5 1b 00 00       	call   c010a1f5 <memset>

	return data;
c0108630:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108633:	c9                   	leave  
c0108634:	c3                   	ret    

c0108635 <realloc>:

void *realloc(void *ptr, size_t size) {
c0108635:	55                   	push   %ebp
c0108636:	89 e5                	mov    %esp,%ebp
c0108638:	83 ec 28             	sub    $0x28,%esp
	void *dest = heap_alloc(&kernel_heap, size);
c010863b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010863e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108642:	c7 04 24 d0 32 13 c0 	movl   $0xc01332d0,(%esp)
c0108649:	e8 d7 01 00 00       	call   c0108825 <heap_alloc>
c010864e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	alloc_t *source_alloc = ptr - sizeof(alloc_t);
c0108651:	8b 45 08             	mov    0x8(%ebp),%eax
c0108654:	83 e8 10             	sub    $0x10,%eax
c0108657:	89 45 f0             	mov    %eax,-0x10(%ebp)

	memmove(dest, ptr, source_alloc->size);
c010865a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010865d:	8b 00                	mov    (%eax),%eax
c010865f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108663:	8b 45 08             	mov    0x8(%ebp),%eax
c0108666:	89 44 24 04          	mov    %eax,0x4(%esp)
c010866a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010866d:	89 04 24             	mov    %eax,(%esp)
c0108670:	e8 f8 19 00 00       	call   c010a06d <memmove>
	free(ptr);
c0108675:	8b 45 08             	mov    0x8(%ebp),%eax
c0108678:	89 04 24             	mov    %eax,(%esp)
c010867b:	e8 5f ff ff ff       	call   c01085df <free>

	return dest;
c0108680:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108683:	c9                   	leave  
c0108684:	c3                   	ret    

c0108685 <heap_init>:
 * Initalize a heap
 *
 * @param heap heap to initalise
 * @return void
 */
void heap_init(heap_t *heap) {
c0108685:	55                   	push   %ebp
c0108686:	89 e5                	mov    %esp,%ebp
c0108688:	83 ec 28             	sub    $0x28,%esp
	vaddr_t vframe = vmm_automap_kernel(current_context, pmm_alloc_page(), VMM_WRITABLE);
c010868b:	e8 78 c9 ff ff       	call   c0105008 <pmm_alloc_page>
c0108690:	8b 15 40 19 11 c0    	mov    0xc0111940,%edx
c0108696:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c010869d:	00 
c010869e:	89 44 24 04          	mov    %eax,0x4(%esp)
c01086a2:	89 14 24             	mov    %edx,(%esp)
c01086a5:	e8 6c ea ff ff       	call   c0107116 <vmm_automap_kernel>
c01086aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	alloc_t *header = (alloc_t *)vframe;
c01086ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01086b0:	89 45 f0             	mov    %eax,-0x10(%ebp)

	header->size = PAGE_SIZE - sizeof(alloc_t);
c01086b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01086b6:	c7 00 f0 0f 00 00    	movl   $0xff0,(%eax)
	header->base = vframe + sizeof(alloc_t);
c01086bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01086bf:	8d 50 10             	lea    0x10(%eax),%edx
c01086c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01086c5:	89 50 04             	mov    %edx,0x4(%eax)
	header->status = HEAP_STATUS_FREE;
c01086c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01086cb:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	header->next = NULL;
c01086d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01086d5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	heap->list_count = 1;
c01086dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01086df:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	heap->alloc_list = header;
c01086e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01086e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01086eb:	89 50 04             	mov    %edx,0x4(%eax)
}
c01086ee:	c9                   	leave  
c01086ef:	c3                   	ret    

c01086f0 <heap_expand>:
 * Add a page to the heap
 *
 * @param heap heap
 * @return void
 */
alloc_t *heap_expand(heap_t *heap, int pages) {
c01086f0:	55                   	push   %ebp
c01086f1:	89 e5                	mov    %esp,%ebp
c01086f3:	83 ec 48             	sub    $0x48,%esp
	/* TODO : Range Allocation */
	heap->list_count++;
c01086f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01086f9:	8b 00                	mov    (%eax),%eax
c01086fb:	8d 50 01             	lea    0x1(%eax),%edx
c01086fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0108701:	89 10                	mov    %edx,(%eax)
	paddr_t pframe = 0;
c0108703:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	vaddr_t vframe = arch_vaddr_find(current_context->arch_context, pages,
c010870a:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c010870f:	8b 00                	mov    (%eax),%eax
c0108711:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
c0108718:	00 
c0108719:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c0108720:	ff 
c0108721:	c7 44 24 08 00 00 00 	movl   $0xe0000000,0x8(%esp)
c0108728:	e0 
c0108729:	8b 55 0c             	mov    0xc(%ebp),%edx
c010872c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108730:	89 04 24             	mov    %eax,(%esp)
c0108733:	e8 fd db ff ff       	call   c0106335 <arch_vaddr_find>
c0108738:	89 45 e8             	mov    %eax,-0x18(%ebp)
				    MEMORY_LAYOUT_KERNEL_HEAP_START,
				    MEMORY_LAYOUT_KERNEL_HEAP_END, VMM_WRITABLE);
	vaddr_t vframe_cur = vframe;
c010873b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010873e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	int i;
	for(i = 0; i < pages; i++) {
c0108741:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0108748:	eb 36                	jmp    c0108780 <heap_expand+0x90>
		pframe = pmm_alloc_page();
c010874a:	e8 b9 c8 ff ff       	call   c0105008 <pmm_alloc_page>
c010874f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		vmm_map(current_context, pframe, vframe_cur, VMM_WRITABLE);
c0108752:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c0108757:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c010875e:	00 
c010875f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108762:	89 54 24 08          	mov    %edx,0x8(%esp)
c0108766:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0108769:	89 54 24 04          	mov    %edx,0x4(%esp)
c010876d:	89 04 24             	mov    %eax,(%esp)
c0108770:	e8 b1 e8 ff ff       	call   c0107026 <vmm_map>
		vframe_cur += PAGE_SIZE;
c0108775:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
				    MEMORY_LAYOUT_KERNEL_HEAP_START,
				    MEMORY_LAYOUT_KERNEL_HEAP_END, VMM_WRITABLE);
	vaddr_t vframe_cur = vframe;

	int i;
	for(i = 0; i < pages; i++) {
c010877c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0108780:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108783:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0108786:	7c c2                	jl     c010874a <heap_expand+0x5a>
		pframe = pmm_alloc_page();
		vmm_map(current_context, pframe, vframe_cur, VMM_WRITABLE);
		vframe_cur += PAGE_SIZE;
	}

	alloc_t *new_header = (alloc_t *) vframe;
c0108788:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010878b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	new_header->size = pages*PAGE_SIZE - sizeof(alloc_t);
c010878e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108791:	c1 e0 0c             	shl    $0xc,%eax
c0108794:	8d 50 f0             	lea    -0x10(%eax),%edx
c0108797:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010879a:	89 10                	mov    %edx,(%eax)
	new_header->base = vframe + sizeof(alloc_t);
c010879c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010879f:	8d 50 10             	lea    0x10(%eax),%edx
c01087a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01087a5:	89 50 04             	mov    %edx,0x4(%eax)
	new_header->status = HEAP_STATUS_FREE;
c01087a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01087ab:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	new_header->next = heap->alloc_list;
c01087b2:	8b 45 08             	mov    0x8(%ebp),%eax
c01087b5:	8b 50 04             	mov    0x4(%eax),%edx
c01087b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01087bb:	89 50 0c             	mov    %edx,0xc(%eax)
	heap->alloc_list = new_header;
c01087be:	8b 45 08             	mov    0x8(%ebp),%eax
c01087c1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01087c4:	89 50 04             	mov    %edx,0x4(%eax)
	heap->list_count ++;
c01087c7:	8b 45 08             	mov    0x8(%ebp),%eax
c01087ca:	8b 00                	mov    (%eax),%eax
c01087cc:	8d 50 01             	lea    0x1(%eax),%edx
c01087cf:	8b 45 08             	mov    0x8(%ebp),%eax
c01087d2:	89 10                	mov    %edx,(%eax)
	return new_header;
c01087d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
c01087d7:	c9                   	leave  
c01087d8:	c3                   	ret    

c01087d9 <heap_destroy>:
 * Destroy a heap
 *
 * @param heap heap
 * @return void
 */
void heap_destroy(heap_t *heap) {
c01087d9:	55                   	push   %ebp
c01087da:	89 e5                	mov    %esp,%ebp
c01087dc:	83 ec 18             	sub    $0x18,%esp
	while (heap->list_count != 0) {
c01087df:	eb 39                	jmp    c010881a <heap_destroy+0x41>
		vmm_unmap(current_context,
			 heap->alloc_list[--heap->list_count].base & ~0xFFF);
c01087e1:	8b 45 08             	mov    0x8(%ebp),%eax
c01087e4:	8b 50 04             	mov    0x4(%eax),%edx
c01087e7:	8b 45 08             	mov    0x8(%ebp),%eax
c01087ea:	8b 00                	mov    (%eax),%eax
c01087ec:	8d 48 ff             	lea    -0x1(%eax),%ecx
c01087ef:	8b 45 08             	mov    0x8(%ebp),%eax
 * @param heap heap
 * @return void
 */
void heap_destroy(heap_t *heap) {
	while (heap->list_count != 0) {
		vmm_unmap(current_context,
c01087f2:	89 08                	mov    %ecx,(%eax)
			 heap->alloc_list[--heap->list_count].base & ~0xFFF);
c01087f4:	8b 45 08             	mov    0x8(%ebp),%eax
c01087f7:	8b 00                	mov    (%eax),%eax
c01087f9:	c1 e0 04             	shl    $0x4,%eax
c01087fc:	01 d0                	add    %edx,%eax
c01087fe:	8b 40 04             	mov    0x4(%eax),%eax
 * @param heap heap
 * @return void
 */
void heap_destroy(heap_t *heap) {
	while (heap->list_count != 0) {
		vmm_unmap(current_context,
c0108801:	89 c2                	mov    %eax,%edx
c0108803:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0108809:	a1 40 19 11 c0       	mov    0xc0111940,%eax
c010880e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108812:	89 04 24             	mov    %eax,(%esp)
c0108815:	e8 3d e8 ff ff       	call   c0107057 <vmm_unmap>
 *
 * @param heap heap
 * @return void
 */
void heap_destroy(heap_t *heap) {
	while (heap->list_count != 0) {
c010881a:	8b 45 08             	mov    0x8(%ebp),%eax
c010881d:	8b 00                	mov    (%eax),%eax
c010881f:	85 c0                	test   %eax,%eax
c0108821:	75 be                	jne    c01087e1 <heap_destroy+0x8>
		vmm_unmap(current_context,
			 heap->alloc_list[--heap->list_count].base & ~0xFFF);
	}
}
c0108823:	c9                   	leave  
c0108824:	c3                   	ret    

c0108825 <heap_alloc>:
 * @param heap heap
 * @param size number of bytes
 *
 * @return pointer to reserved bytes
 */
void *heap_alloc(heap_t *heap, size_t size) {
c0108825:	55                   	push   %ebp
c0108826:	89 e5                	mov    %esp,%ebp
c0108828:	83 ec 28             	sub    $0x28,%esp
	alloc_t *header = heap->alloc_list;
c010882b:	8b 45 08             	mov    0x8(%ebp),%eax
c010882e:	8b 40 04             	mov    0x4(%eax),%eax
c0108831:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vaddr_t data = 0;
c0108834:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int n_size = size + sizeof(alloc_t);
c010883b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010883e:	83 c0 10             	add    $0x10,%eax
c0108841:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(size <= PAGE_SIZE && size > PAGE_SIZE - sizeof(alloc_t)) {
c0108844:	81 7d 0c 00 10 00 00 	cmpl   $0x1000,0xc(%ebp)
c010884b:	77 60                	ja     c01088ad <heap_alloc+0x88>
c010884d:	81 7d 0c f0 0f 00 00 	cmpl   $0xff0,0xc(%ebp)
c0108854:	76 57                	jbe    c01088ad <heap_alloc+0x88>
		data = vmm_automap_kernel(current_context, pmm_alloc_page(), VMM_WRITABLE);
c0108856:	e8 ad c7 ff ff       	call   c0105008 <pmm_alloc_page>
c010885b:	8b 15 40 19 11 c0    	mov    0xc0111940,%edx
c0108861:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c0108868:	00 
c0108869:	89 44 24 04          	mov    %eax,0x4(%esp)
c010886d:	89 14 24             	mov    %edx,(%esp)
c0108870:	e8 a1 e8 ff ff       	call   c0107116 <vmm_automap_kernel>
c0108875:	89 45 f0             	mov    %eax,-0x10(%ebp)
		return (void *)data;
c0108878:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010887b:	eb 75                	jmp    c01088f2 <heap_alloc+0xcd>
	}

	while(header != NULL) {
		if(header->size >= size && header->status == HEAP_STATUS_FREE) {
c010887d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108880:	8b 00                	mov    (%eax),%eax
c0108882:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0108885:	72 1d                	jb     c01088a4 <heap_alloc+0x7f>
c0108887:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010888a:	8b 40 08             	mov    0x8(%eax),%eax
c010888d:	83 f8 01             	cmp    $0x1,%eax
c0108890:	75 12                	jne    c01088a4 <heap_alloc+0x7f>
			header->status = HEAP_STATUS_USED;
c0108892:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108895:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

				new_header->next = heap->alloc_list;
				heap->alloc_list = new_header;
			}*/

			return (void *)header->base;
c010889c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010889f:	8b 40 04             	mov    0x4(%eax),%eax
c01088a2:	eb 4e                	jmp    c01088f2 <heap_alloc+0xcd>
		}
		header = header->next;
c01088a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01088a7:	8b 40 0c             	mov    0xc(%eax),%eax
c01088aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(size <= PAGE_SIZE && size > PAGE_SIZE - sizeof(alloc_t)) {
		data = vmm_automap_kernel(current_context, pmm_alloc_page(), VMM_WRITABLE);
		return (void *)data;
	}

	while(header != NULL) {
c01088ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01088b1:	75 ca                	jne    c010887d <heap_alloc+0x58>
			return (void *)header->base;
		}
		header = header->next;
	}

	header = heap_expand(heap, NUM_PAGES(n_size));
c01088b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01088b6:	05 ff 0f 00 00       	add    $0xfff,%eax
c01088bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01088c0:	c1 e8 0c             	shr    $0xc,%eax
c01088c3:	89 44 24 04          	mov    %eax,0x4(%esp)
c01088c7:	8b 45 08             	mov    0x8(%ebp),%eax
c01088ca:	89 04 24             	mov    %eax,(%esp)
c01088cd:	e8 1e fe ff ff       	call   c01086f0 <heap_expand>
c01088d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(header != NULL) {
c01088d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01088d9:	74 12                	je     c01088ed <heap_alloc+0xc8>
		header->status = HEAP_STATUS_USED;
c01088db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01088de:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		return (void *)header->base;
c01088e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01088e8:	8b 40 04             	mov    0x4(%eax),%eax
c01088eb:	eb 05                	jmp    c01088f2 <heap_alloc+0xcd>

	#ifdef HEAP_DEBUG
		printf("heap_alloc(): reserving %d bytes of memory: %p - %p\n", header->size, data, data + header->size);
	#endif

	return NULL;
c01088ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01088f2:	c9                   	leave  
c01088f3:	c3                   	ret    

c01088f4 <heap_free>:
 * @param heap heap
 * @param ptr pointer
 *
 * @return void
 */
void heap_free(heap_t *heap, void *ptr) {
c01088f4:	55                   	push   %ebp
c01088f5:	89 e5                	mov    %esp,%ebp
c01088f7:	83 ec 10             	sub    $0x10,%esp
	alloc_t *header = (alloc_t*)((uintptr_t)ptr - sizeof(alloc_t));
c01088fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c01088fd:	83 e8 10             	sub    $0x10,%eax
c0108900:	89 45 fc             	mov    %eax,-0x4(%ebp)
	header->status = HEAP_STATUS_FREE;
c0108903:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108906:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	#ifdef HEAP_DEBUG
		printf("heap_free(): freeing %d bytes of memory: %p - %p\n", header->size, ptr, ptr + header->size);
	#endif
}
c010890d:	c9                   	leave  
c010890e:	c3                   	ret    
c010890f:	90                   	nop

c0108910 <exp>:

/**
	Exponential-Function
**/
double exp(double x)
{
c0108910:	55                   	push   %ebp
c0108911:	89 e5                	mov    %esp,%ebp
c0108913:	83 ec 48             	sub    $0x48,%esp
c0108916:	8b 45 08             	mov    0x8(%ebp),%eax
c0108919:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010891c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010891f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    double sigma = 0;
c0108922:	d9 ee                	fldz   
c0108924:	dd 5d f0             	fstpl  -0x10(%ebp)
    int i;
    for (i = 0; i < 150; i++)
c0108927:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c010892e:	eb 4e                	jmp    c010897e <exp+0x6e>
        sigma += powi(x, i ) / factorial(i);
c0108930:	dd 45 e0             	fldl   -0x20(%ebp)
c0108933:	d9 7d de             	fnstcw -0x22(%ebp)
c0108936:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
c010893a:	b4 0c                	mov    $0xc,%ah
c010893c:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c0108940:	d9 6d dc             	fldcw  -0x24(%ebp)
c0108943:	db 5d d8             	fistpl -0x28(%ebp)
c0108946:	d9 6d de             	fldcw  -0x22(%ebp)
c0108949:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010894c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010894f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108953:	89 04 24             	mov    %eax,(%esp)
c0108956:	e8 3a 02 00 00       	call   c0108b95 <powi>
c010895b:	89 45 d8             	mov    %eax,-0x28(%ebp)
c010895e:	db 45 d8             	fildl  -0x28(%ebp)
c0108961:	dd 5d d0             	fstpl  -0x30(%ebp)
c0108964:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108967:	89 04 24             	mov    %eax,(%esp)
c010896a:	e8 68 02 00 00       	call   c0108bd7 <factorial>
c010896f:	dc 7d d0             	fdivrl -0x30(%ebp)
c0108972:	dd 45 f0             	fldl   -0x10(%ebp)
c0108975:	de c1                	faddp  %st,%st(1)
c0108977:	dd 5d f0             	fstpl  -0x10(%ebp)
**/
double exp(double x)
{
    double sigma = 0;
    int i;
    for (i = 0; i < 150; i++)
c010897a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c010897e:	81 7d ec 95 00 00 00 	cmpl   $0x95,-0x14(%ebp)
c0108985:	7e a9                	jle    c0108930 <exp+0x20>
        sigma += powi(x, i ) / factorial(i);
    return sigma;
c0108987:	dd 45 f0             	fldl   -0x10(%ebp)
}
c010898a:	c9                   	leave  
c010898b:	c3                   	ret    

c010898c <ln>:

/**
	Natural logarithm
**/
double ln(double y)
{
c010898c:	55                   	push   %ebp
c010898d:	89 e5                	mov    %esp,%ebp
c010898f:	83 ec 58             	sub    $0x58,%esp
c0108992:	8b 45 08             	mov    0x8(%ebp),%eax
c0108995:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0108998:	8b 45 0c             	mov    0xc(%ebp),%eax
c010899b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    double x = (y - 1) / (y + 1);
c010899e:	dd 45 d0             	fldl   -0x30(%ebp)
c01089a1:	d9 e8                	fld1   
c01089a3:	de e9                	fsubrp %st,%st(1)
c01089a5:	dd 45 d0             	fldl   -0x30(%ebp)
c01089a8:	d9 e8                	fld1   
c01089aa:	de c1                	faddp  %st,%st(1)
c01089ac:	de f9                	fdivrp %st,%st(1)
c01089ae:	dd 5d e0             	fstpl  -0x20(%ebp)
    double sigma = 0;
c01089b1:	d9 ee                	fldz   
c01089b3:	dd 5d f0             	fstpl  -0x10(%ebp)
    int i;
    for (i = 0; i < 150; i++)
c01089b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c01089bd:	eb 55                	jmp    c0108a14 <ln+0x88>
        sigma += powi(x, 2*i+1) /(2*i+1);
c01089bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01089c2:	01 c0                	add    %eax,%eax
c01089c4:	8d 50 01             	lea    0x1(%eax),%edx
c01089c7:	dd 45 e0             	fldl   -0x20(%ebp)
c01089ca:	d9 7d ce             	fnstcw -0x32(%ebp)
c01089cd:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
c01089d1:	b4 0c                	mov    $0xc,%ah
c01089d3:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
c01089d7:	d9 6d cc             	fldcw  -0x34(%ebp)
c01089da:	db 5d c8             	fistpl -0x38(%ebp)
c01089dd:	d9 6d ce             	fldcw  -0x32(%ebp)
c01089e0:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01089e3:	89 54 24 04          	mov    %edx,0x4(%esp)
c01089e7:	89 04 24             	mov    %eax,(%esp)
c01089ea:	e8 a6 01 00 00       	call   c0108b95 <powi>
c01089ef:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01089f2:	01 d2                	add    %edx,%edx
c01089f4:	83 c2 01             	add    $0x1,%edx
c01089f7:	89 55 c4             	mov    %edx,-0x3c(%ebp)
c01089fa:	89 c2                	mov    %eax,%edx
c01089fc:	c1 fa 1f             	sar    $0x1f,%edx
c01089ff:	f7 7d c4             	idivl  -0x3c(%ebp)
c0108a02:	89 45 c8             	mov    %eax,-0x38(%ebp)
c0108a05:	db 45 c8             	fildl  -0x38(%ebp)
c0108a08:	dd 45 f0             	fldl   -0x10(%ebp)
c0108a0b:	de c1                	faddp  %st,%st(1)
c0108a0d:	dd 5d f0             	fstpl  -0x10(%ebp)
double ln(double y)
{
    double x = (y - 1) / (y + 1);
    double sigma = 0;
    int i;
    for (i = 0; i < 150; i++)
c0108a10:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0108a14:	81 7d ec 95 00 00 00 	cmpl   $0x95,-0x14(%ebp)
c0108a1b:	7e a2                	jle    c01089bf <ln+0x33>
        sigma += powi(x, 2*i+1) /(2*i+1);
    return 2*sigma;
c0108a1d:	dd 45 f0             	fldl   -0x10(%ebp)
c0108a20:	d8 c0                	fadd   %st(0),%st
}
c0108a22:	c9                   	leave  
c0108a23:	c3                   	ret    

c0108a24 <pow>:

/**
	Power for real exponents
**/
double pow(double base, double exponent)
{
c0108a24:	55                   	push   %ebp
c0108a25:	89 e5                	mov    %esp,%ebp
c0108a27:	83 ec 28             	sub    $0x28,%esp
c0108a2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0108a30:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108a33:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0108a36:	8b 45 10             	mov    0x10(%ebp),%eax
c0108a39:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0108a3c:	8b 45 14             	mov    0x14(%ebp),%eax
c0108a3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    return exp(exponent * ln(base));
c0108a42:	dd 45 f0             	fldl   -0x10(%ebp)
c0108a45:	dd 1c 24             	fstpl  (%esp)
c0108a48:	e8 3f ff ff ff       	call   c010898c <ln>
c0108a4d:	dc 4d e8             	fmull  -0x18(%ebp)
c0108a50:	dd 1c 24             	fstpl  (%esp)
c0108a53:	e8 b8 fe ff ff       	call   c0108910 <exp>
}
c0108a58:	c9                   	leave  
c0108a59:	c3                   	ret    

c0108a5a <sin>:

/**
	Sine
**/
double sin(double x)
{
c0108a5a:	55                   	push   %ebp
c0108a5b:	89 e5                	mov    %esp,%ebp
c0108a5d:	53                   	push   %ebx
c0108a5e:	83 ec 44             	sub    $0x44,%esp
c0108a61:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a64:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0108a67:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108a6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	double sigma = 0;
c0108a6d:	d9 ee                	fldz   
c0108a6f:	dd 5d f0             	fstpl  -0x10(%ebp)
	int i;
	for (i = 0; i < 20; i++)
c0108a72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0108a79:	eb 70                	jmp    c0108aeb <sin+0x91>
		sigma += ((powi(-1, i) * powi(x, 2 * i + 1)) / factorial(2 * i + 1));
c0108a7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108a7e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108a82:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0108a89:	e8 07 01 00 00       	call   c0108b95 <powi>
c0108a8e:	89 c3                	mov    %eax,%ebx
c0108a90:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108a93:	01 c0                	add    %eax,%eax
c0108a95:	8d 50 01             	lea    0x1(%eax),%edx
c0108a98:	dd 45 e0             	fldl   -0x20(%ebp)
c0108a9b:	d9 7d de             	fnstcw -0x22(%ebp)
c0108a9e:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
c0108aa2:	b4 0c                	mov    $0xc,%ah
c0108aa4:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c0108aa8:	d9 6d dc             	fldcw  -0x24(%ebp)
c0108aab:	db 5d d8             	fistpl -0x28(%ebp)
c0108aae:	d9 6d de             	fldcw  -0x22(%ebp)
c0108ab1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108ab4:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108ab8:	89 04 24             	mov    %eax,(%esp)
c0108abb:	e8 d5 00 00 00       	call   c0108b95 <powi>
c0108ac0:	0f af c3             	imul   %ebx,%eax
c0108ac3:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0108ac6:	db 45 d8             	fildl  -0x28(%ebp)
c0108ac9:	dd 5d d0             	fstpl  -0x30(%ebp)
c0108acc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108acf:	01 c0                	add    %eax,%eax
c0108ad1:	83 c0 01             	add    $0x1,%eax
c0108ad4:	89 04 24             	mov    %eax,(%esp)
c0108ad7:	e8 fb 00 00 00       	call   c0108bd7 <factorial>
c0108adc:	dc 7d d0             	fdivrl -0x30(%ebp)
c0108adf:	dd 45 f0             	fldl   -0x10(%ebp)
c0108ae2:	de c1                	faddp  %st,%st(1)
c0108ae4:	dd 5d f0             	fstpl  -0x10(%ebp)
**/
double sin(double x)
{
	double sigma = 0;
	int i;
	for (i = 0; i < 20; i++)
c0108ae7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0108aeb:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
c0108aef:	7e 8a                	jle    c0108a7b <sin+0x21>
		sigma += ((powi(-1, i) * powi(x, 2 * i + 1)) / factorial(2 * i + 1));
	return sigma;
c0108af1:	dd 45 f0             	fldl   -0x10(%ebp)
}
c0108af4:	83 c4 44             	add    $0x44,%esp
c0108af7:	5b                   	pop    %ebx
c0108af8:	5d                   	pop    %ebp
c0108af9:	c3                   	ret    

c0108afa <cos>:

/**
	Cosine
**/
double cos(double x)
{
c0108afa:	55                   	push   %ebp
c0108afb:	89 e5                	mov    %esp,%ebp
c0108afd:	53                   	push   %ebx
c0108afe:	83 ec 44             	sub    $0x44,%esp
c0108b01:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b04:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0108b07:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108b0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    double sigma = 0;
c0108b0d:	d9 ee                	fldz   
c0108b0f:	dd 5d f0             	fstpl  -0x10(%ebp)
    int i;
    for (i = 0; i < 20; i++)
c0108b12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0108b19:	eb 6b                	jmp    c0108b86 <cos+0x8c>
        sigma += ((powi(-1, i) * powi(x, 2 * i)) / factorial(2 * i));
c0108b1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108b1e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108b22:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0108b29:	e8 67 00 00 00       	call   c0108b95 <powi>
c0108b2e:	89 c3                	mov    %eax,%ebx
c0108b30:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108b33:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0108b36:	dd 45 e0             	fldl   -0x20(%ebp)
c0108b39:	d9 7d de             	fnstcw -0x22(%ebp)
c0108b3c:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
c0108b40:	b4 0c                	mov    $0xc,%ah
c0108b42:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c0108b46:	d9 6d dc             	fldcw  -0x24(%ebp)
c0108b49:	db 5d d8             	fistpl -0x28(%ebp)
c0108b4c:	d9 6d de             	fldcw  -0x22(%ebp)
c0108b4f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108b52:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108b56:	89 04 24             	mov    %eax,(%esp)
c0108b59:	e8 37 00 00 00       	call   c0108b95 <powi>
c0108b5e:	0f af c3             	imul   %ebx,%eax
c0108b61:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0108b64:	db 45 d8             	fildl  -0x28(%ebp)
c0108b67:	dd 5d d0             	fstpl  -0x30(%ebp)
c0108b6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108b6d:	01 c0                	add    %eax,%eax
c0108b6f:	89 04 24             	mov    %eax,(%esp)
c0108b72:	e8 60 00 00 00       	call   c0108bd7 <factorial>
c0108b77:	dc 7d d0             	fdivrl -0x30(%ebp)
c0108b7a:	dd 45 f0             	fldl   -0x10(%ebp)
c0108b7d:	de c1                	faddp  %st,%st(1)
c0108b7f:	dd 5d f0             	fstpl  -0x10(%ebp)
**/
double cos(double x)
{
    double sigma = 0;
    int i;
    for (i = 0; i < 20; i++)
c0108b82:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0108b86:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
c0108b8a:	7e 8f                	jle    c0108b1b <cos+0x21>
        sigma += ((powi(-1, i) * powi(x, 2 * i)) / factorial(2 * i));
    return sigma;
c0108b8c:	dd 45 f0             	fldl   -0x10(%ebp)
}
c0108b8f:	83 c4 44             	add    $0x44,%esp
c0108b92:	5b                   	pop    %ebx
c0108b93:	5d                   	pop    %ebp
c0108b94:	c3                   	ret    

c0108b95 <powi>:

/**
	Power for integer exponents
**/
int powi(int base, int exponent)
{
c0108b95:	55                   	push   %ebp
c0108b96:	89 e5                	mov    %esp,%ebp
c0108b98:	83 ec 10             	sub    $0x10,%esp
  int result = base;
c0108b9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b9e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  int i;

  if (exponent == 0) {
c0108ba1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0108ba5:	75 09                	jne    c0108bb0 <powi+0x1b>
    result = 1;
c0108ba7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
c0108bae:	eb 22                	jmp    c0108bd2 <powi+0x3d>
  } else {
    for (i = 0; i < exponent - 1; ++i) {
c0108bb0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0108bb7:	eb 0e                	jmp    c0108bc7 <powi+0x32>
      result *= base;
c0108bb9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108bbc:	0f af 45 08          	imul   0x8(%ebp),%eax
c0108bc0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  int i;

  if (exponent == 0) {
    result = 1;
  } else {
    for (i = 0; i < exponent - 1; ++i) {
c0108bc3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0108bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108bca:	83 e8 01             	sub    $0x1,%eax
c0108bcd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0108bd0:	7f e7                	jg     c0108bb9 <powi+0x24>
      result *= base;
    }
  }

  return result;
c0108bd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0108bd5:	c9                   	leave  
c0108bd6:	c3                   	ret    

c0108bd7 <factorial>:

/**
	Factorial function
**/
double factorial(long n)
{
c0108bd7:	55                   	push   %ebp
c0108bd8:	89 e5                	mov    %esp,%ebp
c0108bda:	83 ec 10             	sub    $0x10,%esp
	double res = 1;
c0108bdd:	d9 e8                	fld1   
c0108bdf:	dd 5d f8             	fstpl  -0x8(%ebp)
	int i;
	for (i = 1; i <= n; i++)
c0108be2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0108be9:	eb 0f                	jmp    c0108bfa <factorial+0x23>
		res *= i;
c0108beb:	db 45 f4             	fildl  -0xc(%ebp)
c0108bee:	dd 45 f8             	fldl   -0x8(%ebp)
c0108bf1:	de c9                	fmulp  %st,%st(1)
c0108bf3:	dd 5d f8             	fstpl  -0x8(%ebp)
**/
double factorial(long n)
{
	double res = 1;
	int i;
	for (i = 1; i <= n; i++)
c0108bf6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0108bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108bfd:	3b 45 08             	cmp    0x8(%ebp),%eax
c0108c00:	7e e9                	jle    c0108beb <factorial+0x14>
		res *= i;
	return res;
c0108c02:	dd 45 f8             	fldl   -0x8(%ebp)
}
c0108c05:	c9                   	leave  
c0108c06:	c3                   	ret    

c0108c07 <abs>:

/**
	Absolute value
**/
int abs(int x)
{
c0108c07:	55                   	push   %ebp
c0108c08:	89 e5                	mov    %esp,%ebp
	if (x < 0) {
c0108c0a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0108c0e:	79 07                	jns    c0108c17 <abs+0x10>
		return -x;
c0108c10:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c13:	f7 d8                	neg    %eax
c0108c15:	eb 03                	jmp    c0108c1a <abs+0x13>
	} else {
		return x;
c0108c17:	8b 45 08             	mov    0x8(%ebp),%eax
	}
}
c0108c1a:	5d                   	pop    %ebp
c0108c1b:	c3                   	ret    

c0108c1c <bit_scan_forward>:

unsigned int bit_scan_forward(unsigned int i)
{
c0108c1c:	55                   	push   %ebp
c0108c1d:	89 e5                	mov    %esp,%ebp
c0108c1f:	53                   	push   %ebx
c0108c20:	83 ec 10             	sub    $0x10,%esp
	unsigned int j;

	for (j = 0; j < 32; j++) {
c0108c23:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0108c2a:	eb 20                	jmp    c0108c4c <bit_scan_forward+0x30>
		if (i & (1 << j)) {
c0108c2c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108c2f:	ba 01 00 00 00       	mov    $0x1,%edx
c0108c34:	89 d3                	mov    %edx,%ebx
c0108c36:	89 c1                	mov    %eax,%ecx
c0108c38:	d3 e3                	shl    %cl,%ebx
c0108c3a:	89 d8                	mov    %ebx,%eax
c0108c3c:	23 45 08             	and    0x8(%ebp),%eax
c0108c3f:	85 c0                	test   %eax,%eax
c0108c41:	74 05                	je     c0108c48 <bit_scan_forward+0x2c>
			return j;
c0108c43:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108c46:	eb 0f                	jmp    c0108c57 <bit_scan_forward+0x3b>

unsigned int bit_scan_forward(unsigned int i)
{
	unsigned int j;

	for (j = 0; j < 32; j++) {
c0108c48:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0108c4c:	83 7d f8 1f          	cmpl   $0x1f,-0x8(%ebp)
c0108c50:	76 da                	jbe    c0108c2c <bit_scan_forward+0x10>
		if (i & (1 << j)) {
			return j;
		}
	}
	return -1;
c0108c52:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0108c57:	83 c4 10             	add    $0x10,%esp
c0108c5a:	5b                   	pop    %ebx
c0108c5b:	5d                   	pop    %ebp
c0108c5c:	c3                   	ret    
c0108c5d:	66 90                	xchg   %ax,%ax
c0108c5f:	90                   	nop

c0108c60 <list_create>:
#include <heap.h>
#include <stdint.h>
#include <list.h>

list_t *list_create(void)
{
c0108c60:	55                   	push   %ebp
c0108c61:	89 e5                	mov    %esp,%ebp
c0108c63:	83 ec 28             	sub    $0x28,%esp
	list_t *list = (list_t *) malloc(sizeof(list_t));
c0108c66:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0108c6d:	e8 52 f9 ff ff       	call   c01085c4 <malloc>
c0108c72:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct list_node *dummy = (struct list_node *) malloc(sizeof(struct list_node));
c0108c75:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0108c7c:	e8 43 f9 ff ff       	call   c01085c4 <malloc>
c0108c81:	89 45 f0             	mov    %eax,-0x10(%ebp)
    list->head = dummy;
c0108c84:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108c87:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0108c8a:	89 10                	mov    %edx,(%eax)
    list->current = dummy;
c0108c8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108c8f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0108c92:	89 50 04             	mov    %edx,0x4(%eax)
    list->lock = false;
c0108c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108c98:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    dummy->next = dummy;
c0108c9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108ca2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0108ca5:	89 10                	mov    %edx,(%eax)
    dummy->prev = dummy;
c0108ca7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108caa:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0108cad:	89 50 04             	mov    %edx,0x4(%eax)
    dummy->element = (void *) 0;
c0108cb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108cb3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return list;
c0108cba:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108cbd:	c9                   	leave  
c0108cbe:	c3                   	ret    

c0108cbf <list_destroy>:

/* TODO: Check for bugs */
void list_destroy(list_t **list)
{
c0108cbf:	55                   	push   %ebp
c0108cc0:	89 e5                	mov    %esp,%ebp
c0108cc2:	83 ec 28             	sub    $0x28,%esp
	struct list_node *node = list[0]->head->next;
c0108cc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0108cc8:	8b 00                	mov    (%eax),%eax
c0108cca:	8b 00                	mov    (%eax),%eax
c0108ccc:	8b 00                	mov    (%eax),%eax
c0108cce:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct list_node *head = list[0]->head;
c0108cd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0108cd4:	8b 00                	mov    (%eax),%eax
c0108cd6:	8b 00                	mov    (%eax),%eax
c0108cd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (node != head)
c0108cdb:	eb 13                	jmp    c0108cf0 <list_destroy+0x31>
	{

        node = node->next;
c0108cdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ce0:	8b 00                	mov    (%eax),%eax
c0108ce2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		free(node);
c0108ce5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ce8:	89 04 24             	mov    %eax,(%esp)
c0108ceb:	e8 ef f8 ff ff       	call   c01085df <free>
/* TODO: Check for bugs */
void list_destroy(list_t **list)
{
	struct list_node *node = list[0]->head->next;
	struct list_node *head = list[0]->head;
    while (node != head)
c0108cf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108cf3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0108cf6:	75 e5                	jne    c0108cdd <list_destroy+0x1e>

        node = node->next;
		free(node);
    }

	free(*list);
c0108cf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0108cfb:	8b 00                	mov    (%eax),%eax
c0108cfd:	89 04 24             	mov    %eax,(%esp)
c0108d00:	e8 da f8 ff ff       	call   c01085df <free>
	*list = NULL;
c0108d05:	8b 45 08             	mov    0x8(%ebp),%eax
c0108d08:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return;
c0108d0e:	90                   	nop
}
c0108d0f:	c9                   	leave  
c0108d10:	c3                   	ret    

c0108d11 <list_splice>:

void list_splice(struct list_node *start, struct list_node *end, struct list_node *target)
{
c0108d11:	55                   	push   %ebp
c0108d12:	89 e5                	mov    %esp,%ebp
    start->prev->next = end->next;
c0108d14:	8b 45 08             	mov    0x8(%ebp),%eax
c0108d17:	8b 40 04             	mov    0x4(%eax),%eax
c0108d1a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108d1d:	8b 12                	mov    (%edx),%edx
c0108d1f:	89 10                	mov    %edx,(%eax)
    end->next->prev = start->prev;
c0108d21:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108d24:	8b 00                	mov    (%eax),%eax
c0108d26:	8b 55 08             	mov    0x8(%ebp),%edx
c0108d29:	8b 52 04             	mov    0x4(%edx),%edx
c0108d2c:	89 50 04             	mov    %edx,0x4(%eax)
    start->prev = target;
c0108d2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0108d32:	8b 55 10             	mov    0x10(%ebp),%edx
c0108d35:	89 50 04             	mov    %edx,0x4(%eax)
    end->next = target->next;
c0108d38:	8b 45 10             	mov    0x10(%ebp),%eax
c0108d3b:	8b 10                	mov    (%eax),%edx
c0108d3d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108d40:	89 10                	mov    %edx,(%eax)
    target->next->prev = end;
c0108d42:	8b 45 10             	mov    0x10(%ebp),%eax
c0108d45:	8b 00                	mov    (%eax),%eax
c0108d47:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108d4a:	89 50 04             	mov    %edx,0x4(%eax)
    target->next = start;
c0108d4d:	8b 45 10             	mov    0x10(%ebp),%eax
c0108d50:	8b 55 08             	mov    0x8(%ebp),%edx
c0108d53:	89 10                	mov    %edx,(%eax)
	return;
c0108d55:	90                   	nop
}
c0108d56:	5d                   	pop    %ebp
c0108d57:	c3                   	ret    

c0108d58 <list_push_back>:

list_t *list_push_back(list_t *list, void *element)
{
c0108d58:	55                   	push   %ebp
c0108d59:	89 e5                	mov    %esp,%ebp
c0108d5b:	83 ec 28             	sub    $0x28,%esp
	struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0108d5e:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0108d65:	e8 5a f8 ff ff       	call   c01085c4 <malloc>
c0108d6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0108d6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d70:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108d73:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0108d76:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d79:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108d7c:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0108d7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d81:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108d84:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, list->head->prev);
c0108d87:	8b 45 08             	mov    0x8(%ebp),%eax
c0108d8a:	8b 00                	mov    (%eax),%eax
c0108d8c:	8b 40 04             	mov    0x4(%eax),%eax
c0108d8f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108d93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d96:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108d9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d9d:	89 04 24             	mov    %eax,(%esp)
c0108da0:	e8 6c ff ff ff       	call   c0108d11 <list_splice>
	return list;
c0108da5:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0108da8:	c9                   	leave  
c0108da9:	c3                   	ret    

c0108daa <list_push_front>:

list_t *list_push_front(list_t *list, void *element)
{
c0108daa:	55                   	push   %ebp
c0108dab:	89 e5                	mov    %esp,%ebp
c0108dad:	83 ec 28             	sub    $0x28,%esp
	struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0108db0:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0108db7:	e8 08 f8 ff ff       	call   c01085c4 <malloc>
c0108dbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0108dbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108dc2:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108dc5:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0108dc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108dcb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108dce:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0108dd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108dd3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108dd6:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, list->head);
c0108dd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ddc:	8b 00                	mov    (%eax),%eax
c0108dde:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108de2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108de5:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108de9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108dec:	89 04 24             	mov    %eax,(%esp)
c0108def:	e8 1d ff ff ff       	call   c0108d11 <list_splice>
	return list;
c0108df4:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0108df7:	c9                   	leave  
c0108df8:	c3                   	ret    

c0108df9 <list_pop_back>:

void *list_pop_back(list_t *list)
{
c0108df9:	55                   	push   %ebp
c0108dfa:	89 e5                	mov    %esp,%ebp
c0108dfc:	83 ec 28             	sub    $0x28,%esp
	struct list_node *last = list->head->prev;
c0108dff:	8b 45 08             	mov    0x8(%ebp),%eax
c0108e02:	8b 00                	mov    (%eax),%eax
c0108e04:	8b 40 04             	mov    0x4(%eax),%eax
c0108e07:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return list_remove_node(last);
c0108e0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e0d:	89 04 24             	mov    %eax,(%esp)
c0108e10:	e8 c2 00 00 00       	call   c0108ed7 <list_remove_node>
}
c0108e15:	c9                   	leave  
c0108e16:	c3                   	ret    

c0108e17 <list_pop_front>:

void *list_pop_front(list_t *list)
{
c0108e17:	55                   	push   %ebp
c0108e18:	89 e5                	mov    %esp,%ebp
c0108e1a:	83 ec 28             	sub    $0x28,%esp
	struct list_node *first = list->head->next;
c0108e1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108e20:	8b 00                	mov    (%eax),%eax
c0108e22:	8b 00                	mov    (%eax),%eax
c0108e24:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return list_remove_node(first);
c0108e27:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e2a:	89 04 24             	mov    %eax,(%esp)
c0108e2d:	e8 a5 00 00 00       	call   c0108ed7 <list_remove_node>
}
c0108e32:	c9                   	leave  
c0108e33:	c3                   	ret    

c0108e34 <list_insert_after>:

list_t *list_insert_after(list_t *list, void *element)
{
c0108e34:	55                   	push   %ebp
c0108e35:	89 e5                	mov    %esp,%ebp
c0108e37:	83 ec 28             	sub    $0x28,%esp
	struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0108e3a:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0108e41:	e8 7e f7 ff ff       	call   c01085c4 <malloc>
c0108e46:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0108e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e4c:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108e4f:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0108e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e55:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108e58:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0108e5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108e60:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, list->current);
c0108e63:	8b 45 08             	mov    0x8(%ebp),%eax
c0108e66:	8b 40 04             	mov    0x4(%eax),%eax
c0108e69:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108e6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e70:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e77:	89 04 24             	mov    %eax,(%esp)
c0108e7a:	e8 92 fe ff ff       	call   c0108d11 <list_splice>
	return list;
c0108e7f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0108e82:	c9                   	leave  
c0108e83:	c3                   	ret    

c0108e84 <list_insert_before>:

list_t *list_insert_before(list_t *list, void *element)
{
c0108e84:	55                   	push   %ebp
c0108e85:	89 e5                	mov    %esp,%ebp
c0108e87:	83 ec 28             	sub    $0x28,%esp
	struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0108e8a:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0108e91:	e8 2e f7 ff ff       	call   c01085c4 <malloc>
c0108e96:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0108e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e9c:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108e9f:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0108ea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ea5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108ea8:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0108eaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ead:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108eb0:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, list->current->prev);
c0108eb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0108eb6:	8b 40 04             	mov    0x4(%eax),%eax
c0108eb9:	8b 40 04             	mov    0x4(%eax),%eax
c0108ebc:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108ec0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ec3:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108ec7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108eca:	89 04 24             	mov    %eax,(%esp)
c0108ecd:	e8 3f fe ff ff       	call   c0108d11 <list_splice>
	return list;
c0108ed2:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0108ed5:	c9                   	leave  
c0108ed6:	c3                   	ret    

c0108ed7 <list_remove_node>:

void *list_remove_node(struct list_node *node)
{
c0108ed7:	55                   	push   %ebp
c0108ed8:	89 e5                	mov    %esp,%ebp
c0108eda:	83 ec 28             	sub    $0x28,%esp
	void *element = node->element;
c0108edd:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ee0:	8b 40 08             	mov    0x8(%eax),%eax
c0108ee3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->prev->next = node->next;
c0108ee6:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ee9:	8b 40 04             	mov    0x4(%eax),%eax
c0108eec:	8b 55 08             	mov    0x8(%ebp),%edx
c0108eef:	8b 12                	mov    (%edx),%edx
c0108ef1:	89 10                	mov    %edx,(%eax)
    node->next->prev = node->prev;
c0108ef3:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ef6:	8b 00                	mov    (%eax),%eax
c0108ef8:	8b 55 08             	mov    0x8(%ebp),%edx
c0108efb:	8b 52 04             	mov    0x4(%edx),%edx
c0108efe:	89 50 04             	mov    %edx,0x4(%eax)
	free(node);
c0108f01:	8b 45 08             	mov    0x8(%ebp),%eax
c0108f04:	89 04 24             	mov    %eax,(%esp)
c0108f07:	e8 d3 f6 ff ff       	call   c01085df <free>
	return element;
c0108f0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108f0f:	c9                   	leave  
c0108f10:	c3                   	ret    

c0108f11 <list_remove>:

void *list_remove(list_t *list)
{
c0108f11:	55                   	push   %ebp
c0108f12:	89 e5                	mov    %esp,%ebp
c0108f14:	83 ec 28             	sub    $0x28,%esp
	void *element = list_get_current(list);
c0108f17:	8b 45 08             	mov    0x8(%ebp),%eax
c0108f1a:	89 04 24             	mov    %eax,(%esp)
c0108f1d:	e8 71 00 00 00       	call   c0108f93 <list_get_current>
c0108f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct list_node *node = list->current;
c0108f25:	8b 45 08             	mov    0x8(%ebp),%eax
c0108f28:	8b 40 04             	mov    0x4(%eax),%eax
c0108f2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    node->prev->next = node->next;
c0108f2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108f31:	8b 40 04             	mov    0x4(%eax),%eax
c0108f34:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0108f37:	8b 12                	mov    (%edx),%edx
c0108f39:	89 10                	mov    %edx,(%eax)
    node->next->prev = node->prev;
c0108f3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108f3e:	8b 00                	mov    (%eax),%eax
c0108f40:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0108f43:	8b 52 04             	mov    0x4(%edx),%edx
c0108f46:	89 50 04             	mov    %edx,0x4(%eax)
	free(node);
c0108f49:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108f4c:	89 04 24             	mov    %eax,(%esp)
c0108f4f:	e8 8b f6 ff ff       	call   c01085df <free>
	return element;
c0108f54:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108f57:	c9                   	leave  
c0108f58:	c3                   	ret    

c0108f59 <list_length>:

int list_length(list_t *list)
{
c0108f59:	55                   	push   %ebp
c0108f5a:	89 e5                	mov    %esp,%ebp
c0108f5c:	83 ec 10             	sub    $0x10,%esp
	struct list_node *node = list->head->next;
c0108f5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0108f62:	8b 00                	mov    (%eax),%eax
c0108f64:	8b 00                	mov    (%eax),%eax
c0108f66:	89 45 fc             	mov    %eax,-0x4(%ebp)
	struct list_node *head = list->head;
c0108f69:	8b 45 08             	mov    0x8(%ebp),%eax
c0108f6c:	8b 00                	mov    (%eax),%eax
c0108f6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	size_t size = 0;
c0108f71:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while (node != head)
c0108f78:	eb 0c                	jmp    c0108f86 <list_length+0x2d>
	{
        node = node->next;
c0108f7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108f7d:	8b 00                	mov    (%eax),%eax
c0108f7f:	89 45 fc             	mov    %eax,-0x4(%ebp)
        size++;
c0108f82:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
int list_length(list_t *list)
{
	struct list_node *node = list->head->next;
	struct list_node *head = list->head;
	size_t size = 0;
    while (node != head)
c0108f86:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108f89:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0108f8c:	75 ec                	jne    c0108f7a <list_length+0x21>
	{
        node = node->next;
        size++;
    }
	return size;
c0108f8e:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0108f91:	c9                   	leave  
c0108f92:	c3                   	ret    

c0108f93 <list_get_current>:

void *list_get_current(list_t *list)
{
c0108f93:	55                   	push   %ebp
c0108f94:	89 e5                	mov    %esp,%ebp
	return list->current->element;
c0108f96:	8b 45 08             	mov    0x8(%ebp),%eax
c0108f99:	8b 40 04             	mov    0x4(%eax),%eax
c0108f9c:	8b 40 08             	mov    0x8(%eax),%eax
}
c0108f9f:	5d                   	pop    %ebp
c0108fa0:	c3                   	ret    

c0108fa1 <list_next>:

list_t *list_next(list_t *list)
{
c0108fa1:	55                   	push   %ebp
c0108fa2:	89 e5                	mov    %esp,%ebp
	list->current = list->current->next;
c0108fa4:	8b 45 08             	mov    0x8(%ebp),%eax
c0108fa7:	8b 40 04             	mov    0x4(%eax),%eax
c0108faa:	8b 10                	mov    (%eax),%edx
c0108fac:	8b 45 08             	mov    0x8(%ebp),%eax
c0108faf:	89 50 04             	mov    %edx,0x4(%eax)
	return list;
c0108fb2:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0108fb5:	5d                   	pop    %ebp
c0108fb6:	c3                   	ret    

c0108fb7 <list_previous>:

list_t *list_previous(list_t *list)
{
c0108fb7:	55                   	push   %ebp
c0108fb8:	89 e5                	mov    %esp,%ebp
	list->current = list->current->prev;
c0108fba:	8b 45 08             	mov    0x8(%ebp),%eax
c0108fbd:	8b 40 04             	mov    0x4(%eax),%eax
c0108fc0:	8b 50 04             	mov    0x4(%eax),%edx
c0108fc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0108fc6:	89 50 04             	mov    %edx,0x4(%eax)
	return list;
c0108fc9:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0108fcc:	5d                   	pop    %ebp
c0108fcd:	c3                   	ret    

c0108fce <list_is_last>:

bool list_is_last(list_t *list)
{
c0108fce:	55                   	push   %ebp
c0108fcf:	89 e5                	mov    %esp,%ebp
	return (list->current == list->head);
c0108fd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0108fd4:	8b 50 04             	mov    0x4(%eax),%edx
c0108fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0108fda:	8b 00                	mov    (%eax),%eax
c0108fdc:	39 c2                	cmp    %eax,%edx
c0108fde:	0f 94 c0             	sete   %al
c0108fe1:	0f b6 c0             	movzbl %al,%eax
}
c0108fe4:	5d                   	pop    %ebp
c0108fe5:	c3                   	ret    

c0108fe6 <list_set_first>:

list_t *list_set_first(list_t *list)
{
c0108fe6:	55                   	push   %ebp
c0108fe7:	89 e5                	mov    %esp,%ebp
	list->current = list->head->next;
c0108fe9:	8b 45 08             	mov    0x8(%ebp),%eax
c0108fec:	8b 00                	mov    (%eax),%eax
c0108fee:	8b 10                	mov    (%eax),%edx
c0108ff0:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ff3:	89 50 04             	mov    %edx,0x4(%eax)
	return list;
c0108ff6:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0108ff9:	5d                   	pop    %ebp
c0108ffa:	c3                   	ret    

c0108ffb <list_set_last>:

list_t *list_set_last(list_t *list)
{
c0108ffb:	55                   	push   %ebp
c0108ffc:	89 e5                	mov    %esp,%ebp
	list->current = list->head->prev;
c0108ffe:	8b 45 08             	mov    0x8(%ebp),%eax
c0109001:	8b 00                	mov    (%eax),%eax
c0109003:	8b 50 04             	mov    0x4(%eax),%edx
c0109006:	8b 45 08             	mov    0x8(%ebp),%eax
c0109009:	89 50 04             	mov    %edx,0x4(%eax)
	return list;
c010900c:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010900f:	5d                   	pop    %ebp
c0109010:	c3                   	ret    

c0109011 <list_is_empty>:

bool list_is_empty(list_t *list)
{
c0109011:	55                   	push   %ebp
c0109012:	89 e5                	mov    %esp,%ebp
	return (list->head == list->head->next);
c0109014:	8b 45 08             	mov    0x8(%ebp),%eax
c0109017:	8b 10                	mov    (%eax),%edx
c0109019:	8b 45 08             	mov    0x8(%ebp),%eax
c010901c:	8b 00                	mov    (%eax),%eax
c010901e:	8b 00                	mov    (%eax),%eax
c0109020:	39 c2                	cmp    %eax,%edx
c0109022:	0f 94 c0             	sete   %al
c0109025:	0f b6 c0             	movzbl %al,%eax
}
c0109028:	5d                   	pop    %ebp
c0109029:	c3                   	ret    
c010902a:	66 90                	xchg   %ax,%ax

c010902c <INIT_VFS>:
 * Initalizing the Virtual File System
 *
 * @param void
 * @return void
 */
void INIT_VFS(void) {
c010902c:	55                   	push   %ebp
c010902d:	89 e5                	mov    %esp,%ebp
c010902f:	83 ec 28             	sub    $0x28,%esp
	root = malloc(sizeof(vfs_inode_t));
c0109032:	c7 04 24 54 00 00 00 	movl   $0x54,(%esp)
c0109039:	e8 86 f5 ff ff       	call   c01085c4 <malloc>
c010903e:	a3 4c 19 11 c0       	mov    %eax,0xc011194c
	root->stat.st_ino = 0;
c0109043:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c0109048:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	root->stat.st_mode = 0x1ff;
c010904f:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c0109054:	c7 40 0c ff 01 00 00 	movl   $0x1ff,0xc(%eax)
	nodes = 1;
c010905b:	c7 05 50 19 11 c0 01 	movl   $0x1,0xc0111950
c0109062:	00 00 00 
	root->name = "root";
c0109065:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c010906a:	c7 00 01 c5 10 c0    	movl   $0xc010c501,(%eax)
	root->length = 0;
c0109070:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c0109075:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	root->parent = NULL;
c010907c:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c0109081:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)

	vfs_inode_t *foo = vfs_create_inode("foo.txt", 0x1ff, root);
c0109088:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c010908d:	89 44 24 08          	mov    %eax,0x8(%esp)
c0109091:	c7 44 24 04 ff 01 00 	movl   $0x1ff,0x4(%esp)
c0109098:	00 
c0109099:	c7 04 24 06 c5 10 c0 	movl   $0xc010c506,(%esp)
c01090a0:	e8 42 00 00 00       	call   c01090e7 <vfs_create_inode>
c01090a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vfs_write(foo, 0, "Hallo Welt!\n", 13);
c01090a8:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
c01090af:	00 
c01090b0:	c7 44 24 08 0e c5 10 	movl   $0xc010c50e,0x8(%esp)
c01090b7:	c0 
c01090b8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01090bf:	00 
c01090c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01090c3:	89 04 24             	mov    %eax,(%esp)
c01090c6:	e8 39 01 00 00       	call   c0109204 <vfs_write>
}
c01090cb:	c9                   	leave  
c01090cc:	c3                   	ret    

c01090cd <set_vfs_uid>:
 * Set the User-ID
 *
 * @param new_uid the new user-id
 * @return void
 */
void set_vfs_uid(uid_t new_uid) {
c01090cd:	55                   	push   %ebp
c01090ce:	89 e5                	mov    %esp,%ebp
	uid = new_uid;
c01090d0:	8b 45 08             	mov    0x8(%ebp),%eax
c01090d3:	a3 54 19 11 c0       	mov    %eax,0xc0111954
}
c01090d8:	5d                   	pop    %ebp
c01090d9:	c3                   	ret    

c01090da <set_vfs_gid>:
 * Set the Group-ID
 *
 * @param new_gid the new group-id
 * @return void
 */
void set_vfs_gid(gid_t new_gid) {
c01090da:	55                   	push   %ebp
c01090db:	89 e5                	mov    %esp,%ebp
	gid = new_gid;
c01090dd:	8b 45 08             	mov    0x8(%ebp),%eax
c01090e0:	a3 58 19 11 c0       	mov    %eax,0xc0111958
}
c01090e5:	5d                   	pop    %ebp
c01090e6:	c3                   	ret    

c01090e7 <vfs_create_inode>:
 * @param parent the parent node for the new node.
 *               if parent is NULL, the parent for the node is root.
 *
 * @return pointer to the new node
 */
vfs_inode_t* vfs_create_inode(char *name, mode_t mode, vfs_inode_t *parent) {
c01090e7:	55                   	push   %ebp
c01090e8:	89 e5                	mov    %esp,%ebp
c01090ea:	83 ec 28             	sub    $0x28,%esp
	vfs_inode_t *node = malloc(sizeof(vfs_inode_t));
c01090ed:	c7 04 24 54 00 00 00 	movl   $0x54,(%esp)
c01090f4:	e8 cb f4 ff ff       	call   c01085c4 <malloc>
c01090f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	node->name = name;
c01090fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01090ff:	8b 55 08             	mov    0x8(%ebp),%edx
c0109102:	89 10                	mov    %edx,(%eax)
	node->length = 0;
c0109104:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109107:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	node->base = NULL;
c010910e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109111:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	if (parent != NULL) {
c0109118:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010911c:	74 3b                	je     c0109159 <vfs_create_inode+0x72>
		node->parent = parent;
c010911e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109121:	8b 55 10             	mov    0x10(%ebp),%edx
c0109124:	89 50 50             	mov    %edx,0x50(%eax)
		vfs_dentry_t *entry = vfs_create_dir_entry(node);
c0109127:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010912a:	89 04 24             	mov    %eax,(%esp)
c010912d:	e8 a4 00 00 00       	call   c01091d6 <vfs_create_dir_entry>
c0109132:	89 45 f0             	mov    %eax,-0x10(%ebp)
		vfs_write(parent, parent->length, entry, sizeof(vfs_dentry_t));
c0109135:	8b 45 10             	mov    0x10(%ebp),%eax
c0109138:	8b 40 08             	mov    0x8(%eax),%eax
c010913b:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
c0109142:	00 
c0109143:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0109146:	89 54 24 08          	mov    %edx,0x8(%esp)
c010914a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010914e:	8b 45 10             	mov    0x10(%ebp),%eax
c0109151:	89 04 24             	mov    %eax,(%esp)
c0109154:	e8 ab 00 00 00       	call   c0109204 <vfs_write>
	}

	node->stat.st_mode = mode;
c0109159:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010915c:	8b 55 0c             	mov    0xc(%ebp),%edx
c010915f:	89 50 0c             	mov    %edx,0xc(%eax)
	node->stat.st_ino = nodes++;
c0109162:	a1 50 19 11 c0       	mov    0xc0111950,%eax
c0109167:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010916a:	89 42 10             	mov    %eax,0x10(%edx)
c010916d:	83 c0 01             	add    $0x1,%eax
c0109170:	a3 50 19 11 c0       	mov    %eax,0xc0111950
	node->stat.st_uid = uid;
c0109175:	8b 15 54 19 11 c0    	mov    0xc0111954,%edx
c010917b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010917e:	89 50 18             	mov    %edx,0x18(%eax)
	node->stat.st_gid = gid;
c0109181:	8b 15 58 19 11 c0    	mov    0xc0111958,%edx
c0109187:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010918a:	89 50 1c             	mov    %edx,0x1c(%eax)
	node->stat.st_atime = *get_time();
c010918d:	e8 43 ac ff ff       	call   c0103dd5 <get_time>
c0109192:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0109195:	8b 08                	mov    (%eax),%ecx
c0109197:	89 4a 24             	mov    %ecx,0x24(%edx)
c010919a:	8b 48 04             	mov    0x4(%eax),%ecx
c010919d:	89 4a 28             	mov    %ecx,0x28(%edx)
c01091a0:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
c01091a4:	66 89 4a 2c          	mov    %cx,0x2c(%edx)
c01091a8:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c01091ac:	88 42 2e             	mov    %al,0x2e(%edx)
	node->stat.st_mtime = *get_time();
c01091af:	e8 21 ac ff ff       	call   c0103dd5 <get_time>
c01091b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01091b7:	8b 08                	mov    (%eax),%ecx
c01091b9:	89 4a 2f             	mov    %ecx,0x2f(%edx)
c01091bc:	8b 48 04             	mov    0x4(%eax),%ecx
c01091bf:	89 4a 33             	mov    %ecx,0x33(%edx)
c01091c2:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
c01091c6:	66 89 4a 37          	mov    %cx,0x37(%edx)
c01091ca:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c01091ce:	88 42 39             	mov    %al,0x39(%edx)

	return node;
c01091d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01091d4:	c9                   	leave  
c01091d5:	c3                   	ret    

c01091d6 <vfs_create_dir_entry>:
 * Create a new directory entry
 *
 * @param entry_inode the node that will be entried
 * @return the new directory entry
 */
vfs_dentry_t* vfs_create_dir_entry(vfs_inode_t *entry_inode) {
c01091d6:	55                   	push   %ebp
c01091d7:	89 e5                	mov    %esp,%ebp
c01091d9:	83 ec 28             	sub    $0x28,%esp
	vfs_dentry_t *dir_ent = malloc(sizeof(vfs_dentry_t));
c01091dc:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c01091e3:	e8 dc f3 ff ff       	call   c01085c4 <malloc>
c01091e8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	dir_ent->ino = entry_inode->stat.st_ino;
c01091eb:	8b 45 08             	mov    0x8(%ebp),%eax
c01091ee:	8b 50 10             	mov    0x10(%eax),%edx
c01091f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01091f4:	89 10                	mov    %edx,(%eax)
	dir_ent->inode = entry_inode;
c01091f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01091f9:	8b 55 08             	mov    0x8(%ebp),%edx
c01091fc:	89 50 04             	mov    %edx,0x4(%eax)

	return dir_ent;
c01091ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0109202:	c9                   	leave  
c0109203:	c3                   	ret    

c0109204 <vfs_write>:
 * @param node the node, in that will be written
 * @param base pointer to the data
 *
 * @return number of written bytes
 */
int vfs_write(vfs_inode_t *node, int off, void *base, int bytes) {
c0109204:	55                   	push   %ebp
c0109205:	89 e5                	mov    %esp,%ebp
c0109207:	83 ec 38             	sub    $0x38,%esp
	int writable = 0;
c010920a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((node->stat.st_uid == uid) &&
c0109211:	8b 45 08             	mov    0x8(%ebp),%eax
c0109214:	8b 50 18             	mov    0x18(%eax),%edx
c0109217:	a1 54 19 11 c0       	mov    0xc0111954,%eax
c010921c:	39 c2                	cmp    %eax,%edx
c010921e:	75 16                	jne    c0109236 <vfs_write+0x32>
	    (node->stat.st_mode & S_IWUSR))
c0109220:	8b 45 08             	mov    0x8(%ebp),%eax
c0109223:	8b 40 0c             	mov    0xc(%eax),%eax
c0109226:	83 e0 06             	and    $0x6,%eax
 *
 * @return number of written bytes
 */
int vfs_write(vfs_inode_t *node, int off, void *base, int bytes) {
	int writable = 0;
	if ((node->stat.st_uid == uid) &&
c0109229:	85 c0                	test   %eax,%eax
c010922b:	74 09                	je     c0109236 <vfs_write+0x32>
	    (node->stat.st_mode & S_IWUSR))
	{
		writable = 1;
c010922d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0109234:	eb 3b                	jmp    c0109271 <vfs_write+0x6d>
	}
	else if
	    ((node->stat.st_gid == gid) &&
c0109236:	8b 45 08             	mov    0x8(%ebp),%eax
c0109239:	8b 50 1c             	mov    0x1c(%eax),%edx
c010923c:	a1 58 19 11 c0       	mov    0xc0111958,%eax
c0109241:	39 c2                	cmp    %eax,%edx
c0109243:	75 16                	jne    c010925b <vfs_write+0x57>
	    (node->stat.st_mode & S_IWGRP))
c0109245:	8b 45 08             	mov    0x8(%ebp),%eax
c0109248:	8b 40 0c             	mov    0xc(%eax),%eax
c010924b:	83 e0 14             	and    $0x14,%eax
	    (node->stat.st_mode & S_IWUSR))
	{
		writable = 1;
	}
	else if
	    ((node->stat.st_gid == gid) &&
c010924e:	85 c0                	test   %eax,%eax
c0109250:	74 09                	je     c010925b <vfs_write+0x57>
	    (node->stat.st_mode & S_IWGRP))
	{
		writable = 1;
c0109252:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0109259:	eb 16                	jmp    c0109271 <vfs_write+0x6d>
	} else {
		if (node->stat.st_mode & S_IWOTH)
c010925b:	8b 45 08             	mov    0x8(%ebp),%eax
c010925e:	8b 40 0c             	mov    0xc(%eax),%eax
c0109261:	25 84 00 00 00       	and    $0x84,%eax
c0109266:	85 c0                	test   %eax,%eax
c0109268:	74 07                	je     c0109271 <vfs_write+0x6d>
			writable = 1;
c010926a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}

	if (writable) {
c0109271:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0109275:	0f 84 de 00 00 00    	je     c0109359 <vfs_write+0x155>
		int old_len = node->length;
c010927b:	8b 45 08             	mov    0x8(%ebp),%eax
c010927e:	8b 40 08             	mov    0x8(%eax),%eax
c0109281:	89 45 f0             	mov    %eax,-0x10(%ebp)
    		if( (off + bytes) > node->length) {
c0109284:	8b 45 14             	mov    0x14(%ebp),%eax
c0109287:	8b 55 0c             	mov    0xc(%ebp),%edx
c010928a:	01 d0                	add    %edx,%eax
c010928c:	89 c2                	mov    %eax,%edx
c010928e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109291:	8b 40 08             	mov    0x8(%eax),%eax
c0109294:	39 c2                	cmp    %eax,%edx
c0109296:	76 1e                	jbe    c01092b6 <vfs_write+0xb2>
			node->length = off + bytes;
c0109298:	8b 45 14             	mov    0x14(%ebp),%eax
c010929b:	8b 55 0c             	mov    0xc(%ebp),%edx
c010929e:	01 d0                	add    %edx,%eax
c01092a0:	89 c2                	mov    %eax,%edx
c01092a2:	8b 45 08             	mov    0x8(%ebp),%eax
c01092a5:	89 50 08             	mov    %edx,0x8(%eax)
			node->stat.st_size = node->length;
c01092a8:	8b 45 08             	mov    0x8(%ebp),%eax
c01092ab:	8b 40 08             	mov    0x8(%eax),%eax
c01092ae:	89 c2                	mov    %eax,%edx
c01092b0:	8b 45 08             	mov    0x8(%ebp),%eax
c01092b3:	89 50 20             	mov    %edx,0x20(%eax)
		}

		if (node->base == NULL) {
c01092b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01092b9:	8b 40 04             	mov    0x4(%eax),%eax
c01092bc:	85 c0                	test   %eax,%eax
c01092be:	75 18                	jne    c01092d8 <vfs_write+0xd4>
			node->base = malloc(node->length);
c01092c0:	8b 45 08             	mov    0x8(%ebp),%eax
c01092c3:	8b 40 08             	mov    0x8(%eax),%eax
c01092c6:	89 04 24             	mov    %eax,(%esp)
c01092c9:	e8 f6 f2 ff ff       	call   c01085c4 <malloc>
c01092ce:	89 c2                	mov    %eax,%edx
c01092d0:	8b 45 08             	mov    0x8(%ebp),%eax
c01092d3:	89 50 04             	mov    %edx,0x4(%eax)
c01092d6:	eb 4f                	jmp    c0109327 <vfs_write+0x123>
		} else {
			int pages_new = NUM_PAGES(node->length);
c01092d8:	8b 45 08             	mov    0x8(%ebp),%eax
c01092db:	8b 40 08             	mov    0x8(%eax),%eax
c01092de:	05 ff 0f 00 00       	add    $0xfff,%eax
c01092e3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01092e8:	c1 e8 0c             	shr    $0xc,%eax
c01092eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			int pages_old = NUM_PAGES(old_len);
c01092ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01092f1:	05 ff 0f 00 00       	add    $0xfff,%eax
c01092f6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01092fb:	c1 e8 0c             	shr    $0xc,%eax
c01092fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(pages_new > pages_old)
c0109301:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109304:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0109307:	7e 1e                	jle    c0109327 <vfs_write+0x123>
				node->base = realloc(node->base, node->length);
c0109309:	8b 45 08             	mov    0x8(%ebp),%eax
c010930c:	8b 50 08             	mov    0x8(%eax),%edx
c010930f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109312:	8b 40 04             	mov    0x4(%eax),%eax
c0109315:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109319:	89 04 24             	mov    %eax,(%esp)
c010931c:	e8 14 f3 ff ff       	call   c0108635 <realloc>
c0109321:	8b 55 08             	mov    0x8(%ebp),%edx
c0109324:	89 42 04             	mov    %eax,0x4(%edx)
		}

		uint8_t *nbase = (uint8_t*) node->base + off;
c0109327:	8b 45 08             	mov    0x8(%ebp),%eax
c010932a:	8b 50 04             	mov    0x4(%eax),%edx
c010932d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109330:	01 d0                	add    %edx,%eax
c0109332:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint8_t *wbase = (uint8_t*) base;
c0109335:	8b 45 10             	mov    0x10(%ebp),%eax
c0109338:	89 45 e0             	mov    %eax,-0x20(%ebp)
		memcpy(nbase, wbase, bytes);
c010933b:	8b 45 14             	mov    0x14(%ebp),%eax
c010933e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0109342:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109345:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109349:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010934c:	89 04 24             	mov    %eax,(%esp)
c010934f:	e8 d8 0c 00 00       	call   c010a02c <memcpy>
		return bytes;
c0109354:	8b 45 14             	mov    0x14(%ebp),%eax
c0109357:	eb 1b                	jmp    c0109374 <vfs_write+0x170>
	} else {
		printf("vfs: node %d isn't writable!\n", node->stat.st_ino);
c0109359:	8b 45 08             	mov    0x8(%ebp),%eax
c010935c:	8b 40 10             	mov    0x10(%eax),%eax
c010935f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109363:	c7 04 24 1b c5 10 c0 	movl   $0xc010c51b,(%esp)
c010936a:	e8 0d c0 ff ff       	call   c010537c <printf>
	}
	return 0;
c010936f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0109374:	c9                   	leave  
c0109375:	c3                   	ret    

c0109376 <vfs_read>:
 * @param node the node, that will be readed
 * @param offset the offset from the node
 *
 * @return readed data
 */
void* vfs_read(vfs_inode_t *node, uintptr_t offset) {
c0109376:	55                   	push   %ebp
c0109377:	89 e5                	mov    %esp,%ebp
	return (void*) node->base + offset;
c0109379:	8b 45 08             	mov    0x8(%ebp),%eax
c010937c:	8b 50 04             	mov    0x4(%eax),%edx
c010937f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109382:	01 d0                	add    %edx,%eax
}
c0109384:	5d                   	pop    %ebp
c0109385:	c3                   	ret    

c0109386 <vfs_stat>:
 * @param node node
 * @param buffer buffer
 *
 * @return success
 */
int vfs_stat(vfs_inode_t *node, struct stat *buffer) {
c0109386:	55                   	push   %ebp
c0109387:	89 e5                	mov    %esp,%ebp
c0109389:	83 ec 10             	sub    $0x10,%esp
	uint8_t *node_stat = (uint8_t*) &node->stat;
c010938c:	8b 45 08             	mov    0x8(%ebp),%eax
c010938f:	83 c0 0c             	add    $0xc,%eax
c0109392:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint8_t *buf = (uint8_t*) buffer;
c0109395:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109398:	89 45 f8             	mov    %eax,-0x8(%ebp)
	int i = 0;
c010939b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	while (i++ < sizeof(struct stat)) {
c01093a2:	eb 13                	jmp    c01093b7 <vfs_stat+0x31>
		*buf++ = *node_stat++;
c01093a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01093a7:	0f b6 10             	movzbl (%eax),%edx
c01093aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01093ad:	88 10                	mov    %dl,(%eax)
c01093af:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c01093b3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 */
int vfs_stat(vfs_inode_t *node, struct stat *buffer) {
	uint8_t *node_stat = (uint8_t*) &node->stat;
	uint8_t *buf = (uint8_t*) buffer;
	int i = 0;
	while (i++ < sizeof(struct stat)) {
c01093b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01093ba:	83 f8 43             	cmp    $0x43,%eax
c01093bd:	0f 96 c0             	setbe  %al
c01093c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01093c4:	84 c0                	test   %al,%al
c01093c6:	75 dc                	jne    c01093a4 <vfs_stat+0x1e>
		*buf++ = *node_stat++;
	}

	return 0;
c01093c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01093cd:	c9                   	leave  
c01093ce:	c3                   	ret    

c01093cf <vfs_access>:
 * @param node node
 * @param modus access to check
 *
 * @return
 */
int vfs_access(vfs_inode_t *node, mode_t modus) {
c01093cf:	55                   	push   %ebp
c01093d0:	89 e5                	mov    %esp,%ebp
	if (node->stat.st_uid == uid)
c01093d2:	8b 45 08             	mov    0x8(%ebp),%eax
c01093d5:	8b 50 18             	mov    0x18(%eax),%edx
c01093d8:	a1 54 19 11 c0       	mov    0xc0111954,%eax
c01093dd:	39 c2                	cmp    %eax,%edx
c01093df:	75 6b                	jne    c010944c <vfs_access+0x7d>
	{
		if ((modus & R_OK) &&
c01093e1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01093e4:	83 e0 01             	and    $0x1,%eax
c01093e7:	85 c0                	test   %eax,%eax
c01093e9:	74 17                	je     c0109402 <vfs_access+0x33>
		    !(node->stat.st_mode & S_IRUSR))
c01093eb:	8b 45 08             	mov    0x8(%ebp),%eax
c01093ee:	8b 40 0c             	mov    0xc(%eax),%eax
c01093f1:	83 e0 05             	and    $0x5,%eax
 * @return
 */
int vfs_access(vfs_inode_t *node, mode_t modus) {
	if (node->stat.st_uid == uid)
	{
		if ((modus & R_OK) &&
c01093f4:	85 c0                	test   %eax,%eax
c01093f6:	75 0a                	jne    c0109402 <vfs_access+0x33>
		    !(node->stat.st_mode & S_IRUSR))
			return -1;
c01093f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01093fd:	e9 1c 01 00 00       	jmp    c010951e <vfs_access+0x14f>
		if ((modus & W_OK) &&
c0109402:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109405:	83 e0 02             	and    $0x2,%eax
c0109408:	85 c0                	test   %eax,%eax
c010940a:	74 17                	je     c0109423 <vfs_access+0x54>
		    !(node->stat.st_mode & S_IWUSR))
c010940c:	8b 45 08             	mov    0x8(%ebp),%eax
c010940f:	8b 40 0c             	mov    0xc(%eax),%eax
c0109412:	83 e0 06             	and    $0x6,%eax
	if (node->stat.st_uid == uid)
	{
		if ((modus & R_OK) &&
		    !(node->stat.st_mode & S_IRUSR))
			return -1;
		if ((modus & W_OK) &&
c0109415:	85 c0                	test   %eax,%eax
c0109417:	75 0a                	jne    c0109423 <vfs_access+0x54>
		    !(node->stat.st_mode & S_IWUSR))
			return -1;
c0109419:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010941e:	e9 fb 00 00 00       	jmp    c010951e <vfs_access+0x14f>
		if ((modus & X_OK) &&
c0109423:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109426:	83 e0 04             	and    $0x4,%eax
c0109429:	85 c0                	test   %eax,%eax
c010942b:	0f 84 e8 00 00 00    	je     c0109519 <vfs_access+0x14a>
		    !(node->stat.st_mode & S_IXUSR))
c0109431:	8b 45 08             	mov    0x8(%ebp),%eax
c0109434:	8b 40 0c             	mov    0xc(%eax),%eax
c0109437:	83 e0 08             	and    $0x8,%eax
		    !(node->stat.st_mode & S_IRUSR))
			return -1;
		if ((modus & W_OK) &&
		    !(node->stat.st_mode & S_IWUSR))
			return -1;
		if ((modus & X_OK) &&
c010943a:	85 c0                	test   %eax,%eax
c010943c:	0f 85 d7 00 00 00    	jne    c0109519 <vfs_access+0x14a>
		    !(node->stat.st_mode & S_IXUSR))
			return -1;
c0109442:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0109447:	e9 d2 00 00 00       	jmp    c010951e <vfs_access+0x14f>
	}
	else if (node->stat.st_gid == gid)
c010944c:	8b 45 08             	mov    0x8(%ebp),%eax
c010944f:	8b 50 1c             	mov    0x1c(%eax),%edx
c0109452:	a1 58 19 11 c0       	mov    0xc0111958,%eax
c0109457:	39 c2                	cmp    %eax,%edx
c0109459:	75 60                	jne    c01094bb <vfs_access+0xec>
	{
		if ((modus & R_OK) &&
c010945b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010945e:	83 e0 01             	and    $0x1,%eax
c0109461:	85 c0                	test   %eax,%eax
c0109463:	74 17                	je     c010947c <vfs_access+0xad>
		    !(node->stat.st_mode & S_IRGRP))
c0109465:	8b 45 08             	mov    0x8(%ebp),%eax
c0109468:	8b 40 0c             	mov    0xc(%eax),%eax
c010946b:	83 e0 0c             	and    $0xc,%eax
		    !(node->stat.st_mode & S_IXUSR))
			return -1;
	}
	else if (node->stat.st_gid == gid)
	{
		if ((modus & R_OK) &&
c010946e:	85 c0                	test   %eax,%eax
c0109470:	75 0a                	jne    c010947c <vfs_access+0xad>
		    !(node->stat.st_mode & S_IRGRP))
			return -1;
c0109472:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0109477:	e9 a2 00 00 00       	jmp    c010951e <vfs_access+0x14f>
		if ((modus & W_OK) &&
c010947c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010947f:	83 e0 02             	and    $0x2,%eax
c0109482:	85 c0                	test   %eax,%eax
c0109484:	74 17                	je     c010949d <vfs_access+0xce>
		    !(node->stat.st_mode & S_IWGRP))
c0109486:	8b 45 08             	mov    0x8(%ebp),%eax
c0109489:	8b 40 0c             	mov    0xc(%eax),%eax
c010948c:	83 e0 14             	and    $0x14,%eax
	else if (node->stat.st_gid == gid)
	{
		if ((modus & R_OK) &&
		    !(node->stat.st_mode & S_IRGRP))
			return -1;
		if ((modus & W_OK) &&
c010948f:	85 c0                	test   %eax,%eax
c0109491:	75 0a                	jne    c010949d <vfs_access+0xce>
		    !(node->stat.st_mode & S_IWGRP))
			return -1;
c0109493:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0109498:	e9 81 00 00 00       	jmp    c010951e <vfs_access+0x14f>
		if ((modus & X_OK) &&
c010949d:	8b 45 0c             	mov    0xc(%ebp),%eax
c01094a0:	83 e0 04             	and    $0x4,%eax
c01094a3:	85 c0                	test   %eax,%eax
c01094a5:	74 72                	je     c0109519 <vfs_access+0x14a>
		    !(node->stat.st_mode & S_IXGRP))
c01094a7:	8b 45 08             	mov    0x8(%ebp),%eax
c01094aa:	8b 40 0c             	mov    0xc(%eax),%eax
c01094ad:	83 e0 24             	and    $0x24,%eax
		    !(node->stat.st_mode & S_IRGRP))
			return -1;
		if ((modus & W_OK) &&
		    !(node->stat.st_mode & S_IWGRP))
			return -1;
		if ((modus & X_OK) &&
c01094b0:	85 c0                	test   %eax,%eax
c01094b2:	75 65                	jne    c0109519 <vfs_access+0x14a>
		    !(node->stat.st_mode & S_IXGRP))
			return -1;
c01094b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01094b9:	eb 63                	jmp    c010951e <vfs_access+0x14f>
	}
	else
	{
		if ((modus & R_OK) &&
c01094bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c01094be:	83 e0 01             	and    $0x1,%eax
c01094c1:	85 c0                	test   %eax,%eax
c01094c3:	74 14                	je     c01094d9 <vfs_access+0x10a>
		    !(node->stat.st_mode & S_IROTH))
c01094c5:	8b 45 08             	mov    0x8(%ebp),%eax
c01094c8:	8b 40 0c             	mov    0xc(%eax),%eax
c01094cb:	83 e0 44             	and    $0x44,%eax
		    !(node->stat.st_mode & S_IXGRP))
			return -1;
	}
	else
	{
		if ((modus & R_OK) &&
c01094ce:	85 c0                	test   %eax,%eax
c01094d0:	75 07                	jne    c01094d9 <vfs_access+0x10a>
		    !(node->stat.st_mode & S_IROTH))
			return -1;
c01094d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01094d7:	eb 45                	jmp    c010951e <vfs_access+0x14f>
		if ((modus & W_OK) &&
c01094d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01094dc:	83 e0 02             	and    $0x2,%eax
c01094df:	85 c0                	test   %eax,%eax
c01094e1:	74 16                	je     c01094f9 <vfs_access+0x12a>
		    !(node->stat.st_mode & S_IWOTH))
c01094e3:	8b 45 08             	mov    0x8(%ebp),%eax
c01094e6:	8b 40 0c             	mov    0xc(%eax),%eax
c01094e9:	25 84 00 00 00       	and    $0x84,%eax
	else
	{
		if ((modus & R_OK) &&
		    !(node->stat.st_mode & S_IROTH))
			return -1;
		if ((modus & W_OK) &&
c01094ee:	85 c0                	test   %eax,%eax
c01094f0:	75 07                	jne    c01094f9 <vfs_access+0x12a>
		    !(node->stat.st_mode & S_IWOTH))
			return -1;
c01094f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01094f7:	eb 25                	jmp    c010951e <vfs_access+0x14f>
		if ((modus & X_OK) &&
c01094f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01094fc:	83 e0 04             	and    $0x4,%eax
c01094ff:	85 c0                	test   %eax,%eax
c0109501:	74 16                	je     c0109519 <vfs_access+0x14a>
		    !(node->stat.st_mode & S_IXOTH))
c0109503:	8b 45 08             	mov    0x8(%ebp),%eax
c0109506:	8b 40 0c             	mov    0xc(%eax),%eax
c0109509:	25 04 01 00 00       	and    $0x104,%eax
		    !(node->stat.st_mode & S_IROTH))
			return -1;
		if ((modus & W_OK) &&
		    !(node->stat.st_mode & S_IWOTH))
			return -1;
		if ((modus & X_OK) &&
c010950e:	85 c0                	test   %eax,%eax
c0109510:	75 07                	jne    c0109519 <vfs_access+0x14a>
		    !(node->stat.st_mode & S_IXOTH))
			return -1;
c0109512:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0109517:	eb 05                	jmp    c010951e <vfs_access+0x14f>
	}

	return 0;
c0109519:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010951e:	5d                   	pop    %ebp
c010951f:	c3                   	ret    

c0109520 <vfs_lookup_path>:
 * Dissolve a path to an inode
 *
 * @param path
 * @return inode
 */
vfs_inode_t *vfs_lookup_path(char *path) {
c0109520:	55                   	push   %ebp
c0109521:	89 e5                	mov    %esp,%ebp
c0109523:	83 ec 38             	sub    $0x38,%esp
	vfs_inode_t *parent = root;
c0109526:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c010952b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(path[0] != '/') {
c010952e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109531:	0f b6 00             	movzbl (%eax),%eax
c0109534:	3c 2f                	cmp    $0x2f,%al
c0109536:	74 10                	je     c0109548 <vfs_lookup_path+0x28>
		parent = current_thread->process->cwd;
c0109538:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010953d:	8b 40 04             	mov    0x4(%eax),%eax
c0109540:	8b 40 10             	mov    0x10(%eax),%eax
c0109543:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0109546:	eb 04                	jmp    c010954c <vfs_lookup_path+0x2c>
	} else {
		path++;
c0109548:	83 45 08 01          	addl   $0x1,0x8(%ebp)
	}

	int len = strlen(path);
c010954c:	8b 45 08             	mov    0x8(%ebp),%eax
c010954f:	89 04 24             	mov    %eax,(%esp)
c0109552:	e8 cd 06 00 00       	call   c0109c24 <strlen>
c0109557:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if(path[len-1] == '/') {
c010955a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010955d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0109560:	8b 45 08             	mov    0x8(%ebp),%eax
c0109563:	01 d0                	add    %edx,%eax
c0109565:	0f b6 00             	movzbl (%eax),%eax
c0109568:	3c 2f                	cmp    $0x2f,%al
c010956a:	75 0e                	jne    c010957a <vfs_lookup_path+0x5a>
		path[len-1] = '\0';
c010956c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010956f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0109572:	8b 45 08             	mov    0x8(%ebp),%eax
c0109575:	01 d0                	add    %edx,%eax
c0109577:	c6 00 00             	movb   $0x0,(%eax)
	}

	char delimiter[] = "/";
c010957a:	66 c7 45 da 2f 00    	movw   $0x2f,-0x26(%ebp)
	char *str = (char*) strtok(path, delimiter);
c0109580:	8d 45 da             	lea    -0x26(%ebp),%eax
c0109583:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109587:	8b 45 08             	mov    0x8(%ebp),%eax
c010958a:	89 04 24             	mov    %eax,(%esp)
c010958d:	e8 a2 09 00 00       	call   c0109f34 <strtok>
c0109592:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while(str != NULL) {
c0109595:	e9 a4 00 00 00       	jmp    c010963e <vfs_lookup_path+0x11e>
		int num = parent->length / sizeof(vfs_dentry_t);
c010959a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010959d:	8b 40 08             	mov    0x8(%eax),%eax
c01095a0:	c1 e8 03             	shr    $0x3,%eax
c01095a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
		vfs_dentry_t *entries = vfs_read(parent, 0);
c01095a6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01095ad:	00 
c01095ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01095b1:	89 04 24             	mov    %eax,(%esp)
c01095b4:	e8 bd fd ff ff       	call   c0109376 <vfs_read>
c01095b9:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int found = 0;
c01095bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		int i;
		for(i = 0; i < num; i++) {
c01095c3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c01095ca:	eb 47                	jmp    c0109613 <vfs_lookup_path+0xf3>
			if(strcmp(str, entries[i].inode->name)) {
c01095cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01095cf:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c01095d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01095d9:	01 d0                	add    %edx,%eax
c01095db:	8b 40 04             	mov    0x4(%eax),%eax
c01095de:	8b 00                	mov    (%eax),%eax
c01095e0:	89 44 24 04          	mov    %eax,0x4(%esp)
c01095e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01095e7:	89 04 24             	mov    %eax,(%esp)
c01095ea:	e8 79 07 00 00       	call   c0109d68 <strcmp>
c01095ef:	85 c0                	test   %eax,%eax
c01095f1:	74 1c                	je     c010960f <vfs_lookup_path+0xef>
				parent = entries[i].inode;
c01095f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01095f6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c01095fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109600:	01 d0                	add    %edx,%eax
c0109602:	8b 40 04             	mov    0x4(%eax),%eax
c0109605:	89 45 f4             	mov    %eax,-0xc(%ebp)
				found = 1;
c0109608:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	while(str != NULL) {
		int num = parent->length / sizeof(vfs_dentry_t);
		vfs_dentry_t *entries = vfs_read(parent, 0);
		int found = 0;
		int i;
		for(i = 0; i < num; i++) {
c010960f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0109613:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109616:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0109619:	7c b1                	jl     c01095cc <vfs_lookup_path+0xac>
				parent = entries[i].inode;
				found = 1;
			}
		}

		if(!found) {
c010961b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010961f:	75 07                	jne    c0109628 <vfs_lookup_path+0x108>
			return NULL;
c0109621:	b8 00 00 00 00       	mov    $0x0,%eax
c0109626:	eb 23                	jmp    c010964b <vfs_lookup_path+0x12b>
		} else {
			str = strtok(NULL, delimiter);
c0109628:	8d 45 da             	lea    -0x26(%ebp),%eax
c010962b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010962f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0109636:	e8 f9 08 00 00       	call   c0109f34 <strtok>
c010963b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		path[len-1] = '\0';
	}

	char delimiter[] = "/";
	char *str = (char*) strtok(path, delimiter);
	while(str != NULL) {
c010963e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0109642:	0f 85 52 ff ff ff    	jne    c010959a <vfs_lookup_path+0x7a>
		} else {
			str = strtok(NULL, delimiter);
		}
	}

	return parent;
c0109648:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010964b:	c9                   	leave  
c010964c:	c3                   	ret    

c010964d <get_fd>:

// Systemcalls

struct fd *get_fd(int fd) {
c010964d:	55                   	push   %ebp
c010964e:	89 e5                	mov    %esp,%ebp
c0109650:	83 ec 28             	sub    $0x28,%esp
	struct fd *desc = NULL;
c0109653:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct list_node *node = current_thread->process->files->head->next;
c010965a:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010965f:	8b 40 04             	mov    0x4(%eax),%eax
c0109662:	8b 40 14             	mov    0x14(%eax),%eax
c0109665:	8b 00                	mov    (%eax),%eax
c0109667:	8b 00                	mov    (%eax),%eax
c0109669:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i;
	for(i = 0; i < list_length(current_thread->process->files); i++) {
c010966c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0109673:	eb 26                	jmp    c010969b <get_fd+0x4e>
		desc = node->element;
c0109675:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109678:	8b 40 08             	mov    0x8(%eax),%eax
c010967b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(desc->id == fd) {
c010967e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109681:	8b 10                	mov    (%eax),%edx
c0109683:	8b 45 08             	mov    0x8(%ebp),%eax
c0109686:	39 c2                	cmp    %eax,%edx
c0109688:	75 05                	jne    c010968f <get_fd+0x42>
			return desc;
c010968a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010968d:	eb 29                	jmp    c01096b8 <get_fd+0x6b>
		} else {
			node = node->next;
c010968f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109692:	8b 00                	mov    (%eax),%eax
c0109694:	89 45 f4             	mov    %eax,-0xc(%ebp)

struct fd *get_fd(int fd) {
	struct fd *desc = NULL;
	struct list_node *node = current_thread->process->files->head->next;
	int i;
	for(i = 0; i < list_length(current_thread->process->files); i++) {
c0109697:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010969b:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01096a0:	8b 40 04             	mov    0x4(%eax),%eax
c01096a3:	8b 40 14             	mov    0x14(%eax),%eax
c01096a6:	89 04 24             	mov    %eax,(%esp)
c01096a9:	e8 ab f8 ff ff       	call   c0108f59 <list_length>
c01096ae:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c01096b1:	7f c2                	jg     c0109675 <get_fd+0x28>
		} else {
			node = node->next;
		}
	}

	return NULL;
c01096b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01096b8:	c9                   	leave  
c01096b9:	c3                   	ret    

c01096ba <open>:

void open(struct cpu_state **cpu) {
c01096ba:	55                   	push   %ebp
c01096bb:	89 e5                	mov    %esp,%ebp
c01096bd:	83 ec 38             	sub    $0x38,%esp
	char *path = (char *) (*cpu)->ebx;
c01096c0:	8b 45 08             	mov    0x8(%ebp),%eax
c01096c3:	8b 00                	mov    (%eax),%eax
c01096c5:	8b 40 1c             	mov    0x1c(%eax),%eax
c01096c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int oflags = (*cpu)->ecx;
c01096cb:	8b 45 08             	mov    0x8(%ebp),%eax
c01096ce:	8b 00                	mov    (%eax),%eax
c01096d0:	8b 40 24             	mov    0x24(%eax),%eax
c01096d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	mode_t mode = (*cpu)->edx;
c01096d6:	8b 45 08             	mov    0x8(%ebp),%eax
c01096d9:	8b 00                	mov    (%eax),%eax
c01096db:	8b 40 20             	mov    0x20(%eax),%eax
c01096de:	89 45 e8             	mov    %eax,-0x18(%ebp)

	vfs_inode_t *inode = vfs_lookup_path(path);
c01096e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01096e4:	89 04 24             	mov    %eax,(%esp)
c01096e7:	e8 34 fe ff ff       	call   c0109520 <vfs_lookup_path>
c01096ec:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(inode == NULL) {
c01096ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01096f3:	75 63                	jne    c0109758 <open+0x9e>
		if(oflags & O_CREAT) {// create inode
c01096f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01096f8:	83 e0 20             	and    $0x20,%eax
c01096fb:	85 c0                	test   %eax,%eax
c01096fd:	74 48                	je     c0109747 <open+0x8d>
			char *name = malloc(strlen((char*)path));
c01096ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109702:	89 04 24             	mov    %eax,(%esp)
c0109705:	e8 1a 05 00 00       	call   c0109c24 <strlen>
c010970a:	89 04 24             	mov    %eax,(%esp)
c010970d:	e8 b2 ee ff ff       	call   c01085c4 <malloc>
c0109712:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			strcpy(name, path);
c0109715:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109718:	89 44 24 04          	mov    %eax,0x4(%esp)
c010971c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010971f:	89 04 24             	mov    %eax,(%esp)
c0109722:	e8 24 05 00 00       	call   c0109c4b <strcpy>
			inode = vfs_create_inode(name, mode, root);
c0109727:	a1 4c 19 11 c0       	mov    0xc011194c,%eax
c010972c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0109730:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109733:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010973a:	89 04 24             	mov    %eax,(%esp)
c010973d:	e8 a5 f9 ff ff       	call   c01090e7 <vfs_create_inode>
c0109742:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0109745:	eb 2c                	jmp    c0109773 <open+0xb9>
		} else {
			(*cpu)->eax = -1;
c0109747:	8b 45 08             	mov    0x8(%ebp),%eax
c010974a:	8b 00                	mov    (%eax),%eax
c010974c:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
			return;
c0109753:	e9 ba 00 00 00       	jmp    c0109812 <open+0x158>
		}
	} else {
		if(oflags & O_EXCL) {
c0109758:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010975b:	83 e0 40             	and    $0x40,%eax
c010975e:	85 c0                	test   %eax,%eax
c0109760:	74 11                	je     c0109773 <open+0xb9>
			(*cpu)->eax = -2;
c0109762:	8b 45 08             	mov    0x8(%ebp),%eax
c0109765:	8b 00                	mov    (%eax),%eax
c0109767:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
			return;
c010976e:	e9 9f 00 00 00       	jmp    c0109812 <open+0x158>
		}
	}

	if(oflags & O_TRUNC) {
c0109773:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109776:	83 e0 10             	and    $0x10,%eax
c0109779:	85 c0                	test   %eax,%eax
c010977b:	74 20                	je     c010979d <open+0xe3>
		memset(inode->base, 0, inode->length);
c010977d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109780:	8b 50 08             	mov    0x8(%eax),%edx
c0109783:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109786:	8b 40 04             	mov    0x4(%eax),%eax
c0109789:	89 54 24 08          	mov    %edx,0x8(%esp)
c010978d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0109794:	00 
c0109795:	89 04 24             	mov    %eax,(%esp)
c0109798:	e8 58 0a 00 00       	call   c010a1f5 <memset>
	}

	struct fd *desc = malloc(sizeof(struct fd));
c010979d:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c01097a4:	e8 1b ee ff ff       	call   c01085c4 <malloc>
c01097a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	desc->id = list_length(current_thread->process->files);
c01097ac:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01097b1:	8b 40 04             	mov    0x4(%eax),%eax
c01097b4:	8b 40 14             	mov    0x14(%eax),%eax
c01097b7:	89 04 24             	mov    %eax,(%esp)
c01097ba:	e8 9a f7 ff ff       	call   c0108f59 <list_length>
c01097bf:	89 c2                	mov    %eax,%edx
c01097c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01097c4:	89 10                	mov    %edx,(%eax)
	desc->mode = mode;
c01097c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01097c9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01097cc:	89 50 08             	mov    %edx,0x8(%eax)
	desc->flags = oflags;
c01097cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01097d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01097d5:	89 50 0c             	mov    %edx,0xc(%eax)
	desc->pos = 0;
c01097d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01097db:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	desc->inode = inode;
c01097e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01097e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01097e8:	89 50 04             	mov    %edx,0x4(%eax)

	list_push_back(current_thread->process->files, desc);
c01097eb:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01097f0:	8b 40 04             	mov    0x4(%eax),%eax
c01097f3:	8b 40 14             	mov    0x14(%eax),%eax
c01097f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01097f9:	89 54 24 04          	mov    %edx,0x4(%esp)
c01097fd:	89 04 24             	mov    %eax,(%esp)
c0109800:	e8 53 f5 ff ff       	call   c0108d58 <list_push_back>

	(*cpu)->eax = desc->id;
c0109805:	8b 45 08             	mov    0x8(%ebp),%eax
c0109808:	8b 00                	mov    (%eax),%eax
c010980a:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010980d:	8b 12                	mov    (%edx),%edx
c010980f:	89 50 28             	mov    %edx,0x28(%eax)
}
c0109812:	c9                   	leave  
c0109813:	c3                   	ret    

c0109814 <pipe>:

void pipe(struct cpu_state **cpu) {
c0109814:	55                   	push   %ebp
c0109815:	89 e5                	mov    %esp,%ebp
c0109817:	83 ec 28             	sub    $0x28,%esp
	int *id = (int *) (*cpu)->ebx;
c010981a:	8b 45 08             	mov    0x8(%ebp),%eax
c010981d:	8b 00                	mov    (%eax),%eax
c010981f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0109822:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(get_fd(id[0]) != NULL &&
c0109825:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109828:	8b 00                	mov    (%eax),%eax
c010982a:	89 04 24             	mov    %eax,(%esp)
c010982d:	e8 1b fe ff ff       	call   c010964d <get_fd>
c0109832:	85 c0                	test   %eax,%eax
c0109834:	0f 84 00 01 00 00    	je     c010993a <pipe+0x126>
	   get_fd(id[1]) != NULL)
c010983a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010983d:	83 c0 04             	add    $0x4,%eax
c0109840:	8b 00                	mov    (%eax),%eax
c0109842:	89 04 24             	mov    %eax,(%esp)
c0109845:	e8 03 fe ff ff       	call   c010964d <get_fd>
}

void pipe(struct cpu_state **cpu) {
	int *id = (int *) (*cpu)->ebx;

	if(get_fd(id[0]) != NULL &&
c010984a:	85 c0                	test   %eax,%eax
c010984c:	0f 84 e8 00 00 00    	je     c010993a <pipe+0x126>
	   get_fd(id[1]) != NULL)
	{
		vfs_inode_t *inode = vfs_create_inode("pipe", 0, NULL);
c0109852:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0109859:	00 
c010985a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0109861:	00 
c0109862:	c7 04 24 39 c5 10 c0 	movl   $0xc010c539,(%esp)
c0109869:	e8 79 f8 ff ff       	call   c01090e7 <vfs_create_inode>
c010986e:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// create read channel
		struct fd *desc0 = malloc(sizeof(struct fd));
c0109871:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0109878:	e8 47 ed ff ff       	call   c01085c4 <malloc>
c010987d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		desc0->id = id[0];
c0109880:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109883:	8b 00                	mov    (%eax),%eax
c0109885:	89 c2                	mov    %eax,%edx
c0109887:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010988a:	89 10                	mov    %edx,(%eax)
		desc0->mode = 0x7ff;
c010988c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010988f:	c7 40 08 ff 07 00 00 	movl   $0x7ff,0x8(%eax)
		desc0->flags = O_RDONLY;
c0109896:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109899:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
		desc0->pos = 0;
c01098a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01098a3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		desc0->inode = inode;
c01098aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01098ad:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01098b0:	89 50 04             	mov    %edx,0x4(%eax)
		list_push_back(current_thread->process->files, desc0);
c01098b3:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01098b8:	8b 40 04             	mov    0x4(%eax),%eax
c01098bb:	8b 40 14             	mov    0x14(%eax),%eax
c01098be:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01098c1:	89 54 24 04          	mov    %edx,0x4(%esp)
c01098c5:	89 04 24             	mov    %eax,(%esp)
c01098c8:	e8 8b f4 ff ff       	call   c0108d58 <list_push_back>

		// create write channel
		struct fd *desc1 = malloc(sizeof(struct fd));
c01098cd:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c01098d4:	e8 eb ec ff ff       	call   c01085c4 <malloc>
c01098d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		desc1->id = id[1];
c01098dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098df:	83 c0 04             	add    $0x4,%eax
c01098e2:	8b 00                	mov    (%eax),%eax
c01098e4:	89 c2                	mov    %eax,%edx
c01098e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01098e9:	89 10                	mov    %edx,(%eax)
		desc1->mode = 0x7ff;
c01098eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01098ee:	c7 40 08 ff 07 00 00 	movl   $0x7ff,0x8(%eax)
		desc1->flags = O_WRONLY;
c01098f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01098f8:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
		desc1->pos = 0;
c01098ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109902:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		desc1->inode = inode;
c0109909:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010990c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010990f:	89 50 04             	mov    %edx,0x4(%eax)
		list_push_back(current_thread->process->files, desc1);
c0109912:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c0109917:	8b 40 04             	mov    0x4(%eax),%eax
c010991a:	8b 40 14             	mov    0x14(%eax),%eax
c010991d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0109920:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109924:	89 04 24             	mov    %eax,(%esp)
c0109927:	e8 2c f4 ff ff       	call   c0108d58 <list_push_back>

		(*cpu)->eax = 0;
c010992c:	8b 45 08             	mov    0x8(%ebp),%eax
c010992f:	8b 00                	mov    (%eax),%eax
c0109931:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
void pipe(struct cpu_state **cpu) {
	int *id = (int *) (*cpu)->ebx;

	if(get_fd(id[0]) != NULL &&
	   get_fd(id[1]) != NULL)
	{
c0109938:	eb 0c                	jmp    c0109946 <pipe+0x132>
		desc1->inode = inode;
		list_push_back(current_thread->process->files, desc1);

		(*cpu)->eax = 0;
	} else {
		(*cpu)->eax = -1;
c010993a:	8b 45 08             	mov    0x8(%ebp),%eax
c010993d:	8b 00                	mov    (%eax),%eax
c010993f:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
	}
}
c0109946:	c9                   	leave  
c0109947:	c3                   	ret    

c0109948 <close>:

void close(struct cpu_state **cpu) {
c0109948:	55                   	push   %ebp
c0109949:	89 e5                	mov    %esp,%ebp
c010994b:	83 ec 28             	sub    $0x28,%esp
	int fd = (*cpu)->ebx;
c010994e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109951:	8b 00                	mov    (%eax),%eax
c0109953:	8b 40 1c             	mov    0x1c(%eax),%eax
c0109956:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct list_node *node = current_thread->process->files->head->next;
c0109959:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c010995e:	8b 40 04             	mov    0x4(%eax),%eax
c0109961:	8b 40 14             	mov    0x14(%eax),%eax
c0109964:	8b 00                	mov    (%eax),%eax
c0109966:	8b 00                	mov    (%eax),%eax
c0109968:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i;
	for(i = 0; i < list_length(current_thread->process->files); i++) {
c010996b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0109972:	eb 3a                	jmp    c01099ae <close+0x66>
		struct fd *desc = node->element;
c0109974:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109977:	8b 40 08             	mov    0x8(%eax),%eax
c010997a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if(desc->id == fd) {
c010997d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109980:	8b 10                	mov    (%eax),%edx
c0109982:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109985:	39 c2                	cmp    %eax,%edx
c0109987:	75 19                	jne    c01099a2 <close+0x5a>
			list_remove_node(node);
c0109989:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010998c:	89 04 24             	mov    %eax,(%esp)
c010998f:	e8 43 f5 ff ff       	call   c0108ed7 <list_remove_node>
			(*cpu)->eax = 0;
c0109994:	8b 45 08             	mov    0x8(%ebp),%eax
c0109997:	8b 00                	mov    (%eax),%eax
c0109999:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c01099a0:	eb 08                	jmp    c01099aa <close+0x62>
		} else {
			node = node->next;
c01099a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01099a5:	8b 00                	mov    (%eax),%eax
c01099a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
void close(struct cpu_state **cpu) {
	int fd = (*cpu)->ebx;

	struct list_node *node = current_thread->process->files->head->next;
	int i;
	for(i = 0; i < list_length(current_thread->process->files); i++) {
c01099aa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01099ae:	a1 08 30 11 c0       	mov    0xc0113008,%eax
c01099b3:	8b 40 04             	mov    0x4(%eax),%eax
c01099b6:	8b 40 14             	mov    0x14(%eax),%eax
c01099b9:	89 04 24             	mov    %eax,(%esp)
c01099bc:	e8 98 f5 ff ff       	call   c0108f59 <list_length>
c01099c1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c01099c4:	7f ae                	jg     c0109974 <close+0x2c>
		} else {
			node = node->next;
		}
	}

	(*cpu)->eax = -1;
c01099c6:	8b 45 08             	mov    0x8(%ebp),%eax
c01099c9:	8b 00                	mov    (%eax),%eax
c01099cb:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
}
c01099d2:	c9                   	leave  
c01099d3:	c3                   	ret    

c01099d4 <read>:

void read(struct cpu_state **cpu) {
c01099d4:	55                   	push   %ebp
c01099d5:	89 e5                	mov    %esp,%ebp
c01099d7:	83 ec 38             	sub    $0x38,%esp
	int fd = (*cpu)->ebx;
c01099da:	8b 45 08             	mov    0x8(%ebp),%eax
c01099dd:	8b 00                	mov    (%eax),%eax
c01099df:	8b 40 1c             	mov    0x1c(%eax),%eax
c01099e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void *buf = (void*) (*cpu)->ecx;
c01099e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01099e8:	8b 00                	mov    (%eax),%eax
c01099ea:	8b 40 24             	mov    0x24(%eax),%eax
c01099ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size_t len = (*cpu)->edx;
c01099f0:	8b 45 08             	mov    0x8(%ebp),%eax
c01099f3:	8b 00                	mov    (%eax),%eax
c01099f5:	8b 40 20             	mov    0x20(%eax),%eax
c01099f8:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct fd *desc = get_fd(fd);
c01099fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01099fe:	89 04 24             	mov    %eax,(%esp)
c0109a01:	e8 47 fc ff ff       	call   c010964d <get_fd>
c0109a06:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(desc == NULL) {
c0109a09:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0109a0d:	75 11                	jne    c0109a20 <read+0x4c>
		(*cpu)->eax = -1;
c0109a0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a12:	8b 00                	mov    (%eax),%eax
c0109a14:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
		return;
c0109a1b:	e9 96 00 00 00       	jmp    c0109ab6 <read+0xe2>
	}

	if(desc->flags & O_RDONLY ||
c0109a20:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109a23:	8b 40 0c             	mov    0xc(%eax),%eax
c0109a26:	83 e0 01             	and    $0x1,%eax
c0109a29:	85 c0                	test   %eax,%eax
c0109a2b:	75 0d                	jne    c0109a3a <read+0x66>
	   desc->flags & O_RDWR)
c0109a2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109a30:	8b 40 0c             	mov    0xc(%eax),%eax
c0109a33:	83 e0 04             	and    $0x4,%eax
	if(desc == NULL) {
		(*cpu)->eax = -1;
		return;
	}

	if(desc->flags & O_RDONLY ||
c0109a36:	85 c0                	test   %eax,%eax
c0109a38:	74 70                	je     c0109aaa <read+0xd6>
	   desc->flags & O_RDWR)
	{
		vfs_inode_t *inode = desc->inode;
c0109a3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109a3d:	8b 40 04             	mov    0x4(%eax),%eax
c0109a40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		void *read = vfs_read(inode, desc->pos);
c0109a43:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109a46:	8b 40 10             	mov    0x10(%eax),%eax
c0109a49:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109a4d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109a50:	89 04 24             	mov    %eax,(%esp)
c0109a53:	e8 1e f9 ff ff       	call   c0109376 <vfs_read>
c0109a58:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(read != NULL) {
c0109a5b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0109a5f:	74 3b                	je     c0109a9c <read+0xc8>
			memcpy((void*)buf, read, len);
c0109a61:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109a64:	89 44 24 08          	mov    %eax,0x8(%esp)
c0109a68:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109a6b:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109a6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109a72:	89 04 24             	mov    %eax,(%esp)
c0109a75:	e8 b2 05 00 00       	call   c010a02c <memcpy>
			desc->pos += len;
c0109a7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109a7d:	8b 40 10             	mov    0x10(%eax),%eax
c0109a80:	89 c2                	mov    %eax,%edx
c0109a82:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109a85:	01 d0                	add    %edx,%eax
c0109a87:	89 c2                	mov    %eax,%edx
c0109a89:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109a8c:	89 50 10             	mov    %edx,0x10(%eax)
			(*cpu)->eax = len;
c0109a8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a92:	8b 00                	mov    (%eax),%eax
c0109a94:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0109a97:	89 50 28             	mov    %edx,0x28(%eax)
		return;
	}

	if(desc->flags & O_RDONLY ||
	   desc->flags & O_RDWR)
	{
c0109a9a:	eb 1a                	jmp    c0109ab6 <read+0xe2>
		if(read != NULL) {
			memcpy((void*)buf, read, len);
			desc->pos += len;
			(*cpu)->eax = len;
		} else {
			(*cpu)->eax = -2;
c0109a9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a9f:	8b 00                	mov    (%eax),%eax
c0109aa1:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
		return;
	}

	if(desc->flags & O_RDONLY ||
	   desc->flags & O_RDWR)
	{
c0109aa8:	eb 0c                	jmp    c0109ab6 <read+0xe2>
			(*cpu)->eax = len;
		} else {
			(*cpu)->eax = -2;
		}
	} else {
		(*cpu)->eax = -3;
c0109aaa:	8b 45 08             	mov    0x8(%ebp),%eax
c0109aad:	8b 00                	mov    (%eax),%eax
c0109aaf:	c7 40 28 fd ff ff ff 	movl   $0xfffffffd,0x28(%eax)
	}
}
c0109ab6:	c9                   	leave  
c0109ab7:	c3                   	ret    

c0109ab8 <write>:

void write(struct cpu_state **cpu) {
c0109ab8:	55                   	push   %ebp
c0109ab9:	89 e5                	mov    %esp,%ebp
c0109abb:	83 ec 38             	sub    $0x38,%esp
	int fd = (*cpu)->ebx;
c0109abe:	8b 45 08             	mov    0x8(%ebp),%eax
c0109ac1:	8b 00                	mov    (%eax),%eax
c0109ac3:	8b 40 1c             	mov    0x1c(%eax),%eax
c0109ac6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	char *buf = (void*) (*cpu)->ecx;
c0109ac9:	8b 45 08             	mov    0x8(%ebp),%eax
c0109acc:	8b 00                	mov    (%eax),%eax
c0109ace:	8b 40 24             	mov    0x24(%eax),%eax
c0109ad1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	size_t len = (*cpu)->edx;
c0109ad4:	8b 45 08             	mov    0x8(%ebp),%eax
c0109ad7:	8b 00                	mov    (%eax),%eax
c0109ad9:	8b 40 20             	mov    0x20(%eax),%eax
c0109adc:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if(fd < 3) {
c0109adf:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
c0109ae3:	7f 3c                	jg     c0109b21 <write+0x69>
		int i;
		for(i = 0; i < len; i++) {
c0109ae5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0109aec:	eb 1a                	jmp    c0109b08 <write+0x50>
			printf("%c", buf[i]);
c0109aee:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0109af1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109af4:	01 d0                	add    %edx,%eax
c0109af6:	0f b6 00             	movzbl (%eax),%eax
c0109af9:	0f be c0             	movsbl %al,%eax
c0109afc:	89 04 24             	mov    %eax,(%esp)
c0109aff:	e8 f4 8c ff ff       	call   c01027f8 <putchar>
	char *buf = (void*) (*cpu)->ecx;
	size_t len = (*cpu)->edx;

	if(fd < 3) {
		int i;
		for(i = 0; i < len; i++) {
c0109b04:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0109b08:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109b0b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0109b0e:	72 de                	jb     c0109aee <write+0x36>
			printf("%c", buf[i]);
		}
		(*cpu)->eax = 0;
c0109b10:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b13:	8b 00                	mov    (%eax),%eax
c0109b15:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
		return;
c0109b1c:	e9 cd 00 00 00       	jmp    c0109bee <write+0x136>
	}

	struct fd *desc = get_fd(fd);
c0109b21:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109b24:	89 04 24             	mov    %eax,(%esp)
c0109b27:	e8 21 fb ff ff       	call   c010964d <get_fd>
c0109b2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if(desc == NULL) {
c0109b2f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0109b33:	75 11                	jne    c0109b46 <write+0x8e>
		(*cpu)->eax = -1;
c0109b35:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b38:	8b 00                	mov    (%eax),%eax
c0109b3a:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
		return;
c0109b41:	e9 a8 00 00 00       	jmp    c0109bee <write+0x136>
	}

	if(desc->flags & O_WRONLY ||
c0109b46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b49:	8b 40 0c             	mov    0xc(%eax),%eax
c0109b4c:	83 e0 02             	and    $0x2,%eax
c0109b4f:	85 c0                	test   %eax,%eax
c0109b51:	75 0d                	jne    c0109b60 <write+0xa8>
	   desc->flags & O_RDWR)
c0109b53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b56:	8b 40 0c             	mov    0xc(%eax),%eax
c0109b59:	83 e0 04             	and    $0x4,%eax
	if(desc == NULL) {
		(*cpu)->eax = -1;
		return;
	}

	if(desc->flags & O_WRONLY ||
c0109b5c:	85 c0                	test   %eax,%eax
c0109b5e:	74 7f                	je     c0109bdf <write+0x127>
	   desc->flags & O_RDWR)
	{
		if(! (desc->flags & O_APPEND) ) {
c0109b60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b63:	8b 40 0c             	mov    0xc(%eax),%eax
c0109b66:	83 e0 08             	and    $0x8,%eax
c0109b69:	85 c0                	test   %eax,%eax
c0109b6b:	75 1b                	jne    c0109b88 <write+0xd0>
			desc->pos = 0;
c0109b6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b70:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
			desc->flags |= O_APPEND;
c0109b77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b7a:	8b 40 0c             	mov    0xc(%eax),%eax
c0109b7d:	89 c2                	mov    %eax,%edx
c0109b7f:	83 ca 08             	or     $0x8,%edx
c0109b82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b85:	89 50 0c             	mov    %edx,0xc(%eax)
		}

		vfs_inode_t *inode = desc->inode;
c0109b88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b8b:	8b 40 04             	mov    0x4(%eax),%eax
c0109b8e:	89 45 e0             	mov    %eax,-0x20(%ebp)
		int ret = vfs_write(inode, desc->pos, buf, len);
c0109b91:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0109b94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109b97:	8b 40 10             	mov    0x10(%eax),%eax
c0109b9a:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0109b9e:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0109ba1:	89 54 24 08          	mov    %edx,0x8(%esp)
c0109ba5:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109ba9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109bac:	89 04 24             	mov    %eax,(%esp)
c0109baf:	e8 50 f6 ff ff       	call   c0109204 <vfs_write>
c0109bb4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		(*cpu)->eax = ret;
c0109bb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0109bba:	8b 00                	mov    (%eax),%eax
c0109bbc:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0109bbf:	89 50 28             	mov    %edx,0x28(%eax)
		if(ret > 0) {
c0109bc2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0109bc6:	7e 25                	jle    c0109bed <write+0x135>
			desc->pos += len;
c0109bc8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109bcb:	8b 40 10             	mov    0x10(%eax),%eax
c0109bce:	89 c2                	mov    %eax,%edx
c0109bd0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109bd3:	01 d0                	add    %edx,%eax
c0109bd5:	89 c2                	mov    %eax,%edx
c0109bd7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109bda:	89 50 10             	mov    %edx,0x10(%eax)
		return;
	}

	if(desc->flags & O_WRONLY ||
	   desc->flags & O_RDWR)
	{
c0109bdd:	eb 0e                	jmp    c0109bed <write+0x135>
		(*cpu)->eax = ret;
		if(ret > 0) {
			desc->pos += len;
		}
	} else {
		(*cpu)->eax = -3;
c0109bdf:	8b 45 08             	mov    0x8(%ebp),%eax
c0109be2:	8b 00                	mov    (%eax),%eax
c0109be4:	c7 40 28 fd ff ff ff 	movl   $0xfffffffd,0x28(%eax)
c0109beb:	eb 01                	jmp    c0109bee <write+0x136>
		return;
	}

	if(desc->flags & O_WRONLY ||
	   desc->flags & O_RDWR)
	{
c0109bed:	90                   	nop
			desc->pos += len;
		}
	} else {
		(*cpu)->eax = -3;
	}
}
c0109bee:	c9                   	leave  
c0109bef:	c3                   	ret    

c0109bf0 <strnlen>:
 * @param string pointer
 * @param size_t maxlen
 * @return string lengh<= maxlen
 */
size_t strnlen(const char *s, size_t maxlen)
{
c0109bf0:	55                   	push   %ebp
c0109bf1:	89 e5                	mov    %esp,%ebp
c0109bf3:	83 ec 10             	sub    $0x10,%esp
	const char *str = s;
c0109bf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0109bf9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while (*str && maxlen) {
c0109bfc:	eb 08                	jmp    c0109c06 <strnlen+0x16>
		++str;
c0109bfe:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		maxlen--;
c0109c02:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
 * @return string lengh<= maxlen
 */
size_t strnlen(const char *s, size_t maxlen)
{
	const char *str = s;
	while (*str && maxlen) {
c0109c06:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109c09:	0f b6 00             	movzbl (%eax),%eax
c0109c0c:	84 c0                	test   %al,%al
c0109c0e:	74 06                	je     c0109c16 <strnlen+0x26>
c0109c10:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0109c14:	75 e8                	jne    c0109bfe <strnlen+0xe>
		++str;
		maxlen--;
	}

	return str - s;
c0109c16:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109c19:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c1c:	89 d1                	mov    %edx,%ecx
c0109c1e:	29 c1                	sub    %eax,%ecx
c0109c20:	89 c8                	mov    %ecx,%eax
}
c0109c22:	c9                   	leave  
c0109c23:	c3                   	ret    

c0109c24 <strlen>:
 * get string lengh
 * @param string pointer
 * @return string lengh
 */
size_t strlen(const char *string)
{
c0109c24:	55                   	push   %ebp
c0109c25:	89 e5                	mov    %esp,%ebp
c0109c27:	83 ec 10             	sub    $0x10,%esp
	size_t i = 0;
c0109c2a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (string[i]) {
c0109c31:	eb 04                	jmp    c0109c37 <strlen+0x13>
		i++;
c0109c33:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 * @return string lengh
 */
size_t strlen(const char *string)
{
	size_t i = 0;
	while (string[i]) {
c0109c37:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109c3a:	8b 55 08             	mov    0x8(%ebp),%edx
c0109c3d:	01 d0                	add    %edx,%eax
c0109c3f:	0f b6 00             	movzbl (%eax),%eax
c0109c42:	84 c0                	test   %al,%al
c0109c44:	75 ed                	jne    c0109c33 <strlen+0xf>
		i++;
	}

	return i;
c0109c46:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0109c49:	c9                   	leave  
c0109c4a:	c3                   	ret    

c0109c4b <strcpy>:
 * @param destination pointer
 * @param source string
 * @return destination string pointer
 */
char *strcpy(char *dest, const char *src)
{
c0109c4b:	55                   	push   %ebp
c0109c4c:	89 e5                	mov    %esp,%ebp
c0109c4e:	83 ec 10             	sub    $0x10,%esp
	uint32_t i = 0;
c0109c51:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (src[i]) {
c0109c58:	eb 19                	jmp    c0109c73 <strcpy+0x28>
		dest[i] = src[i];
c0109c5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109c5d:	8b 55 08             	mov    0x8(%ebp),%edx
c0109c60:	01 c2                	add    %eax,%edx
c0109c62:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109c65:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0109c68:	01 c8                	add    %ecx,%eax
c0109c6a:	0f b6 00             	movzbl (%eax),%eax
c0109c6d:	88 02                	mov    %al,(%edx)
		i++;
c0109c6f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 * @return destination string pointer
 */
char *strcpy(char *dest, const char *src)
{
	uint32_t i = 0;
	while (src[i]) {
c0109c73:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109c76:	8b 55 0c             	mov    0xc(%ebp),%edx
c0109c79:	01 d0                	add    %edx,%eax
c0109c7b:	0f b6 00             	movzbl (%eax),%eax
c0109c7e:	84 c0                	test   %al,%al
c0109c80:	75 d8                	jne    c0109c5a <strcpy+0xf>
		dest[i] = src[i];
		i++;
	}
	dest[i] = src[i];
c0109c82:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109c85:	8b 55 08             	mov    0x8(%ebp),%edx
c0109c88:	01 c2                	add    %eax,%edx
c0109c8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109c8d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0109c90:	01 c8                	add    %ecx,%eax
c0109c92:	0f b6 00             	movzbl (%eax),%eax
c0109c95:	88 02                	mov    %al,(%edx)
	return dest;
c0109c97:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0109c9a:	c9                   	leave  
c0109c9b:	c3                   	ret    

c0109c9c <strncpy>:
 * @param source string
 * @param maximal number of chars
 * @return destination string
 */
char *strncpy(char *dest, const char *src,size_t n)
{
c0109c9c:	55                   	push   %ebp
c0109c9d:	89 e5                	mov    %esp,%ebp
c0109c9f:	83 ec 10             	sub    $0x10,%esp
	uint32_t i;
	bool eos = false;
c0109ca2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i = 0; i < n; i++) {
c0109ca9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0109cb0:	eb 42                	jmp    c0109cf4 <strncpy+0x58>
		if (eos == false) {
c0109cb2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0109cb6:	75 2d                	jne    c0109ce5 <strncpy+0x49>
			if (src[i] == 0) {
c0109cb8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109cbb:	8b 55 0c             	mov    0xc(%ebp),%edx
c0109cbe:	01 d0                	add    %edx,%eax
c0109cc0:	0f b6 00             	movzbl (%eax),%eax
c0109cc3:	84 c0                	test   %al,%al
c0109cc5:	75 07                	jne    c0109cce <strncpy+0x32>
				eos = true;
c0109cc7:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
			}
			dest[i] = src[i];
c0109cce:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109cd1:	8b 55 08             	mov    0x8(%ebp),%edx
c0109cd4:	01 c2                	add    %eax,%edx
c0109cd6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109cd9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0109cdc:	01 c8                	add    %ecx,%eax
c0109cde:	0f b6 00             	movzbl (%eax),%eax
c0109ce1:	88 02                	mov    %al,(%edx)
c0109ce3:	eb 0b                	jmp    c0109cf0 <strncpy+0x54>
		} else {
			dest[i] = 0;
c0109ce5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109ce8:	8b 55 08             	mov    0x8(%ebp),%edx
c0109ceb:	01 d0                	add    %edx,%eax
c0109ced:	c6 00 00             	movb   $0x0,(%eax)
 */
char *strncpy(char *dest, const char *src,size_t n)
{
	uint32_t i;
	bool eos = false;
	for (i = 0; i < n; i++) {
c0109cf0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0109cf4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109cf7:	3b 45 10             	cmp    0x10(%ebp),%eax
c0109cfa:	72 b6                	jb     c0109cb2 <strncpy+0x16>
			dest[i] = src[i];
		} else {
			dest[i] = 0;
		}
	}
	return dest;
c0109cfc:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0109cff:	c9                   	leave  
c0109d00:	c3                   	ret    

c0109d01 <strcat>:
 * @param destination string
 * @param source string
 * @return destination string
 */
char *strcat(char *dest, const char *src)
{
c0109d01:	55                   	push   %ebp
c0109d02:	89 e5                	mov    %esp,%ebp
c0109d04:	83 ec 18             	sub    $0x18,%esp
	size_t n = strlen(dest);
c0109d07:	8b 45 08             	mov    0x8(%ebp),%eax
c0109d0a:	89 04 24             	mov    %eax,(%esp)
c0109d0d:	e8 12 ff ff ff       	call   c0109c24 <strlen>
c0109d12:	89 45 fc             	mov    %eax,-0x4(%ebp)
	strcpy((char*)(dest+n),src);
c0109d15:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109d18:	8b 55 08             	mov    0x8(%ebp),%edx
c0109d1b:	01 c2                	add    %eax,%edx
c0109d1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109d20:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109d24:	89 14 24             	mov    %edx,(%esp)
c0109d27:	e8 1f ff ff ff       	call   c0109c4b <strcpy>
	return dest;
c0109d2c:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0109d2f:	c9                   	leave  
c0109d30:	c3                   	ret    

c0109d31 <strncat>:
 * @param source string
 * @param maximal number of chars
 * @return destination string
 */
char *strncat(char *dest, const char *src, size_t n)
{
c0109d31:	55                   	push   %ebp
c0109d32:	89 e5                	mov    %esp,%ebp
c0109d34:	83 ec 1c             	sub    $0x1c,%esp
	size_t i = strlen(dest);
c0109d37:	8b 45 08             	mov    0x8(%ebp),%eax
c0109d3a:	89 04 24             	mov    %eax,(%esp)
c0109d3d:	e8 e2 fe ff ff       	call   c0109c24 <strlen>
c0109d42:	89 45 fc             	mov    %eax,-0x4(%ebp)
	strncpy((char*)(dest+i),src,n);
c0109d45:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109d48:	8b 55 08             	mov    0x8(%ebp),%edx
c0109d4b:	01 c2                	add    %eax,%edx
c0109d4d:	8b 45 10             	mov    0x10(%ebp),%eax
c0109d50:	89 44 24 08          	mov    %eax,0x8(%esp)
c0109d54:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109d57:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109d5b:	89 14 24             	mov    %edx,(%esp)
c0109d5e:	e8 39 ff ff ff       	call   c0109c9c <strncpy>
	return dest;
c0109d63:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0109d66:	c9                   	leave  
c0109d67:	c3                   	ret    

c0109d68 <strcmp>:
 * @return 0=strings are similar;
 * @return 1=the value of the first different char of string0 is bigger
 * @return -1=the value of the first different char of string1 is bigger
 */
int strcmp(const char *str1, const char *str2)
{
c0109d68:	55                   	push   %ebp
c0109d69:	89 e5                	mov    %esp,%ebp
c0109d6b:	83 ec 10             	sub    $0x10,%esp
	int i = 0;
c0109d6e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while(str1[i] != '\0' && str2[i] != '\0') {
c0109d75:	eb 25                	jmp    c0109d9c <strcmp+0x34>
		if(str1[i] != str2[i]){
c0109d77:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109d7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0109d7d:	01 d0                	add    %edx,%eax
c0109d7f:	0f b6 10             	movzbl (%eax),%edx
c0109d82:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0109d85:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109d88:	01 c8                	add    %ecx,%eax
c0109d8a:	0f b6 00             	movzbl (%eax),%eax
c0109d8d:	38 c2                	cmp    %al,%dl
c0109d8f:	74 07                	je     c0109d98 <strcmp+0x30>
			return 0;
c0109d91:	b8 00 00 00 00       	mov    $0x0,%eax
c0109d96:	eb 6a                	jmp    c0109e02 <strcmp+0x9a>
			break;
		}
		i++;
c0109d98:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 * @return -1=the value of the first different char of string1 is bigger
 */
int strcmp(const char *str1, const char *str2)
{
	int i = 0;
	while(str1[i] != '\0' && str2[i] != '\0') {
c0109d9c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109d9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109da2:	01 d0                	add    %edx,%eax
c0109da4:	0f b6 00             	movzbl (%eax),%eax
c0109da7:	84 c0                	test   %al,%al
c0109da9:	74 0f                	je     c0109dba <strcmp+0x52>
c0109dab:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109dae:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109db1:	01 d0                	add    %edx,%eax
c0109db3:	0f b6 00             	movzbl (%eax),%eax
c0109db6:	84 c0                	test   %al,%al
c0109db8:	75 bd                	jne    c0109d77 <strcmp+0xf>
			return 0;
			break;
		}
		i++;
	}
	if( (str1[i] == '\0' && str2[i] != '\0') || (str1[i] != '\0' && str2[i] == '\0') )
c0109dba:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109dbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0109dc0:	01 d0                	add    %edx,%eax
c0109dc2:	0f b6 00             	movzbl (%eax),%eax
c0109dc5:	84 c0                	test   %al,%al
c0109dc7:	75 0f                	jne    c0109dd8 <strcmp+0x70>
c0109dc9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109dcf:	01 d0                	add    %edx,%eax
c0109dd1:	0f b6 00             	movzbl (%eax),%eax
c0109dd4:	84 c0                	test   %al,%al
c0109dd6:	75 1e                	jne    c0109df6 <strcmp+0x8e>
c0109dd8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109ddb:	8b 45 08             	mov    0x8(%ebp),%eax
c0109dde:	01 d0                	add    %edx,%eax
c0109de0:	0f b6 00             	movzbl (%eax),%eax
c0109de3:	84 c0                	test   %al,%al
c0109de5:	74 16                	je     c0109dfd <strcmp+0x95>
c0109de7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109dea:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109ded:	01 d0                	add    %edx,%eax
c0109def:	0f b6 00             	movzbl (%eax),%eax
c0109df2:	84 c0                	test   %al,%al
c0109df4:	75 07                	jne    c0109dfd <strcmp+0x95>
		return 0;
c0109df6:	b8 00 00 00 00       	mov    $0x0,%eax
c0109dfb:	eb 05                	jmp    c0109e02 <strcmp+0x9a>
	else
		return 1;
c0109dfd:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0109e02:	c9                   	leave  
c0109e03:	c3                   	ret    

c0109e04 <strncmp>:
 * @return 0=strings are similar;
 * @return 1=the value of the first different char of string0 is bigger
 * @return -1=the value of the first different char of string1 is bigger
 */
int strncmp(const char *st0, const char *st1, size_t n)
{
c0109e04:	55                   	push   %ebp
c0109e05:	89 e5                	mov    %esp,%ebp
c0109e07:	83 ec 10             	sub    $0x10,%esp
	uint32_t i;
	int ret = 0;
c0109e0a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	for (i = 0; st0[i] == st1[i] && st0[i] != 0 && i < n; i++);
c0109e11:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0109e18:	eb 04                	jmp    c0109e1e <strncmp+0x1a>
c0109e1a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0109e1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109e21:	8b 55 08             	mov    0x8(%ebp),%edx
c0109e24:	01 d0                	add    %edx,%eax
c0109e26:	0f b6 10             	movzbl (%eax),%edx
c0109e29:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109e2c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0109e2f:	01 c8                	add    %ecx,%eax
c0109e31:	0f b6 00             	movzbl (%eax),%eax
c0109e34:	38 c2                	cmp    %al,%dl
c0109e36:	75 17                	jne    c0109e4f <strncmp+0x4b>
c0109e38:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109e3b:	8b 55 08             	mov    0x8(%ebp),%edx
c0109e3e:	01 d0                	add    %edx,%eax
c0109e40:	0f b6 00             	movzbl (%eax),%eax
c0109e43:	84 c0                	test   %al,%al
c0109e45:	74 08                	je     c0109e4f <strncmp+0x4b>
c0109e47:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109e4a:	3b 45 10             	cmp    0x10(%ebp),%eax
c0109e4d:	72 cb                	jb     c0109e1a <strncmp+0x16>
	ret = st0[i] - st1[i];
c0109e4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109e52:	8b 55 08             	mov    0x8(%ebp),%edx
c0109e55:	01 d0                	add    %edx,%eax
c0109e57:	0f b6 00             	movzbl (%eax),%eax
c0109e5a:	0f be d0             	movsbl %al,%edx
c0109e5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109e60:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0109e63:	01 c8                	add    %ecx,%eax
c0109e65:	0f b6 00             	movzbl (%eax),%eax
c0109e68:	0f be c0             	movsbl %al,%eax
c0109e6b:	89 d1                	mov    %edx,%ecx
c0109e6d:	29 c1                	sub    %eax,%ecx
c0109e6f:	89 c8                	mov    %ecx,%eax
c0109e71:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (ret < 0) {
c0109e74:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0109e78:	79 09                	jns    c0109e83 <strncmp+0x7f>
	    ret =- 1;
c0109e7a:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
c0109e81:	eb 0d                	jmp    c0109e90 <strncmp+0x8c>
	}
	else if (ret > 0) {
c0109e83:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0109e87:	7e 07                	jle    c0109e90 <strncmp+0x8c>
	    ret = 1;
c0109e89:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
	}
	return ret;
c0109e90:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0109e93:	c9                   	leave  
c0109e94:	c3                   	ret    

c0109e95 <strchr>:
 * @param searched character
 * @return pointer to the first similar char
 * @return 0=no char in str is similar to c
 */
char *strchr(const char *str, int c)
{
c0109e95:	55                   	push   %ebp
c0109e96:	89 e5                	mov    %esp,%ebp
c0109e98:	83 ec 10             	sub    $0x10,%esp
	int i = 0;
c0109e9b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (str[i] != (char)c && str[i] != 0)
c0109ea2:	eb 04                	jmp    c0109ea8 <strchr+0x13>
	{
	    i++;
c0109ea4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 * @return 0=no char in str is similar to c
 */
char *strchr(const char *str, int c)
{
	int i = 0;
	while (str[i] != (char)c && str[i] != 0)
c0109ea8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109eab:	8b 45 08             	mov    0x8(%ebp),%eax
c0109eae:	01 d0                	add    %edx,%eax
c0109eb0:	0f b6 10             	movzbl (%eax),%edx
c0109eb3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109eb6:	38 c2                	cmp    %al,%dl
c0109eb8:	74 0f                	je     c0109ec9 <strchr+0x34>
c0109eba:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109ebd:	8b 45 08             	mov    0x8(%ebp),%eax
c0109ec0:	01 d0                	add    %edx,%eax
c0109ec2:	0f b6 00             	movzbl (%eax),%eax
c0109ec5:	84 c0                	test   %al,%al
c0109ec7:	75 db                	jne    c0109ea4 <strchr+0xf>
	{
	    i++;
	}
	if (str[i]) {
c0109ec9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109ecc:	8b 45 08             	mov    0x8(%ebp),%eax
c0109ecf:	01 d0                	add    %edx,%eax
c0109ed1:	0f b6 00             	movzbl (%eax),%eax
c0109ed4:	84 c0                	test   %al,%al
c0109ed6:	74 0a                	je     c0109ee2 <strchr+0x4d>
	    return (char*)(str+i);
c0109ed8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109edb:	8b 45 08             	mov    0x8(%ebp),%eax
c0109ede:	01 d0                	add    %edx,%eax
c0109ee0:	eb 05                	jmp    c0109ee7 <strchr+0x52>
	}
	return NULL;
c0109ee2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0109ee7:	c9                   	leave  
c0109ee8:	c3                   	ret    

c0109ee9 <strrchr>:
 * @param searched character
 * @return pointer to the last similar char
 * @return 0=no char in str is similar to c
 */
char *strrchr(const char *str, int c)
{
c0109ee9:	55                   	push   %ebp
c0109eea:	89 e5                	mov    %esp,%ebp
c0109eec:	83 ec 10             	sub    $0x10,%esp
	int i = 0;
c0109eef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	char* ret = NULL;
c0109ef6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	while ( str[i] != 0) {
c0109efd:	eb 21                	jmp    c0109f20 <strrchr+0x37>
		if (str[i] == (char)c) {
c0109eff:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109f02:	8b 45 08             	mov    0x8(%ebp),%eax
c0109f05:	01 d0                	add    %edx,%eax
c0109f07:	0f b6 10             	movzbl (%eax),%edx
c0109f0a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109f0d:	38 c2                	cmp    %al,%dl
c0109f0f:	75 0b                	jne    c0109f1c <strrchr+0x33>
		    ret = (char*)(str+i);
c0109f11:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109f14:	8b 45 08             	mov    0x8(%ebp),%eax
c0109f17:	01 d0                	add    %edx,%eax
c0109f19:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
		i++;
c0109f1c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 */
char *strrchr(const char *str, int c)
{
	int i = 0;
	char* ret = NULL;
	while ( str[i] != 0) {
c0109f20:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109f23:	8b 45 08             	mov    0x8(%ebp),%eax
c0109f26:	01 d0                	add    %edx,%eax
c0109f28:	0f b6 00             	movzbl (%eax),%eax
c0109f2b:	84 c0                	test   %al,%al
c0109f2d:	75 d0                	jne    c0109eff <strrchr+0x16>
		if (str[i] == (char)c) {
		    ret = (char*)(str+i);
		}
		i++;
	}
	return ret;
c0109f2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0109f32:	c9                   	leave  
c0109f33:	c3                   	ret    

c0109f34 <strtok>:
char* strpbrk(const char* st0, const char* st1) {}
char* strstr(const char* st0, const char* st1) {}
char* strerror(size_t n) {}
*/

char *strtok(char *string, const char *delimiters) {
c0109f34:	55                   	push   %ebp
c0109f35:	89 e5                	mov    %esp,%ebp
c0109f37:	83 ec 38             	sub    $0x38,%esp
	char *s = NULL;
c0109f3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int num_del = 0;
c0109f41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if(string != NULL) {
c0109f48:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0109f4c:	74 16                	je     c0109f64 <strtok+0x30>
		s = string;
c0109f4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109f51:	89 45 f4             	mov    %eax,-0xc(%ebp)
		num_del = strlen(delimiters);
c0109f54:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109f57:	89 04 24             	mov    %eax,(%esp)
c0109f5a:	e8 c5 fc ff ff       	call   c0109c24 <strlen>
c0109f5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0109f62:	eb 16                	jmp    c0109f7a <strtok+0x46>
	} else {
		if(s == NULL) {
c0109f64:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0109f68:	75 0a                	jne    c0109f74 <strtok+0x40>
      			return NULL;
c0109f6a:	b8 00 00 00 00       	mov    $0x0,%eax
c0109f6f:	e9 b6 00 00 00       	jmp    c010a02a <strtok+0xf6>
    		}
		string = s;
c0109f74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109f77:	89 45 08             	mov    %eax,0x8(%ebp)
	}
	int i, j = 0;
c0109f7a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	while(*s != '\0') {
c0109f81:	eb 70                	jmp    c0109ff3 <strtok+0xbf>
		for(i = 0; i < num_del; i++) {
c0109f83:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0109f8a:	eb 57                	jmp    c0109fe3 <strtok+0xaf>
			if(*s == delimiters[i]) {
c0109f8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109f8f:	0f b6 10             	movzbl (%eax),%edx
c0109f92:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0109f95:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109f98:	01 c8                	add    %ecx,%eax
c0109f9a:	0f b6 00             	movzbl (%eax),%eax
c0109f9d:	38 c2                	cmp    %al,%dl
c0109f9f:	75 3e                	jne    c0109fdf <strtok+0xab>
				s++;
c0109fa1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
				char *ret = (char*) malloc(j+1);
c0109fa5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109fa8:	83 c0 01             	add    $0x1,%eax
c0109fab:	89 04 24             	mov    %eax,(%esp)
c0109fae:	e8 11 e6 ff ff       	call   c01085c4 <malloc>
c0109fb3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				memcpy(ret, string, j);
c0109fb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109fb9:	89 44 24 08          	mov    %eax,0x8(%esp)
c0109fbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0109fc0:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109fc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109fc7:	89 04 24             	mov    %eax,(%esp)
c0109fca:	e8 5d 00 00 00       	call   c010a02c <memcpy>
				ret[j] = '\0';
c0109fcf:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0109fd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109fd5:	01 d0                	add    %edx,%eax
c0109fd7:	c6 00 00             	movb   $0x0,(%eax)
				return ret;
c0109fda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109fdd:	eb 4b                	jmp    c010a02a <strtok+0xf6>
    		}
		string = s;
	}
	int i, j = 0;
	while(*s != '\0') {
		for(i = 0; i < num_del; i++) {
c0109fdf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0109fe3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109fe6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0109fe9:	7c a1                	jl     c0109f8c <strtok+0x58>
				memcpy(ret, string, j);
				ret[j] = '\0';
				return ret;
			}
		}
		s++;
c0109feb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
		j++;
c0109fef:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
      			return NULL;
    		}
		string = s;
	}
	int i, j = 0;
	while(*s != '\0') {
c0109ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109ff6:	0f b6 00             	movzbl (%eax),%eax
c0109ff9:	84 c0                	test   %al,%al
c0109ffb:	75 86                	jne    c0109f83 <strtok+0x4f>
		}
		s++;
		j++;
	}

	char *ret = (char*) malloc(j+1);
c0109ffd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010a000:	83 c0 01             	add    $0x1,%eax
c010a003:	89 04 24             	mov    %eax,(%esp)
c010a006:	e8 b9 e5 ff ff       	call   c01085c4 <malloc>
c010a00b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	strcpy(ret, string);
c010a00e:	8b 45 08             	mov    0x8(%ebp),%eax
c010a011:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a015:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010a018:	89 04 24             	mov    %eax,(%esp)
c010a01b:	e8 2b fc ff ff       	call   c0109c4b <strcpy>

	s = NULL;
c010a020:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	return ret;
c010a027:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
c010a02a:	c9                   	leave  
c010a02b:	c3                   	ret    

c010a02c <memcpy>:
 * @param source
 * @param size of source area
 * @return pointer to destination area
 */
void *memcpy(void *destination, const void *source, size_t size)
{
c010a02c:	55                   	push   %ebp
c010a02d:	89 e5                	mov    %esp,%ebp
c010a02f:	83 ec 10             	sub    $0x10,%esp
	uint8_t *dest = destination;
c010a032:	8b 45 08             	mov    0x8(%ebp),%eax
c010a035:	89 45 f8             	mov    %eax,-0x8(%ebp)
	const uint8_t *sour = source;
c010a038:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a03b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t i = 0;
c010a03e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (i < size) {
c010a045:	eb 19                	jmp    c010a060 <memcpy+0x34>
		dest[i] = sour[i];
c010a047:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a04a:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010a04d:	01 c2                	add    %eax,%edx
c010a04f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a052:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010a055:	01 c8                	add    %ecx,%eax
c010a057:	0f b6 00             	movzbl (%eax),%eax
c010a05a:	88 02                	mov    %al,(%edx)
		i++;
c010a05c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
void *memcpy(void *destination, const void *source, size_t size)
{
	uint8_t *dest = destination;
	const uint8_t *sour = source;
	uint32_t i = 0;
	while (i < size) {
c010a060:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a063:	3b 45 10             	cmp    0x10(%ebp),%eax
c010a066:	72 df                	jb     c010a047 <memcpy+0x1b>
		dest[i] = sour[i];
		i++;
	}
	return destination;
c010a068:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010a06b:	c9                   	leave  
c010a06c:	c3                   	ret    

c010a06d <memmove>:
 * @param source
 * @param size of source area
 * @return pointer to destination area
 */
void *memmove(void *destination,const void *source, size_t n)
{
c010a06d:	55                   	push   %ebp
c010a06e:	89 e5                	mov    %esp,%ebp
c010a070:	83 ec 1c             	sub    $0x1c,%esp
	char *dest = (char *) destination;
c010a073:	8b 45 08             	mov    0x8(%ebp),%eax
c010a076:	89 45 f4             	mov    %eax,-0xc(%ebp)
	char *src = (char *) source;
c010a079:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a07c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	char *c, overlap = 0;
c010a07f:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
	for (c = src; c < src + n; c++) {
c010a083:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a086:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010a089:	eb 10                	jmp    c010a09b <memmove+0x2e>
		if (c == dest) {
c010a08b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a08e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010a091:	75 04                	jne    c010a097 <memmove+0x2a>
			overlap = 1;
c010a093:	c6 45 fb 01          	movb   $0x1,-0x5(%ebp)
void *memmove(void *destination,const void *source, size_t n)
{
	char *dest = (char *) destination;
	char *src = (char *) source;
	char *c, overlap = 0;
	for (c = src; c < src + n; c++) {
c010a097:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010a09b:	8b 45 10             	mov    0x10(%ebp),%eax
c010a09e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010a0a1:	01 d0                	add    %edx,%eax
c010a0a3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c010a0a6:	77 e3                	ja     c010a08b <memmove+0x1e>
		if (c == dest) {
			overlap = 1;
		}
	}
	if (overlap) {
c010a0a8:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c010a0ac:	74 39                	je     c010a0e7 <memmove+0x7a>
		for (c = src + n - 1; c >= src; c--) {
c010a0ae:	8b 45 10             	mov    0x10(%ebp),%eax
c010a0b1:	8d 50 ff             	lea    -0x1(%eax),%edx
c010a0b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a0b7:	01 d0                	add    %edx,%eax
c010a0b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010a0bc:	eb 1f                	jmp    c010a0dd <memmove+0x70>
			*(c + (dest - src)) = *c;
c010a0be:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a0c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a0c4:	89 d1                	mov    %edx,%ecx
c010a0c6:	29 c1                	sub    %eax,%ecx
c010a0c8:	89 c8                	mov    %ecx,%eax
c010a0ca:	89 c2                	mov    %eax,%edx
c010a0cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a0cf:	01 c2                	add    %eax,%edx
c010a0d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a0d4:	0f b6 00             	movzbl (%eax),%eax
c010a0d7:	88 02                	mov    %al,(%edx)
		if (c == dest) {
			overlap = 1;
		}
	}
	if (overlap) {
		for (c = src + n - 1; c >= src; c--) {
c010a0d9:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
c010a0dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a0e0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c010a0e3:	73 d9                	jae    c010a0be <memmove+0x51>
c010a0e5:	eb 19                	jmp    c010a100 <memmove+0x93>
			*(c + (dest - src)) = *c;
		}
	} else {
		memcpy(dest, src, n);
c010a0e7:	8b 45 10             	mov    0x10(%ebp),%eax
c010a0ea:	89 44 24 08          	mov    %eax,0x8(%esp)
c010a0ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a0f1:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a0f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a0f8:	89 04 24             	mov    %eax,(%esp)
c010a0fb:	e8 2c ff ff ff       	call   c010a02c <memcpy>
	}
	return destination;
c010a100:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010a103:	c9                   	leave  
c010a104:	c3                   	ret    

c010a105 <memcmp>:
 * @return 0=areas are similar
 * @return 1=the value of the first different byte of area0 is bigger
 * @return -1=the value of the first different byte of area1 is bigger
 */
int memcmp(const void *mem0, const void *mem1, size_t n)
{
c010a105:	55                   	push   %ebp
c010a106:	89 e5                	mov    %esp,%ebp
c010a108:	83 ec 10             	sub    $0x10,%esp
	const char *st0 = mem0;
c010a10b:	8b 45 08             	mov    0x8(%ebp),%eax
c010a10e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	const char *st1 = mem1;
c010a111:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a114:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t i;
	int ret = 0;
c010a117:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i = 0; st0[i] == st1[i] && st0[i] !=0 && i<n; i++);
c010a11e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010a125:	eb 04                	jmp    c010a12b <memcmp+0x26>
c010a127:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010a12b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a12e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a131:	01 d0                	add    %edx,%eax
c010a133:	0f b6 10             	movzbl (%eax),%edx
c010a136:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a139:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c010a13c:	01 c8                	add    %ecx,%eax
c010a13e:	0f b6 00             	movzbl (%eax),%eax
c010a141:	38 c2                	cmp    %al,%dl
c010a143:	75 17                	jne    c010a15c <memcmp+0x57>
c010a145:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a148:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a14b:	01 d0                	add    %edx,%eax
c010a14d:	0f b6 00             	movzbl (%eax),%eax
c010a150:	84 c0                	test   %al,%al
c010a152:	74 08                	je     c010a15c <memcmp+0x57>
c010a154:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a157:	3b 45 10             	cmp    0x10(%ebp),%eax
c010a15a:	72 cb                	jb     c010a127 <memcmp+0x22>
	ret = st0[i] - st1[i];
c010a15c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a15f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a162:	01 d0                	add    %edx,%eax
c010a164:	0f b6 00             	movzbl (%eax),%eax
c010a167:	0f be d0             	movsbl %al,%edx
c010a16a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a16d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c010a170:	01 c8                	add    %ecx,%eax
c010a172:	0f b6 00             	movzbl (%eax),%eax
c010a175:	0f be c0             	movsbl %al,%eax
c010a178:	89 d1                	mov    %edx,%ecx
c010a17a:	29 c1                	sub    %eax,%ecx
c010a17c:	89 c8                	mov    %ecx,%eax
c010a17e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (ret < 0) {
c010a181:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c010a185:	79 09                	jns    c010a190 <memcmp+0x8b>
	    ret =- 1;
c010a187:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
c010a18e:	eb 0d                	jmp    c010a19d <memcmp+0x98>
	}
	else if (ret > 0) {
c010a190:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c010a194:	7e 07                	jle    c010a19d <memcmp+0x98>
	    ret = 1;
c010a196:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
	}
	return ret;
c010a19d:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c010a1a0:	c9                   	leave  
c010a1a1:	c3                   	ret    

c010a1a2 <memchr>:
 * @param size of mem
 * @return pointer to the fist similar value
 * @return 0=no value in mem is similar to c
 */
void *memchr(const void *mem, int c, size_t n)
{
c010a1a2:	55                   	push   %ebp
c010a1a3:	89 e5                	mov    %esp,%ebp
c010a1a5:	83 ec 10             	sub    $0x10,%esp
	uint32_t i = 0;
c010a1a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	const unsigned char *str = mem;
c010a1af:	8b 45 08             	mov    0x8(%ebp),%eax
c010a1b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (str[i] != (unsigned char)c && i < n) {
c010a1b5:	eb 04                	jmp    c010a1bb <memchr+0x19>
	    i++;
c010a1b7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 */
void *memchr(const void *mem, int c, size_t n)
{
	uint32_t i = 0;
	const unsigned char *str = mem;
	while (str[i] != (unsigned char)c && i < n) {
c010a1bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a1be:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010a1c1:	01 d0                	add    %edx,%eax
c010a1c3:	0f b6 10             	movzbl (%eax),%edx
c010a1c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a1c9:	38 c2                	cmp    %al,%dl
c010a1cb:	74 08                	je     c010a1d5 <memchr+0x33>
c010a1cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a1d0:	3b 45 10             	cmp    0x10(%ebp),%eax
c010a1d3:	72 e2                	jb     c010a1b7 <memchr+0x15>
	    i++;
	}
	if (str[i]) {
c010a1d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a1d8:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010a1db:	01 d0                	add    %edx,%eax
c010a1dd:	0f b6 00             	movzbl (%eax),%eax
c010a1e0:	84 c0                	test   %al,%al
c010a1e2:	74 0a                	je     c010a1ee <memchr+0x4c>
	    return (void*)(str+i);
c010a1e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a1e7:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010a1ea:	01 d0                	add    %edx,%eax
c010a1ec:	eb 05                	jmp    c010a1f3 <memchr+0x51>
	}
	return NULL;
c010a1ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010a1f3:	c9                   	leave  
c010a1f4:	c3                   	ret    

c010a1f5 <memset>:
 * @param size of mem
 * @return pointer to the last similar value
 * @return 0=no value in mem is similar to c
 */
void *memset(void *mem, int c, size_t n)
{
c010a1f5:	55                   	push   %ebp
c010a1f6:	89 e5                	mov    %esp,%ebp
c010a1f8:	83 ec 10             	sub    $0x10,%esp
	unsigned char *str = mem;
c010a1fb:	8b 45 08             	mov    0x8(%ebp),%eax
c010a1fe:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32_t i;
	for (i = 0; i < n; i++) {
c010a201:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010a208:	eb 11                	jmp    c010a21b <memset+0x26>
	    str[i]=(unsigned char)c;
c010a20a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a20d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010a210:	01 c2                	add    %eax,%edx
c010a212:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a215:	88 02                	mov    %al,(%edx)
 */
void *memset(void *mem, int c, size_t n)
{
	unsigned char *str = mem;
	uint32_t i;
	for (i = 0; i < n; i++) {
c010a217:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010a21b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a21e:	3b 45 10             	cmp    0x10(%ebp),%eax
c010a221:	72 e7                	jb     c010a20a <memset+0x15>
	    str[i]=(unsigned char)c;
	}
	return mem;
c010a223:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010a226:	c9                   	leave  
c010a227:	c3                   	ret    

c010a228 <print>:
extern struct thread_state *current_thread;
extern struct process_state *kernel_state;


void print(struct cpu_state **cpu)
{
c010a228:	55                   	push   %ebp
c010a229:	89 e5                	mov    %esp,%ebp
c010a22b:	83 ec 18             	sub    $0x18,%esp
    printf("%s", (char *)(*cpu)->ebx);
c010a22e:	8b 45 08             	mov    0x8(%ebp),%eax
c010a231:	8b 00                	mov    (%eax),%eax
c010a233:	8b 40 1c             	mov    0x1c(%eax),%eax
c010a236:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a23a:	c7 04 24 3e c5 10 c0 	movl   $0xc010c53e,(%esp)
c010a241:	e8 36 b1 ff ff       	call   c010537c <printf>
    (*cpu)->eax = 0;
c010a246:	8b 45 08             	mov    0x8(%ebp),%eax
c010a249:	8b 00                	mov    (%eax),%eax
c010a24b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
}
c010a252:	c9                   	leave  
c010a253:	c3                   	ret    

c010a254 <identify_os>:

void identify_os(struct cpu_state **cpu)
{
c010a254:	55                   	push   %ebp
c010a255:	89 e5                	mov    %esp,%ebp
    (*cpu)->eax = 'u' | ('n' << 8) | ('i' << 16) | (OS_VERSION << 24);
c010a257:	8b 45 08             	mov    0x8(%ebp),%eax
c010a25a:	8b 00                	mov    (%eax),%eax
c010a25c:	c7 40 28 75 6e 69 01 	movl   $0x1696e75,0x28(%eax)
};
c010a263:	5d                   	pop    %ebp
c010a264:	c3                   	ret    

c010a265 <linux_syscall_handler>:
{
    NULL,sys_exit,sys_fork,read,write,open,close, /*FIXME: pipe kommt weiter hinten*/ pipe
};

void linux_syscall_handler(struct cpu_state **cpu)
{
c010a265:	55                   	push   %ebp
c010a266:	89 e5                	mov    %esp,%ebp
c010a268:	83 ec 18             	sub    $0x18,%esp
    if( (*cpu)->eax < DEFINED_LINUX_FUNCTIONS)
c010a26b:	8b 45 08             	mov    0x8(%ebp),%eax
c010a26e:	8b 00                	mov    (%eax),%eax
c010a270:	8b 40 28             	mov    0x28(%eax),%eax
c010a273:	83 f8 06             	cmp    $0x6,%eax
c010a276:	77 2a                	ja     c010a2a2 <linux_syscall_handler+0x3d>
    {
	if(linux_functions[(*cpu)->eax] != NULL)
c010a278:	8b 45 08             	mov    0x8(%ebp),%eax
c010a27b:	8b 00                	mov    (%eax),%eax
c010a27d:	8b 40 28             	mov    0x28(%eax),%eax
c010a280:	8b 04 85 c0 f4 10 c0 	mov    -0x3fef0b40(,%eax,4),%eax
c010a287:	85 c0                	test   %eax,%eax
c010a289:	74 17                	je     c010a2a2 <linux_syscall_handler+0x3d>
            linux_functions[(*cpu)->eax](cpu);
c010a28b:	8b 45 08             	mov    0x8(%ebp),%eax
c010a28e:	8b 00                	mov    (%eax),%eax
c010a290:	8b 40 28             	mov    0x28(%eax),%eax
c010a293:	8b 04 85 c0 f4 10 c0 	mov    -0x3fef0b40(,%eax,4),%eax
c010a29a:	8b 55 08             	mov    0x8(%ebp),%edx
c010a29d:	89 14 24             	mov    %edx,(%esp)
c010a2a0:	ff d0                	call   *%eax
    }
}
c010a2a2:	c9                   	leave  
c010a2a3:	c3                   	ret    

c010a2a4 <universe_syscall_handler>:
    print,thread_exit,launch_thread,identify_os
};


void universe_syscall_handler(struct cpu_state **cpu)
{
c010a2a4:	55                   	push   %ebp
c010a2a5:	89 e5                	mov    %esp,%ebp
c010a2a7:	83 ec 18             	sub    $0x18,%esp
    if( (*cpu)->eax < DEFINED_UNIVERSE_FUNCTIONS)
c010a2aa:	8b 45 08             	mov    0x8(%ebp),%eax
c010a2ad:	8b 00                	mov    (%eax),%eax
c010a2af:	8b 40 28             	mov    0x28(%eax),%eax
c010a2b2:	83 f8 03             	cmp    $0x3,%eax
c010a2b5:	77 2a                	ja     c010a2e1 <universe_syscall_handler+0x3d>
    {
        if(universe_functions[(*cpu)->eax] != NULL)
c010a2b7:	8b 45 08             	mov    0x8(%ebp),%eax
c010a2ba:	8b 00                	mov    (%eax),%eax
c010a2bc:	8b 40 28             	mov    0x28(%eax),%eax
c010a2bf:	8b 04 85 e0 f4 10 c0 	mov    -0x3fef0b20(,%eax,4),%eax
c010a2c6:	85 c0                	test   %eax,%eax
c010a2c8:	74 17                	je     c010a2e1 <universe_syscall_handler+0x3d>
            universe_functions[(*cpu)->eax](cpu);
c010a2ca:	8b 45 08             	mov    0x8(%ebp),%eax
c010a2cd:	8b 00                	mov    (%eax),%eax
c010a2cf:	8b 40 28             	mov    0x28(%eax),%eax
c010a2d2:	8b 04 85 e0 f4 10 c0 	mov    -0x3fef0b20(,%eax,4),%eax
c010a2d9:	8b 55 08             	mov    0x8(%ebp),%edx
c010a2dc:	89 14 24             	mov    %edx,(%esp)
c010a2df:	ff d0                	call   *%eax
    }
}
c010a2e1:	c9                   	leave  
c010a2e2:	c3                   	ret    
c010a2e3:	66 90                	xchg   %ax,%ax
c010a2e5:	66 90                	xchg   %ax,%ax
c010a2e7:	66 90                	xchg   %ax,%ax
c010a2e9:	66 90                	xchg   %ax,%ax
c010a2eb:	66 90                	xchg   %ax,%ax
c010a2ed:	66 90                	xchg   %ax,%ax
c010a2ef:	90                   	nop

c010a2f0 <isr_0>:
c010a2f0:	6a 00                	push   $0x0
c010a2f2:	6a 00                	push   $0x0
c010a2f4:	e9 81 01 00 00       	jmp    c010a47a <isr_save>

c010a2f9 <isr_1>:
c010a2f9:	6a 00                	push   $0x0
c010a2fb:	6a 01                	push   $0x1
c010a2fd:	e9 78 01 00 00       	jmp    c010a47a <isr_save>

c010a302 <isr_2>:
c010a302:	6a 00                	push   $0x0
c010a304:	6a 02                	push   $0x2
c010a306:	e9 6f 01 00 00       	jmp    c010a47a <isr_save>

c010a30b <isr_3>:
c010a30b:	6a 00                	push   $0x0
c010a30d:	6a 03                	push   $0x3
c010a30f:	e9 66 01 00 00       	jmp    c010a47a <isr_save>

c010a314 <isr_4>:
c010a314:	6a 00                	push   $0x0
c010a316:	6a 04                	push   $0x4
c010a318:	e9 5d 01 00 00       	jmp    c010a47a <isr_save>

c010a31d <isr_5>:
c010a31d:	6a 00                	push   $0x0
c010a31f:	6a 05                	push   $0x5
c010a321:	e9 54 01 00 00       	jmp    c010a47a <isr_save>

c010a326 <isr_6>:
c010a326:	6a 00                	push   $0x0
c010a328:	6a 06                	push   $0x6
c010a32a:	e9 4b 01 00 00       	jmp    c010a47a <isr_save>

c010a32f <isr_7>:
c010a32f:	6a 00                	push   $0x0
c010a331:	6a 07                	push   $0x7
c010a333:	e9 42 01 00 00       	jmp    c010a47a <isr_save>

c010a338 <isr_8>:
c010a338:	6a 08                	push   $0x8
c010a33a:	e9 3b 01 00 00       	jmp    c010a47a <isr_save>

c010a33f <isr_9>:
c010a33f:	6a 00                	push   $0x0
c010a341:	6a 09                	push   $0x9
c010a343:	e9 32 01 00 00       	jmp    c010a47a <isr_save>

c010a348 <isr_10>:
c010a348:	6a 0a                	push   $0xa
c010a34a:	e9 2b 01 00 00       	jmp    c010a47a <isr_save>

c010a34f <isr_11>:
c010a34f:	6a 0b                	push   $0xb
c010a351:	e9 24 01 00 00       	jmp    c010a47a <isr_save>

c010a356 <isr_12>:
c010a356:	6a 0c                	push   $0xc
c010a358:	e9 1d 01 00 00       	jmp    c010a47a <isr_save>

c010a35d <isr_13>:
c010a35d:	6a 0d                	push   $0xd
c010a35f:	e9 16 01 00 00       	jmp    c010a47a <isr_save>

c010a364 <isr_14>:
c010a364:	6a 0e                	push   $0xe
c010a366:	e9 0f 01 00 00       	jmp    c010a47a <isr_save>

c010a36b <isr_15>:
c010a36b:	6a 00                	push   $0x0
c010a36d:	6a 0f                	push   $0xf
c010a36f:	e9 06 01 00 00       	jmp    c010a47a <isr_save>

c010a374 <isr_16>:
c010a374:	6a 00                	push   $0x0
c010a376:	6a 10                	push   $0x10
c010a378:	e9 fd 00 00 00       	jmp    c010a47a <isr_save>

c010a37d <isr_17>:
c010a37d:	6a 11                	push   $0x11
c010a37f:	e9 f6 00 00 00       	jmp    c010a47a <isr_save>

c010a384 <isr_18>:
c010a384:	6a 00                	push   $0x0
c010a386:	6a 12                	push   $0x12
c010a388:	e9 ed 00 00 00       	jmp    c010a47a <isr_save>

c010a38d <isr_19>:
c010a38d:	6a 00                	push   $0x0
c010a38f:	6a 13                	push   $0x13
c010a391:	e9 e4 00 00 00       	jmp    c010a47a <isr_save>

c010a396 <isr_20>:
c010a396:	6a 00                	push   $0x0
c010a398:	6a 14                	push   $0x14
c010a39a:	e9 db 00 00 00       	jmp    c010a47a <isr_save>

c010a39f <isr_21>:
c010a39f:	6a 00                	push   $0x0
c010a3a1:	6a 15                	push   $0x15
c010a3a3:	e9 d2 00 00 00       	jmp    c010a47a <isr_save>

c010a3a8 <isr_22>:
c010a3a8:	6a 00                	push   $0x0
c010a3aa:	6a 16                	push   $0x16
c010a3ac:	e9 c9 00 00 00       	jmp    c010a47a <isr_save>

c010a3b1 <isr_23>:
c010a3b1:	6a 00                	push   $0x0
c010a3b3:	6a 17                	push   $0x17
c010a3b5:	e9 c0 00 00 00       	jmp    c010a47a <isr_save>

c010a3ba <isr_24>:
c010a3ba:	6a 00                	push   $0x0
c010a3bc:	6a 18                	push   $0x18
c010a3be:	e9 b7 00 00 00       	jmp    c010a47a <isr_save>

c010a3c3 <isr_25>:
c010a3c3:	6a 00                	push   $0x0
c010a3c5:	6a 19                	push   $0x19
c010a3c7:	e9 ae 00 00 00       	jmp    c010a47a <isr_save>

c010a3cc <isr_26>:
c010a3cc:	6a 00                	push   $0x0
c010a3ce:	6a 1a                	push   $0x1a
c010a3d0:	e9 a5 00 00 00       	jmp    c010a47a <isr_save>

c010a3d5 <isr_27>:
c010a3d5:	6a 00                	push   $0x0
c010a3d7:	6a 1b                	push   $0x1b
c010a3d9:	e9 9c 00 00 00       	jmp    c010a47a <isr_save>

c010a3de <isr_28>:
c010a3de:	6a 00                	push   $0x0
c010a3e0:	6a 1c                	push   $0x1c
c010a3e2:	e9 93 00 00 00       	jmp    c010a47a <isr_save>

c010a3e7 <isr_29>:
c010a3e7:	6a 00                	push   $0x0
c010a3e9:	6a 1d                	push   $0x1d
c010a3eb:	e9 8a 00 00 00       	jmp    c010a47a <isr_save>

c010a3f0 <isr_30>:
c010a3f0:	6a 00                	push   $0x0
c010a3f2:	6a 1e                	push   $0x1e
c010a3f4:	e9 81 00 00 00       	jmp    c010a47a <isr_save>

c010a3f9 <isr_31>:
c010a3f9:	6a 00                	push   $0x0
c010a3fb:	6a 1f                	push   $0x1f
c010a3fd:	eb 7b                	jmp    c010a47a <isr_save>

c010a3ff <isr_default>:
c010a3ff:	6a ff                	push   $0xffffffff
c010a401:	6a ff                	push   $0xffffffff
c010a403:	eb 75                	jmp    c010a47a <isr_save>

c010a405 <isr_32>:
c010a405:	6a 00                	push   $0x0
c010a407:	6a 20                	push   $0x20
c010a409:	eb 6f                	jmp    c010a47a <isr_save>

c010a40b <isr_33>:
c010a40b:	6a 00                	push   $0x0
c010a40d:	6a 21                	push   $0x21
c010a40f:	eb 69                	jmp    c010a47a <isr_save>

c010a411 <isr_34>:
c010a411:	6a 00                	push   $0x0
c010a413:	6a 22                	push   $0x22
c010a415:	eb 63                	jmp    c010a47a <isr_save>

c010a417 <isr_35>:
c010a417:	6a 00                	push   $0x0
c010a419:	6a 23                	push   $0x23
c010a41b:	eb 5d                	jmp    c010a47a <isr_save>

c010a41d <isr_36>:
c010a41d:	6a 00                	push   $0x0
c010a41f:	6a 24                	push   $0x24
c010a421:	eb 57                	jmp    c010a47a <isr_save>

c010a423 <isr_37>:
c010a423:	6a 00                	push   $0x0
c010a425:	6a 25                	push   $0x25
c010a427:	eb 51                	jmp    c010a47a <isr_save>

c010a429 <isr_38>:
c010a429:	6a 00                	push   $0x0
c010a42b:	6a 26                	push   $0x26
c010a42d:	eb 4b                	jmp    c010a47a <isr_save>

c010a42f <isr_39>:
c010a42f:	6a 00                	push   $0x0
c010a431:	6a 27                	push   $0x27
c010a433:	eb 45                	jmp    c010a47a <isr_save>

c010a435 <isr_40>:
c010a435:	6a 00                	push   $0x0
c010a437:	6a 28                	push   $0x28
c010a439:	eb 3f                	jmp    c010a47a <isr_save>

c010a43b <isr_41>:
c010a43b:	6a 00                	push   $0x0
c010a43d:	6a 29                	push   $0x29
c010a43f:	eb 39                	jmp    c010a47a <isr_save>

c010a441 <isr_42>:
c010a441:	6a 00                	push   $0x0
c010a443:	6a 2a                	push   $0x2a
c010a445:	eb 33                	jmp    c010a47a <isr_save>

c010a447 <isr_43>:
c010a447:	6a 00                	push   $0x0
c010a449:	6a 2b                	push   $0x2b
c010a44b:	eb 2d                	jmp    c010a47a <isr_save>

c010a44d <isr_44>:
c010a44d:	6a 00                	push   $0x0
c010a44f:	6a 2c                	push   $0x2c
c010a451:	eb 27                	jmp    c010a47a <isr_save>

c010a453 <isr_45>:
c010a453:	6a 00                	push   $0x0
c010a455:	6a 2d                	push   $0x2d
c010a457:	eb 21                	jmp    c010a47a <isr_save>

c010a459 <isr_46>:
c010a459:	6a 00                	push   $0x0
c010a45b:	6a 2e                	push   $0x2e
c010a45d:	eb 1b                	jmp    c010a47a <isr_save>

c010a45f <isr_47>:
c010a45f:	6a 00                	push   $0x0
c010a461:	6a 2f                	push   $0x2f
c010a463:	eb 15                	jmp    c010a47a <isr_save>

c010a465 <isr_112>:
c010a465:	6a 00                	push   $0x0
c010a467:	6a 70                	push   $0x70
c010a469:	eb 0f                	jmp    c010a47a <isr_save>

c010a46b <isr_128>:
c010a46b:	6a 00                	push   $0x0
c010a46d:	68 80 00 00 00       	push   $0x80
c010a472:	eb 06                	jmp    c010a47a <isr_save>

c010a474 <isr_pci>:
c010a474:	6a 00                	push   $0x0
c010a476:	6a 32                	push   $0x32
c010a478:	eb 00                	jmp    c010a47a <isr_save>

c010a47a <isr_save>:
c010a47a:	50                   	push   %eax
c010a47b:	51                   	push   %ecx
c010a47c:	52                   	push   %edx
c010a47d:	53                   	push   %ebx
c010a47e:	55                   	push   %ebp
c010a47f:	56                   	push   %esi
c010a480:	57                   	push   %edi
c010a481:	1e                   	push   %ds
c010a482:	06                   	push   %es
c010a483:	0f a0                	push   %fs
c010a485:	0f a8                	push   %gs
c010a487:	66 ba 10 00          	mov    $0x10,%dx
c010a48b:	8e da                	mov    %edx,%ds
c010a48d:	8e c2                	mov    %edx,%es
c010a48f:	8e e2                	mov    %edx,%fs
c010a491:	8e ea                	mov    %edx,%gs
c010a493:	54                   	push   %esp
c010a494:	e8 6b 9e ff ff       	call   c0104304 <irq_handler>
c010a499:	89 c4                	mov    %eax,%esp
c010a49b:	0f a9                	pop    %gs
c010a49d:	0f a1                	pop    %fs
c010a49f:	07                   	pop    %es
c010a4a0:	1f                   	pop    %ds
c010a4a1:	5f                   	pop    %edi
c010a4a2:	5e                   	pop    %esi
c010a4a3:	5d                   	pop    %ebp
c010a4a4:	5b                   	pop    %ebx
c010a4a5:	5a                   	pop    %edx
c010a4a6:	59                   	pop    %ecx
c010a4a7:	58                   	pop    %eax
c010a4a8:	83 c4 08             	add    $0x8,%esp
c010a4ab:	cf                   	iret   
c010a4ac:	66 90                	xchg   %ax,%ax
c010a4ae:	66 90                	xchg   %ax,%ax

c010a4b0 <start>:
c010a4b0:	b9 00 00 11 00       	mov    $0x110000,%ecx
c010a4b5:	0f 22 d9             	mov    %ecx,%cr3
c010a4b8:	0f 20 e1             	mov    %cr4,%ecx
c010a4bb:	83 c9 10             	or     $0x10,%ecx
c010a4be:	0f 22 e1             	mov    %ecx,%cr4
c010a4c1:	0f 20 c1             	mov    %cr0,%ecx
c010a4c4:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
c010a4ca:	0f 22 c1             	mov    %ecx,%cr0
c010a4cd:	8d 0d d5 a4 10 c0    	lea    0xc010a4d5,%ecx
c010a4d3:	ff e1                	jmp    *%ecx

c010a4d5 <higherhalf>:
c010a4d5:	bc 00 30 11 c0       	mov    $0xc0113000,%esp
c010a4da:	81 c3 00 00 00 c0    	add    $0xc0000000,%ebx
c010a4e0:	6a 00                	push   $0x0
c010a4e2:	6a 00                	push   $0x0
c010a4e4:	50                   	push   %eax
c010a4e5:	53                   	push   %ebx
c010a4e6:	e8 48 d8 ff ff       	call   c0107d33 <init>
c010a4eb:	eb fe                	jmp    c010a4eb <higherhalf+0x16>
