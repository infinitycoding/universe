
kernel32.elf:     file format elf32-i386


Disassembly of section .text:

c0102000 <powi>:




int powi(int base, int exponent)
{
c0102000:	55                   	push   %ebp
c0102001:	89 e5                	mov    %esp,%ebp
c0102003:	83 ec 10             	sub    $0x10,%esp
    int result = base;
c0102006:	8b 45 08             	mov    0x8(%ebp),%eax
c0102009:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int i;

    if (exponent == 0)
c010200c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0102010:	75 09                	jne    c010201b <powi+0x1b>
    {
        result = 1;
c0102012:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
c0102019:	eb 22                	jmp    c010203d <powi+0x3d>
    }
    else
    {
        for (i = 0; i < exponent - 1; ++i)
c010201b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0102022:	eb 0e                	jmp    c0102032 <powi+0x32>
        {
            result *= base;
c0102024:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102027:	0f af 45 08          	imul   0x8(%ebp),%eax
c010202b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    {
        result = 1;
    }
    else
    {
        for (i = 0; i < exponent - 1; ++i)
c010202e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0102032:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102035:	83 e8 01             	sub    $0x1,%eax
c0102038:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c010203b:	7f e7                	jg     c0102024 <powi+0x24>
        {
            result *= base;
        }
    }

    return result;
c010203d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0102040:	c9                   	leave  
c0102041:	c3                   	ret    

c0102042 <abs>:


int abs(int x)
{
c0102042:	55                   	push   %ebp
c0102043:	89 e5                	mov    %esp,%ebp
    if (x < 0)
c0102045:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0102049:	79 07                	jns    c0102052 <abs+0x10>
    {
        return -x;
c010204b:	8b 45 08             	mov    0x8(%ebp),%eax
c010204e:	f7 d8                	neg    %eax
c0102050:	eb 03                	jmp    c0102055 <abs+0x13>
    }
    else
    {
        return x;
c0102052:	8b 45 08             	mov    0x8(%ebp),%eax
    }
}
c0102055:	5d                   	pop    %ebp
c0102056:	c3                   	ret    

c0102057 <bit_scan_forward>:

unsigned int bit_scan_forward(unsigned int i)
{
c0102057:	55                   	push   %ebp
c0102058:	89 e5                	mov    %esp,%ebp
c010205a:	53                   	push   %ebx
c010205b:	83 ec 10             	sub    $0x10,%esp
    unsigned int j;

    for (j = 0; j < 32; j++)
c010205e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0102065:	eb 20                	jmp    c0102087 <bit_scan_forward+0x30>
    {
        if (i & (1 << j))
c0102067:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010206a:	ba 01 00 00 00       	mov    $0x1,%edx
c010206f:	89 d3                	mov    %edx,%ebx
c0102071:	89 c1                	mov    %eax,%ecx
c0102073:	d3 e3                	shl    %cl,%ebx
c0102075:	89 d8                	mov    %ebx,%eax
c0102077:	23 45 08             	and    0x8(%ebp),%eax
c010207a:	85 c0                	test   %eax,%eax
c010207c:	74 05                	je     c0102083 <bit_scan_forward+0x2c>
        {
            return j;
c010207e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0102081:	eb 0f                	jmp    c0102092 <bit_scan_forward+0x3b>

unsigned int bit_scan_forward(unsigned int i)
{
    unsigned int j;

    for (j = 0; j < 32; j++)
c0102083:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0102087:	83 7d f8 1f          	cmpl   $0x1f,-0x8(%ebp)
c010208b:	76 da                	jbe    c0102067 <bit_scan_forward+0x10>
        if (i & (1 << j))
        {
            return j;
        }
    }
    return -1;
c010208d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0102092:	83 c4 10             	add    $0x10,%esp
c0102095:	5b                   	pop    %ebx
c0102096:	5d                   	pop    %ebp
c0102097:	c3                   	ret    

c0102098 <bcd_decode>:
 * @brief Decodes two binary coded digits into one binary number.
 * @param digits the two BCD digits
 * @return the value of BCD coded value in binary
 */
uint8_t bcd_decode(uint8_t digits)
{
c0102098:	55                   	push   %ebp
c0102099:	89 e5                	mov    %esp,%ebp
c010209b:	83 ec 04             	sub    $0x4,%esp
c010209e:	8b 45 08             	mov    0x8(%ebp),%eax
c01020a1:	88 45 fc             	mov    %al,-0x4(%ebp)
    /* a BCD byte consists of two decimal digits with 4 bit lengh
       first erasing all bits above the first digit (0b1111&digits)
       then add the second digit times 10.
     */
    return (0b1111 & digits) + (10 * (digits >> 4));
c01020a4:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c01020a8:	89 c1                	mov    %eax,%ecx
c01020aa:	83 e1 0f             	and    $0xf,%ecx
c01020ad:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c01020b1:	89 c2                	mov    %eax,%edx
c01020b3:	c0 ea 04             	shr    $0x4,%dl
c01020b6:	89 d0                	mov    %edx,%eax
c01020b8:	c1 e0 02             	shl    $0x2,%eax
c01020bb:	01 d0                	add    %edx,%eax
c01020bd:	01 c0                	add    %eax,%eax
c01020bf:	01 c8                	add    %ecx,%eax
}
c01020c1:	c9                   	leave  
c01020c2:	c3                   	ret    

c01020c3 <bcd_encode>:
 * @breif Encodes the binary input value into BCD format 
 * @param value the value to be encoded
 * @return the BCD encoded value
 */
uint16_t bcd_encode(uint8_t value)
{
c01020c3:	55                   	push   %ebp
c01020c4:	89 e5                	mov    %esp,%ebp
c01020c6:	53                   	push   %ebx
c01020c7:	83 ec 14             	sub    $0x14,%esp
c01020ca:	8b 45 08             	mov    0x8(%ebp),%eax
c01020cd:	88 45 e8             	mov    %al,-0x18(%ebp)
    size_t i,b = 1;
c01020d0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    uint16_t digits = 0;
c01020d7:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
    for(i = 0; i < 3; i++)
c01020dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c01020e4:	eb 5a                	jmp    c0102140 <bcd_encode+0x7d>
    {
        uint8_t currentDigit = value%(b*10);
c01020e6:	0f b6 4d e8          	movzbl -0x18(%ebp),%ecx
c01020ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01020ed:	89 d0                	mov    %edx,%eax
c01020ef:	c1 e0 02             	shl    $0x2,%eax
c01020f2:	01 d0                	add    %edx,%eax
c01020f4:	01 c0                	add    %eax,%eax
c01020f6:	89 c3                	mov    %eax,%ebx
c01020f8:	89 c8                	mov    %ecx,%eax
c01020fa:	ba 00 00 00 00       	mov    $0x0,%edx
c01020ff:	f7 f3                	div    %ebx
c0102101:	89 d0                	mov    %edx,%eax
c0102103:	88 45 f1             	mov    %al,-0xf(%ebp)
        value   -= currentDigit;
c0102106:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
c010210a:	28 45 e8             	sub    %al,-0x18(%ebp)
        digits  |= (currentDigit/b)<<(i*4);
c010210d:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
c0102111:	ba 00 00 00 00       	mov    $0x0,%edx
c0102116:	f7 75 f4             	divl   -0xc(%ebp)
c0102119:	89 c2                	mov    %eax,%edx
c010211b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010211e:	c1 e0 02             	shl    $0x2,%eax
c0102121:	89 d3                	mov    %edx,%ebx
c0102123:	89 c1                	mov    %eax,%ecx
c0102125:	d3 e3                	shl    %cl,%ebx
c0102127:	89 d8                	mov    %ebx,%eax
c0102129:	66 09 45 f2          	or     %ax,-0xe(%ebp)
        b*= 10;
c010212d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102130:	89 d0                	mov    %edx,%eax
c0102132:	c1 e0 02             	shl    $0x2,%eax
c0102135:	01 d0                	add    %edx,%eax
c0102137:	01 c0                	add    %eax,%eax
c0102139:	89 45 f4             	mov    %eax,-0xc(%ebp)
 */
uint16_t bcd_encode(uint8_t value)
{
    size_t i,b = 1;
    uint16_t digits = 0;
    for(i = 0; i < 3; i++)
c010213c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0102140:	83 7d f8 02          	cmpl   $0x2,-0x8(%ebp)
c0102144:	76 a0                	jbe    c01020e6 <bcd_encode+0x23>
        uint8_t currentDigit = value%(b*10);
        value   -= currentDigit;
        digits  |= (currentDigit/b)<<(i*4);
        b*= 10;
    }
    return digits;
c0102146:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c010214a:	83 c4 14             	add    $0x14,%esp
c010214d:	5b                   	pop    %ebx
c010214e:	5d                   	pop    %ebp
c010214f:	c3                   	ret    

c0102150 <panic>:
/**
 *  @brief Shows an errorscreen  with a error message.
 *  @param message The errormessage to be printed.
 */
void panic(char *message)
{
c0102150:	55                   	push   %ebp
c0102151:	89 e5                	mov    %esp,%ebp
c0102153:	57                   	push   %edi
c0102154:	56                   	push   %esi
c0102155:	53                   	push   %ebx
c0102156:	81 ec 2c 04 00 00    	sub    $0x42c,%esp
    char buffer[1024];
    int lines = 8;
c010215c:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
    int len = 0;
c0102163:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    int i;
    len += sprintf(buffer + len, "      %c", 201);
c010216a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010216d:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c0102173:	01 d0                	add    %edx,%eax
c0102175:	c7 44 24 08 c9 00 00 	movl   $0xc9,0x8(%esp)
c010217c:	00 
c010217d:	c7 44 24 04 00 00 11 	movl   $0xc0110000,0x4(%esp)
c0102184:	c0 
c0102185:	89 04 24             	mov    %eax,(%esp)
c0102188:	e8 01 15 00 00       	call   c010368e <sprintf>
c010218d:	01 45 e0             	add    %eax,-0x20(%ebp)
    for(i=0; i<66; i++) len += sprintf(buffer + len, "%c", 205);
c0102190:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c0102197:	eb 2a                	jmp    c01021c3 <panic+0x73>
c0102199:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010219c:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01021a2:	01 d0                	add    %edx,%eax
c01021a4:	c7 44 24 08 cd 00 00 	movl   $0xcd,0x8(%esp)
c01021ab:	00 
c01021ac:	c7 44 24 04 09 00 11 	movl   $0xc0110009,0x4(%esp)
c01021b3:	c0 
c01021b4:	89 04 24             	mov    %eax,(%esp)
c01021b7:	e8 d2 14 00 00       	call   c010368e <sprintf>
c01021bc:	01 45 e0             	add    %eax,-0x20(%ebp)
c01021bf:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c01021c3:	83 7d dc 41          	cmpl   $0x41,-0x24(%ebp)
c01021c7:	7e d0                	jle    c0102199 <panic+0x49>
    len += sprintf(buffer + len, "%c      \n", 187);
c01021c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01021cc:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01021d2:	01 d0                	add    %edx,%eax
c01021d4:	c7 44 24 08 bb 00 00 	movl   $0xbb,0x8(%esp)
c01021db:	00 
c01021dc:	c7 44 24 04 0c 00 11 	movl   $0xc011000c,0x4(%esp)
c01021e3:	c0 
c01021e4:	89 04 24             	mov    %eax,(%esp)
c01021e7:	e8 a2 14 00 00       	call   c010368e <sprintf>
c01021ec:	01 45 e0             	add    %eax,-0x20(%ebp)

    len += sprintf(buffer + len,
c01021ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01021f2:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01021f8:	01 d0                	add    %edx,%eax
c01021fa:	c7 44 24 0c ba 00 00 	movl   $0xba,0xc(%esp)
c0102201:	00 
c0102202:	c7 44 24 08 ba 00 00 	movl   $0xba,0x8(%esp)
c0102209:	00 
c010220a:	c7 44 24 04 18 00 11 	movl   $0xc0110018,0x4(%esp)
c0102211:	c0 
c0102212:	89 04 24             	mov    %eax,(%esp)
c0102215:	e8 74 14 00 00       	call   c010368e <sprintf>
c010221a:	01 45 e0             	add    %eax,-0x20(%ebp)
                   "      %c                             Universe                             %c      \n",
                   186, 186);

    len += sprintf(buffer + len, "      %c", 200);
c010221d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0102220:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c0102226:	01 d0                	add    %edx,%eax
c0102228:	c7 44 24 08 c8 00 00 	movl   $0xc8,0x8(%esp)
c010222f:	00 
c0102230:	c7 44 24 04 00 00 11 	movl   $0xc0110000,0x4(%esp)
c0102237:	c0 
c0102238:	89 04 24             	mov    %eax,(%esp)
c010223b:	e8 4e 14 00 00       	call   c010368e <sprintf>
c0102240:	01 45 e0             	add    %eax,-0x20(%ebp)
    for(i=0; i<66; i++) len += sprintf(buffer + len, "%c", 205);
c0102243:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c010224a:	eb 2a                	jmp    c0102276 <panic+0x126>
c010224c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010224f:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c0102255:	01 d0                	add    %edx,%eax
c0102257:	c7 44 24 08 cd 00 00 	movl   $0xcd,0x8(%esp)
c010225e:	00 
c010225f:	c7 44 24 04 09 00 11 	movl   $0xc0110009,0x4(%esp)
c0102266:	c0 
c0102267:	89 04 24             	mov    %eax,(%esp)
c010226a:	e8 1f 14 00 00       	call   c010368e <sprintf>
c010226f:	01 45 e0             	add    %eax,-0x20(%ebp)
c0102272:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c0102276:	83 7d dc 41          	cmpl   $0x41,-0x24(%ebp)
c010227a:	7e d0                	jle    c010224c <panic+0xfc>
    len += sprintf(buffer + len, "%c      \n", 188);
c010227c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010227f:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c0102285:	01 d0                	add    %edx,%eax
c0102287:	c7 44 24 08 bc 00 00 	movl   $0xbc,0x8(%esp)
c010228e:	00 
c010228f:	c7 44 24 04 0c 00 11 	movl   $0xc011000c,0x4(%esp)
c0102296:	c0 
c0102297:	89 04 24             	mov    %eax,(%esp)
c010229a:	e8 ef 13 00 00       	call   c010368e <sprintf>
c010229f:	01 45 e0             	add    %eax,-0x20(%ebp)

    len += sprintf(buffer + len,
c01022a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01022a5:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c01022ab:	01 d0                	add    %edx,%eax
c01022ad:	ba 6c 00 11 c0       	mov    $0xc011006c,%edx
c01022b2:	bb f4 00 00 00       	mov    $0xf4,%ebx
c01022b7:	89 c1                	mov    %eax,%ecx
c01022b9:	83 e1 01             	and    $0x1,%ecx
c01022bc:	85 c9                	test   %ecx,%ecx
c01022be:	74 0e                	je     c01022ce <panic+0x17e>
c01022c0:	0f b6 0a             	movzbl (%edx),%ecx
c01022c3:	88 08                	mov    %cl,(%eax)
c01022c5:	83 c0 01             	add    $0x1,%eax
c01022c8:	83 c2 01             	add    $0x1,%edx
c01022cb:	83 eb 01             	sub    $0x1,%ebx
c01022ce:	89 c1                	mov    %eax,%ecx
c01022d0:	83 e1 02             	and    $0x2,%ecx
c01022d3:	85 c9                	test   %ecx,%ecx
c01022d5:	74 0f                	je     c01022e6 <panic+0x196>
c01022d7:	0f b7 0a             	movzwl (%edx),%ecx
c01022da:	66 89 08             	mov    %cx,(%eax)
c01022dd:	83 c0 02             	add    $0x2,%eax
c01022e0:	83 c2 02             	add    $0x2,%edx
c01022e3:	83 eb 02             	sub    $0x2,%ebx
c01022e6:	89 d9                	mov    %ebx,%ecx
c01022e8:	c1 e9 02             	shr    $0x2,%ecx
c01022eb:	89 c7                	mov    %eax,%edi
c01022ed:	89 d6                	mov    %edx,%esi
c01022ef:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c01022f1:	89 f2                	mov    %esi,%edx
c01022f3:	89 f8                	mov    %edi,%eax
c01022f5:	b9 00 00 00 00       	mov    $0x0,%ecx
c01022fa:	89 de                	mov    %ebx,%esi
c01022fc:	83 e6 02             	and    $0x2,%esi
c01022ff:	85 f6                	test   %esi,%esi
c0102301:	74 0b                	je     c010230e <panic+0x1be>
c0102303:	0f b7 34 0a          	movzwl (%edx,%ecx,1),%esi
c0102307:	66 89 34 08          	mov    %si,(%eax,%ecx,1)
c010230b:	83 c1 02             	add    $0x2,%ecx
c010230e:	83 e3 01             	and    $0x1,%ebx
c0102311:	85 db                	test   %ebx,%ebx
c0102313:	74 07                	je     c010231c <panic+0x1cc>
c0102315:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
c0102319:	88 14 08             	mov    %dl,(%eax,%ecx,1)
c010231c:	81 45 e0 f3 00 00 00 	addl   $0xf3,-0x20(%ebp)
                   "                                                                                \n"
                   "      Universe has been crashed. You have to restart your computer.             \n"
                   "                                                                                \n"
                  );

    while (*message != '\0')
c0102323:	eb 48                	jmp    c010236d <panic+0x21d>
    {
        buffer[len++] = *message;
c0102325:	8b 45 08             	mov    0x8(%ebp),%eax
c0102328:	0f b6 00             	movzbl (%eax),%eax
c010232b:	8d 8d dc fb ff ff    	lea    -0x424(%ebp),%ecx
c0102331:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0102334:	01 ca                	add    %ecx,%edx
c0102336:	88 02                	mov    %al,(%edx)
c0102338:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)

        if (*message == '\n')
c010233c:	8b 45 08             	mov    0x8(%ebp),%eax
c010233f:	0f b6 00             	movzbl (%eax),%eax
c0102342:	3c 0a                	cmp    $0xa,%al
c0102344:	75 23                	jne    c0102369 <panic+0x219>
        {
            len += sprintf(buffer + len, "      ");
c0102346:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0102349:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c010234f:	01 d0                	add    %edx,%eax
c0102351:	c7 00 20 20 20 20    	movl   $0x20202020,(%eax)
c0102357:	66 c7 40 04 20 20    	movw   $0x2020,0x4(%eax)
c010235d:	c6 40 06 00          	movb   $0x0,0x6(%eax)
c0102361:	83 45 e0 06          	addl   $0x6,-0x20(%ebp)
            ++lines;
c0102365:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        }

        ++message;
c0102369:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                   "                                                                                \n"
                   "      Universe has been crashed. You have to restart your computer.             \n"
                   "                                                                                \n"
                  );

    while (*message != '\0')
c010236d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102370:	0f b6 00             	movzbl (%eax),%eax
c0102373:	84 c0                	test   %al,%al
c0102375:	75 ae                	jne    c0102325 <panic+0x1d5>
        }

        ++message;
    }

    len += sprintf (buffer + len,
c0102377:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010237a:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
c0102380:	01 d0                	add    %edx,%eax
c0102382:	ba 60 01 11 c0       	mov    $0xc0110160,%edx
c0102387:	bb 51 00 00 00       	mov    $0x51,%ebx
c010238c:	89 c1                	mov    %eax,%ecx
c010238e:	83 e1 01             	and    $0x1,%ecx
c0102391:	85 c9                	test   %ecx,%ecx
c0102393:	74 0e                	je     c01023a3 <panic+0x253>
c0102395:	0f b6 0a             	movzbl (%edx),%ecx
c0102398:	88 08                	mov    %cl,(%eax)
c010239a:	83 c0 01             	add    $0x1,%eax
c010239d:	83 c2 01             	add    $0x1,%edx
c01023a0:	83 eb 01             	sub    $0x1,%ebx
c01023a3:	89 c1                	mov    %eax,%ecx
c01023a5:	83 e1 02             	and    $0x2,%ecx
c01023a8:	85 c9                	test   %ecx,%ecx
c01023aa:	74 0f                	je     c01023bb <panic+0x26b>
c01023ac:	0f b7 0a             	movzwl (%edx),%ecx
c01023af:	66 89 08             	mov    %cx,(%eax)
c01023b2:	83 c0 02             	add    $0x2,%eax
c01023b5:	83 c2 02             	add    $0x2,%edx
c01023b8:	83 eb 02             	sub    $0x2,%ebx
c01023bb:	89 d9                	mov    %ebx,%ecx
c01023bd:	c1 e9 02             	shr    $0x2,%ecx
c01023c0:	89 c7                	mov    %eax,%edi
c01023c2:	89 d6                	mov    %edx,%esi
c01023c4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c01023c6:	89 f2                	mov    %esi,%edx
c01023c8:	89 f8                	mov    %edi,%eax
c01023ca:	b9 00 00 00 00       	mov    $0x0,%ecx
c01023cf:	89 de                	mov    %ebx,%esi
c01023d1:	83 e6 02             	and    $0x2,%esi
c01023d4:	85 f6                	test   %esi,%esi
c01023d6:	74 0b                	je     c01023e3 <panic+0x293>
c01023d8:	0f b7 34 0a          	movzwl (%edx,%ecx,1),%esi
c01023dc:	66 89 34 08          	mov    %si,(%eax,%ecx,1)
c01023e0:	83 c1 02             	add    $0x2,%ecx
c01023e3:	83 e3 01             	and    $0x1,%ebx
c01023e6:	85 db                	test   %ebx,%ebx
c01023e8:	74 07                	je     c01023f1 <panic+0x2a1>
c01023ea:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
c01023ee:	88 14 08             	mov    %dl,(%eax,%ecx,1)
c01023f1:	83 45 e0 50          	addl   $0x50,-0x20(%ebp)
                    "\n      To help us improving our systems, please report this incident to us.     "
                   );

    set_color(WHITE | RED << 4);
c01023f5:	c7 04 24 4f 00 00 00 	movl   $0x4f,(%esp)
c01023fc:	e8 69 9f 00 00       	call   c010c36a <set_color>
    //clear_screen();

    //gotoxy(0, (25 / 2) - (lines / 2) - 1);
    printf("%s", buffer);
c0102401:	8d 85 dc fb ff ff    	lea    -0x424(%ebp),%eax
c0102407:	89 44 24 04          	mov    %eax,0x4(%esp)
c010240b:	c7 04 24 b1 01 11 c0 	movl   $0xc01101b1,(%esp)
c0102412:	e8 0a 12 00 00       	call   c0103621 <printf>

    halt();
c0102417:	e8 e5 b8 00 00       	call   c010dd01 <halt>
}
c010241c:	81 c4 2c 04 00 00    	add    $0x42c,%esp
c0102422:	5b                   	pop    %ebx
c0102423:	5e                   	pop    %esi
c0102424:	5f                   	pop    %edi
c0102425:	5d                   	pop    %ebp
c0102426:	c3                   	ret    

c0102427 <winpanic>:



/* easter egg! */
void winpanic(char *message)
{
c0102427:	55                   	push   %ebp
c0102428:	89 e5                	mov    %esp,%ebp
c010242a:	83 ec 18             	sub    $0x18,%esp
    set_color(WHITE | BLUE << 4);
c010242d:	c7 04 24 1f 00 00 00 	movl   $0x1f,(%esp)
c0102434:	e8 31 9f 00 00       	call   c010c36a <set_color>
    clear_screen();
c0102439:	e8 d8 9e 00 00       	call   c010c316 <clear_screen>

    gotoxy(37, 8);
c010243e:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0102445:	00 
c0102446:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
c010244d:	e8 3b 9f 00 00       	call   c010c38d <gotoxy>
    set_color(BLUE | LIGHT_GRAY << 4);
c0102452:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
c0102459:	e8 0c 9f 00 00       	call   c010c36a <set_color>
    printf(" Windows");
c010245e:	c7 04 24 b4 01 11 c0 	movl   $0xc01101b4,(%esp)
c0102465:	e8 b7 11 00 00       	call   c0103621 <printf>
    set_color(WHITE | BLUE << 4);
c010246a:	c7 04 24 1f 00 00 00 	movl   $0x1f,(%esp)
c0102471:	e8 f4 9e 00 00       	call   c010c36a <set_color>
    printf("\n\n      ");
c0102476:	c7 04 24 bd 01 11 c0 	movl   $0xc01101bd,(%esp)
c010247d:	e8 9f 11 00 00       	call   c0103621 <printf>
    while (*message != '\0')
c0102482:	eb 2b                	jmp    c01024af <winpanic+0x88>
    {
        putchar(*message);
c0102484:	8b 45 08             	mov    0x8(%ebp),%eax
c0102487:	0f b6 00             	movzbl (%eax),%eax
c010248a:	0f be c0             	movsbl %al,%eax
c010248d:	89 04 24             	mov    %eax,(%esp)
c0102490:	e8 a9 9c 00 00       	call   c010c13e <putchar>

        if (*message == '\n')
c0102495:	8b 45 08             	mov    0x8(%ebp),%eax
c0102498:	0f b6 00             	movzbl (%eax),%eax
c010249b:	3c 0a                	cmp    $0xa,%al
c010249d:	75 0c                	jne    c01024ab <winpanic+0x84>
        {
            printf("      ");
c010249f:	c7 04 24 c6 01 11 c0 	movl   $0xc01101c6,(%esp)
c01024a6:	e8 76 11 00 00       	call   c0103621 <printf>
        }

        ++message;
c01024ab:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    gotoxy(37, 8);
    set_color(BLUE | LIGHT_GRAY << 4);
    printf(" Windows");
    set_color(WHITE | BLUE << 4);
    printf("\n\n      ");
    while (*message != '\0')
c01024af:	8b 45 08             	mov    0x8(%ebp),%eax
c01024b2:	0f b6 00             	movzbl (%eax),%eax
c01024b5:	84 c0                	test   %al,%al
c01024b7:	75 cb                	jne    c0102484 <winpanic+0x5d>

        ++message;
    }
    //printf("%s\n", message);

    printf("\n\n      *  Druecken Sie eine beliebige Taste, um die Anwendung abzubrechen.\n");
c01024b9:	c7 04 24 d0 01 11 c0 	movl   $0xc01101d0,(%esp)
c01024c0:	e8 da 9d 00 00       	call   c010c29f <puts>
    printf("      *  Druecken Sie Strg+Alt+Entf, um den Computer neu zu\n");
c01024c5:	c7 04 24 1c 02 11 c0 	movl   $0xc011021c,(%esp)
c01024cc:	e8 ce 9d 00 00       	call   c010c29f <puts>
    printf("      starten. nicht gespeicherte Daten gehen dabei verloren.\n");
c01024d1:	c7 04 24 58 02 11 c0 	movl   $0xc0110258,(%esp)
c01024d8:	e8 c2 9d 00 00       	call   c010c29f <puts>
    halt();
c01024dd:	e8 1f b8 00 00       	call   c010dd01 <halt>
}
c01024e2:	c9                   	leave  
c01024e3:	c3                   	ret    

c01024e4 <block_buffer_create>:
 *
 * @param block_size Size of one block
 * @return pointer to object
 */
block_buffer_info_t *block_buffer_create(size_t block_size)
{
c01024e4:	55                   	push   %ebp
c01024e5:	89 e5                	mov    %esp,%ebp
c01024e7:	83 ec 28             	sub    $0x28,%esp
    block_buffer_info_t *buffer = (block_buffer_info_t*) malloc(sizeof(block_buffer_info_t));
c01024ea:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c01024f1:	e8 4f 9a 00 00       	call   c010bf45 <malloc>
c01024f6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    buffer->blocks = list_create();
c01024f9:	e8 7d 04 00 00       	call   c010297b <list_create>
c01024fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102501:	89 02                	mov    %eax,(%edx)
    buffer->block_size = block_size;
c0102503:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102506:	8b 55 08             	mov    0x8(%ebp),%edx
c0102509:	89 50 04             	mov    %edx,0x4(%eax)

    buffer->block_counter = 0;
c010250c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010250f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    return buffer;
c0102516:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0102519:	c9                   	leave  
c010251a:	c3                   	ret    

c010251b <buffer_block_get>:
 * @param id	identifier of searched object
 *
 * @return pointer to block object
 */
buffer_block_t *buffer_block_get(block_buffer_info_t *info, unsigned int id)
{
c010251b:	55                   	push   %ebp
c010251c:	89 e5                	mov    %esp,%ebp
c010251e:	83 ec 18             	sub    $0x18,%esp
    return (buffer_block_t*) list_get_by_int(info->blocks, offsetof(buffer_block_t, id), id);
c0102521:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102524:	8b 45 08             	mov    0x8(%ebp),%eax
c0102527:	8b 00                	mov    (%eax),%eax
c0102529:	89 54 24 08          	mov    %edx,0x8(%esp)
c010252d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0102534:	00 
c0102535:	89 04 24             	mov    %eax,(%esp)
c0102538:	e8 8a 06 00 00       	call   c0102bc7 <list_get_by_int>
}
c010253d:	c9                   	leave  
c010253e:	c3                   	ret    

c010253f <buffer_block_create>:
 *
 * @param info the buffer object
 * @return pointer to the block
 */
buffer_block_t *buffer_block_create(block_buffer_info_t *info, unsigned int id)
{
c010253f:	55                   	push   %ebp
c0102540:	89 e5                	mov    %esp,%ebp
c0102542:	83 ec 28             	sub    $0x28,%esp
    buffer_block_t *block = buffer_block_get(info, id);
c0102545:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102548:	89 44 24 04          	mov    %eax,0x4(%esp)
c010254c:	8b 45 08             	mov    0x8(%ebp),%eax
c010254f:	89 04 24             	mov    %eax,(%esp)
c0102552:	e8 c4 ff ff ff       	call   c010251b <buffer_block_get>
c0102557:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(block == NULL)
c010255a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010255e:	75 50                	jne    c01025b0 <buffer_block_create+0x71>
    {
        block = malloc(sizeof(buffer_block_t));
c0102560:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0102567:	e8 d9 99 00 00       	call   c010bf45 <malloc>
c010256c:	89 45 f4             	mov    %eax,-0xc(%ebp)

        block->base = malloc(info->block_size);
c010256f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102572:	8b 40 04             	mov    0x4(%eax),%eax
c0102575:	89 04 24             	mov    %eax,(%esp)
c0102578:	e8 c8 99 00 00       	call   c010bf45 <malloc>
c010257d:	89 c2                	mov    %eax,%edx
c010257f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102582:	89 50 04             	mov    %edx,0x4(%eax)
        block->id = id;
c0102585:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102588:	8b 55 0c             	mov    0xc(%ebp),%edx
c010258b:	89 10                	mov    %edx,(%eax)
        list_push_back(info->blocks, block);
c010258d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102590:	8b 00                	mov    (%eax),%eax
c0102592:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102595:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102599:	89 04 24             	mov    %eax,(%esp)
c010259c:	e8 be 04 00 00       	call   c0102a5f <list_push_back>

        info->block_counter++;
c01025a1:	8b 45 08             	mov    0x8(%ebp),%eax
c01025a4:	8b 40 08             	mov    0x8(%eax),%eax
c01025a7:	8d 50 01             	lea    0x1(%eax),%edx
c01025aa:	8b 45 08             	mov    0x8(%ebp),%eax
c01025ad:	89 50 08             	mov    %edx,0x8(%eax)
    }

    return block;
c01025b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01025b3:	c9                   	leave  
c01025b4:	c3                   	ret    

c01025b5 <buffer_block_remove>:
 * @param id identifier of the block to remove
 *
 * @return removed block
 */
buffer_block_t *buffer_block_remove(block_buffer_info_t *info, unsigned int id)
{
c01025b5:	55                   	push   %ebp
c01025b6:	89 e5                	mov    %esp,%ebp
c01025b8:	83 ec 28             	sub    $0x28,%esp
    struct list_node *node = list_get_node_by_int(info->blocks, offsetof(buffer_block_t, id), id);
c01025bb:	8b 55 0c             	mov    0xc(%ebp),%edx
c01025be:	8b 45 08             	mov    0x8(%ebp),%eax
c01025c1:	8b 00                	mov    (%eax),%eax
c01025c3:	89 54 24 08          	mov    %edx,0x8(%esp)
c01025c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01025ce:	00 
c01025cf:	89 04 24             	mov    %eax,(%esp)
c01025d2:	e8 45 06 00 00       	call   c0102c1c <list_get_node_by_int>
c01025d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    buffer_block_t *block = list_remove_node(node);
c01025da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01025dd:	89 04 24             	mov    %eax,(%esp)
c01025e0:	e8 1d 05 00 00       	call   c0102b02 <list_remove_node>
c01025e5:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return block;
c01025e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c01025eb:	c9                   	leave  
c01025ec:	c3                   	ret    

c01025ed <block_buffer_write>:
 * @param bytes number of bytes to write
 *
 * @return number of written bytes
 */
int block_buffer_write(block_buffer_info_t *info, uintptr_t offset, uint8_t *data, size_t bytes)
{
c01025ed:	55                   	push   %ebp
c01025ee:	89 e5                	mov    %esp,%ebp
c01025f0:	83 ec 38             	sub    $0x38,%esp
    // calculate block indices
    int block_id  = offset / info->block_size;
c01025f3:	8b 45 08             	mov    0x8(%ebp),%eax
c01025f6:	8b 40 04             	mov    0x4(%eax),%eax
c01025f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01025fc:	8b 45 0c             	mov    0xc(%ebp),%eax
c01025ff:	ba 00 00 00 00       	mov    $0x0,%edx
c0102604:	f7 75 e4             	divl   -0x1c(%ebp)
c0102607:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int block_off = offset % info->block_size;
c010260a:	8b 45 08             	mov    0x8(%ebp),%eax
c010260d:	8b 48 04             	mov    0x4(%eax),%ecx
c0102610:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102613:	ba 00 00 00 00       	mov    $0x0,%edx
c0102618:	f7 f1                	div    %ecx
c010261a:	89 d0                	mov    %edx,%eax
c010261c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // search first block
    buffer_block_t *block = buffer_block_create(info, block_id);
c010261f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102622:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102626:	8b 45 08             	mov    0x8(%ebp),%eax
c0102629:	89 04 24             	mov    %eax,(%esp)
c010262c:	e8 0e ff ff ff       	call   c010253f <buffer_block_create>
c0102631:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // go through all bytes...
    int i;
    for(i = 0; i < bytes; i++)
c0102634:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c010263b:	eb 4d                	jmp    c010268a <block_buffer_write+0x9d>
    {
        // if the block ends, go to the next
        if(block_off >= info->block_size)
c010263d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0102640:	8b 45 08             	mov    0x8(%ebp),%eax
c0102643:	8b 40 04             	mov    0x4(%eax),%eax
c0102646:	39 c2                	cmp    %eax,%edx
c0102648:	72 20                	jb     c010266a <block_buffer_write+0x7d>
        {
            block = buffer_block_create(info, ++block_id);
c010264a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010264e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102651:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102655:	8b 45 08             	mov    0x8(%ebp),%eax
c0102658:	89 04 24             	mov    %eax,(%esp)
c010265b:	e8 df fe ff ff       	call   c010253f <buffer_block_create>
c0102660:	89 45 ec             	mov    %eax,-0x14(%ebp)
            block_off = 0;
c0102663:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        }

        // copy data
        block->base[block_off++] = data[i];
c010266a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010266d:	8b 50 04             	mov    0x4(%eax),%edx
c0102670:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102673:	01 c2                	add    %eax,%edx
c0102675:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0102678:	8b 45 10             	mov    0x10(%ebp),%eax
c010267b:	01 c8                	add    %ecx,%eax
c010267d:	0f b6 00             	movzbl (%eax),%eax
c0102680:	88 02                	mov    %al,(%edx)
c0102682:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    // search first block
    buffer_block_t *block = buffer_block_create(info, block_id);

    // go through all bytes...
    int i;
    for(i = 0; i < bytes; i++)
c0102686:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010268a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010268d:	3b 45 14             	cmp    0x14(%ebp),%eax
c0102690:	72 ab                	jb     c010263d <block_buffer_write+0x50>

        // copy data
        block->base[block_off++] = data[i];
    }

    return i;
c0102692:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c0102695:	c9                   	leave  
c0102696:	c3                   	ret    

c0102697 <block_buffer_read>:
 * @param bytes number of bytes to read
 *
 * @return number of read bytes
 */
int block_buffer_read (block_buffer_info_t *info, uintptr_t offset, uint8_t *data, size_t bytes)
{
c0102697:	55                   	push   %ebp
c0102698:	89 e5                	mov    %esp,%ebp
c010269a:	83 ec 38             	sub    $0x38,%esp
    // calculate block indices
    int block_id  = offset / info->block_size;
c010269d:	8b 45 08             	mov    0x8(%ebp),%eax
c01026a0:	8b 40 04             	mov    0x4(%eax),%eax
c01026a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01026a6:	8b 45 0c             	mov    0xc(%ebp),%eax
c01026a9:	ba 00 00 00 00       	mov    $0x0,%edx
c01026ae:	f7 75 e4             	divl   -0x1c(%ebp)
c01026b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int block_off = offset % info->block_size;
c01026b4:	8b 45 08             	mov    0x8(%ebp),%eax
c01026b7:	8b 48 04             	mov    0x4(%eax),%ecx
c01026ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c01026bd:	ba 00 00 00 00       	mov    $0x0,%edx
c01026c2:	f7 f1                	div    %ecx
c01026c4:	89 d0                	mov    %edx,%eax
c01026c6:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // search first block
    buffer_block_t *block = buffer_block_get(info, block_id);
c01026c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01026cc:	89 44 24 04          	mov    %eax,0x4(%esp)
c01026d0:	8b 45 08             	mov    0x8(%ebp),%eax
c01026d3:	89 04 24             	mov    %eax,(%esp)
c01026d6:	e8 40 fe ff ff       	call   c010251b <buffer_block_get>
c01026db:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // go through all bytes...
    int i;
    for(i = 0; i < bytes; i++)
c01026de:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c01026e5:	eb 53                	jmp    c010273a <block_buffer_read+0xa3>
    {
        // if the block ends, go to the next
        if(block_off >= info->block_size)
c01026e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01026ea:	8b 45 08             	mov    0x8(%ebp),%eax
c01026ed:	8b 40 04             	mov    0x4(%eax),%eax
c01026f0:	39 c2                	cmp    %eax,%edx
c01026f2:	72 20                	jb     c0102714 <block_buffer_read+0x7d>
        {
            block = buffer_block_get(info, ++block_id);
c01026f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01026f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01026fb:	89 44 24 04          	mov    %eax,0x4(%esp)
c01026ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0102702:	89 04 24             	mov    %eax,(%esp)
c0102705:	e8 11 fe ff ff       	call   c010251b <buffer_block_get>
c010270a:	89 45 ec             	mov    %eax,-0x14(%ebp)
            block_off = 0;
c010270d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        }

        if(block == NULL)
c0102714:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0102718:	74 2a                	je     c0102744 <block_buffer_read+0xad>
            break;

        // copy data
        data[i] = block->base[block_off++];
c010271a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010271d:	8b 45 10             	mov    0x10(%ebp),%eax
c0102720:	01 c2                	add    %eax,%edx
c0102722:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102725:	8b 48 04             	mov    0x4(%eax),%ecx
c0102728:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010272b:	01 c8                	add    %ecx,%eax
c010272d:	0f b6 00             	movzbl (%eax),%eax
c0102730:	88 02                	mov    %al,(%edx)
c0102732:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    // search first block
    buffer_block_t *block = buffer_block_get(info, block_id);

    // go through all bytes...
    int i;
    for(i = 0; i < bytes; i++)
c0102736:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010273a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010273d:	3b 45 14             	cmp    0x14(%ebp),%eax
c0102740:	72 a5                	jb     c01026e7 <block_buffer_read+0x50>
c0102742:	eb 01                	jmp    c0102745 <block_buffer_read+0xae>
            block = buffer_block_get(info, ++block_id);
            block_off = 0;
        }

        if(block == NULL)
            break;
c0102744:	90                   	nop

        // copy data
        data[i] = block->base[block_off++];
    }

    return i;
c0102745:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c0102748:	c9                   	leave  
c0102749:	c3                   	ret    

c010274a <itoa_ex>:
 *  @param width 	Field width
 *  @return pointer to buffer
 */

char * itoa_ex(unsigned int value, char * str, int base, int flags, int width)
{
c010274a:	55                   	push   %ebp
c010274b:	89 e5                	mov    %esp,%ebp
c010274d:	83 ec 48             	sub    $0x48,%esp
    char *result = str;
c0102750:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102753:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned int size;
    unsigned int len = 0;
c0102756:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int temp = 0;
c010275d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int negative = 0;
c0102764:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    const char *digits = "0123456789ABCDEF";
c010276b:	c7 45 ec 96 02 11 c0 	movl   $0xc0110296,-0x14(%ebp)

    if (flags & SMALL)
c0102772:	8b 45 14             	mov    0x14(%ebp),%eax
c0102775:	83 e0 20             	and    $0x20,%eax
c0102778:	85 c0                	test   %eax,%eax
c010277a:	74 07                	je     c0102783 <itoa_ex+0x39>
    {
        digits = "0123456789abcdef";
c010277c:	c7 45 ec a7 02 11 c0 	movl   $0xc01102a7,-0x14(%ebp)
    {
        value = - value;
        ++negative;
    }

    temp = value;
c0102783:	8b 45 08             	mov    0x8(%ebp),%eax
c0102786:	89 45 f0             	mov    %eax,-0x10(%ebp)
    do
    {
        temp /= base;
c0102789:	8b 55 10             	mov    0x10(%ebp),%edx
c010278c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c010278f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102792:	ba 00 00 00 00       	mov    $0x0,%edx
c0102797:	f7 75 d4             	divl   -0x2c(%ebp)
c010279a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        ++len;
c010279d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    }
    while (temp);
c01027a1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01027a5:	75 e2                	jne    c0102789 <itoa_ex+0x3f>
    size = len;
c01027a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01027aa:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (!(flags & LEFT) && !(flags & ZEROPAD))
c01027ad:	8b 45 14             	mov    0x14(%ebp),%eax
c01027b0:	83 e0 10             	and    $0x10,%eax
c01027b3:	85 c0                	test   %eax,%eax
c01027b5:	75 27                	jne    c01027de <itoa_ex+0x94>
c01027b7:	8b 45 14             	mov    0x14(%ebp),%eax
c01027ba:	83 e0 01             	and    $0x1,%eax
c01027bd:	85 c0                	test   %eax,%eax
c01027bf:	75 1d                	jne    c01027de <itoa_ex+0x94>
        while (size < width--)
c01027c1:	eb 0a                	jmp    c01027cd <itoa_ex+0x83>
            *str++ = ' ';
c01027c3:	8b 45 0c             	mov    0xc(%ebp),%eax
c01027c6:	c6 00 20             	movb   $0x20,(%eax)
c01027c9:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    }
    while (temp);
    size = len;

    if (!(flags & LEFT) && !(flags & ZEROPAD))
        while (size < width--)
c01027cd:	8b 45 18             	mov    0x18(%ebp),%eax
c01027d0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c01027d3:	0f 97 c0             	seta   %al
c01027d6:	83 6d 18 01          	subl   $0x1,0x18(%ebp)
c01027da:	84 c0                	test   %al,%al
c01027dc:	75 e5                	jne    c01027c3 <itoa_ex+0x79>
            *str++ = ' ';

    if (negative)
c01027de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c01027e2:	74 0c                	je     c01027f0 <itoa_ex+0xa6>
    {
        *str++ = '-';
c01027e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c01027e7:	c6 00 2d             	movb   $0x2d,(%eax)
c01027ea:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c01027ee:	eb 14                	jmp    c0102804 <itoa_ex+0xba>
    }
    else if (flags & PLUS)
c01027f0:	8b 45 14             	mov    0x14(%ebp),%eax
c01027f3:	83 e0 04             	and    $0x4,%eax
c01027f6:	85 c0                	test   %eax,%eax
c01027f8:	74 0a                	je     c0102804 <itoa_ex+0xba>
    {
        *str++ = '+';
c01027fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c01027fd:	c6 00 2b             	movb   $0x2b,(%eax)
c0102800:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    }
    if (flags & SPECIAL)
c0102804:	8b 45 14             	mov    0x14(%ebp),%eax
c0102807:	83 e0 40             	and    $0x40,%eax
c010280a:	85 c0                	test   %eax,%eax
c010280c:	74 18                	je     c0102826 <itoa_ex+0xdc>
    {
        *str++ = '0';
c010280e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102811:	c6 00 30             	movb   $0x30,(%eax)
c0102814:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        *str++ = 'x';
c0102818:	8b 45 0c             	mov    0xc(%ebp),%eax
c010281b:	c6 00 78             	movb   $0x78,(%eax)
c010281e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        width -= 2;
c0102822:	83 6d 18 02          	subl   $0x2,0x18(%ebp)
    }

    if (!(flags & LEFT) && (flags & ZEROPAD))
c0102826:	8b 45 14             	mov    0x14(%ebp),%eax
c0102829:	83 e0 10             	and    $0x10,%eax
c010282c:	85 c0                	test   %eax,%eax
c010282e:	75 27                	jne    c0102857 <itoa_ex+0x10d>
c0102830:	8b 45 14             	mov    0x14(%ebp),%eax
c0102833:	83 e0 01             	and    $0x1,%eax
c0102836:	85 c0                	test   %eax,%eax
c0102838:	74 1d                	je     c0102857 <itoa_ex+0x10d>
        while (size < width--)
c010283a:	eb 0a                	jmp    c0102846 <itoa_ex+0xfc>
            *str++ = '0';
c010283c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010283f:	c6 00 30             	movb   $0x30,(%eax)
c0102842:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        *str++ = 'x';
        width -= 2;
    }

    if (!(flags & LEFT) && (flags & ZEROPAD))
        while (size < width--)
c0102846:	8b 45 18             	mov    0x18(%ebp),%eax
c0102849:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c010284c:	0f 97 c0             	seta   %al
c010284f:	83 6d 18 01          	subl   $0x1,0x18(%ebp)
c0102853:	84 c0                	test   %al,%al
c0102855:	75 e5                	jne    c010283c <itoa_ex+0xf2>
            *str++ = '0';

    do
    {
        int power = powi(base, --len);
c0102857:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c010285b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010285e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102862:	8b 45 10             	mov    0x10(%ebp),%eax
c0102865:	89 04 24             	mov    %eax,(%esp)
c0102868:	e8 93 f7 ff ff       	call   c0102000 <powi>
c010286d:	89 45 dc             	mov    %eax,-0x24(%ebp)
        int digit = value / power;
c0102870:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0102873:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0102876:	8b 45 08             	mov    0x8(%ebp),%eax
c0102879:	ba 00 00 00 00       	mov    $0x0,%edx
c010287e:	f7 75 d4             	divl   -0x2c(%ebp)
c0102881:	89 45 d8             	mov    %eax,-0x28(%ebp)

        *str++ = digits[digit];
c0102884:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0102887:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010288a:	01 d0                	add    %edx,%eax
c010288c:	0f b6 10             	movzbl (%eax),%edx
c010288f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102892:	88 10                	mov    %dl,(%eax)
c0102894:	83 45 0c 01          	addl   $0x1,0xc(%ebp)

        value -= digit * power;
c0102898:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010289b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
c010289f:	29 45 08             	sub    %eax,0x8(%ebp)
    }
    while (len > 0);
c01028a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01028a6:	75 af                	jne    c0102857 <itoa_ex+0x10d>

    while (size < width--)
c01028a8:	eb 0a                	jmp    c01028b4 <itoa_ex+0x16a>
        *str++ = ' ';
c01028aa:	8b 45 0c             	mov    0xc(%ebp),%eax
c01028ad:	c6 00 20             	movb   $0x20,(%eax)
c01028b0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)

        value -= digit * power;
    }
    while (len > 0);

    while (size < width--)
c01028b4:	8b 45 18             	mov    0x18(%ebp),%eax
c01028b7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c01028ba:	0f 97 c0             	seta   %al
c01028bd:	83 6d 18 01          	subl   $0x1,0x18(%ebp)
c01028c1:	84 c0                	test   %al,%al
c01028c3:	75 e5                	jne    c01028aa <itoa_ex+0x160>
        *str++ = ' ';

    *str++ = '\0';
c01028c5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01028c8:	c6 00 00             	movb   $0x0,(%eax)
c01028cb:	83 45 0c 01          	addl   $0x1,0xc(%ebp)

    return result;
c01028cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c01028d2:	c9                   	leave  
c01028d3:	c3                   	ret    

c01028d4 <itoa>:
 *  @param base     numerical base (10 = decimal, 16 = hexadecimal)
 *  @return pointer to buffer
 */

inline char * itoa(unsigned int value, char * str, int base)
{
c01028d4:	55                   	push   %ebp
c01028d5:	89 e5                	mov    %esp,%ebp
c01028d7:	83 ec 28             	sub    $0x28,%esp
    return itoa_ex(value, str, base, 0, 1);
c01028da:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
c01028e1:	00 
c01028e2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c01028e9:	00 
c01028ea:	8b 45 10             	mov    0x10(%ebp),%eax
c01028ed:	89 44 24 08          	mov    %eax,0x8(%esp)
c01028f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01028f4:	89 44 24 04          	mov    %eax,0x4(%esp)
c01028f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01028fb:	89 04 24             	mov    %eax,(%esp)
c01028fe:	e8 47 fe ff ff       	call   c010274a <itoa_ex>
}
c0102903:	c9                   	leave  
c0102904:	c3                   	ret    

c0102905 <atoi>:
 *  @param  str  input string
 *  @return integer value
 */

int atoi(const char *str)
{
c0102905:	55                   	push   %ebp
c0102906:	89 e5                	mov    %esp,%ebp
c0102908:	83 ec 28             	sub    $0x28,%esp
    int result = 0;
c010290b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int length = 0;
c0102912:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    while (isdigit(*str++))
c0102919:	eb 04                	jmp    c010291f <atoi+0x1a>
        ++length;
c010291b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
int atoi(const char *str)
{
    int result = 0;
    int length = 0;

    while (isdigit(*str++))
c010291f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102922:	0f b6 00             	movzbl (%eax),%eax
c0102925:	0f be c0             	movsbl %al,%eax
c0102928:	83 e8 30             	sub    $0x30,%eax
c010292b:	83 f8 09             	cmp    $0x9,%eax
c010292e:	0f 96 c0             	setbe  %al
c0102931:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0102935:	84 c0                	test   %al,%al
c0102937:	75 e2                	jne    c010291b <atoi+0x16>
        ++length;

    str -= length + 1;
c0102939:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010293c:	f7 d0                	not    %eax
c010293e:	01 45 08             	add    %eax,0x8(%ebp)

    while (length > 0)
c0102941:	eb 2d                	jmp    c0102970 <atoi+0x6b>
        result += powi(10, --length) * (*str++ - '0');
c0102943:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0102947:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010294a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010294e:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0102955:	e8 a6 f6 ff ff       	call   c0102000 <powi>
c010295a:	8b 55 08             	mov    0x8(%ebp),%edx
c010295d:	0f b6 12             	movzbl (%edx),%edx
c0102960:	0f be d2             	movsbl %dl,%edx
c0102963:	83 ea 30             	sub    $0x30,%edx
c0102966:	0f af c2             	imul   %edx,%eax
c0102969:	01 45 f4             	add    %eax,-0xc(%ebp)
c010296c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    while (isdigit(*str++))
        ++length;

    str -= length + 1;

    while (length > 0)
c0102970:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0102974:	7f cd                	jg     c0102943 <atoi+0x3e>
        result += powi(10, --length) * (*str++ - '0');

    return result;
c0102976:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0102979:	c9                   	leave  
c010297a:	c3                   	ret    

c010297b <list_create>:
/**
 *  @brief Creates a linked list.
 *  @return new list
 */
list_t *list_create(void)
{
c010297b:	55                   	push   %ebp
c010297c:	89 e5                	mov    %esp,%ebp
c010297e:	83 ec 28             	sub    $0x28,%esp
    list_t *list = (list_t *) malloc(sizeof(list_t));
c0102981:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0102988:	e8 b8 95 00 00       	call   c010bf45 <malloc>
c010298d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct list_node *dummy = (struct list_node *) malloc(sizeof(struct list_node));
c0102990:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0102997:	e8 a9 95 00 00       	call   c010bf45 <malloc>
c010299c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    list->head = dummy;
c010299f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01029a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01029a5:	89 50 04             	mov    %edx,0x4(%eax)
    dummy->next = dummy;
c01029a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01029ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01029ae:	89 10                	mov    %edx,(%eax)
    dummy->prev = dummy;
c01029b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01029b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01029b6:	89 50 04             	mov    %edx,0x4(%eax)
    dummy->element = (void *) 0;
c01029b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01029bc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    unlock(&list->lock);
c01029c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01029c6:	89 04 24             	mov    %eax,(%esp)
c01029c9:	e8 8c b3 00 00       	call   c010dd5a <unlock>
    return list;
c01029ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01029d1:	c9                   	leave  
c01029d2:	c3                   	ret    

c01029d3 <list_destroy>:
/**
 *  @brief Destroys a list.
 *  @param list the list to be destroied
 */
void list_destroy(list_t *list)
{
c01029d3:	55                   	push   %ebp
c01029d4:	89 e5                	mov    %esp,%ebp
c01029d6:	83 ec 28             	sub    $0x28,%esp
    struct list_node *node = list->head->next;
c01029d9:	8b 45 08             	mov    0x8(%ebp),%eax
c01029dc:	8b 40 04             	mov    0x4(%eax),%eax
c01029df:	8b 00                	mov    (%eax),%eax
c01029e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct list_node *head = list->head;
c01029e4:	8b 45 08             	mov    0x8(%ebp),%eax
c01029e7:	8b 40 04             	mov    0x4(%eax),%eax
c01029ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (node != head)
c01029ed:	eb 13                	jmp    c0102a02 <list_destroy+0x2f>
    {
        node = node->next;
c01029ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01029f2:	8b 00                	mov    (%eax),%eax
c01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        free(node);
c01029f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01029fa:	89 04 24             	mov    %eax,(%esp)
c01029fd:	e8 51 96 00 00       	call   c010c053 <free>
 */
void list_destroy(list_t *list)
{
    struct list_node *node = list->head->next;
    struct list_node *head = list->head;
    while (node != head)
c0102a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102a05:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0102a08:	75 e5                	jne    c01029ef <list_destroy+0x1c>
    {
        node = node->next;
        free(node);
    }

    free(list);
c0102a0a:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a0d:	89 04 24             	mov    %eax,(%esp)
c0102a10:	e8 3e 96 00 00       	call   c010c053 <free>
    return;
c0102a15:	90                   	nop
}
c0102a16:	c9                   	leave  
c0102a17:	c3                   	ret    

c0102a18 <list_splice>:
 *  @param start Start of the element chain
 *  @param end end of the element chain
 *  @param target Target place
 */
void list_splice(struct list_node *start, struct list_node *end, struct list_node *target)
{
c0102a18:	55                   	push   %ebp
c0102a19:	89 e5                	mov    %esp,%ebp
    start->prev->next = end->next;
c0102a1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a1e:	8b 40 04             	mov    0x4(%eax),%eax
c0102a21:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102a24:	8b 12                	mov    (%edx),%edx
c0102a26:	89 10                	mov    %edx,(%eax)
    end->next->prev = start->prev;
c0102a28:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102a2b:	8b 00                	mov    (%eax),%eax
c0102a2d:	8b 55 08             	mov    0x8(%ebp),%edx
c0102a30:	8b 52 04             	mov    0x4(%edx),%edx
c0102a33:	89 50 04             	mov    %edx,0x4(%eax)
    start->prev = target;
c0102a36:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a39:	8b 55 10             	mov    0x10(%ebp),%edx
c0102a3c:	89 50 04             	mov    %edx,0x4(%eax)
    end->next = target->next;
c0102a3f:	8b 45 10             	mov    0x10(%ebp),%eax
c0102a42:	8b 10                	mov    (%eax),%edx
c0102a44:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102a47:	89 10                	mov    %edx,(%eax)
    target->next->prev = end;
c0102a49:	8b 45 10             	mov    0x10(%ebp),%eax
c0102a4c:	8b 00                	mov    (%eax),%eax
c0102a4e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102a51:	89 50 04             	mov    %edx,0x4(%eax)
    target->next = start;
c0102a54:	8b 45 10             	mov    0x10(%ebp),%eax
c0102a57:	8b 55 08             	mov    0x8(%ebp),%edx
c0102a5a:	89 10                	mov    %edx,(%eax)
    return;
c0102a5c:	90                   	nop
}
c0102a5d:	5d                   	pop    %ebp
c0102a5e:	c3                   	ret    

c0102a5f <list_push_back>:
 *  @param list the list
 *  @param element the element to be added to the list
 *  @return pointer to the list
 */
list_t *list_push_back(list_t *list, void *element)
{
c0102a5f:	55                   	push   %ebp
c0102a60:	89 e5                	mov    %esp,%ebp
c0102a62:	83 ec 28             	sub    $0x28,%esp
    struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0102a65:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0102a6c:	e8 d4 94 00 00       	call   c010bf45 <malloc>
c0102a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0102a74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102a77:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102a7a:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0102a7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102a80:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102a83:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0102a85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102a88:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102a8b:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, list->head->prev);
c0102a8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a91:	8b 40 04             	mov    0x4(%eax),%eax
c0102a94:	8b 40 04             	mov    0x4(%eax),%eax
c0102a97:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102a9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102a9e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102aa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102aa5:	89 04 24             	mov    %eax,(%esp)
c0102aa8:	e8 6b ff ff ff       	call   c0102a18 <list_splice>
    return list;
c0102aad:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0102ab0:	c9                   	leave  
c0102ab1:	c3                   	ret    

c0102ab2 <list_push_front>:
 *  @param list the list
 *  @param element the element to be added to the list
 *  @return pointer to the list
 */
list_t *list_push_front(list_t *list, void *element)
{
c0102ab2:	55                   	push   %ebp
c0102ab3:	89 e5                	mov    %esp,%ebp
c0102ab5:	83 ec 28             	sub    $0x28,%esp
    struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0102ab8:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0102abf:	e8 81 94 00 00       	call   c010bf45 <malloc>
c0102ac4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0102ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102aca:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102acd:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0102ad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102ad3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102ad6:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0102ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102adb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102ade:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, list->head);
c0102ae1:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ae4:	8b 40 04             	mov    0x4(%eax),%eax
c0102ae7:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102aee:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102af2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102af5:	89 04 24             	mov    %eax,(%esp)
c0102af8:	e8 1b ff ff ff       	call   c0102a18 <list_splice>
    return list;
c0102afd:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0102b00:	c9                   	leave  
c0102b01:	c3                   	ret    

c0102b02 <list_remove_node>:
 *  @brief Internal function which removes a specific node from a list.
 *  @param node the node to be removed
 *  @return pointer to the content of the removed element
 */
void *list_remove_node(struct list_node *node)
{
c0102b02:	55                   	push   %ebp
c0102b03:	89 e5                	mov    %esp,%ebp
c0102b05:	83 ec 28             	sub    $0x28,%esp
    void *element = node->element;
c0102b08:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b0b:	8b 40 08             	mov    0x8(%eax),%eax
c0102b0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->prev->next = node->next;
c0102b11:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b14:	8b 40 04             	mov    0x4(%eax),%eax
c0102b17:	8b 55 08             	mov    0x8(%ebp),%edx
c0102b1a:	8b 12                	mov    (%edx),%edx
c0102b1c:	89 10                	mov    %edx,(%eax)
    node->next->prev = node->prev;
c0102b1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b21:	8b 00                	mov    (%eax),%eax
c0102b23:	8b 55 08             	mov    0x8(%ebp),%edx
c0102b26:	8b 52 04             	mov    0x4(%edx),%edx
c0102b29:	89 50 04             	mov    %edx,0x4(%eax)
    free(node);
c0102b2c:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b2f:	89 04 24             	mov    %eax,(%esp)
c0102b32:	e8 1c 95 00 00       	call   c010c053 <free>
    return element;
c0102b37:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0102b3a:	c9                   	leave  
c0102b3b:	c3                   	ret    

c0102b3c <list_pop_back>:
 *  @brief Removes the element before the dummy (complementary to list_pop_back).
 *  @param the list
 *  @pointer to the removed element
 */
void *list_pop_back(list_t *list)
{
c0102b3c:	55                   	push   %ebp
c0102b3d:	89 e5                	mov    %esp,%ebp
c0102b3f:	83 ec 28             	sub    $0x28,%esp
    struct list_node *last = list->head->prev;
c0102b42:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b45:	8b 40 04             	mov    0x4(%eax),%eax
c0102b48:	8b 40 04             	mov    0x4(%eax),%eax
c0102b4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void *element = last->element;
c0102b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102b51:	8b 40 08             	mov    0x8(%eax),%eax
c0102b54:	89 45 f0             	mov    %eax,-0x10(%ebp)
    last->prev->next = last->next;
c0102b57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102b5a:	8b 40 04             	mov    0x4(%eax),%eax
c0102b5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102b60:	8b 12                	mov    (%edx),%edx
c0102b62:	89 10                	mov    %edx,(%eax)
    last->next->prev = last->prev;
c0102b64:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102b67:	8b 00                	mov    (%eax),%eax
c0102b69:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102b6c:	8b 52 04             	mov    0x4(%edx),%edx
c0102b6f:	89 50 04             	mov    %edx,0x4(%eax)
    free(last);
c0102b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102b75:	89 04 24             	mov    %eax,(%esp)
c0102b78:	e8 d6 94 00 00       	call   c010c053 <free>
    return element;
c0102b7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0102b80:	c9                   	leave  
c0102b81:	c3                   	ret    

c0102b82 <list_pop_front>:
 *  @brief Removes the element after the dummy (complementary to list_pop_front).
 *  @param the list
 *  @pointer to the removed element
 */
void *list_pop_front(list_t *list)
{
c0102b82:	55                   	push   %ebp
c0102b83:	89 e5                	mov    %esp,%ebp
c0102b85:	83 ec 28             	sub    $0x28,%esp
    struct list_node *first = list->head->next;
c0102b88:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b8b:	8b 40 04             	mov    0x4(%eax),%eax
c0102b8e:	8b 00                	mov    (%eax),%eax
c0102b90:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void *element = first->element;
c0102b93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102b96:	8b 40 08             	mov    0x8(%eax),%eax
c0102b99:	89 45 f0             	mov    %eax,-0x10(%ebp)
    first->prev->next = first->next;
c0102b9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102b9f:	8b 40 04             	mov    0x4(%eax),%eax
c0102ba2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102ba5:	8b 12                	mov    (%edx),%edx
c0102ba7:	89 10                	mov    %edx,(%eax)
    first->next->prev = first->prev;
c0102ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102bac:	8b 00                	mov    (%eax),%eax
c0102bae:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102bb1:	8b 52 04             	mov    0x4(%edx),%edx
c0102bb4:	89 50 04             	mov    %edx,0x4(%eax)
    free(first);
c0102bb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102bba:	89 04 24             	mov    %eax,(%esp)
c0102bbd:	e8 91 94 00 00       	call   c010c053 <free>
    return element;
c0102bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0102bc5:	c9                   	leave  
c0102bc6:	c3                   	ret    

c0102bc7 <list_get_by_int>:

void* list_get_by_int(list_t *list, uintptr_t off, int value)
{
c0102bc7:	55                   	push   %ebp
c0102bc8:	89 e5                	mov    %esp,%ebp
c0102bca:	83 ec 10             	sub    $0x10,%esp
    struct list_node *node = list->head->next;
c0102bcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0102bd0:	8b 40 04             	mov    0x4(%eax),%eax
c0102bd3:	8b 00                	mov    (%eax),%eax
c0102bd5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct list_node *head = list->head;
c0102bd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0102bdb:	8b 40 04             	mov    0x4(%eax),%eax
c0102bde:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (node != head)
c0102be1:	eb 2a                	jmp    c0102c0d <list_get_by_int+0x46>
    {
        int val1 = *((int*) ((uintptr_t) node->element + off));
c0102be3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102be6:	8b 40 08             	mov    0x8(%eax),%eax
c0102be9:	89 c2                	mov    %eax,%edx
c0102beb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102bee:	01 d0                	add    %edx,%eax
c0102bf0:	8b 00                	mov    (%eax),%eax
c0102bf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(val1 == value)
c0102bf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102bf8:	3b 45 10             	cmp    0x10(%ebp),%eax
c0102bfb:	75 08                	jne    c0102c05 <list_get_by_int+0x3e>
        {
            return node->element;
c0102bfd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c00:	8b 40 08             	mov    0x8(%eax),%eax
c0102c03:	eb 15                	jmp    c0102c1a <list_get_by_int+0x53>
        }

        node = node->next;
c0102c05:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c08:	8b 00                	mov    (%eax),%eax
c0102c0a:	89 45 fc             	mov    %eax,-0x4(%ebp)
void* list_get_by_int(list_t *list, uintptr_t off, int value)
{
    struct list_node *node = list->head->next;
    struct list_node *head = list->head;

    while (node != head)
c0102c0d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c10:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0102c13:	75 ce                	jne    c0102be3 <list_get_by_int+0x1c>
        }

        node = node->next;
    }

    return NULL;
c0102c15:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0102c1a:	c9                   	leave  
c0102c1b:	c3                   	ret    

c0102c1c <list_get_node_by_int>:

struct list_node* list_get_node_by_int(list_t *list, uintptr_t off, int value)
{
c0102c1c:	55                   	push   %ebp
c0102c1d:	89 e5                	mov    %esp,%ebp
c0102c1f:	83 ec 10             	sub    $0x10,%esp
    struct list_node *node = list->head->next;
c0102c22:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c25:	8b 40 04             	mov    0x4(%eax),%eax
c0102c28:	8b 00                	mov    (%eax),%eax
c0102c2a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct list_node *head = list->head;
c0102c2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c30:	8b 40 04             	mov    0x4(%eax),%eax
c0102c33:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (node != head)
c0102c36:	eb 27                	jmp    c0102c5f <list_get_node_by_int+0x43>
    {
        int val1 = *((int*) ((uintptr_t) node->element + off));
c0102c38:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c3b:	8b 40 08             	mov    0x8(%eax),%eax
c0102c3e:	89 c2                	mov    %eax,%edx
c0102c40:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102c43:	01 d0                	add    %edx,%eax
c0102c45:	8b 00                	mov    (%eax),%eax
c0102c47:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(val1 == value)
c0102c4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102c4d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0102c50:	75 05                	jne    c0102c57 <list_get_node_by_int+0x3b>
        {
            return node;
c0102c52:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c55:	eb 15                	jmp    c0102c6c <list_get_node_by_int+0x50>
        }

        node = node->next;
c0102c57:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c5a:	8b 00                	mov    (%eax),%eax
c0102c5c:	89 45 fc             	mov    %eax,-0x4(%ebp)
struct list_node* list_get_node_by_int(list_t *list, uintptr_t off, int value)
{
    struct list_node *node = list->head->next;
    struct list_node *head = list->head;

    while (node != head)
c0102c5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c62:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0102c65:	75 d1                	jne    c0102c38 <list_get_node_by_int+0x1c>
        }

        node = node->next;
    }

    return NULL;
c0102c67:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0102c6c:	c9                   	leave  
c0102c6d:	c3                   	ret    

c0102c6e <list_length>:
 *  @brief Counts the number of elements in the given list.
 *  @brief list the list
 *  @return number of elements
 */
int list_length(list_t *list)
{
c0102c6e:	55                   	push   %ebp
c0102c6f:	89 e5                	mov    %esp,%ebp
c0102c71:	83 ec 10             	sub    $0x10,%esp
    struct list_node *node = list->head->next;
c0102c74:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c77:	8b 40 04             	mov    0x4(%eax),%eax
c0102c7a:	8b 00                	mov    (%eax),%eax
c0102c7c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct list_node *head = list->head;
c0102c7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c82:	8b 40 04             	mov    0x4(%eax),%eax
c0102c85:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t size = 0;
c0102c88:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while (node != head)
c0102c8f:	eb 0c                	jmp    c0102c9d <list_length+0x2f>
    {
        node = node->next;
c0102c91:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102c94:	8b 00                	mov    (%eax),%eax
c0102c96:	89 45 fc             	mov    %eax,-0x4(%ebp)
        size++;
c0102c99:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
int list_length(list_t *list)
{
    struct list_node *node = list->head->next;
    struct list_node *head = list->head;
    size_t size = 0;
    while (node != head)
c0102c9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102ca0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0102ca3:	75 ec                	jne    c0102c91 <list_length+0x23>
    {
        node = node->next;
        size++;
    }
    return size;
c0102ca5:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0102ca8:	c9                   	leave  
c0102ca9:	c3                   	ret    

c0102caa <list_is_empty>:
 *  @brief Checks if the given list is empty.
 *  @param list the list
 *  @return true if the list is empty, false if the list contains elements
 */
bool list_is_empty(list_t *list)
{
c0102caa:	55                   	push   %ebp
c0102cab:	89 e5                	mov    %esp,%ebp
    return (list->head == list->head->next);
c0102cad:	8b 45 08             	mov    0x8(%ebp),%eax
c0102cb0:	8b 50 04             	mov    0x4(%eax),%edx
c0102cb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0102cb6:	8b 40 04             	mov    0x4(%eax),%eax
c0102cb9:	8b 00                	mov    (%eax),%eax
c0102cbb:	39 c2                	cmp    %eax,%edx
c0102cbd:	0f 94 c0             	sete   %al
c0102cc0:	0f b6 c0             	movzbl %al,%eax
}
c0102cc3:	5d                   	pop    %ebp
c0102cc4:	c3                   	ret    

c0102cc5 <list_lock>:
/**
 *  @brief Locks the optional mutex of a list.
 *  @param list the list
 */
void list_lock(list_t *list)
{
c0102cc5:	55                   	push   %ebp
c0102cc6:	89 e5                	mov    %esp,%ebp
c0102cc8:	83 ec 18             	sub    $0x18,%esp
    lock(&list->lock);
c0102ccb:	8b 45 08             	mov    0x8(%ebp),%eax
c0102cce:	89 04 24             	mov    %eax,(%esp)
c0102cd1:	e8 6c b0 00 00       	call   c010dd42 <lock>
}
c0102cd6:	c9                   	leave  
c0102cd7:	c3                   	ret    

c0102cd8 <list_unlock>:
/**
 *  @brief Unlocks the optional mutex of a list.
 *  @param list the list
 */
void list_unlock(list_t *list)
{
c0102cd8:	55                   	push   %ebp
c0102cd9:	89 e5                	mov    %esp,%ebp
c0102cdb:	83 ec 18             	sub    $0x18,%esp
    unlock(&list->lock);
c0102cde:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ce1:	89 04 24             	mov    %eax,(%esp)
c0102ce4:	e8 71 b0 00 00       	call   c010dd5a <unlock>
}
c0102ce9:	c9                   	leave  
c0102cea:	c3                   	ret    

c0102ceb <iterator_create>:
 *  @breif Creates a new iterator fot a list.
 *  @param list the list
 *  @return the new iterator
 */
iterator_t iterator_create(list_t *list)
{
c0102ceb:	55                   	push   %ebp
c0102cec:	89 e5                	mov    %esp,%ebp
c0102cee:	83 ec 10             	sub    $0x10,%esp
    iterator_t new_iterator;
    new_iterator.list = list;
c0102cf1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102cf4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    new_iterator.current = list->head->next;
c0102cf7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102cfa:	8b 40 04             	mov    0x4(%eax),%eax
c0102cfd:	8b 00                	mov    (%eax),%eax
c0102cff:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return new_iterator;
c0102d02:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0102d05:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0102d08:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0102d0b:	89 01                	mov    %eax,(%ecx)
c0102d0d:	89 51 04             	mov    %edx,0x4(%ecx)
}
c0102d10:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d13:	c9                   	leave  
c0102d14:	c2 04 00             	ret    $0x4

c0102d17 <list_insert_after>:
 *  @brief Inserts an element after the current element which is selected by the iterator.
 *  @param iterator the iterator
 *  @param element the element to be inserted
 */
void list_insert_after(iterator_t *it, void *element)
{
c0102d17:	55                   	push   %ebp
c0102d18:	89 e5                	mov    %esp,%ebp
c0102d1a:	83 ec 28             	sub    $0x28,%esp
    struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0102d1d:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0102d24:	e8 1c 92 00 00       	call   c010bf45 <malloc>
c0102d29:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0102d2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d2f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102d32:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0102d35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d38:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102d3b:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0102d3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d40:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102d43:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, it->current);
c0102d46:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d49:	8b 40 04             	mov    0x4(%eax),%eax
c0102d4c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102d50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d53:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d5a:	89 04 24             	mov    %eax,(%esp)
c0102d5d:	e8 b6 fc ff ff       	call   c0102a18 <list_splice>
}
c0102d62:	c9                   	leave  
c0102d63:	c3                   	ret    

c0102d64 <list_insert_before>:
 *  @brief Inserts an element before the current element which is selected by the iterator.
 *  @param iterator the iterator
 *  @param element the element to be inserted
 */
void list_insert_before(iterator_t *it, void *element)
{
c0102d64:	55                   	push   %ebp
c0102d65:	89 e5                	mov    %esp,%ebp
c0102d67:	83 ec 28             	sub    $0x28,%esp
    struct list_node *node = (struct list_node *) malloc(sizeof(struct list_node));
c0102d6a:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0102d71:	e8 cf 91 00 00       	call   c010bf45 <malloc>
c0102d76:	89 45 f4             	mov    %eax,-0xc(%ebp)
    node->element = element;
c0102d79:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d7c:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102d7f:	89 50 08             	mov    %edx,0x8(%eax)
    node->next = node;
c0102d82:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d85:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102d88:	89 10                	mov    %edx,(%eax)
    node->prev = node;
c0102d8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102d8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102d90:	89 50 04             	mov    %edx,0x4(%eax)
    list_splice(node, node, it->current->prev);
c0102d93:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d96:	8b 40 04             	mov    0x4(%eax),%eax
c0102d99:	8b 40 04             	mov    0x4(%eax),%eax
c0102d9c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102da3:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102da7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102daa:	89 04 24             	mov    %eax,(%esp)
c0102dad:	e8 66 fc ff ff       	call   c0102a18 <list_splice>
}
c0102db2:	c9                   	leave  
c0102db3:	c3                   	ret    

c0102db4 <list_get_current>:
 *  @brief Get the current element of a list selected by an iterator.
 *  @param the iterator
 *  @return the current element
 */
void *list_get_current(iterator_t *it)
{
c0102db4:	55                   	push   %ebp
c0102db5:	89 e5                	mov    %esp,%ebp
    if(it)
c0102db7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0102dbb:	74 15                	je     c0102dd2 <list_get_current+0x1e>
        if(it->current)
c0102dbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0102dc0:	8b 40 04             	mov    0x4(%eax),%eax
c0102dc3:	85 c0                	test   %eax,%eax
c0102dc5:	74 0b                	je     c0102dd2 <list_get_current+0x1e>
            return it->current->element;
c0102dc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0102dca:	8b 40 04             	mov    0x4(%eax),%eax
c0102dcd:	8b 40 08             	mov    0x8(%eax),%eax
c0102dd0:	eb 05                	jmp    c0102dd7 <list_get_current+0x23>

    return NULL;
c0102dd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0102dd7:	5d                   	pop    %ebp
c0102dd8:	c3                   	ret    

c0102dd9 <list_next>:
/**
 *  @brief Switches the current element of an iterator to the next element of it's list. (forward)
 *  @param iterator the iterator
 */
void list_next(iterator_t *it)
{
c0102dd9:	55                   	push   %ebp
c0102dda:	89 e5                	mov    %esp,%ebp
    it->current = it->current->next;
c0102ddc:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ddf:	8b 40 04             	mov    0x4(%eax),%eax
c0102de2:	8b 10                	mov    (%eax),%edx
c0102de4:	8b 45 08             	mov    0x8(%ebp),%eax
c0102de7:	89 50 04             	mov    %edx,0x4(%eax)
}
c0102dea:	5d                   	pop    %ebp
c0102deb:	c3                   	ret    

c0102dec <list_previous>:
/**
 *  @brief Switches the current element of an iterator to the previous element of it's list.
 *  @param iterator the iterator
 */
void list_previous(iterator_t *it)
{
c0102dec:	55                   	push   %ebp
c0102ded:	89 e5                	mov    %esp,%ebp
    it->current = it->current->prev;
c0102def:	8b 45 08             	mov    0x8(%ebp),%eax
c0102df2:	8b 40 04             	mov    0x4(%eax),%eax
c0102df5:	8b 50 04             	mov    0x4(%eax),%edx
c0102df8:	8b 45 08             	mov    0x8(%ebp),%eax
c0102dfb:	89 50 04             	mov    %edx,0x4(%eax)
}
c0102dfe:	5d                   	pop    %ebp
c0102dff:	c3                   	ret    

c0102e00 <list_is_last>:
/**
 *  @brief Checks if the current element is the last before the dummy element or if the list is empty.
 *  @return true if it's the last element, false if it's not.
 */
bool list_is_last(iterator_t *it)
{
c0102e00:	55                   	push   %ebp
c0102e01:	89 e5                	mov    %esp,%ebp
    return (it->current == it->list->head);
c0102e03:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e06:	8b 50 04             	mov    0x4(%eax),%edx
c0102e09:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e0c:	8b 00                	mov    (%eax),%eax
c0102e0e:	8b 40 04             	mov    0x4(%eax),%eax
c0102e11:	39 c2                	cmp    %eax,%edx
c0102e13:	0f 94 c0             	sete   %al
c0102e16:	0f b6 c0             	movzbl %al,%eax
}
c0102e19:	5d                   	pop    %ebp
c0102e1a:	c3                   	ret    

c0102e1b <list_set_first>:
/**
 *  @brief Sets the first element after the dummy as current element of an iterator.
 *  @param iterator the iterator
 */
void list_set_first(iterator_t *it)
{
c0102e1b:	55                   	push   %ebp
c0102e1c:	89 e5                	mov    %esp,%ebp
    it->current = it->list->head->next;
c0102e1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e21:	8b 00                	mov    (%eax),%eax
c0102e23:	8b 40 04             	mov    0x4(%eax),%eax
c0102e26:	8b 10                	mov    (%eax),%edx
c0102e28:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e2b:	89 50 04             	mov    %edx,0x4(%eax)
}
c0102e2e:	5d                   	pop    %ebp
c0102e2f:	c3                   	ret    

c0102e30 <list_set_last>:
/**
 *  @brief Sets the first element before the dummy as current element of an iterator.
 *  @param iterator the iterator
 */
void list_set_last(iterator_t *it)
{
c0102e30:	55                   	push   %ebp
c0102e31:	89 e5                	mov    %esp,%ebp
    it->current = it->list->head->prev;
c0102e33:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e36:	8b 00                	mov    (%eax),%eax
c0102e38:	8b 40 04             	mov    0x4(%eax),%eax
c0102e3b:	8b 50 04             	mov    0x4(%eax),%edx
c0102e3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e41:	89 50 04             	mov    %edx,0x4(%eax)
}
c0102e44:	5d                   	pop    %ebp
c0102e45:	c3                   	ret    

c0102e46 <list_remove>:
 *  @brief Removes the current element from the list and returns it.
 *  @param iterator the iterator
 *  @return the corrent element
 */
void *list_remove(iterator_t *it)
{
c0102e46:	55                   	push   %ebp
c0102e47:	89 e5                	mov    %esp,%ebp
c0102e49:	83 ec 28             	sub    $0x28,%esp
    void *element = list_get_current(it);
c0102e4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e4f:	89 04 24             	mov    %eax,(%esp)
c0102e52:	e8 5d ff ff ff       	call   c0102db4 <list_get_current>
c0102e57:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct list_node *node = it->current;
c0102e5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e5d:	8b 40 04             	mov    0x4(%eax),%eax
c0102e60:	89 45 f0             	mov    %eax,-0x10(%ebp)
    node->prev->next = node->next;
c0102e63:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102e66:	8b 40 04             	mov    0x4(%eax),%eax
c0102e69:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0102e6c:	8b 12                	mov    (%edx),%edx
c0102e6e:	89 10                	mov    %edx,(%eax)
    node->next->prev = node->prev;
c0102e70:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102e73:	8b 00                	mov    (%eax),%eax
c0102e75:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0102e78:	8b 52 04             	mov    0x4(%edx),%edx
c0102e7b:	89 50 04             	mov    %edx,0x4(%eax)
    it->current = node->next;
c0102e7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102e81:	8b 10                	mov    (%eax),%edx
c0102e83:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e86:	89 50 04             	mov    %edx,0x4(%eax)
    free(node);
c0102e89:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102e8c:	89 04 24             	mov    %eax,(%esp)
c0102e8f:	e8 bf 91 00 00       	call   c010c053 <free>
    return element;
c0102e94:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0102e97:	c9                   	leave  
c0102e98:	c3                   	ret    

c0102e99 <strnlen>:
 * @param s the string
 * @param maxlen the maximal lengh
 * @return string lengh<= maxlen
 */
size_t strnlen(const char *s, size_t maxlen)
{
c0102e99:	55                   	push   %ebp
c0102e9a:	89 e5                	mov    %esp,%ebp
c0102e9c:	83 ec 10             	sub    $0x10,%esp
    const char *str = s;
c0102e9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ea2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (*str && maxlen)
c0102ea5:	eb 08                	jmp    c0102eaf <strnlen+0x16>
    {
        ++str;
c0102ea7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        maxlen--;
c0102eab:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
 * @return string lengh<= maxlen
 */
size_t strnlen(const char *s, size_t maxlen)
{
    const char *str = s;
    while (*str && maxlen)
c0102eaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102eb2:	0f b6 00             	movzbl (%eax),%eax
c0102eb5:	84 c0                	test   %al,%al
c0102eb7:	74 06                	je     c0102ebf <strnlen+0x26>
c0102eb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0102ebd:	75 e8                	jne    c0102ea7 <strnlen+0xe>
    {
        ++str;
        maxlen--;
    }

    return str - s;
c0102ebf:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0102ec2:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ec5:	89 d1                	mov    %edx,%ecx
c0102ec7:	29 c1                	sub    %eax,%ecx
c0102ec9:	89 c8                	mov    %ecx,%eax
}
c0102ecb:	c9                   	leave  
c0102ecc:	c3                   	ret    

c0102ecd <strlen>:
 * @breif Returns the string lengh.
 * @param string pointer
 * @return string lengh
 */
size_t strlen(const char *string)
{
c0102ecd:	55                   	push   %ebp
c0102ece:	89 e5                	mov    %esp,%ebp
c0102ed0:	83 ec 10             	sub    $0x10,%esp
    size_t i = 0;
c0102ed3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    while (string[i])
c0102eda:	eb 04                	jmp    c0102ee0 <strlen+0x13>
    {
        i++;
c0102edc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 * @return string lengh
 */
size_t strlen(const char *string)
{
    size_t i = 0;
    while (string[i])
c0102ee0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102ee3:	8b 55 08             	mov    0x8(%ebp),%edx
c0102ee6:	01 d0                	add    %edx,%eax
c0102ee8:	0f b6 00             	movzbl (%eax),%eax
c0102eeb:	84 c0                	test   %al,%al
c0102eed:	75 ed                	jne    c0102edc <strlen+0xf>
    {
        i++;
    }

    return i;
c0102eef:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0102ef2:	c9                   	leave  
c0102ef3:	c3                   	ret    

c0102ef4 <strcpy>:
 * @param dest destination pointer
 * @param src source string
 * @return destination string pointer
 */
char *strcpy(char *dest, const char *src)
{
c0102ef4:	55                   	push   %ebp
c0102ef5:	89 e5                	mov    %esp,%ebp
c0102ef7:	83 ec 10             	sub    $0x10,%esp
    size_t i = 0;
c0102efa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    while (src[i])
c0102f01:	eb 19                	jmp    c0102f1c <strcpy+0x28>
    {
        dest[i] = src[i];
c0102f03:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f06:	8b 55 08             	mov    0x8(%ebp),%edx
c0102f09:	01 c2                	add    %eax,%edx
c0102f0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f0e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102f11:	01 c8                	add    %ecx,%eax
c0102f13:	0f b6 00             	movzbl (%eax),%eax
c0102f16:	88 02                	mov    %al,(%edx)
        i++;
c0102f18:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 * @return destination string pointer
 */
char *strcpy(char *dest, const char *src)
{
    size_t i = 0;
    while (src[i])
c0102f1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f1f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102f22:	01 d0                	add    %edx,%eax
c0102f24:	0f b6 00             	movzbl (%eax),%eax
c0102f27:	84 c0                	test   %al,%al
c0102f29:	75 d8                	jne    c0102f03 <strcpy+0xf>
    {
        dest[i] = src[i];
        i++;
    }
    dest[i] = src[i];
c0102f2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f2e:	8b 55 08             	mov    0x8(%ebp),%edx
c0102f31:	01 c2                	add    %eax,%edx
c0102f33:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f36:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102f39:	01 c8                	add    %ecx,%eax
c0102f3b:	0f b6 00             	movzbl (%eax),%eax
c0102f3e:	88 02                	mov    %al,(%edx)
    return dest;
c0102f40:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0102f43:	c9                   	leave  
c0102f44:	c3                   	ret    

c0102f45 <strncpy>:
 * @param source string
 * @param maximal number of chars
 * @return destination string
 */
char *strncpy(char *dest, const char *src,size_t n)
{
c0102f45:	55                   	push   %ebp
c0102f46:	89 e5                	mov    %esp,%ebp
c0102f48:	83 ec 10             	sub    $0x10,%esp
    size_t i;
    bool eos = false;
c0102f4b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    for (i = 0; i < n; i++)
c0102f52:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0102f59:	eb 42                	jmp    c0102f9d <strncpy+0x58>
    {
        if (!eos)
c0102f5b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0102f5f:	75 2d                	jne    c0102f8e <strncpy+0x49>
        {
            if (src[i] == '\0')
c0102f61:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f64:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102f67:	01 d0                	add    %edx,%eax
c0102f69:	0f b6 00             	movzbl (%eax),%eax
c0102f6c:	84 c0                	test   %al,%al
c0102f6e:	75 07                	jne    c0102f77 <strncpy+0x32>
            {
                eos = true;
c0102f70:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
            }
            dest[i] = src[i];
c0102f77:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f7a:	8b 55 08             	mov    0x8(%ebp),%edx
c0102f7d:	01 c2                	add    %eax,%edx
c0102f7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f82:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0102f85:	01 c8                	add    %ecx,%eax
c0102f87:	0f b6 00             	movzbl (%eax),%eax
c0102f8a:	88 02                	mov    %al,(%edx)
c0102f8c:	eb 0b                	jmp    c0102f99 <strncpy+0x54>
        }
        else
        {
            dest[i] = '\0';
c0102f8e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102f91:	8b 55 08             	mov    0x8(%ebp),%edx
c0102f94:	01 d0                	add    %edx,%eax
c0102f96:	c6 00 00             	movb   $0x0,(%eax)
 */
char *strncpy(char *dest, const char *src,size_t n)
{
    size_t i;
    bool eos = false;
    for (i = 0; i < n; i++)
c0102f99:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0102f9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102fa0:	3b 45 10             	cmp    0x10(%ebp),%eax
c0102fa3:	72 b6                	jb     c0102f5b <strncpy+0x16>
        {
            dest[i] = '\0';
        }

    }
    return dest;
c0102fa5:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0102fa8:	c9                   	leave  
c0102fa9:	c3                   	ret    

c0102faa <strcat>:
 * @param dest destination string
 * @param src source string
 * @return destination string
 */
char *strcat(char *dest, const char *src)
{
c0102faa:	55                   	push   %ebp
c0102fab:	89 e5                	mov    %esp,%ebp
c0102fad:	83 ec 18             	sub    $0x18,%esp
    size_t n = strlen(dest);
c0102fb0:	8b 45 08             	mov    0x8(%ebp),%eax
c0102fb3:	89 04 24             	mov    %eax,(%esp)
c0102fb6:	e8 12 ff ff ff       	call   c0102ecd <strlen>
c0102fbb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    strcpy((char*)(dest+n),src);
c0102fbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102fc1:	8b 55 08             	mov    0x8(%ebp),%edx
c0102fc4:	01 c2                	add    %eax,%edx
c0102fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102fc9:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102fcd:	89 14 24             	mov    %edx,(%esp)
c0102fd0:	e8 1f ff ff ff       	call   c0102ef4 <strcpy>
    return dest;
c0102fd5:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0102fd8:	c9                   	leave  
c0102fd9:	c3                   	ret    

c0102fda <strncat>:
 * @param src source string
 * @param n maximal number of chars
 * @return destination string
 */
char *strncat(char *dest, const char *src, size_t n)
{
c0102fda:	55                   	push   %ebp
c0102fdb:	89 e5                	mov    %esp,%ebp
c0102fdd:	83 ec 1c             	sub    $0x1c,%esp
    size_t i = strlen(dest);
c0102fe0:	8b 45 08             	mov    0x8(%ebp),%eax
c0102fe3:	89 04 24             	mov    %eax,(%esp)
c0102fe6:	e8 e2 fe ff ff       	call   c0102ecd <strlen>
c0102feb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    strncpy((char*)(dest+i),src,n);
c0102fee:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102ff1:	8b 55 08             	mov    0x8(%ebp),%edx
c0102ff4:	01 c2                	add    %eax,%edx
c0102ff6:	8b 45 10             	mov    0x10(%ebp),%eax
c0102ff9:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102ffd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103000:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103004:	89 14 24             	mov    %edx,(%esp)
c0103007:	e8 39 ff ff ff       	call   c0102f45 <strncpy>
    return dest;
c010300c:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010300f:	c9                   	leave  
c0103010:	c3                   	ret    

c0103011 <strcmp>:
 * @return = 0 strings are similar
 *  > 0 value of the first different char of string0 is bigger
 *  < 0 value of the first different char of string1 is bigger
 */
int strcmp(const char *str0, const char *str1)
{
c0103011:	55                   	push   %ebp
c0103012:	89 e5                	mov    %esp,%ebp
c0103014:	83 ec 10             	sub    $0x10,%esp
    size_t i;
    for (i = 0; str0[i] == str1[i] && str0[i] != 0; i++);
c0103017:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010301e:	eb 04                	jmp    c0103024 <strcmp+0x13>
c0103020:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0103024:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103027:	8b 55 08             	mov    0x8(%ebp),%edx
c010302a:	01 d0                	add    %edx,%eax
c010302c:	0f b6 10             	movzbl (%eax),%edx
c010302f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103032:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0103035:	01 c8                	add    %ecx,%eax
c0103037:	0f b6 00             	movzbl (%eax),%eax
c010303a:	38 c2                	cmp    %al,%dl
c010303c:	75 0f                	jne    c010304d <strcmp+0x3c>
c010303e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103041:	8b 55 08             	mov    0x8(%ebp),%edx
c0103044:	01 d0                	add    %edx,%eax
c0103046:	0f b6 00             	movzbl (%eax),%eax
c0103049:	84 c0                	test   %al,%al
c010304b:	75 d3                	jne    c0103020 <strcmp+0xf>
    int ret = str0[i] - str1[i];
c010304d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103050:	8b 55 08             	mov    0x8(%ebp),%edx
c0103053:	01 d0                	add    %edx,%eax
c0103055:	0f b6 00             	movzbl (%eax),%eax
c0103058:	0f be d0             	movsbl %al,%edx
c010305b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010305e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0103061:	01 c8                	add    %ecx,%eax
c0103063:	0f b6 00             	movzbl (%eax),%eax
c0103066:	0f be c0             	movsbl %al,%eax
c0103069:	89 d1                	mov    %edx,%ecx
c010306b:	29 c1                	sub    %eax,%ecx
c010306d:	89 c8                	mov    %ecx,%eax
c010306f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return ret;
c0103072:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0103075:	c9                   	leave  
c0103076:	c3                   	ret    

c0103077 <strncmp>:
 * @return = 0 strings are similar
 *  > 0 value of the first different char of string0 is bigger
 *  < 0 value of the first different char of string1 is bigger
 */
int strncmp(const char *str0, const char *str1, size_t n)
{
c0103077:	55                   	push   %ebp
c0103078:	89 e5                	mov    %esp,%ebp
c010307a:	83 ec 10             	sub    $0x10,%esp
    uint32_t i;
    int ret = 0;
c010307d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    for (i = 0; str0[i] == str1[i] && str0[i] != 0 && i < n-1; i++);
c0103084:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010308b:	eb 04                	jmp    c0103091 <strncmp+0x1a>
c010308d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0103091:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103094:	8b 55 08             	mov    0x8(%ebp),%edx
c0103097:	01 d0                	add    %edx,%eax
c0103099:	0f b6 10             	movzbl (%eax),%edx
c010309c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010309f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c01030a2:	01 c8                	add    %ecx,%eax
c01030a4:	0f b6 00             	movzbl (%eax),%eax
c01030a7:	38 c2                	cmp    %al,%dl
c01030a9:	75 1a                	jne    c01030c5 <strncmp+0x4e>
c01030ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01030ae:	8b 55 08             	mov    0x8(%ebp),%edx
c01030b1:	01 d0                	add    %edx,%eax
c01030b3:	0f b6 00             	movzbl (%eax),%eax
c01030b6:	84 c0                	test   %al,%al
c01030b8:	74 0b                	je     c01030c5 <strncmp+0x4e>
c01030ba:	8b 45 10             	mov    0x10(%ebp),%eax
c01030bd:	83 e8 01             	sub    $0x1,%eax
c01030c0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c01030c3:	77 c8                	ja     c010308d <strncmp+0x16>
    ret = str0[i] - str1[i];
c01030c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01030c8:	8b 55 08             	mov    0x8(%ebp),%edx
c01030cb:	01 d0                	add    %edx,%eax
c01030cd:	0f b6 00             	movzbl (%eax),%eax
c01030d0:	0f be d0             	movsbl %al,%edx
c01030d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01030d6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c01030d9:	01 c8                	add    %ecx,%eax
c01030db:	0f b6 00             	movzbl (%eax),%eax
c01030de:	0f be c0             	movsbl %al,%eax
c01030e1:	89 d1                	mov    %edx,%ecx
c01030e3:	29 c1                	sub    %eax,%ecx
c01030e5:	89 c8                	mov    %ecx,%eax
c01030e7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return ret;
c01030ea:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c01030ed:	c9                   	leave  
c01030ee:	c3                   	ret    

c01030ef <strchr>:
 * @param c searched character
 * @return pointer to the first similar char
 * NULL=no char in str is similar to c
 */
char *strchr(const char *str, int c)
{
c01030ef:	55                   	push   %ebp
c01030f0:	89 e5                	mov    %esp,%ebp
c01030f2:	83 ec 10             	sub    $0x10,%esp
    int i = 0;
c01030f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    while (str[i] != (char)c && str[i] != 0)
c01030fc:	eb 04                	jmp    c0103102 <strchr+0x13>
    {
        i++;
c01030fe:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 * NULL=no char in str is similar to c
 */
char *strchr(const char *str, int c)
{
    int i = 0;
    while (str[i] != (char)c && str[i] != 0)
c0103102:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0103105:	8b 45 08             	mov    0x8(%ebp),%eax
c0103108:	01 d0                	add    %edx,%eax
c010310a:	0f b6 10             	movzbl (%eax),%edx
c010310d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103110:	38 c2                	cmp    %al,%dl
c0103112:	74 0f                	je     c0103123 <strchr+0x34>
c0103114:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0103117:	8b 45 08             	mov    0x8(%ebp),%eax
c010311a:	01 d0                	add    %edx,%eax
c010311c:	0f b6 00             	movzbl (%eax),%eax
c010311f:	84 c0                	test   %al,%al
c0103121:	75 db                	jne    c01030fe <strchr+0xf>
    {
        i++;
    }
    if (str[i])
c0103123:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0103126:	8b 45 08             	mov    0x8(%ebp),%eax
c0103129:	01 d0                	add    %edx,%eax
c010312b:	0f b6 00             	movzbl (%eax),%eax
c010312e:	84 c0                	test   %al,%al
c0103130:	74 0a                	je     c010313c <strchr+0x4d>
    {
        return (char*)(str+i);
c0103132:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0103135:	8b 45 08             	mov    0x8(%ebp),%eax
c0103138:	01 d0                	add    %edx,%eax
c010313a:	eb 05                	jmp    c0103141 <strchr+0x52>
    }
    return NULL;
c010313c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103141:	c9                   	leave  
c0103142:	c3                   	ret    

c0103143 <strrchr>:
 * @param c searched character
 * @return pointer to the last similar char
 * NULL=no char in str is similar to c
 */
char *strrchr(const char *str, int c)
{
c0103143:	55                   	push   %ebp
c0103144:	89 e5                	mov    %esp,%ebp
c0103146:	83 ec 10             	sub    $0x10,%esp
    int i = 0;
c0103149:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char* ret = NULL;
c0103150:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while (str[i] != 0)
c0103157:	eb 21                	jmp    c010317a <strrchr+0x37>
    {
        if (str[i] == (char)c)
c0103159:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010315c:	8b 45 08             	mov    0x8(%ebp),%eax
c010315f:	01 d0                	add    %edx,%eax
c0103161:	0f b6 10             	movzbl (%eax),%edx
c0103164:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103167:	38 c2                	cmp    %al,%dl
c0103169:	75 0b                	jne    c0103176 <strrchr+0x33>
        {
            ret = (char*)(str+i);
c010316b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010316e:	8b 45 08             	mov    0x8(%ebp),%eax
c0103171:	01 d0                	add    %edx,%eax
c0103173:	89 45 f8             	mov    %eax,-0x8(%ebp)
        }
        i++;
c0103176:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 */
char *strrchr(const char *str, int c)
{
    int i = 0;
    char* ret = NULL;
    while (str[i] != 0)
c010317a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010317d:	8b 45 08             	mov    0x8(%ebp),%eax
c0103180:	01 d0                	add    %edx,%eax
c0103182:	0f b6 00             	movzbl (%eax),%eax
c0103185:	84 c0                	test   %al,%al
c0103187:	75 d0                	jne    c0103159 <strrchr+0x16>
        {
            ret = (char*)(str+i);
        }
        i++;
    }
    return ret;
c0103189:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c010318c:	c9                   	leave  
c010318d:	c3                   	ret    

c010318e <strtok>:
	char* strpbrk(const char* st0, const char* st1) {}
	char* strstr(const char* st0, const char* st1) {}
	char* strerror(size_t n) {}
*/
char *strtok(char *string, const char *delimiters)
{
c010318e:	55                   	push   %ebp
c010318f:	89 e5                	mov    %esp,%ebp
c0103191:	83 ec 28             	sub    $0x28,%esp
    static char *s = NULL;
    static int num_del = 0;
    if(string != NULL)
c0103194:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0103198:	74 1a                	je     c01031b4 <strtok+0x26>
    {
        s = string;
c010319a:	8b 45 08             	mov    0x8(%ebp),%eax
c010319d:	a3 00 90 11 c0       	mov    %eax,0xc0119000
        num_del = strlen(delimiters);
c01031a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01031a5:	89 04 24             	mov    %eax,(%esp)
c01031a8:	e8 20 fd ff ff       	call   c0102ecd <strlen>
c01031ad:	a3 04 90 11 c0       	mov    %eax,0xc0119004
c01031b2:	eb 1b                	jmp    c01031cf <strtok+0x41>
    }
    else
    {
        if(s == NULL)
c01031b4:	a1 00 90 11 c0       	mov    0xc0119000,%eax
c01031b9:	85 c0                	test   %eax,%eax
c01031bb:	75 0a                	jne    c01031c7 <strtok+0x39>
        {
            return NULL;
c01031bd:	b8 00 00 00 00       	mov    $0x0,%eax
c01031c2:	e9 da 00 00 00       	jmp    c01032a1 <strtok+0x113>
        }
        string = s;
c01031c7:	a1 00 90 11 c0       	mov    0xc0119000,%eax
c01031cc:	89 45 08             	mov    %eax,0x8(%ebp)
    }
    int i, j = 0;
c01031cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(*s != '\0')
c01031d6:	e9 86 00 00 00       	jmp    c0103261 <strtok+0xd3>
    {
        for(i = 0; i < num_del; i++)
c01031db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01031e2:	eb 62                	jmp    c0103246 <strtok+0xb8>
        {
            if(*s == delimiters[i])
c01031e4:	a1 00 90 11 c0       	mov    0xc0119000,%eax
c01031e9:	0f b6 10             	movzbl (%eax),%edx
c01031ec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c01031ef:	8b 45 0c             	mov    0xc(%ebp),%eax
c01031f2:	01 c8                	add    %ecx,%eax
c01031f4:	0f b6 00             	movzbl (%eax),%eax
c01031f7:	38 c2                	cmp    %al,%dl
c01031f9:	75 47                	jne    c0103242 <strtok+0xb4>
            {
                s++;
c01031fb:	a1 00 90 11 c0       	mov    0xc0119000,%eax
c0103200:	83 c0 01             	add    $0x1,%eax
c0103203:	a3 00 90 11 c0       	mov    %eax,0xc0119000
                char *ret = (char*) malloc(j+1);
c0103208:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010320b:	83 c0 01             	add    $0x1,%eax
c010320e:	89 04 24             	mov    %eax,(%esp)
c0103211:	e8 2f 8d 00 00       	call   c010bf45 <malloc>
c0103216:	89 45 ec             	mov    %eax,-0x14(%ebp)
                memcpy(ret, string, j);
c0103219:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010321c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103220:	8b 45 08             	mov    0x8(%ebp),%eax
c0103223:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103227:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010322a:	89 04 24             	mov    %eax,(%esp)
c010322d:	e8 71 00 00 00       	call   c01032a3 <memcpy>
                ret[j] = '\0';
c0103232:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103235:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103238:	01 d0                	add    %edx,%eax
c010323a:	c6 00 00             	movb   $0x0,(%eax)
                return ret;
c010323d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103240:	eb 5f                	jmp    c01032a1 <strtok+0x113>
        string = s;
    }
    int i, j = 0;
    while(*s != '\0')
    {
        for(i = 0; i < num_del; i++)
c0103242:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0103246:	a1 04 90 11 c0       	mov    0xc0119004,%eax
c010324b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c010324e:	7c 94                	jl     c01031e4 <strtok+0x56>
                memcpy(ret, string, j);
                ret[j] = '\0';
                return ret;
            }
        }
        s++;
c0103250:	a1 00 90 11 c0       	mov    0xc0119000,%eax
c0103255:	83 c0 01             	add    $0x1,%eax
c0103258:	a3 00 90 11 c0       	mov    %eax,0xc0119000
        j++;
c010325d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            return NULL;
        }
        string = s;
    }
    int i, j = 0;
    while(*s != '\0')
c0103261:	a1 00 90 11 c0       	mov    0xc0119000,%eax
c0103266:	0f b6 00             	movzbl (%eax),%eax
c0103269:	84 c0                	test   %al,%al
c010326b:	0f 85 6a ff ff ff    	jne    c01031db <strtok+0x4d>
        }
        s++;
        j++;
    }

    char *ret = (char*) malloc(j+1);
c0103271:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103274:	83 c0 01             	add    $0x1,%eax
c0103277:	89 04 24             	mov    %eax,(%esp)
c010327a:	e8 c6 8c 00 00       	call   c010bf45 <malloc>
c010327f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    strcpy(ret, string);
c0103282:	8b 45 08             	mov    0x8(%ebp),%eax
c0103285:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103289:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010328c:	89 04 24             	mov    %eax,(%esp)
c010328f:	e8 60 fc ff ff       	call   c0102ef4 <strcpy>

    s = NULL;
c0103294:	c7 05 00 90 11 c0 00 	movl   $0x0,0xc0119000
c010329b:	00 00 00 
    return ret;
c010329e:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c01032a1:	c9                   	leave  
c01032a2:	c3                   	ret    

c01032a3 <memcpy>:
 * @param source source string
 * @param size size of source area
 * @return pointer to destination area
 */
void *memcpy(void *destination, const void *source, size_t size)
{
c01032a3:	55                   	push   %ebp
c01032a4:	89 e5                	mov    %esp,%ebp
c01032a6:	83 ec 10             	sub    $0x10,%esp
    uint8_t *dest = destination;
c01032a9:	8b 45 08             	mov    0x8(%ebp),%eax
c01032ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
    const uint8_t *sour = source;
c01032af:	8b 45 0c             	mov    0xc(%ebp),%eax
c01032b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t i;
    for (i = 0; i < size; i++)
c01032b5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01032bc:	eb 19                	jmp    c01032d7 <memcpy+0x34>
    {
        dest[i] = sour[i];
c01032be:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01032c1:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01032c4:	01 c2                	add    %eax,%edx
c01032c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01032c9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c01032cc:	01 c8                	add    %ecx,%eax
c01032ce:	0f b6 00             	movzbl (%eax),%eax
c01032d1:	88 02                	mov    %al,(%edx)
void *memcpy(void *destination, const void *source, size_t size)
{
    uint8_t *dest = destination;
    const uint8_t *sour = source;
    size_t i;
    for (i = 0; i < size; i++)
c01032d3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01032d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01032da:	3b 45 10             	cmp    0x10(%ebp),%eax
c01032dd:	72 df                	jb     c01032be <memcpy+0x1b>
    {
        dest[i] = sour[i];
    }
    return destination;
c01032df:	8b 45 08             	mov    0x8(%ebp),%eax
}
c01032e2:	c9                   	leave  
c01032e3:	c3                   	ret    

c01032e4 <memmove>:
 * @param source source area
 * @param num number of bytes to copy
 * @return pointer to destination area
 */
void *memmove(void *destination, const void *source, size_t num)
{
c01032e4:	55                   	push   %ebp
c01032e5:	89 e5                	mov    %esp,%ebp
c01032e7:	83 ec 1c             	sub    $0x1c,%esp
    uint8_t *dest = destination;
c01032ea:	8b 45 08             	mov    0x8(%ebp),%eax
c01032ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
    const uint8_t *src = source;
c01032f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01032f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (dest > src && src + num > dest && num != 0)
c01032f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01032f9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01032fc:	76 3a                	jbe    c0103338 <memmove+0x54>
c01032fe:	8b 45 10             	mov    0x10(%ebp),%eax
c0103301:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103304:	01 d0                	add    %edx,%eax
c0103306:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0103309:	76 2d                	jbe    c0103338 <memmove+0x54>
c010330b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010330f:	74 27                	je     c0103338 <memmove+0x54>
    {
        size_t i = num;
c0103311:	8b 45 10             	mov    0x10(%ebp),%eax
c0103314:	89 45 fc             	mov    %eax,-0x4(%ebp)
        do
        {
            i--;
c0103317:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
            dest[i] = src[i];
c010331b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010331e:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0103321:	01 c2                	add    %eax,%edx
c0103323:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103326:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0103329:	01 c8                	add    %ecx,%eax
c010332b:	0f b6 00             	movzbl (%eax),%eax
c010332e:	88 02                	mov    %al,(%edx)
        }
        while (i != 0);
c0103330:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0103334:	75 e1                	jne    c0103317 <memmove+0x33>
void *memmove(void *destination, const void *source, size_t num)
{
    uint8_t *dest = destination;
    const uint8_t *src = source;
    if (dest > src && src + num > dest && num != 0)
    {
c0103336:	eb 19                	jmp    c0103351 <memmove+0x6d>
        while (i != 0);
    }
    else
    {
        // because we know that memcpy copy bytes from left to right.
        memcpy(dest, src, num);
c0103338:	8b 45 10             	mov    0x10(%ebp),%eax
c010333b:	89 44 24 08          	mov    %eax,0x8(%esp)
c010333f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103342:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103346:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0103349:	89 04 24             	mov    %eax,(%esp)
c010334c:	e8 52 ff ff ff       	call   c01032a3 <memcpy>
    }
    return destination;
c0103351:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0103354:	c9                   	leave  
c0103355:	c3                   	ret    

c0103356 <memcmp>:
 * @return = 0 areas are similar
 *  > 0 the value of the first different byte of area0 is bigger
 *  < 0 the value of the first different byte of area1 is bigger
 */
int memcmp(const void *mem0, const void *mem1, size_t n)
{
c0103356:	55                   	push   %ebp
c0103357:	89 e5                	mov    %esp,%ebp
c0103359:	83 ec 10             	sub    $0x10,%esp
    const char *st0 = mem0;
c010335c:	8b 45 08             	mov    0x8(%ebp),%eax
c010335f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    const char *st1 = mem1;
c0103362:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103365:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t i;
    for (i = 0; st0[i] == st1[i] && i < n-1; i++);
c0103368:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010336f:	eb 04                	jmp    c0103375 <memcmp+0x1f>
c0103371:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0103375:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103378:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010337b:	01 d0                	add    %edx,%eax
c010337d:	0f b6 10             	movzbl (%eax),%edx
c0103380:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103383:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0103386:	01 c8                	add    %ecx,%eax
c0103388:	0f b6 00             	movzbl (%eax),%eax
c010338b:	38 c2                	cmp    %al,%dl
c010338d:	75 0b                	jne    c010339a <memcmp+0x44>
c010338f:	8b 45 10             	mov    0x10(%ebp),%eax
c0103392:	83 e8 01             	sub    $0x1,%eax
c0103395:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0103398:	77 d7                	ja     c0103371 <memcmp+0x1b>
    return st0[i] - st1[i];
c010339a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010339d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01033a0:	01 d0                	add    %edx,%eax
c01033a2:	0f b6 00             	movzbl (%eax),%eax
c01033a5:	0f be d0             	movsbl %al,%edx
c01033a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01033ab:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c01033ae:	01 c8                	add    %ecx,%eax
c01033b0:	0f b6 00             	movzbl (%eax),%eax
c01033b3:	0f be c0             	movsbl %al,%eax
c01033b6:	89 d1                	mov    %edx,%ecx
c01033b8:	29 c1                	sub    %eax,%ecx
c01033ba:	89 c8                	mov    %ecx,%eax
}
c01033bc:	c9                   	leave  
c01033bd:	c3                   	ret    

c01033be <memchr>:
 * @param n Size of mem.
 * @return Pointer to the fist similar value
 *  or NULL if no value in mem is similar to c.
 */
void *memchr(const void *mem, int c, size_t n)
{
c01033be:	55                   	push   %ebp
c01033bf:	89 e5                	mov    %esp,%ebp
c01033c1:	83 ec 10             	sub    $0x10,%esp
    size_t i;
    const unsigned char *str = mem;
c01033c4:	8b 45 08             	mov    0x8(%ebp),%eax
c01033c7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    const unsigned char value = (unsigned char) c;
c01033ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c01033cd:	88 45 f7             	mov    %al,-0x9(%ebp)
    for (i = 0; str[i] != value && i < n-1; i++);
c01033d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01033d7:	eb 04                	jmp    c01033dd <memchr+0x1f>
c01033d9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01033dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01033e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01033e3:	01 d0                	add    %edx,%eax
c01033e5:	0f b6 00             	movzbl (%eax),%eax
c01033e8:	3a 45 f7             	cmp    -0x9(%ebp),%al
c01033eb:	74 0b                	je     c01033f8 <memchr+0x3a>
c01033ed:	8b 45 10             	mov    0x10(%ebp),%eax
c01033f0:	83 e8 01             	sub    $0x1,%eax
c01033f3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c01033f6:	77 e1                	ja     c01033d9 <memchr+0x1b>

    if (str[i] == value)
c01033f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01033fb:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01033fe:	01 d0                	add    %edx,%eax
c0103400:	0f b6 00             	movzbl (%eax),%eax
c0103403:	3a 45 f7             	cmp    -0x9(%ebp),%al
c0103406:	75 0a                	jne    c0103412 <memchr+0x54>
    {
        return (void*) (str+i);
c0103408:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010340b:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010340e:	01 d0                	add    %edx,%eax
c0103410:	eb 05                	jmp    c0103417 <memchr+0x59>
    }
    else
    {
        return NULL;
c0103412:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c0103417:	c9                   	leave  
c0103418:	c3                   	ret    

c0103419 <memset>:
 * @param c Value to be set. The function will use a unsigned char conversion of this value.
 * @param n size of mem.
 * @return returns <code>mem</code>.
 */
void *memset(void *mem, int c, size_t n)
{
c0103419:	55                   	push   %ebp
c010341a:	89 e5                	mov    %esp,%ebp
c010341c:	83 ec 10             	sub    $0x10,%esp
    unsigned char *str = mem;
c010341f:	8b 45 08             	mov    0x8(%ebp),%eax
c0103422:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t i;
    for (i = 0; i < n; i++)
c0103425:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010342c:	eb 11                	jmp    c010343f <memset+0x26>
    {
        str[i] = (unsigned char) c;
c010342e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103431:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0103434:	01 c2                	add    %eax,%edx
c0103436:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103439:	88 02                	mov    %al,(%edx)
 */
void *memset(void *mem, int c, size_t n)
{
    unsigned char *str = mem;
    size_t i;
    for (i = 0; i < n; i++)
c010343b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010343f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103442:	3b 45 10             	cmp    0x10(%ebp),%eax
c0103445:	72 e7                	jb     c010342e <memset+0x15>
    {
        str[i] = (unsigned char) c;
    }
    return mem;
c0103447:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010344a:	c9                   	leave  
c010344b:	c3                   	ret    

c010344c <isalnum>:
 * @param character c as int
 * @return true  -> c is an alphanumeric character
 * @return false -> c isn't an alphanumeric character
 **/
int isalnum(int c)
{
c010344c:	55                   	push   %ebp
c010344d:	89 e5                	mov    %esp,%ebp
    if ( (c > 0x40 && c < 0x5B) || (c > 0x60 && c < 0x7B) || (c > 0x2F && c < 0x3A) )
c010344f:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0103453:	7e 06                	jle    c010345b <isalnum+0xf>
c0103455:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c0103459:	7e 18                	jle    c0103473 <isalnum+0x27>
c010345b:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c010345f:	7e 06                	jle    c0103467 <isalnum+0x1b>
c0103461:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c0103465:	7e 0c                	jle    c0103473 <isalnum+0x27>
c0103467:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c010346b:	7e 0d                	jle    c010347a <isalnum+0x2e>
c010346d:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0103471:	7f 07                	jg     c010347a <isalnum+0x2e>
    {
        return true;
c0103473:	b8 01 00 00 00       	mov    $0x1,%eax
c0103478:	eb 05                	jmp    c010347f <isalnum+0x33>
    }
    return false;
c010347a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010347f:	5d                   	pop    %ebp
c0103480:	c3                   	ret    

c0103481 <isalpha>:
 * @param character c as int
 * @return true  -> c is an alphabetical character
 * @return false -> c isn't an alphabetical character
 **/
int isalpha(int c)
{
c0103481:	55                   	push   %ebp
c0103482:	89 e5                	mov    %esp,%ebp
    if ( (c > 0x40 && c < 0x5B) || (c > 0x60 && c < 0x7B) )
c0103484:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0103488:	7e 06                	jle    c0103490 <isalpha+0xf>
c010348a:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c010348e:	7e 0c                	jle    c010349c <isalpha+0x1b>
c0103490:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c0103494:	7e 0d                	jle    c01034a3 <isalpha+0x22>
c0103496:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c010349a:	7f 07                	jg     c01034a3 <isalpha+0x22>
    {
        return true;
c010349c:	b8 01 00 00 00       	mov    $0x1,%eax
c01034a1:	eb 05                	jmp    c01034a8 <isalpha+0x27>
    }
    return false;
c01034a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01034a8:	5d                   	pop    %ebp
c01034a9:	c3                   	ret    

c01034aa <iscntrl>:
 * @param character c as int
 * @return true  -> c is a control Key value
 * @return false -> c isn't a control key value
 **/
int iscntrl(int c)
{
c01034aa:	55                   	push   %ebp
c01034ab:	89 e5                	mov    %esp,%ebp
    if ( (c >= 0x0 && c > 0x20) || c == 0x7F)
c01034ad:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c01034b1:	78 06                	js     c01034b9 <iscntrl+0xf>
c01034b3:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c01034b7:	7f 06                	jg     c01034bf <iscntrl+0x15>
c01034b9:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
c01034bd:	75 07                	jne    c01034c6 <iscntrl+0x1c>
    {
        return true;
c01034bf:	b8 01 00 00 00       	mov    $0x1,%eax
c01034c4:	eb 05                	jmp    c01034cb <iscntrl+0x21>
    }
    return false;
c01034c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01034cb:	5d                   	pop    %ebp
c01034cc:	c3                   	ret    

c01034cd <isdigit>:
 * @param character c as int
 * @return true  -> c is a digit
 * @return false -> c isn't an digit
 **/
int isdigit(int c)
{
c01034cd:	55                   	push   %ebp
c01034ce:	89 e5                	mov    %esp,%ebp
    if (c > 0x2F && c < 0x3A)
c01034d0:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c01034d4:	7e 0d                	jle    c01034e3 <isdigit+0x16>
c01034d6:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c01034da:	7f 07                	jg     c01034e3 <isdigit+0x16>
    {
        return true;
c01034dc:	b8 01 00 00 00       	mov    $0x1,%eax
c01034e1:	eb 05                	jmp    c01034e8 <isdigit+0x1b>
    }
    return false;
c01034e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01034e8:	5d                   	pop    %ebp
c01034e9:	c3                   	ret    

c01034ea <isgraph>:
 * @param character c as int
 * @return true  -> c is a graphical character
 * @return false -> c isn't a graphical character
 **/
int isgraph(int c)
{
c01034ea:	55                   	push   %ebp
c01034eb:	89 e5                	mov    %esp,%ebp
    if (c > 0x20 && c < 0x7F)
c01034ed:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c01034f1:	7e 0d                	jle    c0103500 <isgraph+0x16>
c01034f3:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c01034f7:	7f 07                	jg     c0103500 <isgraph+0x16>
    {
        return true;
c01034f9:	b8 01 00 00 00       	mov    $0x1,%eax
c01034fe:	eb 05                	jmp    c0103505 <isgraph+0x1b>
    }
    return false;
c0103500:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103505:	5d                   	pop    %ebp
c0103506:	c3                   	ret    

c0103507 <islower>:
 * @param character c as int
 * @return true  -> c is a lower character
 * @return false -> c isn't a lower character
 **/
int islower(int c)
{
c0103507:	55                   	push   %ebp
c0103508:	89 e5                	mov    %esp,%ebp
    if (c > 0x60 && c < 0x7B)
c010350a:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c010350e:	7e 0d                	jle    c010351d <islower+0x16>
c0103510:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c0103514:	7f 07                	jg     c010351d <islower+0x16>
    {
        return true;
c0103516:	b8 01 00 00 00       	mov    $0x1,%eax
c010351b:	eb 05                	jmp    c0103522 <islower+0x1b>
    }
    return false;
c010351d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103522:	5d                   	pop    %ebp
c0103523:	c3                   	ret    

c0103524 <isprint>:
 * @param character c as int
 * @return true  -> c is an printable character
 * @return false -> c isn't an printable character
 **/
int isprint(int c)
{
c0103524:	55                   	push   %ebp
c0103525:	89 e5                	mov    %esp,%ebp
    if (c > 0x1F && c < 0x7F)
c0103527:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c010352b:	7e 0d                	jle    c010353a <isprint+0x16>
c010352d:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c0103531:	7f 07                	jg     c010353a <isprint+0x16>
    {
        return true;
c0103533:	b8 01 00 00 00       	mov    $0x1,%eax
c0103538:	eb 05                	jmp    c010353f <isprint+0x1b>
    }
    return false;
c010353a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010353f:	5d                   	pop    %ebp
c0103540:	c3                   	ret    

c0103541 <ispunct>:
 * @param character c as int
 * @return true  -> c is a visible character which is not an alphanumerical
 * @return false -> c isn't a visible character which is not an alphanumerical
 **/
int ispunct(int c)
{
c0103541:	55                   	push   %ebp
c0103542:	89 e5                	mov    %esp,%ebp
    if ( (c > 0x20 && c < 0x30) || (c > 0x39 && c < 0x41) || (c > 0x5A && c < 0x61) || (c > 0x7A && c < 0x7F) )
c0103544:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0103548:	7e 06                	jle    c0103550 <ispunct+0xf>
c010354a:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c010354e:	7e 24                	jle    c0103574 <ispunct+0x33>
c0103550:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0103554:	7e 06                	jle    c010355c <ispunct+0x1b>
c0103556:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c010355a:	7e 18                	jle    c0103574 <ispunct+0x33>
c010355c:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c0103560:	7e 06                	jle    c0103568 <ispunct+0x27>
c0103562:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c0103566:	7e 0c                	jle    c0103574 <ispunct+0x33>
c0103568:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
c010356c:	7e 0d                	jle    c010357b <ispunct+0x3a>
c010356e:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c0103572:	7f 07                	jg     c010357b <ispunct+0x3a>
    {
        return true;
c0103574:	b8 01 00 00 00       	mov    $0x1,%eax
c0103579:	eb 05                	jmp    c0103580 <ispunct+0x3f>
    }
    return false;
c010357b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103580:	5d                   	pop    %ebp
c0103581:	c3                   	ret    

c0103582 <isspace>:
 * @param character c as int
 * @return true  -> c is a space character
 * @return false -> c isn't a space character
 **/
int isspace(int c)
{
c0103582:	55                   	push   %ebp
c0103583:	89 e5                	mov    %esp,%ebp
    if (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v')
c0103585:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0103589:	74 1e                	je     c01035a9 <isspace+0x27>
c010358b:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c010358f:	74 18                	je     c01035a9 <isspace+0x27>
c0103591:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0103595:	74 12                	je     c01035a9 <isspace+0x27>
c0103597:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c010359b:	74 0c                	je     c01035a9 <isspace+0x27>
c010359d:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c01035a1:	74 06                	je     c01035a9 <isspace+0x27>
c01035a3:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c01035a7:	75 07                	jne    c01035b0 <isspace+0x2e>
    {
        return true;
c01035a9:	b8 01 00 00 00       	mov    $0x1,%eax
c01035ae:	eb 05                	jmp    c01035b5 <isspace+0x33>
    }
    return false;
c01035b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01035b5:	5d                   	pop    %ebp
c01035b6:	c3                   	ret    

c01035b7 <isupper>:
 * @param character c as int
 * @return true  -> c is an upper alphabetical character
 * @return false -> c isn't an upper alphabetical character
 **/
int isupper(int c)
{
c01035b7:	55                   	push   %ebp
c01035b8:	89 e5                	mov    %esp,%ebp
    if (c > 0x40 && c < 0x5B)
c01035ba:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c01035be:	7e 0d                	jle    c01035cd <isupper+0x16>
c01035c0:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c01035c4:	7f 07                	jg     c01035cd <isupper+0x16>
    {
        return true;
c01035c6:	b8 01 00 00 00       	mov    $0x1,%eax
c01035cb:	eb 05                	jmp    c01035d2 <isupper+0x1b>
    }
    return false;
c01035cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01035d2:	5d                   	pop    %ebp
c01035d3:	c3                   	ret    

c01035d4 <isxdigit>:
 * @param character c as int
 * @return true  -> c is a hexadecimal digit
 * @return false -> c isn't a hexadecimal digit
 **/
int isxdigit(int c)
{
c01035d4:	55                   	push   %ebp
c01035d5:	89 e5                	mov    %esp,%ebp
    if ( (c > 0x2F && c < 0x3A) || (c > 0x40 && c < 0x47) || (c > 0x60 && c < 0x67) )
c01035d7:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c01035db:	7e 06                	jle    c01035e3 <isxdigit+0xf>
c01035dd:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c01035e1:	7e 18                	jle    c01035fb <isxdigit+0x27>
c01035e3:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c01035e7:	7e 06                	jle    c01035ef <isxdigit+0x1b>
c01035e9:	83 7d 08 46          	cmpl   $0x46,0x8(%ebp)
c01035ed:	7e 0c                	jle    c01035fb <isxdigit+0x27>
c01035ef:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
c01035f3:	7e 0d                	jle    c0103602 <isxdigit+0x2e>
c01035f5:	83 7d 08 66          	cmpl   $0x66,0x8(%ebp)
c01035f9:	7f 07                	jg     c0103602 <isxdigit+0x2e>
    {
        return true;
c01035fb:	b8 01 00 00 00       	mov    $0x1,%eax
c0103600:	eb 05                	jmp    c0103607 <isxdigit+0x33>
    }
    return false;
c0103602:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103607:	5d                   	pop    %ebp
c0103608:	c3                   	ret    

c0103609 <tolower>:
 * convert upper to lower character
 * @param upper character c as int
 * @return c as lower character as int
 **/
int tolower(int c)
{
c0103609:	55                   	push   %ebp
c010360a:	89 e5                	mov    %esp,%ebp
    c += 0x20;
c010360c:	83 45 08 20          	addl   $0x20,0x8(%ebp)
    return c;
c0103610:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0103613:	5d                   	pop    %ebp
c0103614:	c3                   	ret    

c0103615 <toupper>:
 * convert lower to upper character
 * @param lower charcter c as int
 * @return c as upper character as int
 **/
int toupper(int c)
{
c0103615:	55                   	push   %ebp
c0103616:	89 e5                	mov    %esp,%ebp
    c -= 0x20;
c0103618:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    return c;
c010361c:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010361f:	5d                   	pop    %ebp
c0103620:	c3                   	ret    

c0103621 <printf>:
#include <ctype.h>
#include <atoi.h>
#include <video.h>

int printf(const char *fmt, ...)
{
c0103621:	55                   	push   %ebp
c0103622:	89 e5                	mov    %esp,%ebp
c0103624:	81 ec 28 04 00 00    	sub    $0x428,%esp
    int size;
    char buffer[1024];
    memset(buffer, 0, 1024);
c010362a:	c7 44 24 08 00 04 00 	movl   $0x400,0x8(%esp)
c0103631:	00 
c0103632:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0103639:	00 
c010363a:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0103640:	89 04 24             	mov    %eax,(%esp)
c0103643:	e8 d1 fd ff ff       	call   c0103419 <memset>

    va_list args;
    va_start(args, fmt);
c0103648:	8d 45 0c             	lea    0xc(%ebp),%eax
c010364b:	89 85 f0 fb ff ff    	mov    %eax,-0x410(%ebp)

    size = vsprintf(buffer, fmt, args);
c0103651:	8b 85 f0 fb ff ff    	mov    -0x410(%ebp),%eax
c0103657:	89 44 24 08          	mov    %eax,0x8(%esp)
c010365b:	8b 45 08             	mov    0x8(%ebp),%eax
c010365e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103662:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0103668:	89 04 24             	mov    %eax,(%esp)
c010366b:	e8 4b 00 00 00       	call   c01036bb <vsprintf>
c0103670:	89 45 f4             	mov    %eax,-0xc(%ebp)

    fputs(buffer, STDOUT);
c0103673:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c010367a:	00 
c010367b:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0103681:	89 04 24             	mov    %eax,(%esp)
c0103684:	e8 59 8c 00 00       	call   c010c2e2 <fputs>

    va_end(args);
    return size;
c0103689:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010368c:	c9                   	leave  
c010368d:	c3                   	ret    

c010368e <sprintf>:

int sprintf(char *buf, const char *fmt, ...)
{
c010368e:	55                   	push   %ebp
c010368f:	89 e5                	mov    %esp,%ebp
c0103691:	83 ec 28             	sub    $0x28,%esp
    int size;

    va_list args;
    va_start(args, fmt);
c0103694:	8d 45 10             	lea    0x10(%ebp),%eax
c0103697:	89 45 f0             	mov    %eax,-0x10(%ebp)

    size = vsprintf(buf, fmt, args);
c010369a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010369d:	89 44 24 08          	mov    %eax,0x8(%esp)
c01036a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01036a4:	89 44 24 04          	mov    %eax,0x4(%esp)
c01036a8:	8b 45 08             	mov    0x8(%ebp),%eax
c01036ab:	89 04 24             	mov    %eax,(%esp)
c01036ae:	e8 08 00 00 00       	call   c01036bb <vsprintf>
c01036b3:	89 45 f4             	mov    %eax,-0xc(%ebp)

    va_end(args);
    return size;
c01036b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c01036b9:	c9                   	leave  
c01036ba:	c3                   	ret    

c01036bb <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
c01036bb:	55                   	push   %ebp
c01036bc:	89 e5                	mov    %esp,%ebp
c01036be:	83 ec 58             	sub    $0x58,%esp
    char *str = buf;
c01036c1:	8b 45 08             	mov    0x8(%ebp),%eax
c01036c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int precision;
    int qualifier;

    int base;

    for (; *fmt; ++fmt)
c01036c7:	e9 1f 04 00 00       	jmp    c0103aeb <vsprintf+0x430>
    {
        if (*fmt != '%')
c01036cc:	8b 45 0c             	mov    0xc(%ebp),%eax
c01036cf:	0f b6 00             	movzbl (%eax),%eax
c01036d2:	3c 25                	cmp    $0x25,%al
c01036d4:	74 14                	je     c01036ea <vsprintf+0x2f>
        {
            *buf++ = *fmt;
c01036d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c01036d9:	0f b6 10             	movzbl (%eax),%edx
c01036dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01036df:	88 10                	mov    %dl,(%eax)
c01036e1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
            continue;
c01036e5:	e9 fd 03 00 00       	jmp    c0103ae7 <vsprintf+0x42c>
        }

        /* flags */
        flags = 0;
c01036ea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
loop:
        ++fmt;
c01036f1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        switch (*fmt)
c01036f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01036f8:	0f b6 00             	movzbl (%eax),%eax
c01036fb:	0f be c0             	movsbl %al,%eax
c01036fe:	83 e8 20             	sub    $0x20,%eax
c0103701:	83 f8 10             	cmp    $0x10,%eax
c0103704:	77 27                	ja     c010372d <vsprintf+0x72>
c0103706:	8b 04 85 bc 02 11 c0 	mov    -0x3feefd44(,%eax,4),%eax
c010370d:	ff e0                	jmp    *%eax
        {
            case '0':
                flags |= ZEROPAD;
c010370f:	83 4d e4 01          	orl    $0x1,-0x1c(%ebp)
                goto loop;
c0103713:	eb dc                	jmp    c01036f1 <vsprintf+0x36>
            case '+':
                flags |= PLUS;
c0103715:	83 4d e4 04          	orl    $0x4,-0x1c(%ebp)
                goto loop;
c0103719:	eb d6                	jmp    c01036f1 <vsprintf+0x36>
            case ' ':
                flags |= SPACE;
c010371b:	83 4d e4 08          	orl    $0x8,-0x1c(%ebp)
                goto loop;
c010371f:	eb d0                	jmp    c01036f1 <vsprintf+0x36>
            case '-':
                flags |= LEFT;
c0103721:	83 4d e4 10          	orl    $0x10,-0x1c(%ebp)
                goto loop;
c0103725:	eb ca                	jmp    c01036f1 <vsprintf+0x36>
            case '#':
                flags |= SPECIAL;
c0103727:	83 4d e4 40          	orl    $0x40,-0x1c(%ebp)
                goto loop;
c010372b:	eb c4                	jmp    c01036f1 <vsprintf+0x36>
        }

        /* width */
        width = 1;
c010372d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        if (isdigit(*fmt))
c0103734:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103737:	0f b6 00             	movzbl (%eax),%eax
c010373a:	0f be c0             	movsbl %al,%eax
c010373d:	83 e8 30             	sub    $0x30,%eax
c0103740:	83 f8 09             	cmp    $0x9,%eax
c0103743:	77 25                	ja     c010376a <vsprintf+0xaf>
        {
            width = atoi(fmt);
c0103745:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103748:	89 04 24             	mov    %eax,(%esp)
c010374b:	e8 b5 f1 ff ff       	call   c0102905 <atoi>
c0103750:	89 45 e0             	mov    %eax,-0x20(%ebp)
            while (isdigit(*++fmt));
c0103753:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0103757:	8b 45 0c             	mov    0xc(%ebp),%eax
c010375a:	0f b6 00             	movzbl (%eax),%eax
c010375d:	0f be c0             	movsbl %al,%eax
c0103760:	83 e8 30             	sub    $0x30,%eax
c0103763:	83 f8 09             	cmp    $0x9,%eax
c0103766:	76 eb                	jbe    c0103753 <vsprintf+0x98>
c0103768:	eb 29                	jmp    c0103793 <vsprintf+0xd8>
        }
        else if (*fmt == '*')
c010376a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010376d:	0f b6 00             	movzbl (%eax),%eax
c0103770:	3c 2a                	cmp    $0x2a,%al
c0103772:	75 1f                	jne    c0103793 <vsprintf+0xd8>
        {
            ++fmt;
c0103774:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
            width = va_arg(args, int);
c0103778:	8b 45 10             	mov    0x10(%ebp),%eax
c010377b:	8d 50 04             	lea    0x4(%eax),%edx
c010377e:	89 55 10             	mov    %edx,0x10(%ebp)
c0103781:	8b 00                	mov    (%eax),%eax
c0103783:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if (width < 0)
c0103786:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010378a:	79 07                	jns    c0103793 <vsprintf+0xd8>
            {
                width = - width;
c010378c:	f7 5d e0             	negl   -0x20(%ebp)
                flags |= LEFT;
c010378f:	83 4d e4 10          	orl    $0x10,-0x1c(%ebp)
            }
        }

        /* precision */
        precision = -1;
c0103793:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
        if (*fmt == '.')
c010379a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010379d:	0f b6 00             	movzbl (%eax),%eax
c01037a0:	3c 2e                	cmp    $0x2e,%al
c01037a2:	75 63                	jne    c0103807 <vsprintf+0x14c>
        {
            ++fmt;
c01037a4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
            if (isdigit(*fmt))
c01037a8:	8b 45 0c             	mov    0xc(%ebp),%eax
c01037ab:	0f b6 00             	movzbl (%eax),%eax
c01037ae:	0f be c0             	movsbl %al,%eax
c01037b1:	83 e8 30             	sub    $0x30,%eax
c01037b4:	83 f8 09             	cmp    $0x9,%eax
c01037b7:	77 25                	ja     c01037de <vsprintf+0x123>
            {
                precision = atoi(fmt);
c01037b9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01037bc:	89 04 24             	mov    %eax,(%esp)
c01037bf:	e8 41 f1 ff ff       	call   c0102905 <atoi>
c01037c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
                while (isdigit(*++fmt));
c01037c7:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c01037cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c01037ce:	0f b6 00             	movzbl (%eax),%eax
c01037d1:	0f be c0             	movsbl %al,%eax
c01037d4:	83 e8 30             	sub    $0x30,%eax
c01037d7:	83 f8 09             	cmp    $0x9,%eax
c01037da:	76 eb                	jbe    c01037c7 <vsprintf+0x10c>
c01037dc:	eb 1c                	jmp    c01037fa <vsprintf+0x13f>
            }
            else if (*fmt == '*')
c01037de:	8b 45 0c             	mov    0xc(%ebp),%eax
c01037e1:	0f b6 00             	movzbl (%eax),%eax
c01037e4:	3c 2a                	cmp    $0x2a,%al
c01037e6:	75 12                	jne    c01037fa <vsprintf+0x13f>
            {
                ++fmt;
c01037e8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
                precision = va_arg(args, int);
c01037ec:	8b 45 10             	mov    0x10(%ebp),%eax
c01037ef:	8d 50 04             	lea    0x4(%eax),%edx
c01037f2:	89 55 10             	mov    %edx,0x10(%ebp)
c01037f5:	8b 00                	mov    (%eax),%eax
c01037f7:	89 45 dc             	mov    %eax,-0x24(%ebp)
            }
            if (precision < 0)
c01037fa:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c01037fe:	79 07                	jns    c0103807 <vsprintf+0x14c>
            {
                precision = 0;
c0103800:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
            }
        }

        /* qualifier */
        qualifier = -1;
c0103807:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
        if (strchr("hlL", *fmt))
c010380e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103811:	0f b6 00             	movzbl (%eax),%eax
c0103814:	0f be c0             	movsbl %al,%eax
c0103817:	89 44 24 04          	mov    %eax,0x4(%esp)
c010381b:	c7 04 24 b8 02 11 c0 	movl   $0xc01102b8,(%esp)
c0103822:	e8 c8 f8 ff ff       	call   c01030ef <strchr>
c0103827:	85 c0                	test   %eax,%eax
c0103829:	74 10                	je     c010383b <vsprintf+0x180>
        {
            qualifier = *fmt;
c010382b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010382e:	0f b6 00             	movzbl (%eax),%eax
c0103831:	0f be c0             	movsbl %al,%eax
c0103834:	89 45 d8             	mov    %eax,-0x28(%ebp)
            ++fmt;
c0103837:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        }

        /* base */
        base = 10;
c010383b:	c7 45 d4 0a 00 00 00 	movl   $0xa,-0x2c(%ebp)

        /* specifier */
        switch (*fmt)
c0103842:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103845:	0f b6 00             	movzbl (%eax),%eax
c0103848:	0f be c0             	movsbl %al,%eax
c010384b:	83 e8 25             	sub    $0x25,%eax
c010384e:	83 f8 53             	cmp    $0x53,%eax
c0103851:	0f 87 c1 01 00 00    	ja     c0103a18 <vsprintf+0x35d>
c0103857:	8b 04 85 00 03 11 c0 	mov    -0x3feefd00(,%eax,4),%eax
c010385e:	ff e0                	jmp    *%eax
        {
            case 'c':
                len = 1;
c0103860:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)

                if (!(flags & LEFT))
c0103867:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010386a:	83 e0 10             	and    $0x10,%eax
c010386d:	85 c0                	test   %eax,%eax
c010386f:	75 1d                	jne    c010388e <vsprintf+0x1d3>
                    while (len < width--)
c0103871:	eb 0a                	jmp    c010387d <vsprintf+0x1c2>
                        *buf++ = ' ';
c0103873:	8b 45 08             	mov    0x8(%ebp),%eax
c0103876:	c6 00 20             	movb   $0x20,(%eax)
c0103879:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        {
            case 'c':
                len = 1;

                if (!(flags & LEFT))
                    while (len < width--)
c010387d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103880:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0103883:	0f 9f c0             	setg   %al
c0103886:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c010388a:	84 c0                	test   %al,%al
c010388c:	75 e5                	jne    c0103873 <vsprintf+0x1b8>
                        *buf++ = ' ';

                *buf++ = (unsigned char)va_arg(args, int);
c010388e:	8b 45 10             	mov    0x10(%ebp),%eax
c0103891:	8d 50 04             	lea    0x4(%eax),%edx
c0103894:	89 55 10             	mov    %edx,0x10(%ebp)
c0103897:	8b 00                	mov    (%eax),%eax
c0103899:	89 c2                	mov    %eax,%edx
c010389b:	8b 45 08             	mov    0x8(%ebp),%eax
c010389e:	88 10                	mov    %dl,(%eax)
c01038a0:	83 45 08 01          	addl   $0x1,0x8(%ebp)

                while (len < width--)
c01038a4:	eb 0a                	jmp    c01038b0 <vsprintf+0x1f5>
                    *buf++ = ' ';
c01038a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01038a9:	c6 00 20             	movb   $0x20,(%eax)
c01038ac:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                    while (len < width--)
                        *buf++ = ' ';

                *buf++ = (unsigned char)va_arg(args, int);

                while (len < width--)
c01038b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01038b3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c01038b6:	0f 9f c0             	setg   %al
c01038b9:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c01038bd:	84 c0                	test   %al,%al
c01038bf:	75 e5                	jne    c01038a6 <vsprintf+0x1eb>
                    *buf++ = ' ';
                continue;
c01038c1:	e9 21 02 00 00       	jmp    c0103ae7 <vsprintf+0x42c>

            case 's':
                s = va_arg(args, char *);
c01038c6:	8b 45 10             	mov    0x10(%ebp),%eax
c01038c9:	8d 50 04             	lea    0x4(%eax),%edx
c01038cc:	89 55 10             	mov    %edx,0x10(%ebp)
c01038cf:	8b 00                	mov    (%eax),%eax
c01038d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
                len = strnlen(s, precision);
c01038d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01038d7:	89 44 24 04          	mov    %eax,0x4(%esp)
c01038db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01038de:	89 04 24             	mov    %eax,(%esp)
c01038e1:	e8 b3 f5 ff ff       	call   c0102e99 <strnlen>
c01038e6:	89 45 d0             	mov    %eax,-0x30(%ebp)

                if (!(flags & LEFT))
c01038e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01038ec:	83 e0 10             	and    $0x10,%eax
c01038ef:	85 c0                	test   %eax,%eax
c01038f1:	75 1d                	jne    c0103910 <vsprintf+0x255>
                    while (len < width--)
c01038f3:	eb 0a                	jmp    c01038ff <vsprintf+0x244>
                        *buf++ = ' ';
c01038f5:	8b 45 08             	mov    0x8(%ebp),%eax
c01038f8:	c6 00 20             	movb   $0x20,(%eax)
c01038fb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
            case 's':
                s = va_arg(args, char *);
                len = strnlen(s, precision);

                if (!(flags & LEFT))
                    while (len < width--)
c01038ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103902:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0103905:	0f 9f c0             	setg   %al
c0103908:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c010390c:	84 c0                	test   %al,%al
c010390e:	75 e5                	jne    c01038f5 <vsprintf+0x23a>
                        *buf++ = ' ';

                for (i = 0; i < len; ++i)
c0103910:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0103917:	eb 17                	jmp    c0103930 <vsprintf+0x275>
                    *buf++ = *s++;
c0103919:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010391c:	0f b6 10             	movzbl (%eax),%edx
c010391f:	8b 45 08             	mov    0x8(%ebp),%eax
c0103922:	88 10                	mov    %dl,(%eax)
c0103924:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0103928:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

                if (!(flags & LEFT))
                    while (len < width--)
                        *buf++ = ' ';

                for (i = 0; i < len; ++i)
c010392c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0103930:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103933:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0103936:	7c e1                	jl     c0103919 <vsprintf+0x25e>
                    *buf++ = *s++;

                while (len < width--)
c0103938:	eb 0a                	jmp    c0103944 <vsprintf+0x289>
                    *buf++ = ' ';
c010393a:	8b 45 08             	mov    0x8(%ebp),%eax
c010393d:	c6 00 20             	movb   $0x20,(%eax)
c0103940:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                        *buf++ = ' ';

                for (i = 0; i < len; ++i)
                    *buf++ = *s++;

                while (len < width--)
c0103944:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103947:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c010394a:	0f 9f c0             	setg   %al
c010394d:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
c0103951:	84 c0                	test   %al,%al
c0103953:	75 e5                	jne    c010393a <vsprintf+0x27f>
                    *buf++ = ' ';
                continue;
c0103955:	e9 8d 01 00 00       	jmp    c0103ae7 <vsprintf+0x42c>

            case 'p':
                width = 2 * sizeof(void *);
c010395a:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
                flags |= ZEROPAD;
c0103961:	83 4d e4 01          	orl    $0x1,-0x1c(%ebp)
                flags |= SPECIAL;
c0103965:	83 4d e4 40          	orl    $0x40,-0x1c(%ebp)
                itoa_ex((unsigned long)va_arg(args, void *), buf, 16, flags, width);
c0103969:	8b 45 10             	mov    0x10(%ebp),%eax
c010396c:	8d 50 04             	lea    0x4(%eax),%edx
c010396f:	89 55 10             	mov    %edx,0x10(%ebp)
c0103972:	8b 00                	mov    (%eax),%eax
c0103974:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0103977:	89 54 24 10          	mov    %edx,0x10(%esp)
c010397b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010397e:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0103982:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
c0103989:	00 
c010398a:	8b 55 08             	mov    0x8(%ebp),%edx
c010398d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103991:	89 04 24             	mov    %eax,(%esp)
c0103994:	e8 b1 ed ff ff       	call   c010274a <itoa_ex>
                while (*++buf);
c0103999:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c010399d:	8b 45 08             	mov    0x8(%ebp),%eax
c01039a0:	0f b6 00             	movzbl (%eax),%eax
c01039a3:	84 c0                	test   %al,%al
c01039a5:	75 f2                	jne    c0103999 <vsprintf+0x2de>
                continue;
c01039a7:	e9 3b 01 00 00       	jmp    c0103ae7 <vsprintf+0x42c>

            case 'n':
                if (qualifier == 'l')
c01039ac:	83 7d d8 6c          	cmpl   $0x6c,-0x28(%ebp)
c01039b0:	75 20                	jne    c01039d2 <vsprintf+0x317>
                {
                    long *dest = va_arg(args, long *);
c01039b2:	8b 45 10             	mov    0x10(%ebp),%eax
c01039b5:	8d 50 04             	lea    0x4(%eax),%edx
c01039b8:	89 55 10             	mov    %edx,0x10(%ebp)
c01039bb:	8b 00                	mov    (%eax),%eax
c01039bd:	89 45 cc             	mov    %eax,-0x34(%ebp)
                    *dest = (buf - str);
c01039c0:	8b 55 08             	mov    0x8(%ebp),%edx
c01039c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01039c6:	29 c2                	sub    %eax,%edx
c01039c8:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01039cb:	89 10                	mov    %edx,(%eax)
                else
                {
                    int *dest = va_arg(args, int *);
                    *dest = (buf - str);
                }
                continue;
c01039cd:	e9 15 01 00 00       	jmp    c0103ae7 <vsprintf+0x42c>
                    long *dest = va_arg(args, long *);
                    *dest = (buf - str);
                }
                else
                {
                    int *dest = va_arg(args, int *);
c01039d2:	8b 45 10             	mov    0x10(%ebp),%eax
c01039d5:	8d 50 04             	lea    0x4(%eax),%edx
c01039d8:	89 55 10             	mov    %edx,0x10(%ebp)
c01039db:	8b 00                	mov    (%eax),%eax
c01039dd:	89 45 c8             	mov    %eax,-0x38(%ebp)
                    *dest = (buf - str);
c01039e0:	8b 55 08             	mov    0x8(%ebp),%edx
c01039e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01039e6:	29 c2                	sub    %eax,%edx
c01039e8:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01039eb:	89 10                	mov    %edx,(%eax)
                }
                continue;
c01039ed:	e9 f5 00 00 00       	jmp    c0103ae7 <vsprintf+0x42c>

            case '%':
                *buf++ = '%';
c01039f2:	8b 45 08             	mov    0x8(%ebp),%eax
c01039f5:	c6 00 25             	movb   $0x25,(%eax)
c01039f8:	83 45 08 01          	addl   $0x1,0x8(%ebp)

            /* integers */

            case 'o':
                base = 8;
c01039fc:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
                break;
c0103a03:	eb 45                	jmp    c0103a4a <vsprintf+0x38f>

            case 'd':
            case 'i':
                flags |= SIGN;
c0103a05:	83 4d e4 02          	orl    $0x2,-0x1c(%ebp)
            case 'u':
                break;
c0103a09:	eb 3e                	jmp    c0103a49 <vsprintf+0x38e>

            case 'x':
                flags |= SMALL;
c0103a0b:	83 4d e4 20          	orl    $0x20,-0x1c(%ebp)
            case 'X':
                base = 16;
c0103a0f:	c7 45 d4 10 00 00 00 	movl   $0x10,-0x2c(%ebp)
                break;
c0103a16:	eb 32                	jmp    c0103a4a <vsprintf+0x38f>

            default:
                *str++ = '%';
c0103a18:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103a1b:	c6 00 25             	movb   $0x25,(%eax)
c0103a1e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                if (*fmt)
c0103a22:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103a25:	0f b6 00             	movzbl (%eax),%eax
c0103a28:	84 c0                	test   %al,%al
c0103a2a:	74 14                	je     c0103a40 <vsprintf+0x385>
                {
                    *str++ = *fmt;
c0103a2c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103a2f:	0f b6 10             	movzbl (%eax),%edx
c0103a32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103a35:	88 10                	mov    %dl,(%eax)
c0103a37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                }
                else
                {
                    --fmt;
                }
                continue;
c0103a3b:	e9 a7 00 00 00       	jmp    c0103ae7 <vsprintf+0x42c>
                {
                    *str++ = *fmt;
                }
                else
                {
                    --fmt;
c0103a40:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
                }
                continue;
c0103a44:	e9 9e 00 00 00       	jmp    c0103ae7 <vsprintf+0x42c>

            case 'd':
            case 'i':
                flags |= SIGN;
            case 'u':
                break;
c0103a49:	90                   	nop
                    --fmt;
                }
                continue;
        }

        if (qualifier == 'l')
c0103a4a:	83 7d d8 6c          	cmpl   $0x6c,-0x28(%ebp)
c0103a4e:	75 10                	jne    c0103a60 <vsprintf+0x3a5>
        {
            num = va_arg(args, unsigned long);
c0103a50:	8b 45 10             	mov    0x10(%ebp),%eax
c0103a53:	8d 50 04             	lea    0x4(%eax),%edx
c0103a56:	89 55 10             	mov    %edx,0x10(%ebp)
c0103a59:	8b 00                	mov    (%eax),%eax
c0103a5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0103a5e:	eb 52                	jmp    c0103ab2 <vsprintf+0x3f7>
        }
        else if (qualifier == 'h')
c0103a60:	83 7d d8 68          	cmpl   $0x68,-0x28(%ebp)
c0103a64:	75 24                	jne    c0103a8a <vsprintf+0x3cf>
        {
            num = (unsigned short)va_arg(args, int);
c0103a66:	8b 45 10             	mov    0x10(%ebp),%eax
c0103a69:	8d 50 04             	lea    0x4(%eax),%edx
c0103a6c:	89 55 10             	mov    %edx,0x10(%ebp)
c0103a6f:	8b 00                	mov    (%eax),%eax
c0103a71:	0f b7 c0             	movzwl %ax,%eax
c0103a74:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (flags & SIGN)
c0103a77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103a7a:	83 e0 02             	and    $0x2,%eax
c0103a7d:	85 c0                	test   %eax,%eax
c0103a7f:	74 31                	je     c0103ab2 <vsprintf+0x3f7>
            {
                num = (short)num;
c0103a81:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103a84:	98                   	cwtl   
c0103a85:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0103a88:	eb 28                	jmp    c0103ab2 <vsprintf+0x3f7>
            }
        }
        else if (flags & SIGN)
c0103a8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103a8d:	83 e0 02             	and    $0x2,%eax
c0103a90:	85 c0                	test   %eax,%eax
c0103a92:	74 10                	je     c0103aa4 <vsprintf+0x3e9>
        {
            num = va_arg(args, int);
c0103a94:	8b 45 10             	mov    0x10(%ebp),%eax
c0103a97:	8d 50 04             	lea    0x4(%eax),%edx
c0103a9a:	89 55 10             	mov    %edx,0x10(%ebp)
c0103a9d:	8b 00                	mov    (%eax),%eax
c0103a9f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0103aa2:	eb 0e                	jmp    c0103ab2 <vsprintf+0x3f7>
        }
        else
        {
            num = va_arg(args, unsigned int);
c0103aa4:	8b 45 10             	mov    0x10(%ebp),%eax
c0103aa7:	8d 50 04             	lea    0x4(%eax),%edx
c0103aaa:	89 55 10             	mov    %edx,0x10(%ebp)
c0103aad:	8b 00                	mov    (%eax),%eax
c0103aaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }

        itoa_ex(num, buf, base, flags, width);
c0103ab2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103ab5:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0103ab8:	89 54 24 10          	mov    %edx,0x10(%esp)
c0103abc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0103abf:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0103ac3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0103ac6:	89 54 24 08          	mov    %edx,0x8(%esp)
c0103aca:	8b 55 08             	mov    0x8(%ebp),%edx
c0103acd:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103ad1:	89 04 24             	mov    %eax,(%esp)
c0103ad4:	e8 71 ec ff ff       	call   c010274a <itoa_ex>
        while (*++buf);
c0103ad9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0103add:	8b 45 08             	mov    0x8(%ebp),%eax
c0103ae0:	0f b6 00             	movzbl (%eax),%eax
c0103ae3:	84 c0                	test   %al,%al
c0103ae5:	75 f2                	jne    c0103ad9 <vsprintf+0x41e>
    int precision;
    int qualifier;

    int base;

    for (; *fmt; ++fmt)
c0103ae7:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0103aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103aee:	0f b6 00             	movzbl (%eax),%eax
c0103af1:	84 c0                	test   %al,%al
c0103af3:	0f 85 d3 fb ff ff    	jne    c01036cc <vsprintf+0x11>

        itoa_ex(num, buf, base, flags, width);
        while (*++buf);
    }

    *buf = '\0';
c0103af9:	8b 45 08             	mov    0x8(%ebp),%eax
c0103afc:	c6 00 00             	movb   $0x0,(%eax)

    return buf - str;
c0103aff:	8b 55 08             	mov    0x8(%ebp),%edx
c0103b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103b05:	89 d1                	mov    %edx,%ecx
c0103b07:	29 c1                	sub    %eax,%ecx
c0103b09:	89 c8                	mov    %ecx,%eax
}
c0103b0b:	c9                   	leave  
c0103b0c:	c3                   	ret    

c0103b0d <print_logo>:
                 UUUUUUUUU       NNNNNNNN         NNNNNNN IIIIIIIIII           \n\
                                                                               \n\
";

static void print_logo(color_t color)
{
c0103b0d:	55                   	push   %ebp
c0103b0e:	89 e5                	mov    %esp,%ebp
c0103b10:	83 ec 38             	sub    $0x38,%esp
c0103b13:	8b 45 08             	mov    0x8(%ebp),%eax
c0103b16:	88 45 e4             	mov    %al,-0x1c(%ebp)
    color_t color_saved = get_color();
c0103b19:	e8 63 88 00 00       	call   c010c381 <get_color>
c0103b1e:	88 45 f7             	mov    %al,-0x9(%ebp)

    set_color(color | BLACK << 4);
c0103b21:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0103b25:	89 04 24             	mov    %eax,(%esp)
c0103b28:	e8 3d 88 00 00       	call   c010c36a <set_color>

    puts(__logo);
c0103b2d:	a1 00 20 11 c0       	mov    0xc0112000,%eax
c0103b32:	89 04 24             	mov    %eax,(%esp)
c0103b35:	e8 65 87 00 00       	call   c010c29f <puts>

    set_color(color_saved);
c0103b3a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0103b3e:	89 04 24             	mov    %eax,(%esp)
c0103b41:	e8 24 88 00 00       	call   c010c36a <set_color>
}
c0103b46:	c9                   	leave  
c0103b47:	c3                   	ret    

c0103b48 <init>:
* @return 0
*/
extern struct process_state *kernel_state;
extern list_t *running_threads;
int init (struct multiboot_struct *mb_info, uint32_t magic_number)
{
c0103b48:	55                   	push   %ebp
c0103b49:	89 e5                	mov    %esp,%ebp
c0103b4b:	83 ec 68             	sub    $0x68,%esp
    clear_screen();
c0103b4e:	e8 c3 87 00 00       	call   c010c316 <clear_screen>
    if (magic_number != 0x2BADB002)
c0103b53:	81 7d 0c 02 b0 ad 2b 	cmpl   $0x2badb002,0xc(%ebp)
c0103b5a:	74 0c                	je     c0103b68 <init+0x20>
    {
        panic("Incompatible Bootloader");
c0103b5c:	c7 04 24 f1 09 11 c0 	movl   $0xc01109f1,(%esp)
c0103b63:	e8 e8 e5 ff ff       	call   c0102150 <panic>
    }
    //Init Kernelmodules
    INIT_PREV();
c0103b68:	e8 ba bc 00 00       	call   c010f827 <INIT_PREV>
    INIT_PMM(mb_info);
c0103b6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0103b70:	89 04 24             	mov    %eax,(%esp)
c0103b73:	e8 78 ba 00 00       	call   c010f5f0 <INIT_PMM>
    INIT_PAGING(mb_info);
c0103b78:	8b 45 08             	mov    0x8(%ebp),%eax
c0103b7b:	89 04 24             	mov    %eax,(%esp)
c0103b7e:	e8 ac 7c 00 00       	call   c010b82f <INIT_PAGING>
    INIT_HEAP();
c0103b83:	e8 bc 81 00 00       	call   c010bd44 <INIT_HEAP>
    INIT_IDT();
c0103b88:	e8 e1 a4 00 00       	call   c010e06e <INIT_IDT>
    INIT_VFS();
c0103b8d:	e8 07 1d 00 00       	call   c0105899 <INIT_VFS>
    INIT_TRIGGER();
c0103b92:	e8 d0 72 00 00       	call   c010ae67 <INIT_TRIGGER>
    INIT_CLOCK(500);
c0103b97:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
c0103b9e:	e8 b9 90 00 00       	call   c010cc5c <INIT_CLOCK>
    INIT_SCHEDULER();
c0103ba3:	e8 04 0e 00 00       	call   c01049ac <INIT_SCHEDULER>
    //print Logo and loading message
    print_logo(YELLOW);
c0103ba8:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c0103baf:	e8 59 ff ff ff       	call   c0103b0d <print_logo>
    set_color(WHITE | (BLACK << 4));
c0103bb4:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c0103bbb:	e8 aa 87 00 00       	call   c010c36a <set_color>
    puts("Universe wird gestartet...\n");
c0103bc0:	c7 04 24 09 0a 11 c0 	movl   $0xc0110a09,(%esp)
c0103bc7:	e8 d3 86 00 00       	call   c010c29f <puts>
    // count free memory and display it
    uint32_t pages = pmm_count_free_pages();
c0103bcc:	e8 fc b4 00 00       	call   c010f0cd <pmm_count_free_pages>
c0103bd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    printf("%u freie Speicherseiten (%u MB)\n", pages, pages >> 8);
c0103bd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103bd7:	c1 e8 08             	shr    $0x8,%eax
c0103bda:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103bde:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103be1:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103be5:	c7 04 24 28 0a 11 c0 	movl   $0xc0110a28,(%esp)
c0103bec:	e8 30 fa ff ff       	call   c0103621 <printf>

    //print current timestamp
    struct time t;
    update_time(&t);
c0103bf1:	8d 45 c5             	lea    -0x3b(%ebp),%eax
c0103bf4:	89 04 24             	mov    %eax,(%esp)
c0103bf7:	e8 8a 91 00 00       	call   c010cd86 <update_time>
    printf("\n");
c0103bfc:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0103c03:	e8 36 85 00 00       	call   c010c13e <putchar>
    printf("Timestamp:%d\n\n",unix_time(&t));
c0103c08:	8d 45 c5             	lea    -0x3b(%ebp),%eax
c0103c0b:	89 04 24             	mov    %eax,(%esp)
c0103c0e:	e8 61 7a 00 00       	call   c010b674 <unix_time>
c0103c13:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103c17:	c7 04 24 49 0a 11 c0 	movl   $0xc0110a49,(%esp)
c0103c1e:	e8 fe f9 ff ff       	call   c0103621 <printf>
    // mapping strings
    int i;
    struct mods_add* modules = (struct mods_add*) mb_info->mods_addr;
c0103c23:	8b 45 08             	mov    0x8(%ebp),%eax
c0103c26:	8b 40 18             	mov    0x18(%eax),%eax
c0103c29:	89 45 ec             	mov    %eax,-0x14(%ebp)

    void *phys = (void*)((int)modules[0].string & (int)~0xfff);
c0103c2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103c2f:	8b 40 08             	mov    0x8(%eax),%eax
c0103c32:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0103c37:	89 45 e8             	mov    %eax,-0x18(%ebp)
    void *virt = (void*) vmm_automap_kernel(current_context, (paddr_t)phys, VMM_WRITABLE);
c0103c3a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0103c3d:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c0103c42:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c0103c49:	00 
c0103c4a:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103c4e:	89 04 24             	mov    %eax,(%esp)
c0103c51:	e8 2b 7d 00 00       	call   c010b981 <vmm_automap_kernel>
c0103c56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(i = 0; i < mb_info->mods_count; i++)
c0103c59:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0103c60:	eb 3a                	jmp    c0103c9c <init+0x154>
    {
        int diff = (int)modules[i].string - (int)phys;
c0103c62:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103c65:	89 c2                	mov    %eax,%edx
c0103c67:	c1 e2 04             	shl    $0x4,%edx
c0103c6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103c6d:	01 d0                	add    %edx,%eax
c0103c6f:	8b 40 08             	mov    0x8(%eax),%eax
c0103c72:	89 c2                	mov    %eax,%edx
c0103c74:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103c77:	89 d1                	mov    %edx,%ecx
c0103c79:	29 c1                	sub    %eax,%ecx
c0103c7b:	89 c8                	mov    %ecx,%eax
c0103c7d:	89 45 e0             	mov    %eax,-0x20(%ebp)
        modules[i].string = virt + diff;
c0103c80:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103c83:	89 c2                	mov    %eax,%edx
c0103c85:	c1 e2 04             	shl    $0x4,%edx
c0103c88:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103c8b:	01 d0                	add    %edx,%eax
c0103c8d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0103c90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0103c93:	01 ca                	add    %ecx,%edx
c0103c95:	89 50 08             	mov    %edx,0x8(%eax)
    int i;
    struct mods_add* modules = (struct mods_add*) mb_info->mods_addr;

    void *phys = (void*)((int)modules[0].string & (int)~0xfff);
    void *virt = (void*) vmm_automap_kernel(current_context, (paddr_t)phys, VMM_WRITABLE);
    for(i = 0; i < mb_info->mods_count; i++)
c0103c98:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0103c9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103c9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0103ca2:	8b 40 14             	mov    0x14(%eax),%eax
c0103ca5:	39 c2                	cmp    %eax,%edx
c0103ca7:	72 b9                	jb     c0103c62 <init+0x11a>
    {
        int diff = (int)modules[i].string - (int)phys;
        modules[i].string = virt + diff;
    }

    struct mapping_statistics stats = map_all(mb_info);
c0103ca9:	8d 45 b8             	lea    -0x48(%ebp),%eax
c0103cac:	8b 55 08             	mov    0x8(%ebp),%edx
c0103caf:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103cb3:	89 04 24             	mov    %eax,(%esp)
c0103cb6:	e8 f8 1d 00 00       	call   c0105ab3 <map_all>
c0103cbb:	83 ec 04             	sub    $0x4,%esp
    printf("%d modules total, %d successfully loaded, %d failed\n", stats.total, stats.load_success, stats.load_failed);
c0103cbe:	8b 4d c0             	mov    -0x40(%ebp),%ecx
c0103cc1:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0103cc4:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0103cc7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0103ccb:	89 54 24 08          	mov    %edx,0x8(%esp)
c0103ccf:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103cd3:	c7 04 24 58 0a 11 c0 	movl   $0xc0110a58,(%esp)
c0103cda:	e8 42 f9 ff ff       	call   c0103621 <printf>

    vfs_inode_t *pfnode = vfs_lookup_path("/drivers/system.pf");
c0103cdf:	c7 04 24 8d 0a 11 c0 	movl   $0xc0110a8d,(%esp)
c0103ce6:	e8 b6 4d 00 00       	call   c0108aa1 <vfs_lookup_path>
c0103ceb:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(pfnode != NULL)
c0103cee:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0103cf2:	0f 84 8c 00 00 00    	je     c0103d84 <init+0x23c>
    {
        void *argv[2];
        char *pf = (char *)malloc(pfnode->length+1);
c0103cf8:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103cfb:	8b 40 08             	mov    0x8(%eax),%eax
c0103cfe:	83 c0 01             	add    $0x1,%eax
c0103d01:	89 04 24             	mov    %eax,(%esp)
c0103d04:	e8 3c 82 00 00       	call   c010bf45 <malloc>
c0103d09:	89 45 d8             	mov    %eax,-0x28(%ebp)
        vfs_read(pfnode, 0, pf, pfnode->length);
c0103d0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103d0f:	8b 40 08             	mov    0x8(%eax),%eax
c0103d12:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0103d16:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0103d19:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103d1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0103d24:	00 
c0103d25:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103d28:	89 04 24             	mov    %eax,(%esp)
c0103d2b:	e8 ee 23 00 00       	call   c010611e <vfs_read>
        pf[pfnode->length+1] = '\0';
c0103d30:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103d33:	8b 40 08             	mov    0x8(%eax),%eax
c0103d36:	8d 50 01             	lea    0x1(%eax),%edx
c0103d39:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0103d3c:	01 d0                	add    %edx,%eax
c0103d3e:	c6 00 00             	movb   $0x0,(%eax)
        list_t *pipelines = pfp(pf);
c0103d41:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0103d44:	89 04 24             	mov    %eax,(%esp)
c0103d47:	e8 5e 65 00 00       	call   c010a2aa <pfp>
c0103d4c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        struct section *sec = list_pop_front(pipelines);
c0103d4f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0103d52:	89 04 24             	mov    %eax,(%esp)
c0103d55:	e8 28 ee ff ff       	call   c0102b82 <list_pop_front>
c0103d5a:	89 45 d0             	mov    %eax,-0x30(%ebp)

        argv[1] = mb_info;
c0103d5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0103d60:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        argv[0] = sec;
c0103d63:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0103d66:	89 45 b0             	mov    %eax,-0x50(%ebp)
        kernel_thread_create(INIT_HYPERVISOR,(char **) argv, NULL);
c0103d69:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0103d70:	00 
c0103d71:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0103d74:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d78:	c7 04 24 35 9c 10 c0 	movl   $0xc0109c35,(%esp)
c0103d7f:	e8 3a 18 00 00       	call   c01055be <kernel_thread_create>
    else
    {
        load_elf_from_file(testnode, 0, 0, 0, 0, 0);
    }
*/
    return 0;
c0103d84:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0103d89:	c9                   	leave  
c0103d8a:	c3                   	ret    

c0103d8b <load_elf_from_file>:
#include <sched/thread.h>
#include <printf.h>
#include <string.h>

struct process_state *load_elf_from_file(vfs_inode_t *inode, uid_t uid, gid_t gid, struct pipeset *s, char **argv, char **environ)
{
c0103d8b:	55                   	push   %ebp
c0103d8c:	89 e5                	mov    %esp,%ebp
c0103d8e:	83 ec 38             	sub    $0x38,%esp
    void *image = malloc(inode->length);
c0103d91:	8b 45 08             	mov    0x8(%ebp),%eax
c0103d94:	8b 40 08             	mov    0x8(%eax),%eax
c0103d97:	89 04 24             	mov    %eax,(%esp)
c0103d9a:	e8 a6 81 00 00       	call   c010bf45 <malloc>
c0103d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    vfs_read(inode, 0, image, inode->length);
c0103da2:	8b 45 08             	mov    0x8(%ebp),%eax
c0103da5:	8b 40 08             	mov    0x8(%eax),%eax
c0103da8:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0103dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103daf:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103db3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0103dba:	00 
c0103dbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0103dbe:	89 04 24             	mov    %eax,(%esp)
c0103dc1:	e8 58 23 00 00       	call   c010611e <vfs_read>
    struct process_state *state = load_elf(image, inode->name, uid, gid, s, argv, environ);
c0103dc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0103dc9:	8b 00                	mov    (%eax),%eax
c0103dcb:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0103dce:	89 54 24 18          	mov    %edx,0x18(%esp)
c0103dd2:	8b 55 18             	mov    0x18(%ebp),%edx
c0103dd5:	89 54 24 14          	mov    %edx,0x14(%esp)
c0103dd9:	8b 55 14             	mov    0x14(%ebp),%edx
c0103ddc:	89 54 24 10          	mov    %edx,0x10(%esp)
c0103de0:	8b 55 10             	mov    0x10(%ebp),%edx
c0103de3:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0103de7:	8b 55 0c             	mov    0xc(%ebp),%edx
c0103dea:	89 54 24 08          	mov    %edx,0x8(%esp)
c0103dee:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103df2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103df5:	89 04 24             	mov    %eax,(%esp)
c0103df8:	e8 13 00 00 00       	call   c0103e10 <load_elf>
c0103dfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    free(image);
c0103e00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103e03:	89 04 24             	mov    %eax,(%esp)
c0103e06:	e8 48 82 00 00       	call   c010c053 <free>

    return state;
c0103e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0103e0e:	c9                   	leave  
c0103e0f:	c3                   	ret    

c0103e10 <load_elf>:

struct process_state *load_elf(void *image, char *name, uid_t uid, gid_t gid, struct pipeset *s, char **argv, char **environ)
{
c0103e10:	55                   	push   %ebp
c0103e11:	89 e5                	mov    %esp,%ebp
c0103e13:	83 ec 38             	sub    $0x38,%esp
    struct process_state *proc = process_create(name, PROCESS_ACTIVE, NULL, uid, gid, s);
c0103e16:	8b 45 18             	mov    0x18(%ebp),%eax
c0103e19:	89 44 24 14          	mov    %eax,0x14(%esp)
c0103e1d:	8b 45 14             	mov    0x14(%ebp),%eax
c0103e20:	89 44 24 10          	mov    %eax,0x10(%esp)
c0103e24:	8b 45 10             	mov    0x10(%ebp),%eax
c0103e27:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0103e2b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0103e32:	00 
c0103e33:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0103e3a:	00 
c0103e3b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103e3e:	89 04 24             	mov    %eax,(%esp)
c0103e41:	e8 59 03 00 00       	call   c010419f <process_create>
c0103e46:	89 45 f4             	mov    %eax,-0xc(%ebp)
    load_elf_thread(image, proc, argv, environ);
c0103e49:	8b 45 20             	mov    0x20(%ebp),%eax
c0103e4c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0103e50:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0103e53:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103e5a:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103e5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e61:	89 04 24             	mov    %eax,(%esp)
c0103e64:	e8 73 00 00 00       	call   c0103edc <load_elf_thread>

    return proc;
c0103e69:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0103e6c:	c9                   	leave  
c0103e6d:	c3                   	ret    

c0103e6e <load_elf_thread_from_file>:

struct thread_state *load_elf_thread_from_file(vfs_inode_t *inode, struct process_state *proc, char **argv, char **environ)
{
c0103e6e:	55                   	push   %ebp
c0103e6f:	89 e5                	mov    %esp,%ebp
c0103e71:	83 ec 28             	sub    $0x28,%esp
    void *image = malloc(inode->length);
c0103e74:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e77:	8b 40 08             	mov    0x8(%eax),%eax
c0103e7a:	89 04 24             	mov    %eax,(%esp)
c0103e7d:	e8 c3 80 00 00       	call   c010bf45 <malloc>
c0103e82:	89 45 f4             	mov    %eax,-0xc(%ebp)
    vfs_read(inode, 0, image, inode->length);
c0103e85:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e88:	8b 40 08             	mov    0x8(%eax),%eax
c0103e8b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0103e8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103e92:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103e96:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0103e9d:	00 
c0103e9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0103ea1:	89 04 24             	mov    %eax,(%esp)
c0103ea4:	e8 75 22 00 00       	call   c010611e <vfs_read>

    struct thread_state *state = load_elf_thread(image, proc, argv, environ);
c0103ea9:	8b 45 14             	mov    0x14(%ebp),%eax
c0103eac:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0103eb0:	8b 45 10             	mov    0x10(%ebp),%eax
c0103eb3:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103eb7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103eba:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103ec1:	89 04 24             	mov    %eax,(%esp)
c0103ec4:	e8 13 00 00 00       	call   c0103edc <load_elf_thread>
c0103ec9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    free(image);
c0103ecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103ecf:	89 04 24             	mov    %eax,(%esp)
c0103ed2:	e8 7c 81 00 00       	call   c010c053 <free>

    return state;
c0103ed7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0103eda:	c9                   	leave  
c0103edb:	c3                   	ret    

c0103edc <load_elf_thread>:

struct thread_state *load_elf_thread(void *image, struct process_state *proc, char **argv, char **environ)
{
c0103edc:	55                   	push   %ebp
c0103edd:	89 e5                	mov    %esp,%ebp
c0103edf:	83 ec 58             	sub    $0x58,%esp
    struct elf_header *header = image;
c0103ee2:	8b 45 08             	mov    0x8(%ebp),%eax
c0103ee5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    struct elf_program_header *ph;

    if(!(header->ident[EI_MAG0] == ELF_MAG0 &&
c0103ee8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103eeb:	0f b6 00             	movzbl (%eax),%eax
c0103eee:	3c 7f                	cmp    $0x7f,%al
c0103ef0:	75 21                	jne    c0103f13 <load_elf_thread+0x37>
            header->ident[EI_MAG1] == ELF_MAG1 &&
c0103ef2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103ef5:	0f b6 40 01          	movzbl 0x1(%eax),%eax
struct thread_state *load_elf_thread(void *image, struct process_state *proc, char **argv, char **environ)
{
    struct elf_header *header = image;
    struct elf_program_header *ph;

    if(!(header->ident[EI_MAG0] == ELF_MAG0 &&
c0103ef9:	3c 45                	cmp    $0x45,%al
c0103efb:	75 16                	jne    c0103f13 <load_elf_thread+0x37>
            header->ident[EI_MAG1] == ELF_MAG1 &&
            header->ident[EI_MAG2] == ELF_MAG2 &&
c0103efd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103f00:	0f b6 40 02          	movzbl 0x2(%eax),%eax
{
    struct elf_header *header = image;
    struct elf_program_header *ph;

    if(!(header->ident[EI_MAG0] == ELF_MAG0 &&
            header->ident[EI_MAG1] == ELF_MAG1 &&
c0103f04:	3c 4c                	cmp    $0x4c,%al
c0103f06:	75 0b                	jne    c0103f13 <load_elf_thread+0x37>
            header->ident[EI_MAG2] == ELF_MAG2 &&
            header->ident[EI_MAG3] == ELF_MAG3))
c0103f08:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103f0b:	0f b6 40 03          	movzbl 0x3(%eax),%eax
struct thread_state *load_elf_thread(void *image, struct process_state *proc, char **argv, char **environ)
{
    struct elf_header *header = image;
    struct elf_program_header *ph;

    if(!(header->ident[EI_MAG0] == ELF_MAG0 &&
c0103f0f:	3c 46                	cmp    $0x46,%al
c0103f11:	74 16                	je     c0103f29 <load_elf_thread+0x4d>
            header->ident[EI_MAG1] == ELF_MAG1 &&
            header->ident[EI_MAG2] == ELF_MAG2 &&
            header->ident[EI_MAG3] == ELF_MAG3))
    {
        printf("Invalid ELF-Magic!\n");
c0103f13:	c7 04 24 a0 0a 11 c0 	movl   $0xc0110aa0,(%esp)
c0103f1a:	e8 80 83 00 00       	call   c010c29f <puts>
        return NULL;
c0103f1f:	b8 00 00 00 00       	mov    $0x0,%eax
c0103f24:	e9 b9 01 00 00       	jmp    c01040e2 <load_elf_thread+0x206>
    }

    int i,j;
    ph = (struct elf_program_header*) (image + header->ph_offset);
c0103f29:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103f2c:	8b 50 1c             	mov    0x1c(%eax),%edx
c0103f2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0103f32:	01 d0                	add    %edx,%eax
c0103f34:	89 45 f4             	mov    %eax,-0xc(%ebp)

    vmm_context_t context;
    vmm_create_context(&context);
c0103f37:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0103f3a:	89 04 24             	mov    %eax,(%esp)
c0103f3d:	e8 00 79 00 00       	call   c010b842 <vmm_create_context>

    for(i = 0; i < header->ph_entry_count; i++, ph++)
c0103f42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0103f49:	e9 41 01 00 00       	jmp    c010408f <load_elf_thread+0x1b3>
    {
        if(ph->type == EPT_LOAD)
c0103f4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103f51:	8b 00                	mov    (%eax),%eax
c0103f53:	83 f8 01             	cmp    $0x1,%eax
c0103f56:	0f 85 2b 01 00 00    	jne    c0104087 <load_elf_thread+0x1ab>
        {
            int pages = NUM_PAGES(ph->mem_size);
c0103f5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103f5f:	8b 40 14             	mov    0x14(%eax),%eax
c0103f62:	05 ff 0f 00 00       	add    $0xfff,%eax
c0103f67:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0103f6c:	c1 e8 0c             	shr    $0xc,%eax
c0103f6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            uintptr_t dest_start = (uintptr_t) arch_vaddr_find((arch_vmm_context_t*)current_context, pages,
c0103f72:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c0103f77:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c0103f7e:	ff 
c0103f7f:	c7 44 24 08 00 00 00 	movl   $0xc0000000,0x8(%esp)
c0103f86:	c0 
c0103f87:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0103f8a:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103f8e:	89 04 24             	mov    %eax,(%esp)
c0103f91:	e8 08 98 00 00       	call   c010d79e <arch_vaddr_find>
c0103f96:	89 45 e0             	mov    %eax,-0x20(%ebp)
                                   MEMORY_LAYOUT_KERNEL_START, MEMORY_LAYOUT_KERNEL_END);

            // map pages
            for(j = 0; j < pages; j++)
c0103f99:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0103fa0:	eb 71                	jmp    c0104013 <load_elf_thread+0x137>
            {
                paddr_t paddr = (uintptr_t) pmm_alloc_page();
c0103fa2:	e8 0d b5 00 00       	call   c010f4b4 <pmm_alloc_page>
c0103fa7:	89 45 dc             	mov    %eax,-0x24(%ebp)
                vaddr_t vaddr = (uintptr_t) ph->virt_addr + j*PAGE_SIZE;
c0103faa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103fad:	8b 50 08             	mov    0x8(%eax),%edx
c0103fb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103fb3:	c1 e0 0c             	shl    $0xc,%eax
c0103fb6:	01 d0                	add    %edx,%eax
c0103fb8:	89 45 d8             	mov    %eax,-0x28(%ebp)
                uintptr_t dest = (uintptr_t) dest_start + j*PAGE_SIZE;
c0103fbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103fbe:	c1 e0 0c             	shl    $0xc,%eax
c0103fc1:	89 c2                	mov    %eax,%edx
c0103fc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103fc6:	01 d0                	add    %edx,%eax
c0103fc8:	89 45 d4             	mov    %eax,-0x2c(%ebp)

                vmm_map(&context, paddr, vaddr, VMM_WRITABLE | VMM_USER);
c0103fcb:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c0103fd2:	00 
c0103fd3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0103fd6:	89 44 24 08          	mov    %eax,0x8(%esp)
c0103fda:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103fdd:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103fe1:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0103fe4:	89 04 24             	mov    %eax,(%esp)
c0103fe7:	e8 ac 78 00 00       	call   c010b898 <vmm_map>
                vmm_map(current_context, paddr, dest, VMM_WRITABLE);
c0103fec:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c0103ff1:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c0103ff8:	00 
c0103ff9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0103ffc:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104000:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0104003:	89 54 24 04          	mov    %edx,0x4(%esp)
c0104007:	89 04 24             	mov    %eax,(%esp)
c010400a:	e8 89 78 00 00       	call   c010b898 <vmm_map>
            int pages = NUM_PAGES(ph->mem_size);
            uintptr_t dest_start = (uintptr_t) arch_vaddr_find((arch_vmm_context_t*)current_context, pages,
                                   MEMORY_LAYOUT_KERNEL_START, MEMORY_LAYOUT_KERNEL_END);

            // map pages
            for(j = 0; j < pages; j++)
c010400f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0104013:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104016:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0104019:	7c 87                	jl     c0103fa2 <load_elf_thread+0xc6>
                vmm_map(&context, paddr, vaddr, VMM_WRITABLE | VMM_USER);
                vmm_map(current_context, paddr, dest, VMM_WRITABLE);
            }

            // copy data
            memcpy((void*) dest_start, image + ph->offset, ph->file_size);
c010401b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010401e:	8b 50 10             	mov    0x10(%eax),%edx
c0104021:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104024:	8b 48 04             	mov    0x4(%eax),%ecx
c0104027:	8b 45 08             	mov    0x8(%ebp),%eax
c010402a:	01 c1                	add    %eax,%ecx
c010402c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010402f:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104033:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c0104037:	89 04 24             	mov    %eax,(%esp)
c010403a:	e8 64 f2 ff ff       	call   c01032a3 <memcpy>

            // clear rest
            memset((void*)dest_start + ph->file_size, 0, ph->mem_size - ph->file_size);
c010403f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104042:	8b 50 14             	mov    0x14(%eax),%edx
c0104045:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104048:	8b 40 10             	mov    0x10(%eax),%eax
c010404b:	29 c2                	sub    %eax,%edx
c010404d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104050:	8b 48 10             	mov    0x10(%eax),%ecx
c0104053:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104056:	01 c8                	add    %ecx,%eax
c0104058:	89 54 24 08          	mov    %edx,0x8(%esp)
c010405c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0104063:	00 
c0104064:	89 04 24             	mov    %eax,(%esp)
c0104067:	e8 ad f3 ff ff       	call   c0103419 <memset>

            vmm_unmap_range(current_context, dest_start, pages);
c010406c:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c0104071:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0104074:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104078:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010407b:	89 54 24 04          	mov    %edx,0x4(%esp)
c010407f:	89 04 24             	mov    %eax,(%esp)
c0104082:	e8 bc 78 00 00       	call   c010b943 <vmm_unmap_range>
    ph = (struct elf_program_header*) (image + header->ph_offset);

    vmm_context_t context;
    vmm_create_context(&context);

    for(i = 0; i < header->ph_entry_count; i++, ph++)
c0104087:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010408b:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
c010408f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104092:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
c0104096:	0f b7 c0             	movzwl %ax,%eax
c0104099:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c010409c:	0f 8f ac fe ff ff    	jg     c0103f4e <load_elf_thread+0x72>

            vmm_unmap_range(current_context, dest_start, pages);
        }
    }

    struct thread_state *thread = thread_create(proc, 3, header->entry, argv, environ, 0, &context);
c01040a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01040a5:	8b 40 18             	mov    0x18(%eax),%eax
c01040a8:	8d 55 c8             	lea    -0x38(%ebp),%edx
c01040ab:	89 54 24 18          	mov    %edx,0x18(%esp)
c01040af:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c01040b6:	00 
c01040b7:	8b 55 14             	mov    0x14(%ebp),%edx
c01040ba:	89 54 24 10          	mov    %edx,0x10(%esp)
c01040be:	8b 55 10             	mov    0x10(%ebp),%edx
c01040c1:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01040c5:	89 44 24 08          	mov    %eax,0x8(%esp)
c01040c9:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c01040d0:	00 
c01040d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01040d4:	89 04 24             	mov    %eax,(%esp)
c01040d7:	e8 60 10 00 00       	call   c010513c <thread_create>
c01040dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
    return thread;
c01040df:	8b 45 d0             	mov    -0x30(%ebp),%eax
}
c01040e2:	c9                   	leave  
c01040e3:	c3                   	ret    

c01040e4 <disable_irqs>:


void halt(void);

static inline void disable_irqs(void)
{
c01040e4:	55                   	push   %ebp
c01040e5:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c01040e7:	fa                   	cli    
}
c01040e8:	5d                   	pop    %ebp
c01040e9:	c3                   	ret    

c01040ea <enable_irqs>:

static inline void enable_irqs(void)
{
c01040ea:	55                   	push   %ebp
c01040eb:	89 e5                	mov    %esp,%ebp
    asm volatile("sti");
c01040ed:	fb                   	sti    
}
c01040ee:	5d                   	pop    %ebp
c01040ef:	c3                   	ret    

c01040f0 <min>:
 * @param a     inputvalue
 * @param b     inputvalue
 * @return the smallest inputvalue
 */
static inline int min(int a, int b)
{
c01040f0:	55                   	push   %ebp
c01040f1:	89 e5                	mov    %esp,%ebp
    return (a < b) ? a : b;
c01040f3:	8b 45 08             	mov    0x8(%ebp),%eax
c01040f6:	39 45 0c             	cmp    %eax,0xc(%ebp)
c01040f9:	0f 4e 45 0c          	cmovle 0xc(%ebp),%eax
}
c01040fd:	5d                   	pop    %ebp
c01040fe:	c3                   	ret    

c01040ff <dump_thread_list>:
/**
 * @brief Prints a thread-list.
 * @param The thread list
 */
void dump_thread_list(list_t *threads)
{
c01040ff:	55                   	push   %ebp
c0104100:	89 e5                	mov    %esp,%ebp
c0104102:	83 ec 28             	sub    $0x28,%esp
    iterator_t it = iterator_create(threads);
c0104105:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104108:	8b 55 08             	mov    0x8(%ebp),%edx
c010410b:	89 54 24 04          	mov    %edx,0x4(%esp)
c010410f:	89 04 24             	mov    %eax,(%esp)
c0104112:	e8 d4 eb ff ff       	call   c0102ceb <iterator_create>
c0104117:	83 ec 04             	sub    $0x4,%esp
    printf("-----%d-----\n", list_length(threads));
c010411a:	8b 45 08             	mov    0x8(%ebp),%eax
c010411d:	89 04 24             	mov    %eax,(%esp)
c0104120:	e8 49 eb ff ff       	call   c0102c6e <list_length>
c0104125:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104129:	c7 04 24 b3 0a 11 c0 	movl   $0xc0110ab3,(%esp)
c0104130:	e8 ec f4 ff ff       	call   c0103621 <printf>
    while(!list_is_empty(threads) && !list_is_last(&it))
c0104135:	eb 48                	jmp    c010417f <dump_thread_list+0x80>
    {
        struct thread_state *t = list_get_current(&it);
c0104137:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010413a:	89 04 24             	mov    %eax,(%esp)
c010413d:	e8 72 ec ff ff       	call   c0102db4 <list_get_current>
c0104142:	89 45 f4             	mov    %eax,-0xc(%ebp)
        printf("PID: %d  TID: %d  FLAG: %08x\n",t->process->pid, t->tid, t->flags);
c0104145:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104148:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c010414c:	0f b7 c8             	movzwl %ax,%ecx
c010414f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104152:	8b 50 04             	mov    0x4(%eax),%edx
c0104155:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104158:	8b 00                	mov    (%eax),%eax
c010415a:	8b 00                	mov    (%eax),%eax
c010415c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0104160:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104164:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104168:	c7 04 24 c1 0a 11 c0 	movl   $0xc0110ac1,(%esp)
c010416f:	e8 ad f4 ff ff       	call   c0103621 <printf>
        list_next(&it);
c0104174:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104177:	89 04 24             	mov    %eax,(%esp)
c010417a:	e8 5a ec ff ff       	call   c0102dd9 <list_next>
 */
void dump_thread_list(list_t *threads)
{
    iterator_t it = iterator_create(threads);
    printf("-----%d-----\n", list_length(threads));
    while(!list_is_empty(threads) && !list_is_last(&it))
c010417f:	8b 45 08             	mov    0x8(%ebp),%eax
c0104182:	89 04 24             	mov    %eax,(%esp)
c0104185:	e8 20 eb ff ff       	call   c0102caa <list_is_empty>
c010418a:	85 c0                	test   %eax,%eax
c010418c:	75 0f                	jne    c010419d <dump_thread_list+0x9e>
c010418e:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104191:	89 04 24             	mov    %eax,(%esp)
c0104194:	e8 67 ec ff ff       	call   c0102e00 <list_is_last>
c0104199:	85 c0                	test   %eax,%eax
c010419b:	74 9a                	je     c0104137 <dump_thread_list+0x38>
    {
        struct thread_state *t = list_get_current(&it);
        printf("PID: %d  TID: %d  FLAG: %08x\n",t->process->pid, t->tid, t->flags);
        list_next(&it);
    }
}
c010419d:	c9                   	leave  
c010419e:	c3                   	ret    

c010419f <process_create>:
 * @param flags     process flags (activ, freezed, zombies)
 * @param parent    pointer to the parent process struct (NULL: parent = Kernel Init)
 * @return          The new process-state
 */
struct process_state *process_create(const char *name, uint16_t flags, struct process_state *parent, uid_t uid, gid_t gid, struct pipeset *set)
{
c010419f:	55                   	push   %ebp
c01041a0:	89 e5                	mov    %esp,%ebp
c01041a2:	81 ec 98 00 00 00    	sub    $0x98,%esp
c01041a8:	8b 45 0c             	mov    0xc(%ebp),%eax
c01041ab:	66 89 45 94          	mov    %ax,-0x6c(%ebp)
    list_lock(process_list);
c01041af:	a1 14 90 11 c0       	mov    0xc0119014,%eax
c01041b4:	89 04 24             	mov    %eax,(%esp)
c01041b7:	e8 09 eb ff ff       	call   c0102cc5 <list_lock>

    // allocate memory
    struct process_state *state = malloc(sizeof(struct process_state));
c01041bc:	c7 04 24 54 00 00 00 	movl   $0x54,(%esp)
c01041c3:	e8 7d 7d 00 00       	call   c010bf45 <malloc>
c01041c8:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // set IDs
    state->uid = uid;
c01041cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01041ce:	8b 55 14             	mov    0x14(%ebp),%edx
c01041d1:	89 50 04             	mov    %edx,0x4(%eax)
    state->gid = gid;
c01041d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01041d7:	8b 55 18             	mov    0x18(%ebp),%edx
c01041da:	89 50 08             	mov    %edx,0x8(%eax)
    if (list_is_empty(zombie_list))
c01041dd:	a1 18 90 11 c0       	mov    0xc0119018,%eax
c01041e2:	89 04 24             	mov    %eax,(%esp)
c01041e5:	e8 c0 ea ff ff       	call   c0102caa <list_is_empty>
c01041ea:	85 c0                	test   %eax,%eax
c01041ec:	74 14                	je     c0104202 <process_create+0x63>
        state->pid = pid_counter++;
c01041ee:	a1 04 20 11 c0       	mov    0xc0112004,%eax
c01041f3:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01041f6:	89 02                	mov    %eax,(%edx)
c01041f8:	83 c0 01             	add    $0x1,%eax
c01041fb:	a3 04 20 11 c0       	mov    %eax,0xc0112004
c0104200:	eb 14                	jmp    c0104216 <process_create+0x77>
    else
        state->pid = (pid_t) list_pop_front(zombie_list);
c0104202:	a1 18 90 11 c0       	mov    0xc0119018,%eax
c0104207:	89 04 24             	mov    %eax,(%esp)
c010420a:	e8 73 e9 ff ff       	call   c0102b82 <list_pop_front>
c010420f:	89 c2                	mov    %eax,%edx
c0104211:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104214:	89 10                	mov    %edx,(%eax)

    // copy name string
    int string_len = min(strlen(name), 255);
c0104216:	8b 45 08             	mov    0x8(%ebp),%eax
c0104219:	89 04 24             	mov    %eax,(%esp)
c010421c:	e8 ac ec ff ff       	call   c0102ecd <strlen>
c0104221:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
c0104228:	00 
c0104229:	89 04 24             	mov    %eax,(%esp)
c010422c:	e8 bf fe ff ff       	call   c01040f0 <min>
c0104231:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    state->name = (char *) malloc(string_len + 1);
c0104234:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104237:	83 c0 01             	add    $0x1,%eax
c010423a:	89 04 24             	mov    %eax,(%esp)
c010423d:	e8 03 7d 00 00       	call   c010bf45 <malloc>
c0104242:	89 c2                	mov    %eax,%edx
c0104244:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104247:	89 50 0c             	mov    %edx,0xc(%eax)
    strncpy(state->name, name, string_len);
c010424a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010424d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104250:	8b 40 0c             	mov    0xc(%eax),%eax
c0104253:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104257:	8b 55 08             	mov    0x8(%ebp),%edx
c010425a:	89 54 24 04          	mov    %edx,0x4(%esp)
c010425e:	89 04 24             	mov    %eax,(%esp)
c0104261:	e8 df ec ff ff       	call   c0102f45 <strncpy>
    state->name[string_len + 1] = '\0';
c0104266:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104269:	8b 40 0c             	mov    0xc(%eax),%eax
c010426c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010426f:	83 c2 01             	add    $0x1,%edx
c0104272:	01 d0                	add    %edx,%eax
c0104274:	c6 00 00             	movb   $0x0,(%eax)

    // take parent
    // if parent is NULL, use kernel init
    if (parent == NULL)
c0104277:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010427b:	75 0e                	jne    c010428b <process_create+0xec>
        state->parent = kernel_state;
c010427d:	8b 15 08 90 11 c0    	mov    0xc0119008,%edx
c0104283:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104286:	89 50 10             	mov    %edx,0x10(%eax)
c0104289:	eb 09                	jmp    c0104294 <process_create+0xf5>
    else
        state->parent = parent;
c010428b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010428e:	8b 55 10             	mov    0x10(%ebp),%edx
c0104291:	89 50 10             	mov    %edx,0x10(%eax)

    // take working directory of parent
    if(parent == NULL)
c0104294:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0104298:	75 0e                	jne    c01042a8 <process_create+0x109>
        state->cwd = root;
c010429a:	8b 15 20 90 11 c0    	mov    0xc0119020,%edx
c01042a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01042a3:	89 50 14             	mov    %edx,0x14(%eax)
c01042a6:	eb 0c                	jmp    c01042b4 <process_create+0x115>
    else
        state->cwd = parent->cwd;
c01042a8:	8b 45 10             	mov    0x10(%ebp),%eax
c01042ab:	8b 50 14             	mov    0x14(%eax),%edx
c01042ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01042b1:	89 50 14             	mov    %edx,0x14(%eax)

    // create lists of files & ports
    state->files = list_create();
c01042b4:	e8 c2 e6 ff ff       	call   c010297b <list_create>
c01042b9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01042bc:	89 42 18             	mov    %eax,0x18(%edx)
    state->ports = list_create();
c01042bf:	e8 b7 e6 ff ff       	call   c010297b <list_create>
c01042c4:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01042c7:	89 42 1c             	mov    %eax,0x1c(%edx)

    // threads
    state->main_thread = NULL;
c01042ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01042cd:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    state->threads = list_create();
c01042d4:	e8 a2 e6 ff ff       	call   c010297b <list_create>
c01042d9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01042dc:	89 42 34             	mov    %eax,0x34(%edx)
    state->zombie_tids = list_create();
c01042df:	e8 97 e6 ff ff       	call   c010297b <list_create>
c01042e4:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01042e7:	89 42 38             	mov    %eax,0x38(%edx)
    state->tid_counter = 1;
c01042ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01042ed:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)

    // child processes
    state->children = list_create();
c01042f4:	e8 82 e6 ff ff       	call   c010297b <list_create>
c01042f9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01042fc:	89 42 40             	mov    %eax,0x40(%edx)
        list_push_front(state->parent->children, new_child);
    }
    */

    // flags
    state->flags = flags;
c01042ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104302:	0f b7 55 94          	movzwl -0x6c(%ebp),%edx
c0104306:	66 89 50 44          	mov    %dx,0x44(%eax)

    // memory stuff
    state->heap_top = 0;
c010430a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010430d:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    state->heap_lower_limit = 0;
c0104314:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104317:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
    state->heap_upper_limit = 0;
c010431e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104321:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
    // create stream files
    // if pipeset is avaiable, use it
    vfs_inode_t *stdin;
    vfs_inode_t *stdout;
    vfs_inode_t *stderr;
    if(!set)
c0104328:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c010432c:	75 41                	jne    c010436f <process_create+0x1d0>
    {
        stdin = vfs_create_pipe(uid, gid);
c010432e:	8b 45 18             	mov    0x18(%ebp),%eax
c0104331:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104335:	8b 45 14             	mov    0x14(%ebp),%eax
c0104338:	89 04 24             	mov    %eax,(%esp)
c010433b:	e8 ba 1c 00 00       	call   c0105ffa <vfs_create_pipe>
c0104340:	89 45 f4             	mov    %eax,-0xc(%ebp)
        stdout = vfs_create_pipe(uid, gid);
c0104343:	8b 45 18             	mov    0x18(%ebp),%eax
c0104346:	89 44 24 04          	mov    %eax,0x4(%esp)
c010434a:	8b 45 14             	mov    0x14(%ebp),%eax
c010434d:	89 04 24             	mov    %eax,(%esp)
c0104350:	e8 a5 1c 00 00       	call   c0105ffa <vfs_create_pipe>
c0104355:	89 45 f0             	mov    %eax,-0x10(%ebp)
        stderr = vfs_create_pipe(uid, gid);
c0104358:	8b 45 18             	mov    0x18(%ebp),%eax
c010435b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010435f:	8b 45 14             	mov    0x14(%ebp),%eax
c0104362:	89 04 24             	mov    %eax,(%esp)
c0104365:	e8 90 1c 00 00       	call   c0105ffa <vfs_create_pipe>
c010436a:	89 45 ec             	mov    %eax,-0x14(%ebp)
c010436d:	eb 1a                	jmp    c0104389 <process_create+0x1ea>
    }
    else
    {
        stdin = set->stdin;
c010436f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0104372:	8b 00                	mov    (%eax),%eax
c0104374:	89 45 f4             	mov    %eax,-0xc(%ebp)
        stdout = set->stdout;
c0104377:	8b 45 1c             	mov    0x1c(%ebp),%eax
c010437a:	8b 40 04             	mov    0x4(%eax),%eax
c010437d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        stderr = set->stderr;
c0104380:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0104383:	8b 40 08             	mov    0x8(%eax),%eax
c0104386:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }

    struct fd *desc0 = malloc(sizeof(struct fd));
c0104389:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0104390:	e8 b0 7b 00 00       	call   c010bf45 <malloc>
c0104395:	89 45 e0             	mov    %eax,-0x20(%ebp)
    desc0->id = 0;
c0104398:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010439b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    desc0->mode = 0x7ff;
c01043a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01043a4:	c7 40 04 ff 07 00 00 	movl   $0x7ff,0x4(%eax)
    desc0->flags = O_RDONLY;
c01043ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01043ae:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
    desc0->permission = VFS_PERMISSION_READ;
c01043b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01043b8:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    desc0->read_pos = 0;
c01043bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01043c2:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    desc0->write_pos = 0;
c01043c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01043cc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    desc0->read_inode = stdin;
c01043d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01043d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01043d9:	89 50 10             	mov    %edx,0x10(%eax)
    desc0->write_inode = NULL;
c01043dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01043df:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    list_push_back(state->files, desc0);
c01043e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01043e9:	8b 40 18             	mov    0x18(%eax),%eax
c01043ec:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01043ef:	89 54 24 04          	mov    %edx,0x4(%esp)
c01043f3:	89 04 24             	mov    %eax,(%esp)
c01043f6:	e8 64 e6 ff ff       	call   c0102a5f <list_push_back>

    struct fd *desc1 = malloc(sizeof(struct fd));
c01043fb:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0104402:	e8 3e 7b 00 00       	call   c010bf45 <malloc>
c0104407:	89 45 dc             	mov    %eax,-0x24(%ebp)
    desc1->id = 1;
c010440a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010440d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    desc1->mode = 0x7ff;
c0104413:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104416:	c7 40 04 ff 07 00 00 	movl   $0x7ff,0x4(%eax)
    desc1->flags = O_WRONLY;
c010441d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104420:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
    desc1->permission = VFS_PERMISSION_WRITE;
c0104427:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010442a:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
    desc1->read_pos = 0;
c0104431:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104434:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    desc1->write_pos = 0;
c010443b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010443e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    desc1->read_inode = NULL;
c0104445:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104448:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    desc1->write_inode = stdout;
c010444f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104452:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0104455:	89 50 14             	mov    %edx,0x14(%eax)
    list_push_back(state->files, desc1);
c0104458:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010445b:	8b 40 18             	mov    0x18(%eax),%eax
c010445e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0104461:	89 54 24 04          	mov    %edx,0x4(%esp)
c0104465:	89 04 24             	mov    %eax,(%esp)
c0104468:	e8 f2 e5 ff ff       	call   c0102a5f <list_push_back>

    struct fd *desc2 = malloc(sizeof(struct fd));
c010446d:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0104474:	e8 cc 7a 00 00       	call   c010bf45 <malloc>
c0104479:	89 45 d8             	mov    %eax,-0x28(%ebp)
    desc2->id = 2;
c010447c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010447f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    desc2->mode = 0x7ff;
c0104485:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0104488:	c7 40 04 ff 07 00 00 	movl   $0x7ff,0x4(%eax)
    desc2->flags = O_WRONLY;
c010448f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0104492:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
    desc2->permission = VFS_PERMISSION_WRITE;
c0104499:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010449c:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
    desc2->read_pos = 0;
c01044a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01044a6:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    desc2->write_pos = 0;
c01044ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01044b0:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    desc2->read_inode = NULL;
c01044b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01044ba:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    desc2->write_inode = stderr;
c01044c1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01044c4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01044c7:	89 50 14             	mov    %edx,0x14(%eax)
    list_push_back(state->files, desc2);
c01044ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01044cd:	8b 40 18             	mov    0x18(%eax),%eax
c01044d0:	8b 55 d8             	mov    -0x28(%ebp),%edx
c01044d3:	89 54 24 04          	mov    %edx,0x4(%esp)
c01044d7:	89 04 24             	mov    %eax,(%esp)
c01044da:	e8 80 e5 ff ff       	call   c0102a5f <list_push_back>

    // create directory /proc/<pid>/ and /proc/<pid>/socket/
    char str[64];
    itoa(state->pid, str, 10);
c01044df:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01044e2:	8b 00                	mov    (%eax),%eax
c01044e4:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
c01044eb:	00 
c01044ec:	8d 55 98             	lea    -0x68(%ebp),%edx
c01044ef:	89 54 24 04          	mov    %edx,0x4(%esp)
c01044f3:	89 04 24             	mov    %eax,(%esp)
c01044f6:	e8 d9 e3 ff ff       	call   c01028d4 <itoa>
    state->proc_inode = vfs_create_inode(str, S_IFDIR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, proc_dir_inode, 0, 0);
c01044fb:	a1 1c 90 11 c0       	mov    0xc011901c,%eax
c0104500:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0104507:	00 
c0104508:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010450f:	00 
c0104510:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104514:	c7 44 24 04 20 13 01 	movl   $0x11320,0x4(%esp)
c010451b:	00 
c010451c:	8d 45 98             	lea    -0x68(%ebp),%eax
c010451f:	89 04 24             	mov    %eax,(%esp)
c0104522:	e8 07 19 00 00       	call   c0105e2e <vfs_create_inode>
c0104527:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010452a:	89 42 28             	mov    %eax,0x28(%edx)
    state->socket_inode = vfs_create_inode("socket", S_IFDIR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, state->proc_inode, 0, 0);
c010452d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104530:	8b 40 28             	mov    0x28(%eax),%eax
c0104533:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010453a:	00 
c010453b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0104542:	00 
c0104543:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104547:	c7 44 24 04 20 13 01 	movl   $0x11320,0x4(%esp)
c010454e:	00 
c010454f:	c7 04 24 df 0a 11 c0 	movl   $0xc0110adf,(%esp)
c0104556:	e8 d3 18 00 00       	call   c0105e2e <vfs_create_inode>
c010455b:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010455e:	89 42 2c             	mov    %eax,0x2c(%edx)
    state->socket_requests = list_create();
c0104561:	e8 15 e4 ff ff       	call   c010297b <list_create>
c0104566:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0104569:	89 42 20             	mov    %eax,0x20(%edx)
    state->socket_event_id = 0;
c010456c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010456f:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

    // add to process list
    list_push_front(process_list, state);
c0104576:	a1 14 90 11 c0       	mov    0xc0119014,%eax
c010457b:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010457e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0104582:	89 04 24             	mov    %eax,(%esp)
c0104585:	e8 28 e5 ff ff       	call   c0102ab2 <list_push_front>

    list_unlock(process_list);
c010458a:	a1 14 90 11 c0       	mov    0xc0119014,%eax
c010458f:	89 04 24             	mov    %eax,(%esp)
c0104592:	e8 41 e7 ff ff       	call   c0102cd8 <list_unlock>

    return state;
c0104597:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c010459a:	c9                   	leave  
c010459b:	c3                   	ret    

c010459c <process_kill>:
/**
 * @brief			kills a process
 * @param process	pointer to the process state
 */
void process_kill(struct process_state *process)
{
c010459c:	55                   	push   %ebp
c010459d:	89 e5                	mov    %esp,%ebp
c010459f:	83 ec 38             	sub    $0x38,%esp
    disable_irqs();
c01045a2:	e8 3d fb ff ff       	call   c01040e4 <disable_irqs>

    send_killed_process(process);
c01045a7:	8b 45 08             	mov    0x8(%ebp),%eax
c01045aa:	89 04 24             	mov    %eax,(%esp)
c01045ad:	e8 d2 6e 00 00       	call   c010b484 <send_killed_process>

    // kill all threads
    while(!list_is_empty(process->threads))
c01045b2:	eb 51                	jmp    c0104605 <process_kill+0x69>
    {
        struct thread_state *thread = list_pop_front(process->threads);
c01045b4:	8b 45 08             	mov    0x8(%ebp),%eax
c01045b7:	8b 40 34             	mov    0x34(%eax),%eax
c01045ba:	89 04 24             	mov    %eax,(%esp)
c01045bd:	e8 c0 e5 ff ff       	call   c0102b82 <list_pop_front>
c01045c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(thread == current_thread)
c01045c5:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01045ca:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c01045cd:	75 2b                	jne    c01045fa <process_kill+0x5e>
        {
            current_thread->flags |= THREAD_ZOMBIE;
c01045cf:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01045d4:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c01045da:	0f b7 52 10          	movzwl 0x10(%edx),%edx
c01045de:	83 ca 08             	or     $0x8,%edx
c01045e1:	66 89 50 10          	mov    %dx,0x10(%eax)
            process->flags |= PROCESS_ZOMBIE;
c01045e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01045e8:	0f b7 40 44          	movzwl 0x44(%eax),%eax
c01045ec:	89 c2                	mov    %eax,%edx
c01045ee:	83 ca 04             	or     $0x4,%edx
c01045f1:	8b 45 08             	mov    0x8(%ebp),%eax
c01045f4:	66 89 50 44          	mov    %dx,0x44(%eax)
c01045f8:	eb 0b                	jmp    c0104605 <process_kill+0x69>
        }
        else
            thread_kill_sub(thread);
c01045fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01045fd:	89 04 24             	mov    %eax,(%esp)
c0104600:	e8 7c 11 00 00       	call   c0105781 <thread_kill_sub>
    disable_irqs();

    send_killed_process(process);

    // kill all threads
    while(!list_is_empty(process->threads))
c0104605:	8b 45 08             	mov    0x8(%ebp),%eax
c0104608:	8b 40 34             	mov    0x34(%eax),%eax
c010460b:	89 04 24             	mov    %eax,(%esp)
c010460e:	e8 97 e6 ff ff       	call   c0102caa <list_is_empty>
c0104613:	85 c0                	test   %eax,%eax
c0104615:	74 9d                	je     c01045b4 <process_kill+0x18>
        else
            thread_kill_sub(thread);
    }

    // kill all children
    list_lock(process->children);
c0104617:	8b 45 08             	mov    0x8(%ebp),%eax
c010461a:	8b 40 40             	mov    0x40(%eax),%eax
c010461d:	89 04 24             	mov    %eax,(%esp)
c0104620:	e8 a0 e6 ff ff       	call   c0102cc5 <list_lock>
    while(!list_is_empty(process->children))
c0104625:	eb 34                	jmp    c010465b <process_kill+0xbf>
    {
        struct child *current_child = list_pop_front(process->children);
c0104627:	8b 45 08             	mov    0x8(%ebp),%eax
c010462a:	8b 40 40             	mov    0x40(%eax),%eax
c010462d:	89 04 24             	mov    %eax,(%esp)
c0104630:	e8 4d e5 ff ff       	call   c0102b82 <list_pop_front>
c0104635:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(current_child->process)
c0104638:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010463b:	8b 40 04             	mov    0x4(%eax),%eax
c010463e:	85 c0                	test   %eax,%eax
c0104640:	74 0e                	je     c0104650 <process_kill+0xb4>
            process_kill(current_child->process);
c0104642:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104645:	8b 40 04             	mov    0x4(%eax),%eax
c0104648:	89 04 24             	mov    %eax,(%esp)
c010464b:	e8 4c ff ff ff       	call   c010459c <process_kill>
        free(current_child);
c0104650:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104653:	89 04 24             	mov    %eax,(%esp)
c0104656:	e8 f8 79 00 00       	call   c010c053 <free>
            thread_kill_sub(thread);
    }

    // kill all children
    list_lock(process->children);
    while(!list_is_empty(process->children))
c010465b:	8b 45 08             	mov    0x8(%ebp),%eax
c010465e:	8b 40 40             	mov    0x40(%eax),%eax
c0104661:	89 04 24             	mov    %eax,(%esp)
c0104664:	e8 41 e6 ff ff       	call   c0102caa <list_is_empty>
c0104669:	85 c0                	test   %eax,%eax
c010466b:	74 ba                	je     c0104627 <process_kill+0x8b>
        struct child *current_child = list_pop_front(process->children);
        if(current_child->process)
            process_kill(current_child->process);
        free(current_child);
    }
    free(process->children);
c010466d:	8b 45 08             	mov    0x8(%ebp),%eax
c0104670:	8b 40 40             	mov    0x40(%eax),%eax
c0104673:	89 04 24             	mov    %eax,(%esp)
c0104676:	e8 d8 79 00 00       	call   c010c053 <free>

    // remove process from parents children list
    list_lock(process->parent->children);
c010467b:	8b 45 08             	mov    0x8(%ebp),%eax
c010467e:	8b 40 10             	mov    0x10(%eax),%eax
c0104681:	8b 40 40             	mov    0x40(%eax),%eax
c0104684:	89 04 24             	mov    %eax,(%esp)
c0104687:	e8 39 e6 ff ff       	call   c0102cc5 <list_lock>
    iterator_t parents_children_it = iterator_create(process->parent->children);
c010468c:	8b 45 08             	mov    0x8(%ebp),%eax
c010468f:	8b 40 10             	mov    0x10(%eax),%eax
c0104692:	8b 50 40             	mov    0x40(%eax),%edx
c0104695:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0104698:	89 54 24 04          	mov    %edx,0x4(%esp)
c010469c:	89 04 24             	mov    %eax,(%esp)
c010469f:	e8 47 e6 ff ff       	call   c0102ceb <iterator_create>
c01046a4:	83 ec 04             	sub    $0x4,%esp

    while(!list_is_empty(process->parent->children) && !list_is_last(&parents_children_it))
c01046a7:	eb 3c                	jmp    c01046e5 <process_kill+0x149>
    {
        struct child *current_child = list_get_current(&parents_children_it);
c01046a9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01046ac:	89 04 24             	mov    %eax,(%esp)
c01046af:	e8 00 e7 ff ff       	call   c0102db4 <list_get_current>
c01046b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(current_child->process == process)
c01046b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01046ba:	8b 40 04             	mov    0x4(%eax),%eax
c01046bd:	3b 45 08             	cmp    0x8(%ebp),%eax
c01046c0:	75 18                	jne    c01046da <process_kill+0x13e>
        {
            list_remove(&parents_children_it);
c01046c2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01046c5:	89 04 24             	mov    %eax,(%esp)
c01046c8:	e8 79 e7 ff ff       	call   c0102e46 <list_remove>
            free(current_child);
c01046cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01046d0:	89 04 24             	mov    %eax,(%esp)
c01046d3:	e8 7b 79 00 00       	call   c010c053 <free>
            break;
c01046d8:	eb 2f                	jmp    c0104709 <process_kill+0x16d>
        }
        list_next(&parents_children_it);
c01046da:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01046dd:	89 04 24             	mov    %eax,(%esp)
c01046e0:	e8 f4 e6 ff ff       	call   c0102dd9 <list_next>

    // remove process from parents children list
    list_lock(process->parent->children);
    iterator_t parents_children_it = iterator_create(process->parent->children);

    while(!list_is_empty(process->parent->children) && !list_is_last(&parents_children_it))
c01046e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01046e8:	8b 40 10             	mov    0x10(%eax),%eax
c01046eb:	8b 40 40             	mov    0x40(%eax),%eax
c01046ee:	89 04 24             	mov    %eax,(%esp)
c01046f1:	e8 b4 e5 ff ff       	call   c0102caa <list_is_empty>
c01046f6:	85 c0                	test   %eax,%eax
c01046f8:	75 0f                	jne    c0104709 <process_kill+0x16d>
c01046fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01046fd:	89 04 24             	mov    %eax,(%esp)
c0104700:	e8 fb e6 ff ff       	call   c0102e00 <list_is_last>
c0104705:	85 c0                	test   %eax,%eax
c0104707:	74 a0                	je     c01046a9 <process_kill+0x10d>
            break;
        }
        list_next(&parents_children_it);
    }

    list_unlock(process->parent->children);
c0104709:	8b 45 08             	mov    0x8(%ebp),%eax
c010470c:	8b 40 10             	mov    0x10(%eax),%eax
c010470f:	8b 40 40             	mov    0x40(%eax),%eax
c0104712:	89 04 24             	mov    %eax,(%esp)
c0104715:	e8 be e5 ff ff       	call   c0102cd8 <list_unlock>

    // remove from global process list
    list_lock(process_list);
c010471a:	a1 14 90 11 c0       	mov    0xc0119014,%eax
c010471f:	89 04 24             	mov    %eax,(%esp)
c0104722:	e8 9e e5 ff ff       	call   c0102cc5 <list_lock>

    iterator_t process_it = iterator_create(process_list);
c0104727:	8b 15 14 90 11 c0    	mov    0xc0119014,%edx
c010472d:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0104730:	89 54 24 04          	mov    %edx,0x4(%esp)
c0104734:	89 04 24             	mov    %eax,(%esp)
c0104737:	e8 af e5 ff ff       	call   c0102ceb <iterator_create>
c010473c:	83 ec 04             	sub    $0x4,%esp

    while(!list_is_empty(process_list) &&!list_is_last(&process_it))
c010473f:	eb 28                	jmp    c0104769 <process_kill+0x1cd>
    {
        if(((struct process_state *)list_get_current(&process_it)) == process)
c0104741:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0104744:	89 04 24             	mov    %eax,(%esp)
c0104747:	e8 68 e6 ff ff       	call   c0102db4 <list_get_current>
c010474c:	3b 45 08             	cmp    0x8(%ebp),%eax
c010474f:	75 0d                	jne    c010475e <process_kill+0x1c2>
        {
            list_remove(&process_it);
c0104751:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0104754:	89 04 24             	mov    %eax,(%esp)
c0104757:	e8 ea e6 ff ff       	call   c0102e46 <list_remove>
            break;
c010475c:	eb 2b                	jmp    c0104789 <process_kill+0x1ed>
        }
        list_next(&process_it);
c010475e:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0104761:	89 04 24             	mov    %eax,(%esp)
c0104764:	e8 70 e6 ff ff       	call   c0102dd9 <list_next>
    // remove from global process list
    list_lock(process_list);

    iterator_t process_it = iterator_create(process_list);

    while(!list_is_empty(process_list) &&!list_is_last(&process_it))
c0104769:	a1 14 90 11 c0       	mov    0xc0119014,%eax
c010476e:	89 04 24             	mov    %eax,(%esp)
c0104771:	e8 34 e5 ff ff       	call   c0102caa <list_is_empty>
c0104776:	85 c0                	test   %eax,%eax
c0104778:	75 0f                	jne    c0104789 <process_kill+0x1ed>
c010477a:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010477d:	89 04 24             	mov    %eax,(%esp)
c0104780:	e8 7b e6 ff ff       	call   c0102e00 <list_is_last>
c0104785:	85 c0                	test   %eax,%eax
c0104787:	74 b8                	je     c0104741 <process_kill+0x1a5>
            list_remove(&process_it);
            break;
        }
        list_next(&process_it);
    }
    list_unlock(process_list);
c0104789:	a1 14 90 11 c0       	mov    0xc0119014,%eax
c010478e:	89 04 24             	mov    %eax,(%esp)
c0104791:	e8 42 e5 ff ff       	call   c0102cd8 <list_unlock>

    // remove vfs inode
    vfs_remove_dir_entry(proc_dir_inode, process->proc_inode);
c0104796:	8b 45 08             	mov    0x8(%ebp),%eax
c0104799:	8b 50 28             	mov    0x28(%eax),%edx
c010479c:	a1 1c 90 11 c0       	mov    0xc011901c,%eax
c01047a1:	89 54 24 04          	mov    %edx,0x4(%esp)
c01047a5:	89 04 24             	mov    %eax,(%esp)
c01047a8:	e8 8f 35 00 00       	call   c0107d3c <vfs_remove_dir_entry>

    // free process data
    list_destroy(process->ports);
c01047ad:	8b 45 08             	mov    0x8(%ebp),%eax
c01047b0:	8b 40 1c             	mov    0x1c(%eax),%eax
c01047b3:	89 04 24             	mov    %eax,(%esp)
c01047b6:	e8 18 e2 ff ff       	call   c01029d3 <list_destroy>
    list_destroy(process->zombie_tids);
c01047bb:	8b 45 08             	mov    0x8(%ebp),%eax
c01047be:	8b 40 38             	mov    0x38(%eax),%eax
c01047c1:	89 04 24             	mov    %eax,(%esp)
c01047c4:	e8 0a e2 ff ff       	call   c01029d3 <list_destroy>
    free(process->name);
c01047c9:	8b 45 08             	mov    0x8(%ebp),%eax
c01047cc:	8b 40 0c             	mov    0xc(%eax),%eax
c01047cf:	89 04 24             	mov    %eax,(%esp)
c01047d2:	e8 7c 78 00 00       	call   c010c053 <free>

    if(!(process->flags & PROCESS_ZOMBIE) )
c01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
c01047da:	0f b7 40 44          	movzwl 0x44(%eax),%eax
c01047de:	0f b7 c0             	movzwl %ax,%eax
c01047e1:	83 e0 04             	and    $0x4,%eax
c01047e4:	85 c0                	test   %eax,%eax
c01047e6:	75 0b                	jne    c01047f3 <process_kill+0x257>
    {
        free(process);
c01047e8:	8b 45 08             	mov    0x8(%ebp),%eax
c01047eb:	89 04 24             	mov    %eax,(%esp)
c01047ee:	e8 60 78 00 00       	call   c010c053 <free>
    }

    enable_irqs();
c01047f3:	e8 f2 f8 ff ff       	call   c01040ea <enable_irqs>
}
c01047f8:	c9                   	leave  
c01047f9:	c3                   	ret    

c01047fa <process_suspend>:
/**
 *  @brief			Suspends a process
 *  @param process	pointer to the process state
 */
void process_suspend(struct process_state *process)
{
c01047fa:	55                   	push   %ebp
c01047fb:	89 e5                	mov    %esp,%ebp
c01047fd:	83 ec 28             	sub    $0x28,%esp
    // suspend threads
    if(! list_is_empty(process->threads))
c0104800:	8b 45 08             	mov    0x8(%ebp),%eax
c0104803:	8b 40 34             	mov    0x34(%eax),%eax
c0104806:	89 04 24             	mov    %eax,(%esp)
c0104809:	e8 9c e4 ff ff       	call   c0102caa <list_is_empty>
c010480e:	85 c0                	test   %eax,%eax
c0104810:	75 69                	jne    c010487b <process_suspend+0x81>
    {
        iterator_t it = iterator_create(process->threads);
c0104812:	8b 45 08             	mov    0x8(%ebp),%eax
c0104815:	8b 50 34             	mov    0x34(%eax),%edx
c0104818:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010481b:	89 54 24 04          	mov    %edx,0x4(%esp)
c010481f:	89 04 24             	mov    %eax,(%esp)
c0104822:	e8 c4 e4 ff ff       	call   c0102ceb <iterator_create>
c0104827:	83 ec 04             	sub    $0x4,%esp
        list_set_first(&it);
c010482a:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010482d:	89 04 24             	mov    %eax,(%esp)
c0104830:	e8 e6 e5 ff ff       	call   c0102e1b <list_set_first>

        while(! list_is_last(&it))
c0104835:	eb 35                	jmp    c010486c <process_suspend+0x72>
        {
            struct thread_state *thread = (struct thread_state *) list_get_current(&it);
c0104837:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010483a:	89 04 24             	mov    %eax,(%esp)
c010483d:	e8 72 e5 ff ff       	call   c0102db4 <list_get_current>
c0104842:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(thread->flags & THREAD_ACTIVE)
c0104845:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104848:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c010484c:	0f b7 c0             	movzwl %ax,%eax
c010484f:	83 e0 01             	and    $0x1,%eax
c0104852:	85 c0                	test   %eax,%eax
c0104854:	74 0b                	je     c0104861 <process_suspend+0x67>
                thread_suspend(thread);
c0104856:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104859:	89 04 24             	mov    %eax,(%esp)
c010485c:	e8 25 0e 00 00       	call   c0105686 <thread_suspend>

            list_next(&it);
c0104861:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104864:	89 04 24             	mov    %eax,(%esp)
c0104867:	e8 6d e5 ff ff       	call   c0102dd9 <list_next>
    if(! list_is_empty(process->threads))
    {
        iterator_t it = iterator_create(process->threads);
        list_set_first(&it);

        while(! list_is_last(&it))
c010486c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010486f:	89 04 24             	mov    %eax,(%esp)
c0104872:	e8 89 e5 ff ff       	call   c0102e00 <list_is_last>
c0104877:	85 c0                	test   %eax,%eax
c0104879:	74 bc                	je     c0104837 <process_suspend+0x3d>
            list_next(&it);
        }
    }

    // set flag
    process->flags &= ~PROCESS_ACTIVE;
c010487b:	8b 45 08             	mov    0x8(%ebp),%eax
c010487e:	0f b7 40 44          	movzwl 0x44(%eax),%eax
c0104882:	89 c2                	mov    %eax,%edx
c0104884:	83 e2 fe             	and    $0xfffffffe,%edx
c0104887:	8b 45 08             	mov    0x8(%ebp),%eax
c010488a:	66 89 50 44          	mov    %dx,0x44(%eax)
}
c010488e:	c9                   	leave  
c010488f:	c3                   	ret    

c0104890 <process_wakeup>:
/**
 * @brief			Wakes up a process
 * @param process	pointer to the process state
 **/
void process_wakeup(struct process_state *process)
{
c0104890:	55                   	push   %ebp
c0104891:	89 e5                	mov    %esp,%ebp
c0104893:	83 ec 28             	sub    $0x28,%esp
    // wakeup threads
    if(! list_is_empty(process->threads))
c0104896:	8b 45 08             	mov    0x8(%ebp),%eax
c0104899:	8b 40 34             	mov    0x34(%eax),%eax
c010489c:	89 04 24             	mov    %eax,(%esp)
c010489f:	e8 06 e4 ff ff       	call   c0102caa <list_is_empty>
c01048a4:	85 c0                	test   %eax,%eax
c01048a6:	75 69                	jne    c0104911 <process_wakeup+0x81>
    {
        iterator_t it = iterator_create(process->threads);
c01048a8:	8b 45 08             	mov    0x8(%ebp),%eax
c01048ab:	8b 50 34             	mov    0x34(%eax),%edx
c01048ae:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01048b1:	89 54 24 04          	mov    %edx,0x4(%esp)
c01048b5:	89 04 24             	mov    %eax,(%esp)
c01048b8:	e8 2e e4 ff ff       	call   c0102ceb <iterator_create>
c01048bd:	83 ec 04             	sub    $0x4,%esp
        list_set_first(&it);
c01048c0:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01048c3:	89 04 24             	mov    %eax,(%esp)
c01048c6:	e8 50 e5 ff ff       	call   c0102e1b <list_set_first>

        while(! list_is_last(&it))
c01048cb:	eb 35                	jmp    c0104902 <process_wakeup+0x72>
        {
            struct thread_state *thread = (struct thread_state *) list_get_current(&it);
c01048cd:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01048d0:	89 04 24             	mov    %eax,(%esp)
c01048d3:	e8 dc e4 ff ff       	call   c0102db4 <list_get_current>
c01048d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(! (thread->flags & THREAD_ACTIVE))
c01048db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01048de:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01048e2:	0f b7 c0             	movzwl %ax,%eax
c01048e5:	83 e0 01             	and    $0x1,%eax
c01048e8:	85 c0                	test   %eax,%eax
c01048ea:	75 0b                	jne    c01048f7 <process_wakeup+0x67>
                thread_wakeup(thread);
c01048ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01048ef:	89 04 24             	mov    %eax,(%esp)
c01048f2:	e8 1f 0e 00 00       	call   c0105716 <thread_wakeup>

            list_next(&it);
c01048f7:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01048fa:	89 04 24             	mov    %eax,(%esp)
c01048fd:	e8 d7 e4 ff ff       	call   c0102dd9 <list_next>
    if(! list_is_empty(process->threads))
    {
        iterator_t it = iterator_create(process->threads);
        list_set_first(&it);

        while(! list_is_last(&it))
c0104902:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104905:	89 04 24             	mov    %eax,(%esp)
c0104908:	e8 f3 e4 ff ff       	call   c0102e00 <list_is_last>
c010490d:	85 c0                	test   %eax,%eax
c010490f:	74 bc                	je     c01048cd <process_wakeup+0x3d>
            list_next(&it);
        }
    }

    // set flag
    process->flags |= PROCESS_ACTIVE;
c0104911:	8b 45 08             	mov    0x8(%ebp),%eax
c0104914:	0f b7 40 44          	movzwl 0x44(%eax),%eax
c0104918:	89 c2                	mov    %eax,%edx
c010491a:	83 ca 01             	or     $0x1,%edx
c010491d:	8b 45 08             	mov    0x8(%ebp),%eax
c0104920:	66 89 50 44          	mov    %dx,0x44(%eax)
}
c0104924:	c9                   	leave  
c0104925:	c3                   	ret    

c0104926 <process_find>:
 * @brief		finds a process by (Proccess-)ID
 * @param pid	Process ID
 * @return		process state pointer or NULL if the process does not exist
 */
struct process_state *process_find(pid_t pid)
{
c0104926:	55                   	push   %ebp
c0104927:	89 e5                	mov    %esp,%ebp
c0104929:	83 ec 28             	sub    $0x28,%esp
    if(! list_is_empty(process_list))
c010492c:	a1 14 90 11 c0       	mov    0xc0119014,%eax
c0104931:	89 04 24             	mov    %eax,(%esp)
c0104934:	e8 71 e3 ff ff       	call   c0102caa <list_is_empty>
c0104939:	85 c0                	test   %eax,%eax
c010493b:	75 5c                	jne    c0104999 <process_find+0x73>
    {
        iterator_t process_it = iterator_create(process_list);
c010493d:	8b 15 14 90 11 c0    	mov    0xc0119014,%edx
c0104943:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104946:	89 54 24 04          	mov    %edx,0x4(%esp)
c010494a:	89 04 24             	mov    %eax,(%esp)
c010494d:	e8 99 e3 ff ff       	call   c0102ceb <iterator_create>
c0104952:	83 ec 04             	sub    $0x4,%esp
        list_set_first(&process_it);
c0104955:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104958:	89 04 24             	mov    %eax,(%esp)
c010495b:	e8 bb e4 ff ff       	call   c0102e1b <list_set_first>

        while(! list_is_last(&process_it))
c0104960:	eb 28                	jmp    c010498a <process_find+0x64>
        {
            struct process_state *state = (struct process_state *) list_get_current(&process_it);
c0104962:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104965:	89 04 24             	mov    %eax,(%esp)
c0104968:	e8 47 e4 ff ff       	call   c0102db4 <list_get_current>
c010496d:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(state->pid == pid)
c0104970:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104973:	8b 00                	mov    (%eax),%eax
c0104975:	3b 45 08             	cmp    0x8(%ebp),%eax
c0104978:	75 05                	jne    c010497f <process_find+0x59>
            {
                return state;
c010497a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010497d:	eb 1f                	jmp    c010499e <process_find+0x78>
            }
            list_next(&process_it);
c010497f:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104982:	89 04 24             	mov    %eax,(%esp)
c0104985:	e8 4f e4 ff ff       	call   c0102dd9 <list_next>
    if(! list_is_empty(process_list))
    {
        iterator_t process_it = iterator_create(process_list);
        list_set_first(&process_it);

        while(! list_is_last(&process_it))
c010498a:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010498d:	89 04 24             	mov    %eax,(%esp)
c0104990:	e8 6b e4 ff ff       	call   c0102e00 <list_is_last>
c0104995:	85 c0                	test   %eax,%eax
c0104997:	74 c9                	je     c0104962 <process_find+0x3c>
            }
            list_next(&process_it);
        }
    }

    return NULL;
c0104999:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010499e:	c9                   	leave  
c010499f:	c3                   	ret    

c01049a0 <disable_irqs>:


void halt(void);

static inline void disable_irqs(void)
{
c01049a0:	55                   	push   %ebp
c01049a1:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c01049a3:	fa                   	cli    
}
c01049a4:	5d                   	pop    %ebp
c01049a5:	c3                   	ret    

c01049a6 <enable_irqs>:

static inline void enable_irqs(void)
{
c01049a6:	55                   	push   %ebp
c01049a7:	89 e5                	mov    %esp,%ebp
    asm volatile("sti");
c01049a9:	fb                   	sti    
}
c01049aa:	5d                   	pop    %ebp
c01049ab:	c3                   	ret    

c01049ac <INIT_SCHEDULER>:

/**
 * @brief	Initiate the scheduler module
 */
void INIT_SCHEDULER(void)
{
c01049ac:	55                   	push   %ebp
c01049ad:	89 e5                	mov    %esp,%ebp
c01049af:	83 ec 38             	sub    $0x38,%esp
    running_threads = list_create();
c01049b2:	e8 c4 df ff ff       	call   c010297b <list_create>
c01049b7:	a3 10 90 11 c0       	mov    %eax,0xc0119010
    process_list = list_create();
c01049bc:	e8 ba df ff ff       	call   c010297b <list_create>
c01049c1:	a3 14 90 11 c0       	mov    %eax,0xc0119014
    zombie_list = list_create();
c01049c6:	e8 b0 df ff ff       	call   c010297b <list_create>
c01049cb:	a3 18 90 11 c0       	mov    %eax,0xc0119018
    thread_iterator = iterator_create(running_threads);
c01049d0:	8b 15 10 90 11 c0    	mov    0xc0119010,%edx
c01049d6:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01049d9:	89 54 24 04          	mov    %edx,0x4(%esp)
c01049dd:	89 04 24             	mov    %eax,(%esp)
c01049e0:	e8 06 e3 ff ff       	call   c0102ceb <iterator_create>
c01049e5:	83 ec 04             	sub    $0x4,%esp
c01049e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01049eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01049ee:	a3 14 f0 11 c0       	mov    %eax,0xc011f014
c01049f3:	89 15 18 f0 11 c0    	mov    %edx,0xc011f018

    // create "/proc" directory in vfs
    proc_dir_inode = vfs_create_inode("proc", S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO, root, 0, 0);
c01049f9:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c01049fe:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0104a05:	00 
c0104a06:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0104a0d:	00 
c0104a0e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0104a12:	c7 44 24 04 20 07 00 	movl   $0x720,0x4(%esp)
c0104a19:	00 
c0104a1a:	c7 04 24 e6 0a 11 c0 	movl   $0xc0110ae6,(%esp)
c0104a21:	e8 08 14 00 00       	call   c0105e2e <vfs_create_inode>
c0104a26:	a3 1c 90 11 c0       	mov    %eax,0xc011901c

    // create kernel process
    kernel_state = process_create("Kernel INIT", PROCESS_ACTIVE, NULL, 0, 0, NULL);
c0104a2b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0104a32:	00 
c0104a33:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0104a3a:	00 
c0104a3b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0104a42:	00 
c0104a43:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0104a4a:	00 
c0104a4b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0104a52:	00 
c0104a53:	c7 04 24 eb 0a 11 c0 	movl   $0xc0110aeb,(%esp)
c0104a5a:	e8 40 f7 ff ff       	call   c010419f <process_create>
c0104a5f:	a3 08 90 11 c0       	mov    %eax,0xc0119008
    current_thread = kernel_thread_create(NULL, NULL, NULL);
c0104a64:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0104a6b:	00 
c0104a6c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0104a73:	00 
c0104a74:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0104a7b:	e8 3e 0b 00 00       	call   c01055be <kernel_thread_create>
c0104a80:	a3 0c 90 11 c0       	mov    %eax,0xc011900c

    // map kernel stack
    vmm_map(current_context, pmm_alloc_page(), 0xFFFFF000, VMM_PRESENT | VMM_WRITABLE);
c0104a85:	e8 2a aa 00 00       	call   c010f4b4 <pmm_alloc_page>
c0104a8a:	8b 15 30 90 11 c0    	mov    0xc0119030,%edx
c0104a90:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c0104a97:	00 
c0104a98:	c7 44 24 08 00 f0 ff 	movl   $0xfffff000,0x8(%esp)
c0104a9f:	ff 
c0104aa0:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104aa4:	89 14 24             	mov    %edx,(%esp)
c0104aa7:	e8 ec 6d 00 00       	call   c010b898 <vmm_map>
    vmm_map(current_context, pmm_alloc_page(), 0xFFFFE000, VMM_PRESENT | VMM_WRITABLE);
c0104aac:	e8 03 aa 00 00       	call   c010f4b4 <pmm_alloc_page>
c0104ab1:	8b 15 30 90 11 c0    	mov    0xc0119030,%edx
c0104ab7:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c0104abe:	00 
c0104abf:	c7 44 24 08 00 e0 ff 	movl   $0xffffe000,0x8(%esp)
c0104ac6:	ff 
c0104ac7:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104acb:	89 14 24             	mov    %edx,(%esp)
c0104ace:	e8 c5 6d 00 00       	call   c010b898 <vmm_map>
    vmm_map(current_context, pmm_alloc_page(), 0xFFFFD000, VMM_PRESENT | VMM_WRITABLE);
c0104ad3:	e8 dc a9 00 00       	call   c010f4b4 <pmm_alloc_page>
c0104ad8:	8b 15 30 90 11 c0    	mov    0xc0119030,%edx
c0104ade:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c0104ae5:	00 
c0104ae6:	c7 44 24 08 00 d0 ff 	movl   $0xffffd000,0x8(%esp)
c0104aed:	ff 
c0104aee:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104af2:	89 14 24             	mov    %edx,(%esp)
c0104af5:	e8 9e 6d 00 00       	call   c010b898 <vmm_map>
    vmm_map(current_context, pmm_alloc_page(), 0xFFFFC000, VMM_PRESENT | VMM_WRITABLE);
c0104afa:	e8 b5 a9 00 00       	call   c010f4b4 <pmm_alloc_page>
c0104aff:	8b 15 30 90 11 c0    	mov    0xc0119030,%edx
c0104b05:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c0104b0c:	00 
c0104b0d:	c7 44 24 08 00 c0 ff 	movl   $0xffffc000,0x8(%esp)
c0104b14:	ff 
c0104b15:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104b19:	89 14 24             	mov    %edx,(%esp)
c0104b1c:	e8 77 6d 00 00       	call   c010b898 <vmm_map>

    // enable multitasking
    enable_irqs();
c0104b21:	e8 80 fe ff ff       	call   c01049a6 <enable_irqs>
}
c0104b26:	c9                   	leave  
c0104b27:	c3                   	ret    

c0104b28 <task_switch>:
 * @brief			performs context switches
 * @param thread	pointer to the thread state to switch to
 * @return			new cpu state
 */
struct cpu_state *task_switch(struct thread_state *thread)
{
c0104b28:	55                   	push   %ebp
c0104b29:	89 e5                	mov    %esp,%ebp
c0104b2b:	83 ec 28             	sub    $0x28,%esp
    struct cpu_state *cpu = thread->context.state;
c0104b2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0104b31:	8b 40 18             	mov    0x18(%eax),%eax
c0104b34:	89 45 f4             	mov    %eax,-0xc(%ebp)
    set_kernelstack(cpu+1);
c0104b37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104b3a:	83 c0 48             	add    $0x48,%eax
c0104b3d:	89 04 24             	mov    %eax,(%esp)
c0104b40:	e8 93 af 00 00       	call   c010fad8 <set_kernelstack>
    vmm_switch_context(&thread->context.memory);
c0104b45:	8b 45 08             	mov    0x8(%ebp),%eax
c0104b48:	83 c0 24             	add    $0x24,%eax
c0104b4b:	89 04 24             	mov    %eax,(%esp)
c0104b4e:	e8 15 6d 00 00       	call   c010b868 <vmm_switch_context>
    set_iobmp(&thread->context);
c0104b53:	8b 45 08             	mov    0x8(%ebp),%eax
c0104b56:	83 c0 18             	add    $0x18,%eax
c0104b59:	89 04 24             	mov    %eax,(%esp)
c0104b5c:	e8 84 af 00 00       	call   c010fae5 <set_iobmp>
    return cpu;
c0104b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0104b64:	c9                   	leave  
c0104b65:	c3                   	ret    

c0104b66 <task_schedule>:
 * @brief		selects the next thread and calls a context switch
 * @param cpu	current cpu state
 * @return		new cpu state
 */
struct cpu_state *task_schedule(struct cpu_state *cpu)
{
c0104b66:	55                   	push   %ebp
c0104b67:	89 e5                	mov    %esp,%ebp
c0104b69:	83 ec 18             	sub    $0x18,%esp
    if(current_thread == NULL)
c0104b6c:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104b71:	85 c0                	test   %eax,%eax
c0104b73:	75 1f                	jne    c0104b94 <task_schedule+0x2e>
    {
        current_thread = list_get_current(&thread_iterator);
c0104b75:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104b7c:	e8 33 e2 ff ff       	call   c0102db4 <list_get_current>
c0104b81:	a3 0c 90 11 c0       	mov    %eax,0xc011900c
        current_thread->ticks = 0;
c0104b86:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104b8b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c0104b92:	eb 0b                	jmp    c0104b9f <task_schedule+0x39>
    }
    else
    {
        current_thread->context.state = cpu;
c0104b94:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104b99:	8b 55 08             	mov    0x8(%ebp),%edx
c0104b9c:	89 50 18             	mov    %edx,0x18(%eax)
    }

    if(current_thread->flags & THREAD_ZOMBIE)
c0104b9f:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104ba4:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c0104ba8:	0f b7 c0             	movzwl %ax,%eax
c0104bab:	83 e0 08             	and    $0x8,%eax
c0104bae:	85 c0                	test   %eax,%eax
c0104bb0:	74 69                	je     c0104c1b <task_schedule+0xb5>
    {
        thread_kill_sub(current_thread);
c0104bb2:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104bb7:	89 04 24             	mov    %eax,(%esp)
c0104bba:	e8 c2 0b 00 00       	call   c0105781 <thread_kill_sub>
        if(list_is_empty(running_threads))
c0104bbf:	a1 10 90 11 c0       	mov    0xc0119010,%eax
c0104bc4:	89 04 24             	mov    %eax,(%esp)
c0104bc7:	e8 de e0 ff ff       	call   c0102caa <list_is_empty>
c0104bcc:	85 c0                	test   %eax,%eax
c0104bce:	74 1c                	je     c0104bec <task_schedule+0x86>
        {
            enable_irqs();
c0104bd0:	e8 d1 fd ff ff       	call   c01049a6 <enable_irqs>
            while(list_is_empty(running_threads));
c0104bd5:	90                   	nop
c0104bd6:	a1 10 90 11 c0       	mov    0xc0119010,%eax
c0104bdb:	89 04 24             	mov    %eax,(%esp)
c0104bde:	e8 c7 e0 ff ff       	call   c0102caa <list_is_empty>
c0104be3:	85 c0                	test   %eax,%eax
c0104be5:	75 ef                	jne    c0104bd6 <task_schedule+0x70>
            disable_irqs();
c0104be7:	e8 b4 fd ff ff       	call   c01049a0 <disable_irqs>
        }

        list_set_first(&thread_iterator);
c0104bec:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104bf3:	e8 23 e2 ff ff       	call   c0102e1b <list_set_first>
        current_thread = list_get_current(&thread_iterator);
c0104bf8:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104bff:	e8 b0 e1 ff ff       	call   c0102db4 <list_get_current>
c0104c04:	a3 0c 90 11 c0       	mov    %eax,0xc011900c

        cpu = task_switch(current_thread);
c0104c09:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104c0e:	89 04 24             	mov    %eax,(%esp)
c0104c11:	e8 12 ff ff ff       	call   c0104b28 <task_switch>
c0104c16:	89 45 08             	mov    %eax,0x8(%ebp)
c0104c19:	eb 71                	jmp    c0104c8c <task_schedule+0x126>
    }
    else if(current_thread->ticks == 0)
c0104c1b:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104c20:	8b 40 0c             	mov    0xc(%eax),%eax
c0104c23:	85 c0                	test   %eax,%eax
c0104c25:	75 57                	jne    c0104c7e <task_schedule+0x118>
    {
        current_thread->ticks = 10;
c0104c27:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104c2c:	c7 40 0c 0a 00 00 00 	movl   $0xa,0xc(%eax)
        list_next(&thread_iterator);
c0104c33:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104c3a:	e8 9a e1 ff ff       	call   c0102dd9 <list_next>
        if(list_is_last(&thread_iterator))
c0104c3f:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104c46:	e8 b5 e1 ff ff       	call   c0102e00 <list_is_last>
c0104c4b:	85 c0                	test   %eax,%eax
c0104c4d:	74 0c                	je     c0104c5b <task_schedule+0xf5>
        {
            list_set_first(&thread_iterator);
c0104c4f:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104c56:	e8 c0 e1 ff ff       	call   c0102e1b <list_set_first>
        }
        current_thread = list_get_current(&thread_iterator);
c0104c5b:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104c62:	e8 4d e1 ff ff       	call   c0102db4 <list_get_current>
c0104c67:	a3 0c 90 11 c0       	mov    %eax,0xc011900c

        cpu = task_switch(current_thread);
c0104c6c:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104c71:	89 04 24             	mov    %eax,(%esp)
c0104c74:	e8 af fe ff ff       	call   c0104b28 <task_switch>
c0104c79:	89 45 08             	mov    %eax,0x8(%ebp)
c0104c7c:	eb 0e                	jmp    c0104c8c <task_schedule+0x126>
    }
    else
    {
        current_thread->ticks--;
c0104c7e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104c83:	8b 50 0c             	mov    0xc(%eax),%edx
c0104c86:	83 ea 01             	sub    $0x1,%edx
c0104c89:	89 50 0c             	mov    %edx,0xc(%eax)
    }

    return cpu;
c0104c8c:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0104c8f:	c9                   	leave  
c0104c90:	c3                   	ret    

c0104c91 <usys_thread_exit>:
extern struct thread_state* current_thread;
extern struct process_state *kernel_state;
extern iterator_t thread_iterator;

void usys_thread_exit(struct cpu_state **cpu)
{
c0104c91:	55                   	push   %ebp
c0104c92:	89 e5                	mov    %esp,%ebp
c0104c94:	83 ec 18             	sub    $0x18,%esp
    current_thread->flags |= THREAD_ZOMBIE;
c0104c97:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104c9c:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c0104ca2:	0f b7 52 10          	movzwl 0x10(%edx),%edx
c0104ca6:	83 ca 08             	or     $0x8,%edx
c0104ca9:	66 89 50 10          	mov    %dx,0x10(%eax)
    *cpu = task_schedule(*cpu);
c0104cad:	8b 45 08             	mov    0x8(%ebp),%eax
c0104cb0:	8b 00                	mov    (%eax),%eax
c0104cb2:	89 04 24             	mov    %eax,(%esp)
c0104cb5:	e8 ac fe ff ff       	call   c0104b66 <task_schedule>
c0104cba:	8b 55 08             	mov    0x8(%ebp),%edx
c0104cbd:	89 02                	mov    %eax,(%edx)
}
c0104cbf:	c9                   	leave  
c0104cc0:	c3                   	ret    

c0104cc1 <usys_thread_launch>:

void usys_thread_launch(struct cpu_state **cpu)
{
c0104cc1:	55                   	push   %ebp
c0104cc2:	89 e5                	mov    %esp,%ebp
c0104cc4:	56                   	push   %esi
c0104cc5:	53                   	push   %ebx
c0104cc6:	83 ec 20             	sub    $0x20,%esp
    thread_create(current_thread->process, USERMODE, (vaddr_t) (*cpu)->CPU_ARG1, (char**)(*cpu)->CPU_ARG2, (char **)(*cpu)->CPU_ARG3, (vaddr_t)(*cpu)->CPU_ARG4, NULL);
c0104cc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0104ccc:	8b 00                	mov    (%eax),%eax
c0104cce:	8b 70 14             	mov    0x14(%eax),%esi
c0104cd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0104cd4:	8b 00                	mov    (%eax),%eax
c0104cd6:	8b 40 20             	mov    0x20(%eax),%eax
c0104cd9:	89 c3                	mov    %eax,%ebx
c0104cdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0104cde:	8b 00                	mov    (%eax),%eax
c0104ce0:	8b 40 24             	mov    0x24(%eax),%eax
c0104ce3:	89 c1                	mov    %eax,%ecx
c0104ce5:	8b 45 08             	mov    0x8(%ebp),%eax
c0104ce8:	8b 00                	mov    (%eax),%eax
c0104cea:	8b 50 1c             	mov    0x1c(%eax),%edx
c0104ced:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104cf2:	8b 00                	mov    (%eax),%eax
c0104cf4:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0104cfb:	00 
c0104cfc:	89 74 24 14          	mov    %esi,0x14(%esp)
c0104d00:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c0104d04:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0104d08:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104d0c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c0104d13:	00 
c0104d14:	89 04 24             	mov    %eax,(%esp)
c0104d17:	e8 20 04 00 00       	call   c010513c <thread_create>
}
c0104d1c:	83 c4 20             	add    $0x20,%esp
c0104d1f:	5b                   	pop    %ebx
c0104d20:	5e                   	pop    %esi
c0104d21:	5d                   	pop    %ebp
c0104d22:	c3                   	ret    

c0104d23 <sys_exit>:
/**
 * @brief terminates the current process (linux function for the API)
 * @param cpu registers of the corrent process
 */
void sys_exit(struct cpu_state **cpu)
{
c0104d23:	55                   	push   %ebp
c0104d24:	89 e5                	mov    %esp,%ebp
c0104d26:	83 ec 28             	sub    $0x28,%esp
    iterator_t parents_children_it = iterator_create(current_thread->process->parent->children);
c0104d29:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104d2e:	8b 00                	mov    (%eax),%eax
c0104d30:	8b 40 10             	mov    0x10(%eax),%eax
c0104d33:	8b 50 40             	mov    0x40(%eax),%edx
c0104d36:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104d39:	89 54 24 04          	mov    %edx,0x4(%esp)
c0104d3d:	89 04 24             	mov    %eax,(%esp)
c0104d40:	e8 a6 df ff ff       	call   c0102ceb <iterator_create>
c0104d45:	83 ec 04             	sub    $0x4,%esp

    while(!list_is_empty(current_thread->process->parent->children) && !list_is_last(&parents_children_it))
c0104d48:	eb 3b                	jmp    c0104d85 <sys_exit+0x62>
    {
        struct child *current_child = list_get_current(&parents_children_it);
c0104d4a:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104d4d:	89 04 24             	mov    %eax,(%esp)
c0104d50:	e8 5f e0 ff ff       	call   c0102db4 <list_get_current>
c0104d55:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(current_child->process == current_thread->process)
c0104d58:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104d5b:	8b 50 04             	mov    0x4(%eax),%edx
c0104d5e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104d63:	8b 00                	mov    (%eax),%eax
c0104d65:	39 c2                	cmp    %eax,%edx
c0104d67:	75 11                	jne    c0104d7a <sys_exit+0x57>
        {
            current_child->status = (*cpu)->CPU_ARG1;
c0104d69:	8b 45 08             	mov    0x8(%ebp),%eax
c0104d6c:	8b 00                	mov    (%eax),%eax
c0104d6e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0104d71:	89 c2                	mov    %eax,%edx
c0104d73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104d76:	89 10                	mov    %edx,(%eax)
            break;
c0104d78:	eb 33                	jmp    c0104dad <sys_exit+0x8a>
        }
        list_next(&parents_children_it);
c0104d7a:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104d7d:	89 04 24             	mov    %eax,(%esp)
c0104d80:	e8 54 e0 ff ff       	call   c0102dd9 <list_next>
 */
void sys_exit(struct cpu_state **cpu)
{
    iterator_t parents_children_it = iterator_create(current_thread->process->parent->children);

    while(!list_is_empty(current_thread->process->parent->children) && !list_is_last(&parents_children_it))
c0104d85:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104d8a:	8b 00                	mov    (%eax),%eax
c0104d8c:	8b 40 10             	mov    0x10(%eax),%eax
c0104d8f:	8b 40 40             	mov    0x40(%eax),%eax
c0104d92:	89 04 24             	mov    %eax,(%esp)
c0104d95:	e8 10 df ff ff       	call   c0102caa <list_is_empty>
c0104d9a:	85 c0                	test   %eax,%eax
c0104d9c:	75 0f                	jne    c0104dad <sys_exit+0x8a>
c0104d9e:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0104da1:	89 04 24             	mov    %eax,(%esp)
c0104da4:	e8 57 e0 ff ff       	call   c0102e00 <list_is_last>
c0104da9:	85 c0                	test   %eax,%eax
c0104dab:	74 9d                	je     c0104d4a <sys_exit+0x27>
            current_child->status = (*cpu)->CPU_ARG1;
            break;
        }
        list_next(&parents_children_it);
    }
    send_killed_process(current_thread->process);
c0104dad:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104db2:	8b 00                	mov    (%eax),%eax
c0104db4:	89 04 24             	mov    %eax,(%esp)
c0104db7:	e8 c8 66 00 00       	call   c010b484 <send_killed_process>
    process_kill(current_thread->process);
c0104dbc:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104dc1:	8b 00                	mov    (%eax),%eax
c0104dc3:	89 04 24             	mov    %eax,(%esp)
c0104dc6:	e8 d1 f7 ff ff       	call   c010459c <process_kill>
    *cpu = (struct cpu_state *)task_schedule(*cpu);
c0104dcb:	8b 45 08             	mov    0x8(%ebp),%eax
c0104dce:	8b 00                	mov    (%eax),%eax
c0104dd0:	89 04 24             	mov    %eax,(%esp)
c0104dd3:	e8 8e fd ff ff       	call   c0104b66 <task_schedule>
c0104dd8:	8b 55 08             	mov    0x8(%ebp),%edx
c0104ddb:	89 02                	mov    %eax,(%edx)
}
c0104ddd:	c9                   	leave  
c0104dde:	c3                   	ret    

c0104ddf <sys_fork>:
/**
 * @brief creates a new child process (linux function for the API)
 * @param cpu registers of the current process
 */
void sys_fork(struct cpu_state **cpu)
{
c0104ddf:	55                   	push   %ebp
c0104de0:	89 e5                	mov    %esp,%ebp
c0104de2:	53                   	push   %ebx
c0104de3:	83 ec 44             	sub    $0x44,%esp
    const char *add = "_fork";
c0104de6:	c7 45 f0 f7 0a 11 c0 	movl   $0xc0110af7,-0x10(%ebp)
    char *newname = malloc(strlen(current_thread->process->name)+strlen(add)+1);
c0104ded:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104df2:	8b 00                	mov    (%eax),%eax
c0104df4:	8b 40 0c             	mov    0xc(%eax),%eax
c0104df7:	89 04 24             	mov    %eax,(%esp)
c0104dfa:	e8 ce e0 ff ff       	call   c0102ecd <strlen>
c0104dff:	89 c3                	mov    %eax,%ebx
c0104e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104e04:	89 04 24             	mov    %eax,(%esp)
c0104e07:	e8 c1 e0 ff ff       	call   c0102ecd <strlen>
c0104e0c:	01 d8                	add    %ebx,%eax
c0104e0e:	83 c0 01             	add    $0x1,%eax
c0104e11:	89 04 24             	mov    %eax,(%esp)
c0104e14:	e8 2c 71 00 00       	call   c010bf45 <malloc>
c0104e19:	89 45 ec             	mov    %eax,-0x14(%ebp)
    strcpy(newname, current_thread->process->name);
c0104e1c:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104e21:	8b 00                	mov    (%eax),%eax
c0104e23:	8b 40 0c             	mov    0xc(%eax),%eax
c0104e26:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104e2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e2d:	89 04 24             	mov    %eax,(%esp)
c0104e30:	e8 bf e0 ff ff       	call   c0102ef4 <strcpy>
    strcat(newname, add);
c0104e35:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104e38:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104e3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e3f:	89 04 24             	mov    %eax,(%esp)
c0104e42:	e8 63 e1 ff ff       	call   c0102faa <strcat>

    struct process_state *new_process = process_create(newname ,current_thread->process->flags ,current_thread->process, current_thread->process->uid, current_thread->process->gid, NULL);
c0104e47:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104e4c:	8b 00                	mov    (%eax),%eax
c0104e4e:	8b 58 08             	mov    0x8(%eax),%ebx
c0104e51:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104e56:	8b 00                	mov    (%eax),%eax
c0104e58:	8b 48 04             	mov    0x4(%eax),%ecx
c0104e5b:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104e60:	8b 10                	mov    (%eax),%edx
c0104e62:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104e67:	8b 00                	mov    (%eax),%eax
c0104e69:	0f b7 40 44          	movzwl 0x44(%eax),%eax
c0104e6d:	0f b7 c0             	movzwl %ax,%eax
c0104e70:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0104e77:	00 
c0104e78:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c0104e7c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0104e80:	89 54 24 08          	mov    %edx,0x8(%esp)
c0104e84:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104e88:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e8b:	89 04 24             	mov    %eax,(%esp)
c0104e8e:	e8 0c f3 ff ff       	call   c010419f <process_create>
c0104e93:	89 45 e8             	mov    %eax,-0x18(%ebp)
    struct thread_state *new_thread = thread_clone(new_process, current_thread);
c0104e96:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104e9b:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104e9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104ea2:	89 04 24             	mov    %eax,(%esp)
c0104ea5:	e8 78 04 00 00       	call   c0105322 <thread_clone>
c0104eaa:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    // copy file descriptors
    struct list_node *node = current_thread->process->files->head->next;
c0104ead:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104eb2:	8b 00                	mov    (%eax),%eax
c0104eb4:	8b 40 18             	mov    0x18(%eax),%eax
c0104eb7:	8b 40 04             	mov    0x4(%eax),%eax
c0104eba:	8b 00                	mov    (%eax),%eax
c0104ebc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct list_node *head = current_thread->process->files->head;
c0104ebf:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104ec4:	8b 00                	mov    (%eax),%eax
c0104ec6:	8b 40 18             	mov    0x18(%eax),%eax
c0104ec9:	8b 40 04             	mov    0x4(%eax),%eax
c0104ecc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    while(node != head)
c0104ecf:	eb 4f                	jmp    c0104f20 <sys_fork+0x141>
    {
        struct fd *dest = malloc(sizeof(struct fd));
c0104ed1:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0104ed8:	e8 68 70 00 00       	call   c010bf45 <malloc>
c0104edd:	89 45 dc             	mov    %eax,-0x24(%ebp)
        struct fd *src  = (struct fd*) node->element;
c0104ee0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104ee3:	8b 40 08             	mov    0x8(%eax),%eax
c0104ee6:	89 45 d8             	mov    %eax,-0x28(%ebp)
        memcpy(dest, src, sizeof(struct fd));
c0104ee9:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
c0104ef0:	00 
c0104ef1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0104ef4:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104ef8:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104efb:	89 04 24             	mov    %eax,(%esp)
c0104efe:	e8 a0 e3 ff ff       	call   c01032a3 <memcpy>
        list_push_back(new_process->files, dest);
c0104f03:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104f06:	8b 40 18             	mov    0x18(%eax),%eax
c0104f09:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0104f0c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0104f10:	89 04 24             	mov    %eax,(%esp)
c0104f13:	e8 47 db ff ff       	call   c0102a5f <list_push_back>

        node = node->next;
c0104f18:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104f1b:	8b 00                	mov    (%eax),%eax
c0104f1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct thread_state *new_thread = thread_clone(new_process, current_thread);

    // copy file descriptors
    struct list_node *node = current_thread->process->files->head->next;
    struct list_node *head = current_thread->process->files->head;
    while(node != head)
c0104f20:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104f23:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0104f26:	75 a9                	jne    c0104ed1 <sys_fork+0xf2>
        list_push_back(new_process->files, dest);

        node = node->next;
    }

    new_thread->context.state->CPU_ARG0 = 0;
c0104f28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104f2b:	8b 40 18             	mov    0x18(%eax),%eax
c0104f2e:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    current_thread->context.state->CPU_ARG0 = new_process->pid;
c0104f35:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104f3a:	8b 40 18             	mov    0x18(%eax),%eax
c0104f3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0104f40:	8b 12                	mov    (%edx),%edx
c0104f42:	89 50 28             	mov    %edx,0x28(%eax)
}
c0104f45:	83 c4 44             	add    $0x44,%esp
c0104f48:	5b                   	pop    %ebx
c0104f49:	5d                   	pop    %ebp
c0104f4a:	c3                   	ret    

c0104f4b <sys_waitpid>:
 *  @param cpu registers of the current process
 *  Not completed
 */

void sys_waitpid(struct cpu_state **cpu)
{
c0104f4b:	55                   	push   %ebp
c0104f4c:	89 e5                	mov    %esp,%ebp
c0104f4e:	83 ec 28             	sub    $0x28,%esp
    list_set_first(&thread_iterator);
c0104f51:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104f58:	e8 be de ff ff       	call   c0102e1b <list_set_first>
    while(list_get_current(&thread_iterator) != current_thread)
c0104f5d:	eb 0c                	jmp    c0104f6b <sys_waitpid+0x20>
    {
        list_next(&thread_iterator);
c0104f5f:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104f66:	e8 6e de ff ff       	call   c0102dd9 <list_next>
 */

void sys_waitpid(struct cpu_state **cpu)
{
    list_set_first(&thread_iterator);
    while(list_get_current(&thread_iterator) != current_thread)
c0104f6b:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104f72:	e8 3d de ff ff       	call   c0102db4 <list_get_current>
c0104f77:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c0104f7d:	39 d0                	cmp    %edx,%eax
c0104f7f:	75 de                	jne    c0104f5f <sys_waitpid+0x14>
    {
        list_next(&thread_iterator);
    }
    list_remove(&thread_iterator);
c0104f81:	c7 04 24 14 f0 11 c0 	movl   $0xc011f014,(%esp)
c0104f88:	e8 b9 de ff ff       	call   c0102e46 <list_remove>
    current_thread->ticks = 0;
c0104f8d:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104f92:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    current_thread->flags |= THREAD_WAITPID;
c0104f99:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104f9e:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c0104fa4:	0f b7 52 10          	movzwl 0x10(%edx),%edx
c0104fa8:	83 ca 10             	or     $0x10,%edx
c0104fab:	66 89 50 10          	mov    %dx,0x10(%eax)
    current_thread->waitpid = (*cpu)->CPU_ARG1;
c0104faf:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104fb4:	8b 55 08             	mov    0x8(%ebp),%edx
c0104fb7:	8b 12                	mov    (%edx),%edx
c0104fb9:	8b 52 1c             	mov    0x1c(%edx),%edx
c0104fbc:	89 50 08             	mov    %edx,0x8(%eax)
    add_trigger(WAIT_PID, current_thread->waitpid, false, (void *)current_thread,NULL);
c0104fbf:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c0104fc5:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0104fca:	8b 40 08             	mov    0x8(%eax),%eax
c0104fcd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0104fd4:	00 
c0104fd5:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0104fd9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0104fe0:	00 
c0104fe1:	89 44 24 04          	mov    %eax,0x4(%esp)
c0104fe5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0104fec:	e8 cf 62 00 00       	call   c010b2c0 <add_trigger>
    *cpu = task_schedule(*cpu);
c0104ff1:	8b 45 08             	mov    0x8(%ebp),%eax
c0104ff4:	8b 00                	mov    (%eax),%eax
c0104ff6:	89 04 24             	mov    %eax,(%esp)
c0104ff9:	e8 68 fb ff ff       	call   c0104b66 <task_schedule>
c0104ffe:	8b 55 08             	mov    0x8(%ebp),%edx
c0105001:	89 02                	mov    %eax,(%edx)
}
c0105003:	c9                   	leave  
c0105004:	c3                   	ret    

c0105005 <sys_getpid>:

void sys_getpid(struct cpu_state **cpu)
{
c0105005:	55                   	push   %ebp
c0105006:	89 e5                	mov    %esp,%ebp
    (*cpu)->CPU_ARG0 = current_thread->process->pid;
c0105008:	8b 45 08             	mov    0x8(%ebp),%eax
c010500b:	8b 00                	mov    (%eax),%eax
c010500d:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c0105013:	8b 12                	mov    (%edx),%edx
c0105015:	8b 12                	mov    (%edx),%edx
c0105017:	89 50 28             	mov    %edx,0x28(%eax)
}
c010501a:	5d                   	pop    %ebp
c010501b:	c3                   	ret    

c010501c <sys_execve>:
 * executes a programm
 * @param cpu registers of the current process
 * todo: the function is still a litte bit slow and envp is not taken over from the new process.
 */
void sys_execve(struct cpu_state **cpu)
{
c010501c:	55                   	push   %ebp
c010501d:	89 e5                	mov    %esp,%ebp
c010501f:	83 ec 38             	sub    $0x38,%esp
    char *filename = (char*) (*cpu)->CPU_ARG1;
c0105022:	8b 45 08             	mov    0x8(%ebp),%eax
c0105025:	8b 00                	mov    (%eax),%eax
c0105027:	8b 40 1c             	mov    0x1c(%eax),%eax
c010502a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char **argv = (char**) (*cpu)->CPU_ARG2;
c010502d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105030:	8b 00                	mov    (%eax),%eax
c0105032:	8b 40 24             	mov    0x24(%eax),%eax
c0105035:	89 45 f0             	mov    %eax,-0x10(%ebp)
    char **envp = (char**) (*cpu)->CPU_ARG3;
c0105038:	8b 45 08             	mov    0x8(%ebp),%eax
c010503b:	8b 00                	mov    (%eax),%eax
c010503d:	8b 40 20             	mov    0x20(%eax),%eax
c0105040:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // lookup file
    vfs_inode_t *filenode = vfs_lookup_path(filename);
c0105043:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105046:	89 04 24             	mov    %eax,(%esp)
c0105049:	e8 53 3a 00 00       	call   c0108aa1 <vfs_lookup_path>
c010504e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(filenode == NULL)
c0105051:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0105055:	75 11                	jne    c0105068 <sys_execve+0x4c>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0105057:	8b 45 08             	mov    0x8(%ebp),%eax
c010505a:	8b 00                	mov    (%eax),%eax
c010505c:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0105063:	e9 c6 00 00 00       	jmp    c010512e <sys_execve+0x112>
    }

    // terminate all threads
    struct process_state *process = current_thread->process;
c0105068:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010506d:	8b 00                	mov    (%eax),%eax
c010506f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(!list_is_empty(process->threads))
c0105072:	eb 1c                	jmp    c0105090 <sys_execve+0x74>
    {
        struct thread_state *thread = list_pop_front(process->threads);
c0105074:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105077:	8b 40 34             	mov    0x34(%eax),%eax
c010507a:	89 04 24             	mov    %eax,(%esp)
c010507d:	e8 00 db ff ff       	call   c0102b82 <list_pop_front>
c0105082:	89 45 e0             	mov    %eax,-0x20(%ebp)
        thread_kill_sub(thread);
c0105085:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0105088:	89 04 24             	mov    %eax,(%esp)
c010508b:	e8 f1 06 00 00       	call   c0105781 <thread_kill_sub>
        return;
    }

    // terminate all threads
    struct process_state *process = current_thread->process;
    while(!list_is_empty(process->threads))
c0105090:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105093:	8b 40 34             	mov    0x34(%eax),%eax
c0105096:	89 04 24             	mov    %eax,(%esp)
c0105099:	e8 0c dc ff ff       	call   c0102caa <list_is_empty>
c010509e:	85 c0                	test   %eax,%eax
c01050a0:	74 d2                	je     c0105074 <sys_execve+0x58>
        struct thread_state *thread = list_pop_front(process->threads);
        thread_kill_sub(thread);
    }

    // cleanup the process
    process->heap_top = 0;
c01050a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01050a5:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    process->heap_lower_limit = 0;
c01050ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01050af:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
    process->heap_upper_limit = 0;
c01050b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01050b9:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)

    list_destroy(process->ports);
c01050c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01050c3:	8b 40 1c             	mov    0x1c(%eax),%eax
c01050c6:	89 04 24             	mov    %eax,(%esp)
c01050c9:	e8 05 d9 ff ff       	call   c01029d3 <list_destroy>
    list_destroy(process->zombie_tids);
c01050ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01050d1:	8b 40 38             	mov    0x38(%eax),%eax
c01050d4:	89 04 24             	mov    %eax,(%esp)
c01050d7:	e8 f7 d8 ff ff       	call   c01029d3 <list_destroy>

    process->zombie_tids = list_create();
c01050dc:	e8 9a d8 ff ff       	call   c010297b <list_create>
c01050e1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01050e4:	89 42 38             	mov    %eax,0x38(%edx)
    process->ports = list_create();
c01050e7:	e8 8f d8 ff ff       	call   c010297b <list_create>
c01050ec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01050ef:	89 42 1c             	mov    %eax,0x1c(%edx)
    process->tid_counter = 1;
c01050f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01050f5:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)

    // run the new thread
    load_elf_thread_from_file(filenode, process, argv, envp);
c01050fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01050ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0105103:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105106:	89 44 24 08          	mov    %eax,0x8(%esp)
c010510a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010510d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105111:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105114:	89 04 24             	mov    %eax,(%esp)
c0105117:	e8 52 ed ff ff       	call   c0103e6e <load_elf_thread_from_file>
    *cpu = (struct cpu_state *)task_schedule(*cpu);
c010511c:	8b 45 08             	mov    0x8(%ebp),%eax
c010511f:	8b 00                	mov    (%eax),%eax
c0105121:	89 04 24             	mov    %eax,(%esp)
c0105124:	e8 3d fa ff ff       	call   c0104b66 <task_schedule>
c0105129:	8b 55 08             	mov    0x8(%ebp),%edx
c010512c:	89 02                	mov    %eax,(%edx)
}
c010512e:	c9                   	leave  
c010512f:	c3                   	ret    

c0105130 <disable_irqs>:


void halt(void);

static inline void disable_irqs(void)
{
c0105130:	55                   	push   %ebp
c0105131:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c0105133:	fa                   	cli    
}
c0105134:	5d                   	pop    %ebp
c0105135:	c3                   	ret    

c0105136 <enable_irqs>:

static inline void enable_irqs(void)
{
c0105136:	55                   	push   %ebp
c0105137:	89 e5                	mov    %esp,%ebp
    asm volatile("sti");
c0105139:	fb                   	sti    
}
c010513a:	5d                   	pop    %ebp
c010513b:	c3                   	ret    

c010513c <thread_create>:
 * @param argv			argument values
 * @param environ		environment variables
 * @param return_adress	adress to jump after exiting
 */
struct thread_state *thread_create(struct process_state *process, privilege_t prev, vaddr_t eip, char **argv, char **environ, vaddr_t return_address, vmm_context_t *context)
{
c010513c:	55                   	push   %ebp
c010513d:	89 e5                	mov    %esp,%ebp
c010513f:	53                   	push   %ebx
c0105140:	83 ec 34             	sub    $0x34,%esp
    if(process == NULL)
c0105143:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0105147:	75 0a                	jne    c0105153 <thread_create+0x17>
    {
        // cannot create thread without process
        return NULL;
c0105149:	b8 00 00 00 00       	mov    $0x0,%eax
c010514e:	e9 c9 01 00 00       	jmp    c010531c <thread_create+0x1e0>
    }

    // allocate memory
    struct thread_state *new_thread = malloc(sizeof(struct thread_state));
c0105153:	c7 04 24 30 20 00 00 	movl   $0x2030,(%esp)
c010515a:	e8 e6 6d 00 00       	call   c010bf45 <malloc>
c010515f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // process stuff
    new_thread->process = process;
c0105162:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105165:	8b 55 08             	mov    0x8(%ebp),%edx
c0105168:	89 10                	mov    %edx,(%eax)
    if(list_is_empty(process->zombie_tids))
c010516a:	8b 45 08             	mov    0x8(%ebp),%eax
c010516d:	8b 40 38             	mov    0x38(%eax),%eax
c0105170:	89 04 24             	mov    %eax,(%esp)
c0105173:	e8 32 db ff ff       	call   c0102caa <list_is_empty>
c0105178:	85 c0                	test   %eax,%eax
c010517a:	74 17                	je     c0105193 <thread_create+0x57>
        new_thread->tid = process->tid_counter++;
c010517c:	8b 45 08             	mov    0x8(%ebp),%eax
c010517f:	8b 40 3c             	mov    0x3c(%eax),%eax
c0105182:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105185:	89 42 04             	mov    %eax,0x4(%edx)
c0105188:	8d 50 01             	lea    0x1(%eax),%edx
c010518b:	8b 45 08             	mov    0x8(%ebp),%eax
c010518e:	89 50 3c             	mov    %edx,0x3c(%eax)
c0105191:	eb 16                	jmp    c01051a9 <thread_create+0x6d>
    else
        new_thread->tid = (tid_t) list_pop_back(process->zombie_tids);
c0105193:	8b 45 08             	mov    0x8(%ebp),%eax
c0105196:	8b 40 38             	mov    0x38(%eax),%eax
c0105199:	89 04 24             	mov    %eax,(%esp)
c010519c:	e8 9b d9 ff ff       	call   c0102b3c <list_pop_back>
c01051a1:	89 c2                	mov    %eax,%edx
c01051a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01051a6:	89 50 04             	mov    %edx,0x4(%eax)

    if(process->main_thread == NULL)
c01051a9:	8b 45 08             	mov    0x8(%ebp),%eax
c01051ac:	8b 40 30             	mov    0x30(%eax),%eax
c01051af:	85 c0                	test   %eax,%eax
c01051b1:	75 09                	jne    c01051bc <thread_create+0x80>
        process->main_thread = new_thread;
c01051b3:	8b 45 08             	mov    0x8(%ebp),%eax
c01051b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01051b9:	89 50 30             	mov    %edx,0x30(%eax)

    // flags
    new_thread->ticks = 10;
c01051bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01051bf:	c7 40 0c 0a 00 00 00 	movl   $0xa,0xc(%eax)
    new_thread->flags = THREAD_ACTIVE;
c01051c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01051c9:	66 c7 40 10 01 00    	movw   $0x1,0x10(%eax)
    if(prev == KERNELMODE)
c01051cf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01051d3:	75 13                	jne    c01051e8 <thread_create+0xac>
        new_thread->flags |= THREAD_KERNELMODE;
c01051d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01051d8:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01051dc:	89 c2                	mov    %eax,%edx
c01051de:	83 ca 04             	or     $0x4,%edx
c01051e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01051e4:	66 89 50 10          	mov    %dx,0x10(%eax)

    new_thread->getdents_pos = 0;
c01051e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01051eb:	c7 80 28 20 00 00 00 	movl   $0x0,0x2028(%eax)
c01051f2:	00 00 00 
    new_thread->getdents_old_fd = -1;
c01051f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01051f8:	c7 80 2c 20 00 00 ff 	movl   $0xffffffff,0x202c(%eax)
c01051ff:	ff ff ff 

    // context
    new_thread->return_value = 0;
c0105202:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105205:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

    if(context != NULL)
c010520c:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
c0105210:	74 1f                	je     c0105231 <thread_create+0xf5>
        memcpy(&new_thread->context.memory.arch_context, &context->arch_context, sizeof(arch_vmm_context_t));
c0105212:	8b 45 20             	mov    0x20(%ebp),%eax
c0105215:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105218:	83 c2 24             	add    $0x24,%edx
c010521b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c0105222:	00 
c0105223:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105227:	89 14 24             	mov    %edx,(%esp)
c010522a:	e8 74 e0 ff ff       	call   c01032a3 <memcpy>
c010522f:	eb 0e                	jmp    c010523f <thread_create+0x103>
    else
        vmm_create_context(&new_thread->context.memory);
c0105231:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105234:	83 c0 24             	add    $0x24,%eax
c0105237:	89 04 24             	mov    %eax,(%esp)
c010523a:	e8 03 66 00 00       	call   c010b842 <vmm_create_context>

    thread_sync_context(new_thread);
c010523f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105242:	89 04 24             	mov    %eax,(%esp)
c0105245:	e8 bd 03 00 00       	call   c0105607 <thread_sync_context>
    arch_create_thread_context(&new_thread->context, prev, eip, (vaddr_t) return_address, argv, environ);
c010524a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010524d:	8d 50 18             	lea    0x18(%eax),%edx
c0105250:	8b 45 18             	mov    0x18(%ebp),%eax
c0105253:	89 44 24 14          	mov    %eax,0x14(%esp)
c0105257:	8b 45 14             	mov    0x14(%ebp),%eax
c010525a:	89 44 24 10          	mov    %eax,0x10(%esp)
c010525e:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0105261:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0105265:	8b 45 10             	mov    0x10(%ebp),%eax
c0105268:	89 44 24 08          	mov    %eax,0x8(%esp)
c010526c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010526f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105273:	89 14 24             	mov    %edx,(%esp)
c0105276:	e8 6d 72 00 00       	call   c010c4e8 <arch_create_thread_context>

    // heap
    if(process->heap_top == 0)
c010527b:	8b 45 08             	mov    0x8(%ebp),%eax
c010527e:	8b 40 48             	mov    0x48(%eax),%eax
c0105281:	85 c0                	test   %eax,%eax
c0105283:	75 6b                	jne    c01052f0 <thread_create+0x1b4>
    {
        process->heap_top = arch_vaddr_find(&new_thread->context.memory.arch_context, 1, MEMORY_LAYOUT_USER_HEAP_START, MEMORY_LAYOUT_USER_HEAP_END);
c0105285:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105288:	83 c0 24             	add    $0x24,%eax
c010528b:	c7 44 24 0c 00 00 00 	movl   $0xb0000000,0xc(%esp)
c0105292:	b0 
c0105293:	c7 44 24 08 00 00 00 	movl   $0xa0000000,0x8(%esp)
c010529a:	a0 
c010529b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c01052a2:	00 
c01052a3:	89 04 24             	mov    %eax,(%esp)
c01052a6:	e8 f3 84 00 00       	call   c010d79e <arch_vaddr_find>
c01052ab:	8b 55 08             	mov    0x8(%ebp),%edx
c01052ae:	89 42 48             	mov    %eax,0x48(%edx)
        vmm_map(&new_thread->context.memory, pmm_alloc_page(), process->heap_top, VMM_PRESENT|VMM_WRITABLE|VMM_USER);
c01052b1:	8b 45 08             	mov    0x8(%ebp),%eax
c01052b4:	8b 58 48             	mov    0x48(%eax),%ebx
c01052b7:	e8 f8 a1 00 00       	call   c010f4b4 <pmm_alloc_page>
c01052bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01052bf:	83 c2 24             	add    $0x24,%edx
c01052c2:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c01052c9:	00 
c01052ca:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c01052ce:	89 44 24 04          	mov    %eax,0x4(%esp)
c01052d2:	89 14 24             	mov    %edx,(%esp)
c01052d5:	e8 be 65 00 00       	call   c010b898 <vmm_map>
        process->heap_lower_limit = process->heap_top;
c01052da:	8b 45 08             	mov    0x8(%ebp),%eax
c01052dd:	8b 50 48             	mov    0x48(%eax),%edx
c01052e0:	8b 45 08             	mov    0x8(%ebp),%eax
c01052e3:	89 50 4c             	mov    %edx,0x4c(%eax)
        process->heap_upper_limit = (uint32_t) MEMORY_LAYOUT_STACK_TOP - 0x1000;
c01052e6:	8b 45 08             	mov    0x8(%ebp),%eax
c01052e9:	c7 40 50 00 f0 ff bf 	movl   $0xbffff000,0x50(%eax)
    }

    // add to thread lists
    list_push_front(running_threads, new_thread);
c01052f0:	a1 10 90 11 c0       	mov    0xc0119010,%eax
c01052f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01052f8:	89 54 24 04          	mov    %edx,0x4(%esp)
c01052fc:	89 04 24             	mov    %eax,(%esp)
c01052ff:	e8 ae d7 ff ff       	call   c0102ab2 <list_push_front>
    list_push_front(process->threads, new_thread);
c0105304:	8b 45 08             	mov    0x8(%ebp),%eax
c0105307:	8b 40 34             	mov    0x34(%eax),%eax
c010530a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010530d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105311:	89 04 24             	mov    %eax,(%esp)
c0105314:	e8 99 d7 ff ff       	call   c0102ab2 <list_push_front>

    return new_thread;
c0105319:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010531c:	83 c4 34             	add    $0x34,%esp
c010531f:	5b                   	pop    %ebx
c0105320:	5d                   	pop    %ebp
c0105321:	c3                   	ret    

c0105322 <thread_clone>:
 * @brief				clone a thread
 * @param process		the process for the new thread
 * @param src_thread	the original thread
 */
struct thread_state *thread_clone(struct process_state *process, struct thread_state *src_thread)
{
c0105322:	55                   	push   %ebp
c0105323:	89 e5                	mov    %esp,%ebp
c0105325:	53                   	push   %ebx
c0105326:	83 ec 44             	sub    $0x44,%esp
    if(process == NULL)
c0105329:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010532d:	75 0a                	jne    c0105339 <thread_clone+0x17>
    {
        // cannot create thread without process
        return NULL;
c010532f:	b8 00 00 00 00       	mov    $0x0,%eax
c0105334:	e9 7f 02 00 00       	jmp    c01055b8 <thread_clone+0x296>
    }

    // allocate memory
    struct thread_state *new_thread = malloc(sizeof(struct thread_state));
c0105339:	c7 04 24 30 20 00 00 	movl   $0x2030,(%esp)
c0105340:	e8 00 6c 00 00       	call   c010bf45 <malloc>
c0105345:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // process stuff
    new_thread->process = process;
c0105348:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010534b:	8b 55 08             	mov    0x8(%ebp),%edx
c010534e:	89 10                	mov    %edx,(%eax)
    if(list_is_empty(process->zombie_tids))
c0105350:	8b 45 08             	mov    0x8(%ebp),%eax
c0105353:	8b 40 38             	mov    0x38(%eax),%eax
c0105356:	89 04 24             	mov    %eax,(%esp)
c0105359:	e8 4c d9 ff ff       	call   c0102caa <list_is_empty>
c010535e:	85 c0                	test   %eax,%eax
c0105360:	74 17                	je     c0105379 <thread_clone+0x57>
        new_thread->tid = process->tid_counter++;
c0105362:	8b 45 08             	mov    0x8(%ebp),%eax
c0105365:	8b 40 3c             	mov    0x3c(%eax),%eax
c0105368:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010536b:	89 42 04             	mov    %eax,0x4(%edx)
c010536e:	8d 50 01             	lea    0x1(%eax),%edx
c0105371:	8b 45 08             	mov    0x8(%ebp),%eax
c0105374:	89 50 3c             	mov    %edx,0x3c(%eax)
c0105377:	eb 16                	jmp    c010538f <thread_clone+0x6d>
    else
        new_thread->tid = (tid_t) list_pop_back(process->zombie_tids);
c0105379:	8b 45 08             	mov    0x8(%ebp),%eax
c010537c:	8b 40 38             	mov    0x38(%eax),%eax
c010537f:	89 04 24             	mov    %eax,(%esp)
c0105382:	e8 b5 d7 ff ff       	call   c0102b3c <list_pop_back>
c0105387:	89 c2                	mov    %eax,%edx
c0105389:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010538c:	89 50 04             	mov    %edx,0x4(%eax)

    if(process->main_thread == NULL)
c010538f:	8b 45 08             	mov    0x8(%ebp),%eax
c0105392:	8b 40 30             	mov    0x30(%eax),%eax
c0105395:	85 c0                	test   %eax,%eax
c0105397:	75 09                	jne    c01053a2 <thread_clone+0x80>
        process->main_thread = new_thread;
c0105399:	8b 45 08             	mov    0x8(%ebp),%eax
c010539c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010539f:	89 50 30             	mov    %edx,0x30(%eax)

    // flags
    new_thread->ticks = 10;
c01053a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01053a5:	c7 40 0c 0a 00 00 00 	movl   $0xa,0xc(%eax)
    new_thread->flags = THREAD_ACTIVE;
c01053ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01053af:	66 c7 40 10 01 00    	movw   $0x1,0x10(%eax)

    privilege_t prev;
    if(src_thread->flags & THREAD_KERNELMODE)
c01053b5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01053b8:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01053bc:	0f b7 c0             	movzwl %ax,%eax
c01053bf:	83 e0 04             	and    $0x4,%eax
c01053c2:	85 c0                	test   %eax,%eax
c01053c4:	74 1c                	je     c01053e2 <thread_clone+0xc0>
    {
        prev = KERNELMODE;
c01053c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        new_thread->flags |= THREAD_KERNELMODE;
c01053cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01053d0:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01053d4:	89 c2                	mov    %eax,%edx
c01053d6:	83 ca 04             	or     $0x4,%edx
c01053d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01053dc:	66 89 50 10          	mov    %dx,0x10(%eax)
c01053e0:	eb 07                	jmp    c01053e9 <thread_clone+0xc7>
    }
    else
        prev = USERMODE;
c01053e2:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)


    // context
    new_thread->return_value = 0;
c01053e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01053ec:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

    vmm_create_context(&new_thread->context.memory);
c01053f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01053f6:	83 c0 24             	add    $0x24,%eax
c01053f9:	89 04 24             	mov    %eax,(%esp)
c01053fc:	e8 41 64 00 00       	call   c010b842 <vmm_create_context>
    arch_fork_context(&src_thread->context.memory.arch_context, &new_thread->context.memory.arch_context);
c0105401:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105404:	8d 50 24             	lea    0x24(%eax),%edx
c0105407:	8b 45 0c             	mov    0xc(%ebp),%eax
c010540a:	83 c0 24             	add    $0x24,%eax
c010540d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105411:	89 04 24             	mov    %eax,(%esp)
c0105414:	e8 24 7f 00 00       	call   c010d33d <arch_fork_context>
    thread_sync_context(new_thread);
c0105419:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010541c:	89 04 24             	mov    %eax,(%esp)
c010541f:	e8 e3 01 00 00       	call   c0105607 <thread_sync_context>

    arch_create_thread_context(&new_thread->context, prev, (vaddr_t) 0, (vaddr_t) 0, 0, 0);
c0105424:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105427:	8d 50 18             	lea    0x18(%eax),%edx
c010542a:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0105431:	00 
c0105432:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0105439:	00 
c010543a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0105441:	00 
c0105442:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0105449:	00 
c010544a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010544d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0105451:	89 14 24             	mov    %edx,(%esp)
c0105454:	e8 8f 70 00 00       	call   c010c4e8 <arch_create_thread_context>

    // copy kernelstack
    memcpy((void*) new_thread->context.kernel_mode_stack, (void*) src_thread->context.kernel_mode_stack, 0x1000);
c0105459:	8b 45 0c             	mov    0xc(%ebp),%eax
c010545c:	8b 40 1c             	mov    0x1c(%eax),%eax
c010545f:	89 c2                	mov    %eax,%edx
c0105461:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105464:	8b 40 1c             	mov    0x1c(%eax),%eax
c0105467:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010546e:	00 
c010546f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105473:	89 04 24             	mov    %eax,(%esp)
c0105476:	e8 28 de ff ff       	call   c01032a3 <memcpy>

    // copy userstack
    if(prev == USERMODE)
c010547b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c010547f:	0f 85 92 00 00 00    	jne    c0105517 <thread_clone+0x1f5>
    {
        paddr_t src_paddr = src_thread->context.program_stack;
c0105485:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105488:	8b 40 20             	mov    0x20(%eax),%eax
c010548b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        paddr_t dest_paddr = new_thread->context.program_stack;
c010548e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105491:	8b 40 20             	mov    0x20(%eax),%eax
c0105494:	89 45 e8             	mov    %eax,-0x18(%ebp)
        void *src_stack  = (void *) vmm_automap_kernel(current_context, src_paddr, VMM_PRESENT | VMM_WRITABLE);
c0105497:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010549c:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c01054a3:	00 
c01054a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01054a7:	89 54 24 04          	mov    %edx,0x4(%esp)
c01054ab:	89 04 24             	mov    %eax,(%esp)
c01054ae:	e8 ce 64 00 00       	call   c010b981 <vmm_automap_kernel>
c01054b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        void *dest_stack = (void *) vmm_automap_kernel(current_context, dest_paddr, VMM_PRESENT | VMM_WRITABLE);
c01054b6:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c01054bb:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c01054c2:	00 
c01054c3:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01054c6:	89 54 24 04          	mov    %edx,0x4(%esp)
c01054ca:	89 04 24             	mov    %eax,(%esp)
c01054cd:	e8 af 64 00 00       	call   c010b981 <vmm_automap_kernel>
c01054d2:	89 45 e0             	mov    %eax,-0x20(%ebp)

        memcpy(dest_stack, src_stack, 0x1000);
c01054d5:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c01054dc:	00 
c01054dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01054e0:	89 44 24 04          	mov    %eax,0x4(%esp)
c01054e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01054e7:	89 04 24             	mov    %eax,(%esp)
c01054ea:	e8 b4 dd ff ff       	call   c01032a3 <memcpy>

        vmm_unmap(current_context, (vaddr_t) src_stack);
c01054ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01054f2:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c01054f7:	89 54 24 04          	mov    %edx,0x4(%esp)
c01054fb:	89 04 24             	mov    %eax,(%esp)
c01054fe:	e8 c4 63 00 00       	call   c010b8c7 <vmm_unmap>
        vmm_unmap(current_context, (vaddr_t) dest_stack);
c0105503:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0105506:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010550b:	89 54 24 04          	mov    %edx,0x4(%esp)
c010550f:	89 04 24             	mov    %eax,(%esp)
c0105512:	e8 b0 63 00 00       	call   c010b8c7 <vmm_unmap>
    }

    if(process->heap_top == 0)
c0105517:	8b 45 08             	mov    0x8(%ebp),%eax
c010551a:	8b 40 48             	mov    0x48(%eax),%eax
c010551d:	85 c0                	test   %eax,%eax
c010551f:	75 6b                	jne    c010558c <thread_clone+0x26a>
    {
        // what the fuck?
        process->heap_top = arch_vaddr_find(&new_thread->context.memory.arch_context, 1, MEMORY_LAYOUT_USER_HEAP_START, MEMORY_LAYOUT_USER_HEAP_END);
c0105521:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105524:	83 c0 24             	add    $0x24,%eax
c0105527:	c7 44 24 0c 00 00 00 	movl   $0xb0000000,0xc(%esp)
c010552e:	b0 
c010552f:	c7 44 24 08 00 00 00 	movl   $0xa0000000,0x8(%esp)
c0105536:	a0 
c0105537:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c010553e:	00 
c010553f:	89 04 24             	mov    %eax,(%esp)
c0105542:	e8 57 82 00 00       	call   c010d79e <arch_vaddr_find>
c0105547:	8b 55 08             	mov    0x8(%ebp),%edx
c010554a:	89 42 48             	mov    %eax,0x48(%edx)
        vmm_map(&new_thread->context.memory, pmm_alloc_page(), process->heap_top, VMM_PRESENT|VMM_WRITABLE|VMM_USER);
c010554d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105550:	8b 58 48             	mov    0x48(%eax),%ebx
c0105553:	e8 5c 9f 00 00       	call   c010f4b4 <pmm_alloc_page>
c0105558:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010555b:	83 c2 24             	add    $0x24,%edx
c010555e:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c0105565:	00 
c0105566:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c010556a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010556e:	89 14 24             	mov    %edx,(%esp)
c0105571:	e8 22 63 00 00       	call   c010b898 <vmm_map>
        process->heap_lower_limit = process->heap_top;
c0105576:	8b 45 08             	mov    0x8(%ebp),%eax
c0105579:	8b 50 48             	mov    0x48(%eax),%edx
c010557c:	8b 45 08             	mov    0x8(%ebp),%eax
c010557f:	89 50 4c             	mov    %edx,0x4c(%eax)
        process->heap_upper_limit = (uint32_t) MEMORY_LAYOUT_STACK_TOP - 0x1000;
c0105582:	8b 45 08             	mov    0x8(%ebp),%eax
c0105585:	c7 40 50 00 f0 ff bf 	movl   $0xbffff000,0x50(%eax)
    }

    // add to thread lists
    list_push_front(process->threads,new_thread);
c010558c:	8b 45 08             	mov    0x8(%ebp),%eax
c010558f:	8b 40 34             	mov    0x34(%eax),%eax
c0105592:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0105595:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105599:	89 04 24             	mov    %eax,(%esp)
c010559c:	e8 11 d5 ff ff       	call   c0102ab2 <list_push_front>
    list_push_front(running_threads, new_thread);
c01055a1:	a1 10 90 11 c0       	mov    0xc0119010,%eax
c01055a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01055a9:	89 54 24 04          	mov    %edx,0x4(%esp)
c01055ad:	89 04 24             	mov    %eax,(%esp)
c01055b0:	e8 fd d4 ff ff       	call   c0102ab2 <list_push_front>

    return new_thread;
c01055b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c01055b8:	83 c4 44             	add    $0x44,%esp
c01055bb:	5b                   	pop    %ebx
c01055bc:	5d                   	pop    %ebp
c01055bd:	c3                   	ret    

c01055be <kernel_thread_create>:

/**
 * @brief create a kernel-thread
 */
struct thread_state *kernel_thread_create(int (*thread)(int argc, char **argv, char **environ), char **argv, char **environ)
{
c01055be:	55                   	push   %ebp
c01055bf:	89 e5                	mov    %esp,%ebp
c01055c1:	83 ec 38             	sub    $0x38,%esp
    struct thread_state *new_thread = thread_create(kernel_state, KERNELMODE, (vaddr_t) thread, argv, environ, (vaddr_t) &kernel_thread_exit, NULL);
c01055c4:	b9 5c 56 10 c0       	mov    $0xc010565c,%ecx
c01055c9:	8b 55 08             	mov    0x8(%ebp),%edx
c01055cc:	a1 08 90 11 c0       	mov    0xc0119008,%eax
c01055d1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c01055d8:	00 
c01055d9:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c01055dd:	8b 4d 10             	mov    0x10(%ebp),%ecx
c01055e0:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c01055e4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c01055e7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c01055eb:	89 54 24 08          	mov    %edx,0x8(%esp)
c01055ef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01055f6:	00 
c01055f7:	89 04 24             	mov    %eax,(%esp)
c01055fa:	e8 3d fb ff ff       	call   c010513c <thread_create>
c01055ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return new_thread;
c0105602:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0105605:	c9                   	leave  
c0105606:	c3                   	ret    

c0105607 <thread_sync_context>:
/**
 * @brief			synchronize a threads context with the context of the main thread
 * @param thread	thread to synchronize
 */
void thread_sync_context(struct thread_state *thread)
{
c0105607:	55                   	push   %ebp
c0105608:	89 e5                	mov    %esp,%ebp
c010560a:	83 ec 28             	sub    $0x28,%esp
    struct thread_state *main_thread = thread->process->main_thread;
c010560d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105610:	8b 00                	mov    (%eax),%eax
c0105612:	8b 40 30             	mov    0x30(%eax),%eax
c0105615:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(thread != main_thread && main_thread != NULL && thread != NULL)
c0105618:	8b 45 08             	mov    0x8(%ebp),%eax
c010561b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010561e:	74 3a                	je     c010565a <thread_sync_context+0x53>
c0105620:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0105624:	74 34                	je     c010565a <thread_sync_context+0x53>
c0105626:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010562a:	74 2e                	je     c010565a <thread_sync_context+0x53>
    {
        int end = PDE_INDEX(0xB0000000);
c010562c:	c7 45 f0 c0 02 00 00 	movl   $0x2c0,-0x10(%ebp)
        arch_sync_pts(&thread->context.memory.arch_context, &main_thread->context.memory.arch_context, 0, end);
c0105633:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105636:	8d 48 24             	lea    0x24(%eax),%ecx
c0105639:	8b 45 08             	mov    0x8(%ebp),%eax
c010563c:	8d 50 24             	lea    0x24(%eax),%edx
c010563f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105642:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0105646:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010564d:	00 
c010564e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c0105652:	89 14 24             	mov    %edx,(%esp)
c0105655:	e8 a9 7c 00 00       	call   c010d303 <arch_sync_pts>
    }
}
c010565a:	c9                   	leave  
c010565b:	c3                   	ret    

c010565c <kernel_thread_exit>:

/**
 * @brief	exit the current thread in kernelmode
 */
void kernel_thread_exit(void)
{
c010565c:	55                   	push   %ebp
c010565d:	89 e5                	mov    %esp,%ebp
c010565f:	83 ec 18             	sub    $0x18,%esp
    current_thread->flags |= THREAD_ZOMBIE;
c0105662:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0105667:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c010566d:	0f b7 52 10          	movzwl 0x10(%edx),%edx
c0105671:	83 ca 08             	or     $0x8,%edx
c0105674:	66 89 50 10          	mov    %dx,0x10(%eax)
    printf("death row\n");
c0105678:	c7 04 24 fd 0a 11 c0 	movl   $0xc0110afd,(%esp)
c010567f:	e8 1b 6c 00 00       	call   c010c29f <puts>
    while(1) {}
c0105684:	eb fe                	jmp    c0105684 <kernel_thread_exit+0x28>

c0105686 <thread_suspend>:
/**
 *  @brief			Suspends a running thread
 *  @param thread	pointer to the thread state
 */
void thread_suspend(struct thread_state *thread)
{
c0105686:	55                   	push   %ebp
c0105687:	89 e5                	mov    %esp,%ebp
c0105689:	83 ec 28             	sub    $0x28,%esp
    if(! list_is_empty(running_threads))
c010568c:	a1 10 90 11 c0       	mov    0xc0119010,%eax
c0105691:	89 04 24             	mov    %eax,(%esp)
c0105694:	e8 11 d6 ff ff       	call   c0102caa <list_is_empty>
c0105699:	85 c0                	test   %eax,%eax
c010569b:	75 77                	jne    c0105714 <thread_suspend+0x8e>
    {
        iterator_t it = iterator_create(running_threads);
c010569d:	8b 15 10 90 11 c0    	mov    0xc0119010,%edx
c01056a3:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01056a6:	89 54 24 04          	mov    %edx,0x4(%esp)
c01056aa:	89 04 24             	mov    %eax,(%esp)
c01056ad:	e8 39 d6 ff ff       	call   c0102ceb <iterator_create>
c01056b2:	83 ec 04             	sub    $0x4,%esp
        list_set_first(&it);
c01056b5:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01056b8:	89 04 24             	mov    %eax,(%esp)
c01056bb:	e8 5b d7 ff ff       	call   c0102e1b <list_set_first>

        while(!list_is_last(&it))
c01056c0:	eb 43                	jmp    c0105705 <thread_suspend+0x7f>
        {
            if(list_get_current(&it) == thread)
c01056c2:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01056c5:	89 04 24             	mov    %eax,(%esp)
c01056c8:	e8 e7 d6 ff ff       	call   c0102db4 <list_get_current>
c01056cd:	3b 45 08             	cmp    0x8(%ebp),%eax
c01056d0:	75 28                	jne    c01056fa <thread_suspend+0x74>
            {
                list_remove(&it);
c01056d2:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01056d5:	89 04 24             	mov    %eax,(%esp)
c01056d8:	e8 69 d7 ff ff       	call   c0102e46 <list_remove>
                thread->ticks = 0;
c01056dd:	8b 45 08             	mov    0x8(%ebp),%eax
c01056e0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
                thread->flags &= ~THREAD_ACTIVE;
c01056e7:	8b 45 08             	mov    0x8(%ebp),%eax
c01056ea:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01056ee:	89 c2                	mov    %eax,%edx
c01056f0:	83 e2 fe             	and    $0xfffffffe,%edx
c01056f3:	8b 45 08             	mov    0x8(%ebp),%eax
c01056f6:	66 89 50 10          	mov    %dx,0x10(%eax)
            }
            list_next(&it);
c01056fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01056fd:	89 04 24             	mov    %eax,(%esp)
c0105700:	e8 d4 d6 ff ff       	call   c0102dd9 <list_next>
    if(! list_is_empty(running_threads))
    {
        iterator_t it = iterator_create(running_threads);
        list_set_first(&it);

        while(!list_is_last(&it))
c0105705:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0105708:	89 04 24             	mov    %eax,(%esp)
c010570b:	e8 f0 d6 ff ff       	call   c0102e00 <list_is_last>
c0105710:	85 c0                	test   %eax,%eax
c0105712:	74 ae                	je     c01056c2 <thread_suspend+0x3c>
                thread->flags &= ~THREAD_ACTIVE;
            }
            list_next(&it);
        }
    }
}
c0105714:	c9                   	leave  
c0105715:	c3                   	ret    

c0105716 <thread_wakeup>:
/**
 * @brief			Wakes up a thread
 * @param thread	pointer to the thread state
 */
void thread_wakeup(struct thread_state *thread)
{
c0105716:	55                   	push   %ebp
c0105717:	89 e5                	mov    %esp,%ebp
c0105719:	83 ec 18             	sub    $0x18,%esp
    thread->flags |= THREAD_ACTIVE;
c010571c:	8b 45 08             	mov    0x8(%ebp),%eax
c010571f:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c0105723:	89 c2                	mov    %eax,%edx
c0105725:	83 ca 01             	or     $0x1,%edx
c0105728:	8b 45 08             	mov    0x8(%ebp),%eax
c010572b:	66 89 50 10          	mov    %dx,0x10(%eax)
    // the ticks will be set in the scheduler

    list_push_front(running_threads, thread);
c010572f:	a1 10 90 11 c0       	mov    0xc0119010,%eax
c0105734:	8b 55 08             	mov    0x8(%ebp),%edx
c0105737:	89 54 24 04          	mov    %edx,0x4(%esp)
c010573b:	89 04 24             	mov    %eax,(%esp)
c010573e:	e8 6f d3 ff ff       	call   c0102ab2 <list_push_front>
}
c0105743:	c9                   	leave  
c0105744:	c3                   	ret    

c0105745 <thread_kill>:
/**
 * @brief			kills a thread. if its the current, define it as zombie
 * @param thread	thread to kill
 */
void thread_kill(struct thread_state *thread)
{
c0105745:	55                   	push   %ebp
c0105746:	89 e5                	mov    %esp,%ebp
c0105748:	83 ec 18             	sub    $0x18,%esp
    disable_irqs();
c010574b:	e8 e0 f9 ff ff       	call   c0105130 <disable_irqs>

    if(current_thread == thread)
c0105750:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0105755:	3b 45 08             	cmp    0x8(%ebp),%eax
c0105758:	75 15                	jne    c010576f <thread_kill+0x2a>
        thread->flags |= THREAD_ZOMBIE;
c010575a:	8b 45 08             	mov    0x8(%ebp),%eax
c010575d:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c0105761:	89 c2                	mov    %eax,%edx
c0105763:	83 ca 08             	or     $0x8,%edx
c0105766:	8b 45 08             	mov    0x8(%ebp),%eax
c0105769:	66 89 50 10          	mov    %dx,0x10(%eax)
c010576d:	eb 0b                	jmp    c010577a <thread_kill+0x35>
    else
    {
        thread_kill_sub(thread);
c010576f:	8b 45 08             	mov    0x8(%ebp),%eax
c0105772:	89 04 24             	mov    %eax,(%esp)
c0105775:	e8 07 00 00 00       	call   c0105781 <thread_kill_sub>
    }

    enable_irqs();
c010577a:	e8 b7 f9 ff ff       	call   c0105136 <enable_irqs>
}
c010577f:	c9                   	leave  
c0105780:	c3                   	ret    

c0105781 <thread_kill_sub>:
/**
 * @brief			destroys a thread and removes it from all lists
 * @param thread	thread to kill
 */
void thread_kill_sub(struct thread_state *thread)
{
c0105781:	55                   	push   %ebp
c0105782:	89 e5                	mov    %esp,%ebp
c0105784:	83 ec 38             	sub    $0x38,%esp
    struct process_state *process = thread->process;
c0105787:	8b 45 08             	mov    0x8(%ebp),%eax
c010578a:	8b 00                	mov    (%eax),%eax
c010578c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // remove it from the global thread list
    if(thread == current_thread)
c010578f:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0105794:	39 45 08             	cmp    %eax,0x8(%ebp)
c0105797:	75 0a                	jne    c01057a3 <thread_kill_sub+0x22>
    {
        current_thread = NULL;
c0105799:	c7 05 0c 90 11 c0 00 	movl   $0x0,0xc011900c
c01057a0:	00 00 00 
    }

    if(thread->flags & THREAD_ACTIVE || thread->flags & THREAD_ZOMBIE)
c01057a3:	8b 45 08             	mov    0x8(%ebp),%eax
c01057a6:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01057aa:	0f b7 c0             	movzwl %ax,%eax
c01057ad:	83 e0 01             	and    $0x1,%eax
c01057b0:	85 c0                	test   %eax,%eax
c01057b2:	75 11                	jne    c01057c5 <thread_kill_sub+0x44>
c01057b4:	8b 45 08             	mov    0x8(%ebp),%eax
c01057b7:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c01057bb:	0f b7 c0             	movzwl %ax,%eax
c01057be:	83 e0 08             	and    $0x8,%eax
c01057c1:	85 c0                	test   %eax,%eax
c01057c3:	74 57                	je     c010581c <thread_kill_sub+0x9b>
    {
        iterator_t running_thread_it = iterator_create(running_threads);
c01057c5:	8b 15 10 90 11 c0    	mov    0xc0119010,%edx
c01057cb:	8d 45 dc             	lea    -0x24(%ebp),%eax
c01057ce:	89 54 24 04          	mov    %edx,0x4(%esp)
c01057d2:	89 04 24             	mov    %eax,(%esp)
c01057d5:	e8 11 d5 ff ff       	call   c0102ceb <iterator_create>
c01057da:	83 ec 04             	sub    $0x4,%esp
        while(!list_is_last(&running_thread_it))
c01057dd:	eb 2e                	jmp    c010580d <thread_kill_sub+0x8c>
        {
            struct thread_state *t = list_get_current(&running_thread_it);
c01057df:	8d 45 dc             	lea    -0x24(%ebp),%eax
c01057e2:	89 04 24             	mov    %eax,(%esp)
c01057e5:	e8 ca d5 ff ff       	call   c0102db4 <list_get_current>
c01057ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if(t == thread)
c01057ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01057f0:	3b 45 08             	cmp    0x8(%ebp),%eax
c01057f3:	75 0d                	jne    c0105802 <thread_kill_sub+0x81>
            {
                list_remove(&running_thread_it);
c01057f5:	8d 45 dc             	lea    -0x24(%ebp),%eax
c01057f8:	89 04 24             	mov    %eax,(%esp)
c01057fb:	e8 46 d6 ff ff       	call   c0102e46 <list_remove>
                break;
c0105800:	eb 1a                	jmp    c010581c <thread_kill_sub+0x9b>
            }
            list_next(&running_thread_it);
c0105802:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0105805:	89 04 24             	mov    %eax,(%esp)
c0105808:	e8 cc d5 ff ff       	call   c0102dd9 <list_next>
    }

    if(thread->flags & THREAD_ACTIVE || thread->flags & THREAD_ZOMBIE)
    {
        iterator_t running_thread_it = iterator_create(running_threads);
        while(!list_is_last(&running_thread_it))
c010580d:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0105810:	89 04 24             	mov    %eax,(%esp)
c0105813:	e8 e8 d5 ff ff       	call   c0102e00 <list_is_last>
c0105818:	85 c0                	test   %eax,%eax
c010581a:	74 c3                	je     c01057df <thread_kill_sub+0x5e>
    if(! (thread->flags & THREAD_KERNELMODE))
    {
        // arch_destroy_thread_context(&thread->context); // FIXME
    }

    if(thread == thread->process->main_thread)
c010581c:	8b 45 08             	mov    0x8(%ebp),%eax
c010581f:	8b 00                	mov    (%eax),%eax
c0105821:	8b 40 30             	mov    0x30(%eax),%eax
c0105824:	3b 45 08             	cmp    0x8(%ebp),%eax
c0105827:	75 0c                	jne    c0105835 <thread_kill_sub+0xb4>
    {
        thread->process->main_thread = NULL;
c0105829:	8b 45 08             	mov    0x8(%ebp),%eax
c010582c:	8b 00                	mov    (%eax),%eax
c010582e:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)

    //if(thread->process->flags & PROCESS_ZOMBIE)
    //{
    //    list_push_front(thread->process->zombie_tids,(void *) thread->tid);
    // remove it from process thread list
    iterator_t thread_it = iterator_create(process->threads);
c0105835:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105838:	8b 50 34             	mov    0x34(%eax),%edx
c010583b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010583e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105842:	89 04 24             	mov    %eax,(%esp)
c0105845:	e8 a1 d4 ff ff       	call   c0102ceb <iterator_create>
c010584a:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_last(&thread_it))
c010584d:	eb 2e                	jmp    c010587d <thread_kill_sub+0xfc>
    {
        struct thread_state *t = list_get_current(&thread_it);
c010584f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0105852:	89 04 24             	mov    %eax,(%esp)
c0105855:	e8 5a d5 ff ff       	call   c0102db4 <list_get_current>
c010585a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(t == thread)
c010585d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105860:	3b 45 08             	cmp    0x8(%ebp),%eax
c0105863:	75 0d                	jne    c0105872 <thread_kill_sub+0xf1>
        {
            list_remove(&thread_it);
c0105865:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0105868:	89 04 24             	mov    %eax,(%esp)
c010586b:	e8 d6 d5 ff ff       	call   c0102e46 <list_remove>
            //if(list_is_empty(thread->process->threads))
            //    process_kill(thread->process);
            break;
c0105870:	eb 1a                	jmp    c010588c <thread_kill_sub+0x10b>
        }
        list_next(&thread_it);
c0105872:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0105875:	89 04 24             	mov    %eax,(%esp)
c0105878:	e8 5c d5 ff ff       	call   c0102dd9 <list_next>
    //if(thread->process->flags & PROCESS_ZOMBIE)
    //{
    //    list_push_front(thread->process->zombie_tids,(void *) thread->tid);
    // remove it from process thread list
    iterator_t thread_it = iterator_create(process->threads);
    while(!list_is_last(&thread_it))
c010587d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0105880:	89 04 24             	mov    %eax,(%esp)
c0105883:	e8 78 d5 ff ff       	call   c0102e00 <list_is_last>
c0105888:	85 c0                	test   %eax,%eax
c010588a:	74 c3                	je     c010584f <thread_kill_sub+0xce>
            break;
        }
        list_next(&thread_it);
    }

    free(thread);
c010588c:	8b 45 08             	mov    0x8(%ebp),%eax
c010588f:	89 04 24             	mov    %eax,(%esp)
c0105892:	e8 bc 67 00 00       	call   c010c053 <free>
    //}
}
c0105897:	c9                   	leave  
c0105898:	c3                   	ret    

c0105899 <INIT_VFS>:
 *
 * @param void
 * @return void
 */
void INIT_VFS(void)
{
c0105899:	55                   	push   %ebp
c010589a:	89 e5                	mov    %esp,%ebp
c010589c:	83 ec 38             	sub    $0x38,%esp
    root = vfs_create_inode(NULL, S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO, NULL, 0, 0);
c010589f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c01058a6:	00 
c01058a7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c01058ae:	00 
c01058af:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c01058b6:	00 
c01058b7:	c7 44 24 04 20 07 00 	movl   $0x720,0x4(%esp)
c01058be:	00 
c01058bf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c01058c6:	e8 63 05 00 00       	call   c0105e2e <vfs_create_inode>
c01058cb:	a3 20 90 11 c0       	mov    %eax,0xc0119020

    vfs_inode_t *foo = vfs_create_inode("foo.txt", S_IRWXU | S_IRWXG | S_IRWXO, root, 0, 0);
c01058d0:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c01058d5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c01058dc:	00 
c01058dd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c01058e4:	00 
c01058e5:	89 44 24 08          	mov    %eax,0x8(%esp)
c01058e9:	c7 44 24 04 00 07 00 	movl   $0x700,0x4(%esp)
c01058f0:	00 
c01058f1:	c7 04 24 07 0b 11 c0 	movl   $0xc0110b07,(%esp)
c01058f8:	e8 31 05 00 00       	call   c0105e2e <vfs_create_inode>
c01058fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    vfs_write(foo, 0, "Hallo Welt!\n", 13);
c0105900:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
c0105907:	00 
c0105908:	c7 44 24 08 0f 0b 11 	movl   $0xc0110b0f,0x8(%esp)
c010590f:	c0 
c0105910:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105917:	00 
c0105918:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010591b:	89 04 24             	mov    %eax,(%esp)
c010591e:	e8 2f 07 00 00       	call   c0106052 <vfs_write>
}
c0105923:	c9                   	leave  
c0105924:	c3                   	ret    

c0105925 <vfs_debug_output_all>:

#ifdef VFS_DEBUG
void vfs_debug_output_all()
{
c0105925:	55                   	push   %ebp
c0105926:	89 e5                	mov    %esp,%ebp
c0105928:	83 ec 18             	sub    $0x18,%esp
    vfs_debug_output(root);
c010592b:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c0105930:	89 04 24             	mov    %eax,(%esp)
c0105933:	e8 02 00 00 00       	call   c010593a <vfs_debug_output>
}
c0105938:	c9                   	leave  
c0105939:	c3                   	ret    

c010593a <vfs_debug_output>:

void vfs_debug_output(vfs_inode_t *start)
{
c010593a:	55                   	push   %ebp
c010593b:	89 e5                	mov    %esp,%ebp
c010593d:	83 ec 28             	sub    $0x28,%esp
    vfs_inode_t *current;

    int num = start->length / sizeof(vfs_dentry_t);
c0105940:	8b 45 08             	mov    0x8(%ebp),%eax
c0105943:	8b 40 08             	mov    0x8(%eax),%eax
c0105946:	c1 e8 03             	shr    $0x3,%eax
c0105949:	89 45 ec             	mov    %eax,-0x14(%ebp)
    vfs_dentry_t *entries = malloc(start->length);
c010594c:	8b 45 08             	mov    0x8(%ebp),%eax
c010594f:	8b 40 08             	mov    0x8(%eax),%eax
c0105952:	89 04 24             	mov    %eax,(%esp)
c0105955:	e8 eb 65 00 00       	call   c010bf45 <malloc>
c010595a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    vfs_read(start, 0, entries, start->length);
c010595d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105960:	8b 40 08             	mov    0x8(%eax),%eax
c0105963:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0105967:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010596a:	89 44 24 08          	mov    %eax,0x8(%esp)
c010596e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105975:	00 
c0105976:	8b 45 08             	mov    0x8(%ebp),%eax
c0105979:	89 04 24             	mov    %eax,(%esp)
c010597c:	e8 9d 07 00 00       	call   c010611e <vfs_read>

    int i;
    for(i = 0; i < num; i++)
c0105981:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0105988:	e9 87 00 00 00       	jmp    c0105a14 <vfs_debug_output+0xda>
    {
        if(S_ISDIR(entries[i].inode->stat))
c010598d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105990:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0105997:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010599a:	01 d0                	add    %edx,%eax
c010599c:	8b 40 04             	mov    0x4(%eax),%eax
c010599f:	8b 40 0c             	mov    0xc(%eax),%eax
c01059a2:	83 e0 20             	and    $0x20,%eax
c01059a5:	85 c0                	test   %eax,%eax
c01059a7:	74 1c                	je     c01059c5 <vfs_debug_output+0x8b>
        {
            vfs_debug_output(entries[i].inode);
c01059a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01059ac:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c01059b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01059b6:	01 d0                	add    %edx,%eax
c01059b8:	8b 40 04             	mov    0x4(%eax),%eax
c01059bb:	89 04 24             	mov    %eax,(%esp)
c01059be:	e8 77 ff ff ff       	call   c010593a <vfs_debug_output>
c01059c3:	eb 4b                	jmp    c0105a10 <vfs_debug_output+0xd6>
        }
        else
        {
            current = entries[i].inode;
c01059c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01059c8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c01059cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01059d2:	01 d0                	add    %edx,%eax
c01059d4:	8b 40 04             	mov    0x4(%eax),%eax
c01059d7:	89 45 f4             	mov    %eax,-0xc(%ebp)

            while(current != root)
c01059da:	eb 1e                	jmp    c01059fa <vfs_debug_output+0xc0>
            {
                printf("%s in ", current->name);
c01059dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01059df:	8b 00                	mov    (%eax),%eax
c01059e1:	89 44 24 04          	mov    %eax,0x4(%esp)
c01059e5:	c7 04 24 1c 0b 11 c0 	movl   $0xc0110b1c,(%esp)
c01059ec:	e8 30 dc ff ff       	call   c0103621 <printf>
                current = current->parent;
c01059f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01059f4:	8b 40 38             	mov    0x38(%eax),%eax
c01059f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }
        else
        {
            current = entries[i].inode;

            while(current != root)
c01059fa:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c01059ff:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0105a02:	75 d8                	jne    c01059dc <vfs_debug_output+0xa2>
            {
                printf("%s in ", current->name);
                current = current->parent;
            }

            printf("root\n");
c0105a04:	c7 04 24 23 0b 11 c0 	movl   $0xc0110b23,(%esp)
c0105a0b:	e8 8f 68 00 00       	call   c010c29f <puts>
    int num = start->length / sizeof(vfs_dentry_t);
    vfs_dentry_t *entries = malloc(start->length);
    vfs_read(start, 0, entries, start->length);

    int i;
    for(i = 0; i < num; i++)
c0105a10:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0105a14:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105a17:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0105a1a:	0f 8c 6d ff ff ff    	jl     c010598d <vfs_debug_output+0x53>

            printf("root\n");
        }
    }

    free(entries);
c0105a20:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105a23:	89 04 24             	mov    %eax,(%esp)
c0105a26:	e8 28 66 00 00       	call   c010c053 <free>
}
c0105a2b:	c9                   	leave  
c0105a2c:	c3                   	ret    

c0105a2d <launch_pipe_handlers>:
#endif

void launch_pipe_handlers(vfs_inode_t *pipe)
{
c0105a2d:	55                   	push   %ebp
c0105a2e:	89 e5                	mov    %esp,%ebp
c0105a30:	53                   	push   %ebx
c0105a31:	83 ec 34             	sub    $0x34,%esp
    struct list_node *node = pipe->handlers->head->next;
c0105a34:	8b 45 08             	mov    0x8(%ebp),%eax
c0105a37:	8b 40 48             	mov    0x48(%eax),%eax
c0105a3a:	8b 40 04             	mov    0x4(%eax),%eax
c0105a3d:	8b 00                	mov    (%eax),%eax
c0105a3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct list_node *head = pipe->handlers->head;
c0105a42:	8b 45 08             	mov    0x8(%ebp),%eax
c0105a45:	8b 40 48             	mov    0x48(%eax),%eax
c0105a48:	8b 40 04             	mov    0x4(%eax),%eax
c0105a4b:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(node != head)
c0105a4e:	eb 55                	jmp    c0105aa5 <launch_pipe_handlers+0x78>
    {
        vfs_pipe_trigger_t *trigger = (vfs_pipe_trigger_t*) node->element;
c0105a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105a53:	8b 40 08             	mov    0x8(%eax),%eax
c0105a56:	89 45 ec             	mov    %eax,-0x14(%ebp)
        thread_create(current_thread->process, USERMODE, trigger->eip, trigger->argv, trigger->environ, 0, NULL);
c0105a59:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105a5c:	8b 58 0c             	mov    0xc(%eax),%ebx
c0105a5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105a62:	8b 48 08             	mov    0x8(%eax),%ecx
c0105a65:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105a68:	8b 10                	mov    (%eax),%edx
c0105a6a:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0105a6f:	8b 00                	mov    (%eax),%eax
c0105a71:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0105a78:	00 
c0105a79:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0105a80:	00 
c0105a81:	89 5c 24 10          	mov    %ebx,0x10(%esp)
c0105a85:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0105a89:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105a8d:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c0105a94:	00 
c0105a95:	89 04 24             	mov    %eax,(%esp)
c0105a98:	e8 9f f6 ff ff       	call   c010513c <thread_create>

        node = node->next;
c0105a9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105aa0:	8b 00                	mov    (%eax),%eax
c0105aa2:	89 45 f4             	mov    %eax,-0xc(%ebp)
void launch_pipe_handlers(vfs_inode_t *pipe)
{
    struct list_node *node = pipe->handlers->head->next;
    struct list_node *head = pipe->handlers->head;

    while(node != head)
c0105aa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105aa8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0105aab:	75 a3                	jne    c0105a50 <launch_pipe_handlers+0x23>
        vfs_pipe_trigger_t *trigger = (vfs_pipe_trigger_t*) node->element;
        thread_create(current_thread->process, USERMODE, trigger->eip, trigger->argv, trigger->environ, 0, NULL);

        node = node->next;
    }
}
c0105aad:	83 c4 34             	add    $0x34,%esp
c0105ab0:	5b                   	pop    %ebx
c0105ab1:	5d                   	pop    %ebp
c0105ab2:	c3                   	ret    

c0105ab3 <map_all>:
 * @brief maps all multiboot modules into the vfs
 * @param mb_info the multiboot struct with the modules in it
 * @return how many modules got mapped and how many failed
 */
struct mapping_statistics map_all(struct multiboot_struct *mb_info)
{
c0105ab3:	55                   	push   %ebp
c0105ab4:	89 e5                	mov    %esp,%ebp
c0105ab6:	83 ec 28             	sub    $0x28,%esp
    struct mapping_statistics s;
    memset(&s, 0, sizeof(struct mapping_statistics));
c0105ab9:	c7 44 24 08 0c 00 00 	movl   $0xc,0x8(%esp)
c0105ac0:	00 
c0105ac1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105ac8:	00 
c0105ac9:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0105acc:	89 04 24             	mov    %eax,(%esp)
c0105acf:	e8 45 d9 ff ff       	call   c0103419 <memset>
    struct mods_add *modules = (struct mods_add*) mb_info->mods_addr;
c0105ad4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105ad7:	8b 40 18             	mov    0x18(%eax),%eax
c0105ada:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(s.total = 0; s.total < mb_info->mods_count; s.total++)
c0105add:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0105ae4:	eb 36                	jmp    c0105b1c <map_all+0x69>
    {
        if(map_module(&modules[s.total]) == success)
c0105ae6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105ae9:	89 c2                	mov    %eax,%edx
c0105aeb:	c1 e2 04             	shl    $0x4,%edx
c0105aee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105af1:	01 d0                	add    %edx,%eax
c0105af3:	89 04 24             	mov    %eax,(%esp)
c0105af6:	e8 4b 00 00 00       	call   c0105b46 <map_module>
c0105afb:	85 c0                	test   %eax,%eax
c0105afd:	75 0b                	jne    c0105b0a <map_all+0x57>
            s.load_success++;
c0105aff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105b02:	83 c0 01             	add    $0x1,%eax
c0105b05:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0105b08:	eb 09                	jmp    c0105b13 <map_all+0x60>
        else
            s.load_failed++;
c0105b0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105b0d:	83 c0 01             	add    $0x1,%eax
c0105b10:	89 45 f0             	mov    %eax,-0x10(%ebp)
{
    struct mapping_statistics s;
    memset(&s, 0, sizeof(struct mapping_statistics));
    struct mods_add *modules = (struct mods_add*) mb_info->mods_addr;

    for(s.total = 0; s.total < mb_info->mods_count; s.total++)
c0105b13:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105b16:	83 c0 01             	add    $0x1,%eax
c0105b19:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0105b1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105b1f:	89 c2                	mov    %eax,%edx
c0105b21:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105b24:	8b 40 14             	mov    0x14(%eax),%eax
c0105b27:	39 c2                	cmp    %eax,%edx
c0105b29:	72 bb                	jb     c0105ae6 <map_all+0x33>
            s.load_success++;
        else
            s.load_failed++;
    }

    return s;
c0105b2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b2e:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0105b31:	89 10                	mov    %edx,(%eax)
c0105b33:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0105b36:	89 50 04             	mov    %edx,0x4(%eax)
c0105b39:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0105b3c:	89 50 08             	mov    %edx,0x8(%eax)
}
c0105b3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b42:	c9                   	leave  
c0105b43:	c2 04 00             	ret    $0x4

c0105b46 <map_module>:
 * @brief maps one module into the vfs
 * @param module the information i need to map this module
 * @return success or failture
 */
success_t map_module(struct mods_add *module)
{
c0105b46:	55                   	push   %ebp
c0105b47:	89 e5                	mov    %esp,%ebp
c0105b49:	83 ec 48             	sub    $0x48,%esp
    if(module == NULL)  // i don't think this will ever happen, but you have what you have
c0105b4c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0105b50:	75 0a                	jne    c0105b5c <map_module+0x16>
        return failed;
c0105b52:	b8 01 00 00 00       	mov    $0x1,%eax
c0105b57:	e9 3d 01 00 00       	jmp    c0105c99 <map_module+0x153>

    char *path = NULL;  // later i will need path and name
c0105b5c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    char *name = NULL;
c0105b63:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    if(split_module_string(module->string, &path, &name) == failed)     // if i can't split the module string there is no reason for executing further
c0105b6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0105b6d:	8b 40 08             	mov    0x8(%eax),%eax
c0105b70:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0105b73:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105b77:	8d 55 e0             	lea    -0x20(%ebp),%edx
c0105b7a:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105b7e:	89 04 24             	mov    %eax,(%esp)
c0105b81:	e8 15 01 00 00       	call   c0105c9b <split_module_string>
c0105b86:	83 f8 01             	cmp    $0x1,%eax
c0105b89:	75 0a                	jne    c0105b95 <map_module+0x4f>
        return failed;
c0105b8b:	b8 01 00 00 00       	mov    $0x1,%eax
c0105b90:	e9 04 01 00 00       	jmp    c0105c99 <map_module+0x153>

//    printf("%s%s\n", path, name);

    vfs_inode_t *node = vfs_create_path(path, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH | S_IFDIR, 0, 0); // i need a node to place the module in
c0105b95:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0105b98:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0105b9f:	00 
c0105ba0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0105ba7:	00 
c0105ba8:	c7 44 24 04 20 13 01 	movl   $0x11320,0x4(%esp)
c0105baf:	00 
c0105bb0:	89 04 24             	mov    %eax,(%esp)
c0105bb3:	e8 53 30 00 00       	call   c0108c0b <vfs_create_path>
c0105bb8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int size = module->mod_end - module->mod_start;     // basic stuff
c0105bbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0105bbe:	8b 50 04             	mov    0x4(%eax),%edx
c0105bc1:	8b 45 08             	mov    0x8(%ebp),%eax
c0105bc4:	8b 00                	mov    (%eax),%eax
c0105bc6:	89 d1                	mov    %edx,%ecx
c0105bc8:	29 c1                	sub    %eax,%ecx
c0105bca:	89 c8                	mov    %ecx,%eax
c0105bcc:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(size < 0)        // should never happen, but you never know
c0105bcf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0105bd3:	79 20                	jns    c0105bf5 <map_module+0xaf>
    {
        free(path);     // i have to free the allocated memory (to avoid memory leaks)
c0105bd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0105bd8:	89 04 24             	mov    %eax,(%esp)
c0105bdb:	e8 73 64 00 00       	call   c010c053 <free>
        free(name);
c0105be0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0105be3:	89 04 24             	mov    %eax,(%esp)
c0105be6:	e8 68 64 00 00       	call   c010c053 <free>
        return failed;
c0105beb:	b8 01 00 00 00       	mov    $0x1,%eax
c0105bf0:	e9 a4 00 00 00       	jmp    c0105c99 <map_module+0x153>
    }

    int pages = NUM_PAGES(size);
c0105bf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105bf8:	05 ff 0f 00 00       	add    $0xfff,%eax
c0105bfd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0105c02:	c1 e8 0c             	shr    $0xc,%eax
c0105c05:	89 45 ec             	mov    %eax,-0x14(%ebp)

    vaddr_t virtaddr = vmm_automap_kernel_range(current_context, module->mod_start, pages, VMM_WRITABLE);   // something about physical and virtual memory and kernel and user space... ask someone else
c0105c08:	8b 45 08             	mov    0x8(%ebp),%eax
c0105c0b:	8b 10                	mov    (%eax),%edx
c0105c0d:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c0105c12:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c0105c19:	00 
c0105c1a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0105c1d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0105c21:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105c25:	89 04 24             	mov    %eax,(%esp)
c0105c28:	e8 b2 5d 00 00       	call   c010b9df <vmm_automap_kernel_range>
c0105c2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

    vfs_inode_t *file = vfs_create_inode(name,  S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH, node, 0, 0);   // create the module in the vfs
c0105c30:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0105c33:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0105c3a:	00 
c0105c3b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0105c42:	00 
c0105c43:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105c46:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105c4a:	c7 44 24 04 00 57 05 	movl   $0x55700,0x4(%esp)
c0105c51:	00 
c0105c52:	89 04 24             	mov    %eax,(%esp)
c0105c55:	e8 d4 01 00 00       	call   c0105e2e <vfs_create_inode>
c0105c5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    vfs_write(file, 0, (void*)virtaddr, size);
c0105c5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105c60:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0105c63:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0105c67:	89 44 24 08          	mov    %eax,0x8(%esp)
c0105c6b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105c72:	00 
c0105c73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105c76:	89 04 24             	mov    %eax,(%esp)
c0105c79:	e8 d4 03 00 00       	call   c0106052 <vfs_write>

    free(path);     // "we don't waste memory" (tdotu)
c0105c7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0105c81:	89 04 24             	mov    %eax,(%esp)
c0105c84:	e8 ca 63 00 00       	call   c010c053 <free>
    free(name);
c0105c89:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0105c8c:	89 04 24             	mov    %eax,(%esp)
c0105c8f:	e8 bf 63 00 00       	call   c010c053 <free>

    return success; // be happy
c0105c94:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0105c99:	c9                   	leave  
c0105c9a:	c3                   	ret    

c0105c9b <split_module_string>:
 * @param path_buffer the adress of the char pointer in which the path should be placed
 * @param name_buffer the adress of the char pointer in which the name should be placed
 * @return success or failture
 */
success_t split_module_string(char *string, char **path_buffer, char **name_buffer)
{
c0105c9b:	55                   	push   %ebp
c0105c9c:	89 e5                	mov    %esp,%ebp
c0105c9e:	83 ec 28             	sub    $0x28,%esp
    if(string == NULL || path_buffer == NULL || name_buffer == NULL)    // i don't think this will ever happen, but you have what you have
c0105ca1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0105ca5:	74 0c                	je     c0105cb3 <split_module_string+0x18>
c0105ca7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0105cab:	74 06                	je     c0105cb3 <split_module_string+0x18>
c0105cad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0105cb1:	75 0a                	jne    c0105cbd <split_module_string+0x22>
        return failed;
c0105cb3:	b8 01 00 00 00       	mov    $0x1,%eax
c0105cb8:	e9 6f 01 00 00       	jmp    c0105e2c <split_module_string+0x191>

    int i, j;

    for(i = 0, j = 0; string[i] != '\0'; i++)       // in this loop i count the number of slashes in a string
c0105cbd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0105cc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0105ccb:	eb 17                	jmp    c0105ce4 <split_module_string+0x49>
        if(string[i] == '/')
c0105ccd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105cd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0105cd3:	01 d0                	add    %edx,%eax
c0105cd5:	0f b6 00             	movzbl (%eax),%eax
c0105cd8:	3c 2f                	cmp    $0x2f,%al
c0105cda:	75 04                	jne    c0105ce0 <split_module_string+0x45>
            j++;
c0105cdc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    if(string == NULL || path_buffer == NULL || name_buffer == NULL)    // i don't think this will ever happen, but you have what you have
        return failed;

    int i, j;

    for(i = 0, j = 0; string[i] != '\0'; i++)       // in this loop i count the number of slashes in a string
c0105ce0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0105ce4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105ce7:	8b 45 08             	mov    0x8(%ebp),%eax
c0105cea:	01 d0                	add    %edx,%eax
c0105cec:	0f b6 00             	movzbl (%eax),%eax
c0105cef:	84 c0                	test   %al,%al
c0105cf1:	75 da                	jne    c0105ccd <split_module_string+0x32>
        if(string[i] == '/')
            j++;

    if(j == 0)  // illegal path
c0105cf3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0105cf7:	75 0a                	jne    c0105d03 <split_module_string+0x68>
        return failed;
c0105cf9:	b8 01 00 00 00       	mov    $0x1,%eax
c0105cfe:	e9 29 01 00 00       	jmp    c0105e2c <split_module_string+0x191>

    for(i = 0; j > 0; i++)                          // in this loop i count the number of characters from the beginning to the final slash
c0105d03:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0105d0a:	eb 17                	jmp    c0105d23 <split_module_string+0x88>
        if(string[i] == '/')
c0105d0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105d0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0105d12:	01 d0                	add    %edx,%eax
c0105d14:	0f b6 00             	movzbl (%eax),%eax
c0105d17:	3c 2f                	cmp    $0x2f,%al
c0105d19:	75 04                	jne    c0105d1f <split_module_string+0x84>
            j--;
c0105d1b:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
            j++;

    if(j == 0)  // illegal path
        return failed;

    for(i = 0; j > 0; i++)                          // in this loop i count the number of characters from the beginning to the final slash
c0105d1f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0105d23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0105d27:	7f e3                	jg     c0105d0c <split_module_string+0x71>
        if(string[i] == '/')
            j--;

    (*path_buffer) = (char *)malloc(sizeof(char) * (i + 1));    // the length of the path is the number of characters to the final slash plus one for zero-termination
c0105d29:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105d2c:	83 c0 01             	add    $0x1,%eax
c0105d2f:	89 04 24             	mov    %eax,(%esp)
c0105d32:	e8 0e 62 00 00       	call   c010bf45 <malloc>
c0105d37:	89 c2                	mov    %eax,%edx
c0105d39:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105d3c:	89 10                	mov    %edx,(%eax)

    if((*path_buffer) == NULL)  // if malloc fails (virtually impossible)
c0105d3e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105d41:	8b 00                	mov    (%eax),%eax
c0105d43:	85 c0                	test   %eax,%eax
c0105d45:	75 0a                	jne    c0105d51 <split_module_string+0xb6>
        return failed;
c0105d47:	b8 01 00 00 00       	mov    $0x1,%eax
c0105d4c:	e9 db 00 00 00       	jmp    c0105e2c <split_module_string+0x191>

    memset((*path_buffer), '\0', sizeof(char) * (i + 1));
c0105d51:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0105d54:	83 c0 01             	add    $0x1,%eax
c0105d57:	89 c2                	mov    %eax,%edx
c0105d59:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105d5c:	8b 00                	mov    (%eax),%eax
c0105d5e:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105d62:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105d69:	00 
c0105d6a:	89 04 24             	mov    %eax,(%esp)
c0105d6d:	e8 a7 d6 ff ff       	call   c0103419 <memset>

    (*name_buffer) = (char *)malloc(sizeof(char) * ((strlen(string) - i) + 1));     // the length of the name is the number of characters after the final slash plus one for zero-termination
c0105d72:	8b 45 08             	mov    0x8(%ebp),%eax
c0105d75:	89 04 24             	mov    %eax,(%esp)
c0105d78:	e8 50 d1 ff ff       	call   c0102ecd <strlen>
c0105d7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105d80:	29 d0                	sub    %edx,%eax
c0105d82:	83 c0 01             	add    $0x1,%eax
c0105d85:	89 04 24             	mov    %eax,(%esp)
c0105d88:	e8 b8 61 00 00       	call   c010bf45 <malloc>
c0105d8d:	89 c2                	mov    %eax,%edx
c0105d8f:	8b 45 10             	mov    0x10(%ebp),%eax
c0105d92:	89 10                	mov    %edx,(%eax)

    if((*name_buffer) == NULL)  // if malloc fails (virtually impossible)
c0105d94:	8b 45 10             	mov    0x10(%ebp),%eax
c0105d97:	8b 00                	mov    (%eax),%eax
c0105d99:	85 c0                	test   %eax,%eax
c0105d9b:	75 14                	jne    c0105db1 <split_module_string+0x116>
    {
        free(*path_buffer);     // i have to free the successfully allocated memory (to avoid memory leaks)
c0105d9d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105da0:	8b 00                	mov    (%eax),%eax
c0105da2:	89 04 24             	mov    %eax,(%esp)
c0105da5:	e8 a9 62 00 00       	call   c010c053 <free>
        return failed;
c0105daa:	b8 01 00 00 00       	mov    $0x1,%eax
c0105daf:	eb 7b                	jmp    c0105e2c <split_module_string+0x191>
    }

    memset((*name_buffer), '\0', sizeof(char) * ((strlen(string) - i) + 1));
c0105db1:	8b 45 08             	mov    0x8(%ebp),%eax
c0105db4:	89 04 24             	mov    %eax,(%esp)
c0105db7:	e8 11 d1 ff ff       	call   c0102ecd <strlen>
c0105dbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105dbf:	29 d0                	sub    %edx,%eax
c0105dc1:	8d 50 01             	lea    0x1(%eax),%edx
c0105dc4:	8b 45 10             	mov    0x10(%ebp),%eax
c0105dc7:	8b 00                	mov    (%eax),%eax
c0105dc9:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105dcd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0105dd4:	00 
c0105dd5:	89 04 24             	mov    %eax,(%esp)
c0105dd8:	e8 3c d6 ff ff       	call   c0103419 <memset>

    strncpy((*path_buffer), string, i);                         // copy the two parts of the string in the two other strings
c0105ddd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105de0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105de3:	8b 00                	mov    (%eax),%eax
c0105de5:	89 54 24 08          	mov    %edx,0x8(%esp)
c0105de9:	8b 55 08             	mov    0x8(%ebp),%edx
c0105dec:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105df0:	89 04 24             	mov    %eax,(%esp)
c0105df3:	e8 4d d1 ff ff       	call   c0102f45 <strncpy>
    strncpy((*name_buffer), &string[i], strlen(string) - i);
c0105df8:	8b 45 08             	mov    0x8(%ebp),%eax
c0105dfb:	89 04 24             	mov    %eax,(%esp)
c0105dfe:	e8 ca d0 ff ff       	call   c0102ecd <strlen>
c0105e03:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105e06:	89 c1                	mov    %eax,%ecx
c0105e08:	29 d1                	sub    %edx,%ecx
c0105e0a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105e0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105e10:	01 c2                	add    %eax,%edx
c0105e12:	8b 45 10             	mov    0x10(%ebp),%eax
c0105e15:	8b 00                	mov    (%eax),%eax
c0105e17:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0105e1b:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105e1f:	89 04 24             	mov    %eax,(%esp)
c0105e22:	e8 1e d1 ff ff       	call   c0102f45 <strncpy>

    return success;
c0105e27:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0105e2c:	c9                   	leave  
c0105e2d:	c3                   	ret    

c0105e2e <vfs_create_inode>:
 *               if parent is NULL, the parent for the node is root.
 *
 * @return pointer to the new node
 */
vfs_inode_t* vfs_create_inode(char *name, mode_t mode, vfs_inode_t *parent, uid_t uid, gid_t gid)
{
c0105e2e:	55                   	push   %ebp
c0105e2f:	89 e5                	mov    %esp,%ebp
c0105e31:	83 ec 48             	sub    $0x48,%esp
    static uint32_t nodes = 0;


    vfs_inode_t *inode = malloc(sizeof(vfs_inode_t));
c0105e34:	c7 04 24 4c 00 00 00 	movl   $0x4c,(%esp)
c0105e3b:	e8 05 61 00 00       	call   c010bf45 <malloc>
c0105e40:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(name != NULL)
c0105e43:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0105e47:	74 31                	je     c0105e7a <vfs_create_inode+0x4c>
    {
        inode->name = (char*) malloc(strlen(name)+1);
c0105e49:	8b 45 08             	mov    0x8(%ebp),%eax
c0105e4c:	89 04 24             	mov    %eax,(%esp)
c0105e4f:	e8 79 d0 ff ff       	call   c0102ecd <strlen>
c0105e54:	83 c0 01             	add    $0x1,%eax
c0105e57:	89 04 24             	mov    %eax,(%esp)
c0105e5a:	e8 e6 60 00 00       	call   c010bf45 <malloc>
c0105e5f:	89 c2                	mov    %eax,%edx
c0105e61:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105e64:	89 10                	mov    %edx,(%eax)
        strcpy(inode->name, name);
c0105e66:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105e69:	8b 00                	mov    (%eax),%eax
c0105e6b:	8b 55 08             	mov    0x8(%ebp),%edx
c0105e6e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105e72:	89 04 24             	mov    %eax,(%esp)
c0105e75:	e8 7a d0 ff ff       	call   c0102ef4 <strcpy>
    }

    inode->length = 0;
c0105e7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105e7d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    inode->stat.st_mode = mode;
c0105e84:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105e87:	8b 55 0c             	mov    0xc(%ebp),%edx
c0105e8a:	89 50 0c             	mov    %edx,0xc(%eax)
    inode->stat.st_ino = nodes++;
c0105e8d:	a1 24 90 11 c0       	mov    0xc0119024,%eax
c0105e92:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0105e95:	89 42 10             	mov    %eax,0x10(%edx)
c0105e98:	83 c0 01             	add    $0x1,%eax
c0105e9b:	a3 24 90 11 c0       	mov    %eax,0xc0119024
    inode->stat.st_uid = uid;
c0105ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105ea3:	8b 55 14             	mov    0x14(%ebp),%edx
c0105ea6:	89 50 18             	mov    %edx,0x18(%eax)
    inode->stat.st_gid = gid;
c0105ea9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105eac:	8b 55 18             	mov    0x18(%ebp),%edx
c0105eaf:	89 50 1c             	mov    %edx,0x1c(%eax)
    update_time((struct time*)&inode->stat.st_atime);
c0105eb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105eb5:	83 c0 24             	add    $0x24,%eax
c0105eb8:	89 04 24             	mov    %eax,(%esp)
c0105ebb:	e8 c6 6e 00 00       	call   c010cd86 <update_time>
    update_time((struct time*)&inode->stat.st_mtime);
c0105ec0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105ec3:	83 c0 28             	add    $0x28,%eax
c0105ec6:	89 04 24             	mov    %eax,(%esp)
c0105ec9:	e8 b8 6e 00 00       	call   c010cd86 <update_time>

    if(mode & S_IFLNK)
c0105ece:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105ed1:	83 e0 40             	and    $0x40,%eax
c0105ed4:	85 c0                	test   %eax,%eax
c0105ed6:	74 20                	je     c0105ef8 <vfs_create_inode+0xca>
    {
        inode->type = VFS_LINK;
c0105ed8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105edb:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
        inode->read_buffer = NULL;
c0105ee2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105ee5:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
        inode->write_buffer = NULL;
c0105eec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105eef:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
c0105ef6:	eb 50                	jmp    c0105f48 <vfs_create_inode+0x11a>
    }
    else
    {
        inode->type = VFS_REGULAR;
c0105ef8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105efb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

        block_buffer_info_t *buf = NULL;
c0105f02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        if(S_ISDIR(inode->stat))
c0105f09:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f0c:	8b 40 0c             	mov    0xc(%eax),%eax
c0105f0f:	83 e0 20             	and    $0x20,%eax
c0105f12:	85 c0                	test   %eax,%eax
c0105f14:	74 11                	je     c0105f27 <vfs_create_inode+0xf9>
            buf = block_buffer_create(sizeof(vfs_dentry_t));
c0105f16:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0105f1d:	e8 c2 c5 ff ff       	call   c01024e4 <block_buffer_create>
c0105f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0105f25:	eb 0f                	jmp    c0105f36 <vfs_create_inode+0x108>
        else
            buf = block_buffer_create(0x1000);
c0105f27:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
c0105f2e:	e8 b1 c5 ff ff       	call   c01024e4 <block_buffer_create>
c0105f33:	89 45 f4             	mov    %eax,-0xc(%ebp)

        inode->read_buffer = buf;
c0105f36:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f39:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105f3c:	89 50 3c             	mov    %edx,0x3c(%eax)
        inode->write_buffer = buf;
c0105f3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f42:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0105f45:	89 50 40             	mov    %edx,0x40(%eax)
    }

    // write inode into parents entries
    if(parent != NULL)
c0105f48:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0105f4c:	74 2c                	je     c0105f7a <vfs_create_inode+0x14c>
    {
        inode->parent = parent;
c0105f4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f51:	8b 55 10             	mov    0x10(%ebp),%edx
c0105f54:	89 50 38             	mov    %edx,0x38(%eax)
        vfs_dentry_t *entry = vfs_create_dir_entry(inode);
c0105f57:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f5a:	89 04 24             	mov    %eax,(%esp)
c0105f5d:	e8 55 1d 00 00       	call   c0107cb7 <vfs_create_dir_entry>
c0105f62:	89 45 ec             	mov    %eax,-0x14(%ebp)
        vfs_add_dir_entry(inode->parent, entry);
c0105f65:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f68:	8b 40 38             	mov    0x38(%eax),%eax
c0105f6b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0105f6e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0105f72:	89 04 24             	mov    %eax,(%esp)
c0105f75:	e8 6b 1d 00 00       	call   c0107ce5 <vfs_add_dir_entry>
    }

    // write "." and ".." entries
    if(S_ISDIR(inode->stat))
c0105f7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f7d:	8b 40 0c             	mov    0xc(%eax),%eax
c0105f80:	83 e0 20             	and    $0x20,%eax
c0105f83:	85 c0                	test   %eax,%eax
c0105f85:	74 6e                	je     c0105ff5 <vfs_create_inode+0x1c7>
    {
        vfs_inode_t *current = vfs_create_inode(".", S_IFLNK, inode, 0, 0);
c0105f87:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0105f8e:	00 
c0105f8f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0105f96:	00 
c0105f97:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105f9a:	89 44 24 08          	mov    %eax,0x8(%esp)
c0105f9e:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
c0105fa5:	00 
c0105fa6:	c7 04 24 28 0b 11 c0 	movl   $0xc0110b28,(%esp)
c0105fad:	e8 7c fe ff ff       	call   c0105e2e <vfs_create_inode>
c0105fb2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        current->read_buffer = inode;
c0105fb5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0105fb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0105fbb:	89 50 3c             	mov    %edx,0x3c(%eax)

        vfs_inode_t *par = vfs_create_inode("..", S_IFLNK, inode, 0, 0);
c0105fbe:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0105fc5:	00 
c0105fc6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0105fcd:	00 
c0105fce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0105fd1:	89 44 24 08          	mov    %eax,0x8(%esp)
c0105fd5:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
c0105fdc:	00 
c0105fdd:	c7 04 24 2a 0b 11 c0 	movl   $0xc0110b2a,(%esp)
c0105fe4:	e8 45 fe ff ff       	call   c0105e2e <vfs_create_inode>
c0105fe9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        par->read_buffer = parent;
c0105fec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0105fef:	8b 55 10             	mov    0x10(%ebp),%edx
c0105ff2:	89 50 3c             	mov    %edx,0x3c(%eax)
    }

    return inode;
c0105ff5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0105ff8:	c9                   	leave  
c0105ff9:	c3                   	ret    

c0105ffa <vfs_create_pipe>:

vfs_inode_t *vfs_create_pipe(uid_t uid, gid_t gid)
{
c0105ffa:	55                   	push   %ebp
c0105ffb:	89 e5                	mov    %esp,%ebp
c0105ffd:	83 ec 38             	sub    $0x38,%esp
    vfs_inode_t *inode = vfs_create_inode(NULL, 0, NULL, uid, gid);
c0106000:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106003:	89 44 24 10          	mov    %eax,0x10(%esp)
c0106007:	8b 45 08             	mov    0x8(%ebp),%eax
c010600a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010600e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0106015:	00 
c0106016:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010601d:	00 
c010601e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0106025:	e8 04 fe ff ff       	call   c0105e2e <vfs_create_inode>
c010602a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    inode->event_id = get_new_event_ID();
c010602d:	e8 17 52 00 00       	call   c010b249 <get_new_event_ID>
c0106032:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106035:	89 42 44             	mov    %eax,0x44(%edx)
    inode->handlers = list_create();
c0106038:	e8 3e c9 ff ff       	call   c010297b <list_create>
c010603d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106040:	89 42 48             	mov    %eax,0x48(%edx)

    inode->type = VFS_PIPE;
c0106043:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106046:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)

    return inode;
c010604d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106050:	c9                   	leave  
c0106051:	c3                   	ret    

c0106052 <vfs_write>:
 * @param bytes number of bytes to write
 *
 * @return number of written bytes
 */
int vfs_write(vfs_inode_t *inode, int offset, void *buffer, int bytes)
{
c0106052:	55                   	push   %ebp
c0106053:	89 e5                	mov    %esp,%ebp
c0106055:	83 ec 28             	sub    $0x28,%esp
    GET_INODE(inode);
c0106058:	8b 45 08             	mov    0x8(%ebp),%eax
c010605b:	8b 40 04             	mov    0x4(%eax),%eax
c010605e:	83 f8 03             	cmp    $0x3,%eax
c0106061:	75 09                	jne    c010606c <vfs_write+0x1a>
c0106063:	8b 45 08             	mov    0x8(%ebp),%eax
c0106066:	8b 40 3c             	mov    0x3c(%eax),%eax
c0106069:	89 45 08             	mov    %eax,0x8(%ebp)

    if(inode == NULL || inode->write_buffer == NULL)
c010606c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106070:	74 0a                	je     c010607c <vfs_write+0x2a>
c0106072:	8b 45 08             	mov    0x8(%ebp),%eax
c0106075:	8b 40 40             	mov    0x40(%eax),%eax
c0106078:	85 c0                	test   %eax,%eax
c010607a:	75 16                	jne    c0106092 <vfs_write+0x40>
    {
        printf("trying to write into uninitalized buffer.\n");
c010607c:	c7 04 24 30 0b 11 c0 	movl   $0xc0110b30,(%esp)
c0106083:	e8 17 62 00 00       	call   c010c29f <puts>
        return 0;
c0106088:	b8 00 00 00 00       	mov    $0x0,%eax
c010608d:	e9 8a 00 00 00       	jmp    c010611c <vfs_write+0xca>
    }

    int len = block_buffer_write(inode->write_buffer, offset, (uint8_t*) buffer, bytes);
c0106092:	8b 4d 14             	mov    0x14(%ebp),%ecx
c0106095:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106098:	8b 45 08             	mov    0x8(%ebp),%eax
c010609b:	8b 40 40             	mov    0x40(%eax),%eax
c010609e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c01060a2:	8b 4d 10             	mov    0x10(%ebp),%ecx
c01060a5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c01060a9:	89 54 24 04          	mov    %edx,0x4(%esp)
c01060ad:	89 04 24             	mov    %eax,(%esp)
c01060b0:	e8 38 c5 ff ff       	call   c01025ed <block_buffer_write>
c01060b5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // increase length
    if( (offset + len) > inode->length)
c01060b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01060bb:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060be:	01 d0                	add    %edx,%eax
c01060c0:	89 c2                	mov    %eax,%edx
c01060c2:	8b 45 08             	mov    0x8(%ebp),%eax
c01060c5:	8b 40 08             	mov    0x8(%eax),%eax
c01060c8:	39 c2                	cmp    %eax,%edx
c01060ca:	76 1e                	jbe    c01060ea <vfs_write+0x98>
    {
        inode->length = offset + len;
c01060cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01060cf:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060d2:	01 d0                	add    %edx,%eax
c01060d4:	89 c2                	mov    %eax,%edx
c01060d6:	8b 45 08             	mov    0x8(%ebp),%eax
c01060d9:	89 50 08             	mov    %edx,0x8(%eax)
        inode->stat.st_size = inode->length;
c01060dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01060df:	8b 40 08             	mov    0x8(%eax),%eax
c01060e2:	89 c2                	mov    %eax,%edx
c01060e4:	8b 45 08             	mov    0x8(%ebp),%eax
c01060e7:	89 50 20             	mov    %edx,0x20(%eax)
    }

    // pipes send an event signal
    if(inode->type == VFS_PIPE)
c01060ea:	8b 45 08             	mov    0x8(%ebp),%eax
c01060ed:	8b 40 04             	mov    0x4(%eax),%eax
c01060f0:	83 f8 01             	cmp    $0x1,%eax
c01060f3:	75 24                	jne    c0106119 <vfs_write+0xc7>
    {
        send_event(inode->event_id);
c01060f5:	8b 45 08             	mov    0x8(%ebp),%eax
c01060f8:	8b 40 44             	mov    0x44(%eax),%eax
c01060fb:	89 04 24             	mov    %eax,(%esp)
c01060fe:	e8 a2 4f 00 00       	call   c010b0a5 <send_event>
        inode->event_id = get_new_event_ID();
c0106103:	e8 41 51 00 00       	call   c010b249 <get_new_event_ID>
c0106108:	8b 55 08             	mov    0x8(%ebp),%edx
c010610b:	89 42 44             	mov    %eax,0x44(%edx)

        launch_pipe_handlers(inode);
c010610e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106111:	89 04 24             	mov    %eax,(%esp)
c0106114:	e8 14 f9 ff ff       	call   c0105a2d <launch_pipe_handlers>
    }

    return len;
c0106119:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010611c:	c9                   	leave  
c010611d:	c3                   	ret    

c010611e <vfs_read>:
 * @param offset the offset from the node
 *
 * @return number of bytes
 */
int vfs_read(vfs_inode_t *inode, int offset, void *buffer, int bytes)
{
c010611e:	55                   	push   %ebp
c010611f:	89 e5                	mov    %esp,%ebp
c0106121:	83 ec 28             	sub    $0x28,%esp
    GET_INODE(inode);
c0106124:	8b 45 08             	mov    0x8(%ebp),%eax
c0106127:	8b 40 04             	mov    0x4(%eax),%eax
c010612a:	83 f8 03             	cmp    $0x3,%eax
c010612d:	75 09                	jne    c0106138 <vfs_read+0x1a>
c010612f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106132:	8b 40 3c             	mov    0x3c(%eax),%eax
c0106135:	89 45 08             	mov    %eax,0x8(%ebp)

    if(inode == NULL || inode->read_buffer == NULL)
c0106138:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010613c:	74 0a                	je     c0106148 <vfs_read+0x2a>
c010613e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106141:	8b 40 3c             	mov    0x3c(%eax),%eax
c0106144:	85 c0                	test   %eax,%eax
c0106146:	75 13                	jne    c010615b <vfs_read+0x3d>
    {
        printf("trying to read from uninitalized buffer.\n");
c0106148:	c7 04 24 5c 0b 11 c0 	movl   $0xc0110b5c,(%esp)
c010614f:	e8 4b 61 00 00       	call   c010c29f <puts>
        return 0;
c0106154:	b8 00 00 00 00       	mov    $0x0,%eax
c0106159:	eb 4f                	jmp    c01061aa <vfs_read+0x8c>
    }

    int b = bytes;
c010615b:	8b 45 14             	mov    0x14(%ebp),%eax
c010615e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if( (offset + bytes) > inode->length)
c0106161:	8b 45 14             	mov    0x14(%ebp),%eax
c0106164:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106167:	01 d0                	add    %edx,%eax
c0106169:	89 c2                	mov    %eax,%edx
c010616b:	8b 45 08             	mov    0x8(%ebp),%eax
c010616e:	8b 40 08             	mov    0x8(%eax),%eax
c0106171:	39 c2                	cmp    %eax,%edx
c0106173:	76 12                	jbe    c0106187 <vfs_read+0x69>
        b = inode->length - offset;
c0106175:	8b 45 08             	mov    0x8(%ebp),%eax
c0106178:	8b 50 08             	mov    0x8(%eax),%edx
c010617b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010617e:	89 d1                	mov    %edx,%ecx
c0106180:	29 c1                	sub    %eax,%ecx
c0106182:	89 c8                	mov    %ecx,%eax
c0106184:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return block_buffer_read(inode->read_buffer, offset, (uint8_t*) buffer, b);
c0106187:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010618a:	8b 55 0c             	mov    0xc(%ebp),%edx
c010618d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106190:	8b 40 3c             	mov    0x3c(%eax),%eax
c0106193:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0106197:	8b 4d 10             	mov    0x10(%ebp),%ecx
c010619a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010619e:	89 54 24 04          	mov    %edx,0x4(%esp)
c01061a2:	89 04 24             	mov    %eax,(%esp)
c01061a5:	e8 ed c4 ff ff       	call   c0102697 <block_buffer_read>
}
c01061aa:	c9                   	leave  
c01061ab:	c3                   	ret    

c01061ac <vfs_access>:
 * @param modus access to check
 *
 * @return
 */
int vfs_access(vfs_inode_t *node, mode_t modus, uid_t uid, gid_t gid)
{
c01061ac:	55                   	push   %ebp
c01061ad:	89 e5                	mov    %esp,%ebp
    GET_INODE(node);
c01061af:	8b 45 08             	mov    0x8(%ebp),%eax
c01061b2:	8b 40 04             	mov    0x4(%eax),%eax
c01061b5:	83 f8 03             	cmp    $0x3,%eax
c01061b8:	75 09                	jne    c01061c3 <vfs_access+0x17>
c01061ba:	8b 45 08             	mov    0x8(%ebp),%eax
c01061bd:	8b 40 3c             	mov    0x3c(%eax),%eax
c01061c0:	89 45 08             	mov    %eax,0x8(%ebp)

    if (node->stat.st_uid == uid)
c01061c3:	8b 45 08             	mov    0x8(%ebp),%eax
c01061c6:	8b 40 18             	mov    0x18(%eax),%eax
c01061c9:	3b 45 10             	cmp    0x10(%ebp),%eax
c01061cc:	75 71                	jne    c010623f <vfs_access+0x93>
    {
        if ((modus & R_OK) &&
c01061ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c01061d1:	83 e0 01             	and    $0x1,%eax
c01061d4:	85 c0                	test   %eax,%eax
c01061d6:	74 19                	je     c01061f1 <vfs_access+0x45>
                !(node->stat.st_mode & S_IRUSR))
c01061d8:	8b 45 08             	mov    0x8(%ebp),%eax
c01061db:	8b 40 0c             	mov    0xc(%eax),%eax
c01061de:	25 00 01 00 00       	and    $0x100,%eax
{
    GET_INODE(node);

    if (node->stat.st_uid == uid)
    {
        if ((modus & R_OK) &&
c01061e3:	85 c0                	test   %eax,%eax
c01061e5:	75 0a                	jne    c01061f1 <vfs_access+0x45>
                !(node->stat.st_mode & S_IRUSR))
            return -1;
c01061e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01061ec:	e9 24 01 00 00       	jmp    c0106315 <vfs_access+0x169>
        if ((modus & W_OK) &&
c01061f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01061f4:	83 e0 02             	and    $0x2,%eax
c01061f7:	85 c0                	test   %eax,%eax
c01061f9:	74 19                	je     c0106214 <vfs_access+0x68>
                !(node->stat.st_mode & S_IWUSR))
c01061fb:	8b 45 08             	mov    0x8(%ebp),%eax
c01061fe:	8b 40 0c             	mov    0xc(%eax),%eax
c0106201:	25 00 02 00 00       	and    $0x200,%eax
    if (node->stat.st_uid == uid)
    {
        if ((modus & R_OK) &&
                !(node->stat.st_mode & S_IRUSR))
            return -1;
        if ((modus & W_OK) &&
c0106206:	85 c0                	test   %eax,%eax
c0106208:	75 0a                	jne    c0106214 <vfs_access+0x68>
                !(node->stat.st_mode & S_IWUSR))
            return -1;
c010620a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010620f:	e9 01 01 00 00       	jmp    c0106315 <vfs_access+0x169>
        if ((modus & X_OK) &&
c0106214:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106217:	83 e0 04             	and    $0x4,%eax
c010621a:	85 c0                	test   %eax,%eax
c010621c:	0f 84 ee 00 00 00    	je     c0106310 <vfs_access+0x164>
                !(node->stat.st_mode & S_IXUSR))
c0106222:	8b 45 08             	mov    0x8(%ebp),%eax
c0106225:	8b 40 0c             	mov    0xc(%eax),%eax
c0106228:	25 00 04 00 00       	and    $0x400,%eax
                !(node->stat.st_mode & S_IRUSR))
            return -1;
        if ((modus & W_OK) &&
                !(node->stat.st_mode & S_IWUSR))
            return -1;
        if ((modus & X_OK) &&
c010622d:	85 c0                	test   %eax,%eax
c010622f:	0f 85 db 00 00 00    	jne    c0106310 <vfs_access+0x164>
                !(node->stat.st_mode & S_IXUSR))
            return -1;
c0106235:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010623a:	e9 d6 00 00 00       	jmp    c0106315 <vfs_access+0x169>
    }
    else if (node->stat.st_gid == gid)
c010623f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106242:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106245:	3b 45 14             	cmp    0x14(%ebp),%eax
c0106248:	75 66                	jne    c01062b0 <vfs_access+0x104>
    {
        if ((modus & R_OK) &&
c010624a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010624d:	83 e0 01             	and    $0x1,%eax
c0106250:	85 c0                	test   %eax,%eax
c0106252:	74 19                	je     c010626d <vfs_access+0xc1>
                !(node->stat.st_mode & S_IRGRP))
c0106254:	8b 45 08             	mov    0x8(%ebp),%eax
c0106257:	8b 40 0c             	mov    0xc(%eax),%eax
c010625a:	25 00 10 00 00       	and    $0x1000,%eax
                !(node->stat.st_mode & S_IXUSR))
            return -1;
    }
    else if (node->stat.st_gid == gid)
    {
        if ((modus & R_OK) &&
c010625f:	85 c0                	test   %eax,%eax
c0106261:	75 0a                	jne    c010626d <vfs_access+0xc1>
                !(node->stat.st_mode & S_IRGRP))
            return -1;
c0106263:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106268:	e9 a8 00 00 00       	jmp    c0106315 <vfs_access+0x169>
        if ((modus & W_OK) &&
c010626d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106270:	83 e0 02             	and    $0x2,%eax
c0106273:	85 c0                	test   %eax,%eax
c0106275:	74 19                	je     c0106290 <vfs_access+0xe4>
                !(node->stat.st_mode & S_IWGRP))
c0106277:	8b 45 08             	mov    0x8(%ebp),%eax
c010627a:	8b 40 0c             	mov    0xc(%eax),%eax
c010627d:	25 00 20 00 00       	and    $0x2000,%eax
    else if (node->stat.st_gid == gid)
    {
        if ((modus & R_OK) &&
                !(node->stat.st_mode & S_IRGRP))
            return -1;
        if ((modus & W_OK) &&
c0106282:	85 c0                	test   %eax,%eax
c0106284:	75 0a                	jne    c0106290 <vfs_access+0xe4>
                !(node->stat.st_mode & S_IWGRP))
            return -1;
c0106286:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010628b:	e9 85 00 00 00       	jmp    c0106315 <vfs_access+0x169>
        if ((modus & X_OK) &&
c0106290:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106293:	83 e0 04             	and    $0x4,%eax
c0106296:	85 c0                	test   %eax,%eax
c0106298:	74 76                	je     c0106310 <vfs_access+0x164>
                !(node->stat.st_mode & S_IXGRP))
c010629a:	8b 45 08             	mov    0x8(%ebp),%eax
c010629d:	8b 40 0c             	mov    0xc(%eax),%eax
c01062a0:	25 00 40 00 00       	and    $0x4000,%eax
                !(node->stat.st_mode & S_IRGRP))
            return -1;
        if ((modus & W_OK) &&
                !(node->stat.st_mode & S_IWGRP))
            return -1;
        if ((modus & X_OK) &&
c01062a5:	85 c0                	test   %eax,%eax
c01062a7:	75 67                	jne    c0106310 <vfs_access+0x164>
                !(node->stat.st_mode & S_IXGRP))
            return -1;
c01062a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01062ae:	eb 65                	jmp    c0106315 <vfs_access+0x169>
    }
    else
    {
        if ((modus & R_OK) &&
c01062b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01062b3:	83 e0 01             	and    $0x1,%eax
c01062b6:	85 c0                	test   %eax,%eax
c01062b8:	74 16                	je     c01062d0 <vfs_access+0x124>
                !(node->stat.st_mode & S_IROTH))
c01062ba:	8b 45 08             	mov    0x8(%ebp),%eax
c01062bd:	8b 40 0c             	mov    0xc(%eax),%eax
c01062c0:	25 00 00 01 00       	and    $0x10000,%eax
                !(node->stat.st_mode & S_IXGRP))
            return -1;
    }
    else
    {
        if ((modus & R_OK) &&
c01062c5:	85 c0                	test   %eax,%eax
c01062c7:	75 07                	jne    c01062d0 <vfs_access+0x124>
                !(node->stat.st_mode & S_IROTH))
            return -1;
c01062c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01062ce:	eb 45                	jmp    c0106315 <vfs_access+0x169>
        if ((modus & W_OK) &&
c01062d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01062d3:	83 e0 02             	and    $0x2,%eax
c01062d6:	85 c0                	test   %eax,%eax
c01062d8:	74 16                	je     c01062f0 <vfs_access+0x144>
                !(node->stat.st_mode & S_IWOTH))
c01062da:	8b 45 08             	mov    0x8(%ebp),%eax
c01062dd:	8b 40 0c             	mov    0xc(%eax),%eax
c01062e0:	25 00 00 02 00       	and    $0x20000,%eax
    else
    {
        if ((modus & R_OK) &&
                !(node->stat.st_mode & S_IROTH))
            return -1;
        if ((modus & W_OK) &&
c01062e5:	85 c0                	test   %eax,%eax
c01062e7:	75 07                	jne    c01062f0 <vfs_access+0x144>
                !(node->stat.st_mode & S_IWOTH))
            return -1;
c01062e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01062ee:	eb 25                	jmp    c0106315 <vfs_access+0x169>
        if ((modus & X_OK) &&
c01062f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01062f3:	83 e0 04             	and    $0x4,%eax
c01062f6:	85 c0                	test   %eax,%eax
c01062f8:	74 16                	je     c0106310 <vfs_access+0x164>
                !(node->stat.st_mode & S_IXOTH))
c01062fa:	8b 45 08             	mov    0x8(%ebp),%eax
c01062fd:	8b 40 0c             	mov    0xc(%eax),%eax
c0106300:	25 00 00 04 00       	and    $0x40000,%eax
                !(node->stat.st_mode & S_IROTH))
            return -1;
        if ((modus & W_OK) &&
                !(node->stat.st_mode & S_IWOTH))
            return -1;
        if ((modus & X_OK) &&
c0106305:	85 c0                	test   %eax,%eax
c0106307:	75 07                	jne    c0106310 <vfs_access+0x164>
                !(node->stat.st_mode & S_IXOTH))
            return -1;
c0106309:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010630e:	eb 05                	jmp    c0106315 <vfs_access+0x169>
    }

    return 0;
c0106310:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106315:	5d                   	pop    %ebp
c0106316:	c3                   	ret    

c0106317 <sys_link>:
extern struct thread_state *current_thread;
extern vfs_inode_t *root;


void sys_link(struct cpu_state **cpu)
{
c0106317:	55                   	push   %ebp
c0106318:	89 e5                	mov    %esp,%ebp
c010631a:	83 ec 48             	sub    $0x48,%esp
    char *src_path = (char *)(*cpu)->CPU_ARG1;
c010631d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106320:	8b 00                	mov    (%eax),%eax
c0106322:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106325:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char *dest_path = (char *)(*cpu)->CPU_ARG2;
c0106328:	8b 45 08             	mov    0x8(%ebp),%eax
c010632b:	8b 00                	mov    (%eax),%eax
c010632d:	8b 40 24             	mov    0x24(%eax),%eax
c0106330:	89 45 f0             	mov    %eax,-0x10(%ebp)

    vfs_inode_t *src_inode = vfs_lookup_path(src_path);
c0106333:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106336:	89 04 24             	mov    %eax,(%esp)
c0106339:	e8 63 27 00 00       	call   c0108aa1 <vfs_lookup_path>
c010633e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // FIXME: only works in root
    vfs_inode_t *dest_parent = root; // FIXME TODO
c0106341:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c0106346:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(src_inode != NULL && dest_parent != NULL)
c0106349:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010634d:	0f 84 06 01 00 00    	je     c0106459 <sys_link+0x142>
c0106353:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106357:	0f 84 fc 00 00 00    	je     c0106459 <sys_link+0x142>
    {
        if(vfs_access(src_inode, R_OK, current_thread->process->uid, current_thread->process->gid == 0) &&
c010635d:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106362:	8b 00                	mov    (%eax),%eax
c0106364:	8b 40 08             	mov    0x8(%eax),%eax
c0106367:	85 c0                	test   %eax,%eax
c0106369:	0f 94 c0             	sete   %al
c010636c:	0f b6 d0             	movzbl %al,%edx
c010636f:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106374:	8b 00                	mov    (%eax),%eax
c0106376:	8b 40 04             	mov    0x4(%eax),%eax
c0106379:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010637d:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106381:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0106388:	00 
c0106389:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010638c:	89 04 24             	mov    %eax,(%esp)
c010638f:	e8 18 fe ff ff       	call   c01061ac <vfs_access>
c0106394:	85 c0                	test   %eax,%eax
c0106396:	0f 84 ad 00 00 00    	je     c0106449 <sys_link+0x132>
                vfs_access(dest_parent, W_OK, current_thread->process->uid, current_thread->process->gid == 0))
c010639c:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01063a1:	8b 00                	mov    (%eax),%eax
c01063a3:	8b 40 08             	mov    0x8(%eax),%eax
c01063a6:	85 c0                	test   %eax,%eax
c01063a8:	0f 94 c0             	sete   %al
c01063ab:	0f b6 d0             	movzbl %al,%edx
c01063ae:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01063b3:	8b 00                	mov    (%eax),%eax
c01063b5:	8b 40 04             	mov    0x4(%eax),%eax
c01063b8:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01063bc:	89 44 24 08          	mov    %eax,0x8(%esp)
c01063c0:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c01063c7:	00 
c01063c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01063cb:	89 04 24             	mov    %eax,(%esp)
c01063ce:	e8 d9 fd ff ff       	call   c01061ac <vfs_access>
    // FIXME: only works in root
    vfs_inode_t *dest_parent = root; // FIXME TODO

    if(src_inode != NULL && dest_parent != NULL)
    {
        if(vfs_access(src_inode, R_OK, current_thread->process->uid, current_thread->process->gid == 0) &&
c01063d3:	85 c0                	test   %eax,%eax
c01063d5:	74 72                	je     c0106449 <sys_link+0x132>
                vfs_access(dest_parent, W_OK, current_thread->process->uid, current_thread->process->gid == 0))
        {
            vfs_inode_t *dest_inode = vfs_create_inode(dest_path, src_inode->stat.st_mode | S_IFLNK, dest_parent, current_thread->process->uid, current_thread->process->gid);
c01063d7:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01063dc:	8b 00                	mov    (%eax),%eax
c01063de:	8b 50 08             	mov    0x8(%eax),%edx
c01063e1:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01063e6:	8b 00                	mov    (%eax),%eax
c01063e8:	8b 40 04             	mov    0x4(%eax),%eax
c01063eb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c01063ee:	8b 49 0c             	mov    0xc(%ecx),%ecx
c01063f1:	83 c9 40             	or     $0x40,%ecx
c01063f4:	89 54 24 10          	mov    %edx,0x10(%esp)
c01063f8:	89 44 24 0c          	mov    %eax,0xc(%esp)
c01063fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01063ff:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106403:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c0106407:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010640a:	89 04 24             	mov    %eax,(%esp)
c010640d:	e8 1c fa ff ff       	call   c0105e2e <vfs_create_inode>
c0106412:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            if(dest_inode != NULL)
c0106415:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0106419:	74 20                	je     c010643b <sys_link+0x124>
            {
                dest_inode->read_buffer = (void *)dest_inode;
c010641b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010641e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106421:	89 50 3c             	mov    %edx,0x3c(%eax)
                dest_inode->write_buffer = (void *)dest_inode;
c0106424:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106427:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010642a:	89 50 40             	mov    %edx,0x40(%eax)

                (*cpu)->CPU_ARG0 = _SUCCESS;
c010642d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106430:	8b 00                	mov    (%eax),%eax
c0106432:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)

    if(src_inode != NULL && dest_parent != NULL)
    {
        if(vfs_access(src_inode, R_OK, current_thread->process->uid, current_thread->process->gid == 0) &&
                vfs_access(dest_parent, W_OK, current_thread->process->uid, current_thread->process->gid == 0))
        {
c0106439:	eb 1c                	jmp    c0106457 <sys_link+0x140>

                (*cpu)->CPU_ARG0 = _SUCCESS;
            }
            else
            {
                (*cpu)->CPU_ARG0 = _FAILURE;
c010643b:	8b 45 08             	mov    0x8(%ebp),%eax
c010643e:	8b 00                	mov    (%eax),%eax
c0106440:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)

    if(src_inode != NULL && dest_parent != NULL)
    {
        if(vfs_access(src_inode, R_OK, current_thread->process->uid, current_thread->process->gid == 0) &&
                vfs_access(dest_parent, W_OK, current_thread->process->uid, current_thread->process->gid == 0))
        {
c0106447:	eb 0e                	jmp    c0106457 <sys_link+0x140>
                (*cpu)->CPU_ARG0 = _FAILURE;
            }
        }
        else
        {
            (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0106449:	8b 45 08             	mov    0x8(%ebp),%eax
c010644c:	8b 00                	mov    (%eax),%eax
c010644e:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
    // FIXME: only works in root
    vfs_inode_t *dest_parent = root; // FIXME TODO

    if(src_inode != NULL && dest_parent != NULL)
    {
        if(vfs_access(src_inode, R_OK, current_thread->process->uid, current_thread->process->gid == 0) &&
c0106455:	eb 0e                	jmp    c0106465 <sys_link+0x14e>
c0106457:	eb 0c                	jmp    c0106465 <sys_link+0x14e>
            (*cpu)->CPU_ARG0 = _NO_PERMISSION;
        }
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0106459:	8b 45 08             	mov    0x8(%ebp),%eax
c010645c:	8b 00                	mov    (%eax),%eax
c010645e:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c0106465:	c9                   	leave  
c0106466:	c3                   	ret    

c0106467 <sys_unlink>:

void sys_unlink(struct cpu_state **cpu)
{
c0106467:	55                   	push   %ebp
c0106468:	89 e5                	mov    %esp,%ebp
c010646a:	83 ec 28             	sub    $0x28,%esp
    char *path = (char *)(*cpu)->CPU_ARG1;
c010646d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106470:	8b 00                	mov    (%eax),%eax
c0106472:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106475:	89 45 f4             	mov    %eax,-0xc(%ebp)

    vfs_inode_t *link = vfs_lookup_path(path);
c0106478:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010647b:	89 04 24             	mov    %eax,(%esp)
c010647e:	e8 1e 26 00 00       	call   c0108aa1 <vfs_lookup_path>
c0106483:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(link != NULL)
c0106486:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010648a:	0f 84 8a 00 00 00    	je     c010651a <sys_unlink+0xb3>
    {
        if(vfs_access(link, W_OK, current_thread->process->uid, current_thread->process->gid == 0))
c0106490:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106495:	8b 00                	mov    (%eax),%eax
c0106497:	8b 40 08             	mov    0x8(%eax),%eax
c010649a:	85 c0                	test   %eax,%eax
c010649c:	0f 94 c0             	sete   %al
c010649f:	0f b6 d0             	movzbl %al,%edx
c01064a2:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01064a7:	8b 00                	mov    (%eax),%eax
c01064a9:	8b 40 04             	mov    0x4(%eax),%eax
c01064ac:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01064b0:	89 44 24 08          	mov    %eax,0x8(%esp)
c01064b4:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c01064bb:	00 
c01064bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064bf:	89 04 24             	mov    %eax,(%esp)
c01064c2:	e8 e5 fc ff ff       	call   c01061ac <vfs_access>
c01064c7:	85 c0                	test   %eax,%eax
c01064c9:	74 41                	je     c010650c <sys_unlink+0xa5>
        {
            link->read_buffer = NULL;
c01064cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064ce:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
            link->write_buffer = NULL;
c01064d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064d8:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
            link->type = VFS_REGULAR;
c01064df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064e2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

            vfs_remove_dir_entry(link->parent, link);
c01064e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064ec:	8b 40 38             	mov    0x38(%eax),%eax
c01064ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01064f2:	89 54 24 04          	mov    %edx,0x4(%esp)
c01064f6:	89 04 24             	mov    %eax,(%esp)
c01064f9:	e8 3e 18 00 00       	call   c0107d3c <vfs_remove_dir_entry>
            (*cpu)->CPU_ARG0 = _SUCCESS;
c01064fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0106501:	8b 00                	mov    (%eax),%eax
c0106503:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c010650a:	eb 1a                	jmp    c0106526 <sys_unlink+0xbf>
        }
        else
        {
            (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c010650c:	8b 45 08             	mov    0x8(%ebp),%eax
c010650f:	8b 00                	mov    (%eax),%eax
c0106511:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
c0106518:	eb 0c                	jmp    c0106526 <sys_unlink+0xbf>
        }
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c010651a:	8b 45 08             	mov    0x8(%ebp),%eax
c010651d:	8b 00                	mov    (%eax),%eax
c010651f:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c0106526:	c9                   	leave  
c0106527:	c3                   	ret    

c0106528 <get_socket_request>:
extern struct thread_state *current_thread;
extern vfs_inode_t *root;


socket_request_t *get_socket_request(struct process_state *proc, int id)
{
c0106528:	55                   	push   %ebp
c0106529:	89 e5                	mov    %esp,%ebp
c010652b:	83 ec 18             	sub    $0x18,%esp
    return (socket_request_t*) list_get_by_int(proc->socket_requests, offsetof(socket_request_t, id), id);
c010652e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106531:	8b 40 20             	mov    0x20(%eax),%eax
c0106534:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106537:	89 54 24 08          	mov    %edx,0x8(%esp)
c010653b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106542:	00 
c0106543:	89 04 24             	mov    %eax,(%esp)
c0106546:	e8 7c c6 ff ff       	call   c0102bc7 <list_get_by_int>
}
c010654b:	c9                   	leave  
c010654c:	c3                   	ret    

c010654d <port_accepted>:

void port_accepted(struct cpu_state **cpu)
{
c010654d:	55                   	push   %ebp
c010654e:	89 e5                	mov    %esp,%ebp
c0106550:	83 ec 28             	sub    $0x28,%esp
    socket_request_t *req = (socket_request_t*) (*cpu)->CPU_ARG0;
c0106553:	8b 45 08             	mov    0x8(%ebp),%eax
c0106556:	8b 00                	mov    (%eax),%eax
c0106558:	8b 40 28             	mov    0x28(%eax),%eax
c010655b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    struct fd *desc = create_fd(current_thread->process);
c010655e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106563:	8b 00                	mov    (%eax),%eax
c0106565:	89 04 24             	mov    %eax,(%esp)
c0106568:	e8 a7 04 00 00       	call   c0106a14 <create_fd>
c010656d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    desc->mode = 0;
c0106570:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106573:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    desc->flags = O_RDWR;
c010657a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010657d:	c7 40 08 04 00 00 00 	movl   $0x4,0x8(%eax)
    desc->permission = VFS_PERMISSION_READ | VFS_PERMISSION_WRITE;
c0106584:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106587:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
    desc->read_inode = req->inodes[0];
c010658e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106591:	8b 50 10             	mov    0x10(%eax),%edx
c0106594:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106597:	89 50 10             	mov    %edx,0x10(%eax)
    desc->write_inode = req->inodes[1];
c010659a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010659d:	8b 50 14             	mov    0x14(%eax),%edx
c01065a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01065a3:	89 50 14             	mov    %edx,0x14(%eax)

    (*cpu)->CPU_ARG0 = desc->id;
c01065a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01065a9:	8b 00                	mov    (%eax),%eax
c01065ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01065ae:	8b 12                	mov    (%edx),%edx
c01065b0:	89 50 28             	mov    %edx,0x28(%eax)
}
c01065b3:	c9                   	leave  
c01065b4:	c3                   	ret    

c01065b5 <usys_connect>:

void usys_connect(struct cpu_state **cpu)
{
c01065b5:	55                   	push   %ebp
c01065b6:	89 e5                	mov    %esp,%ebp
c01065b8:	83 ec 28             	sub    $0x28,%esp
    static int req_id_counter = 1;

    int pid = (int) (*cpu)->CPU_ARG1;
c01065bb:	8b 45 08             	mov    0x8(%ebp),%eax
c01065be:	8b 00                	mov    (%eax),%eax
c01065c0:	8b 40 1c             	mov    0x1c(%eax),%eax
c01065c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char *port = (char *) (*cpu)->CPU_ARG2;
c01065c6:	8b 45 08             	mov    0x8(%ebp),%eax
c01065c9:	8b 00                	mov    (%eax),%eax
c01065cb:	8b 40 24             	mov    0x24(%eax),%eax
c01065ce:	89 45 f0             	mov    %eax,-0x10(%ebp)

    struct process_state *proc = process_find(pid);
c01065d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01065d4:	89 04 24             	mov    %eax,(%esp)
c01065d7:	e8 4a e3 ff ff       	call   c0104926 <process_find>
c01065dc:	89 45 ec             	mov    %eax,-0x14(%ebp)

    socket_request_t *req = (socket_request_t*) malloc(sizeof(socket_request_t));
c01065df:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
c01065e6:	e8 5a 59 00 00       	call   c010bf45 <malloc>
c01065eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    req->pid = current_thread->process->pid;
c01065ee:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01065f3:	8b 00                	mov    (%eax),%eax
c01065f5:	8b 00                	mov    (%eax),%eax
c01065f7:	89 c2                	mov    %eax,%edx
c01065f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01065fc:	89 50 04             	mov    %edx,0x4(%eax)
    req->port = malloc(strlen(port)+1);
c01065ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106602:	89 04 24             	mov    %eax,(%esp)
c0106605:	e8 c3 c8 ff ff       	call   c0102ecd <strlen>
c010660a:	83 c0 01             	add    $0x1,%eax
c010660d:	89 04 24             	mov    %eax,(%esp)
c0106610:	e8 30 59 00 00       	call   c010bf45 <malloc>
c0106615:	89 c2                	mov    %eax,%edx
c0106617:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010661a:	89 50 08             	mov    %edx,0x8(%eax)
    strcpy(req->port,port);
c010661d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106620:	8b 40 08             	mov    0x8(%eax),%eax
c0106623:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0106626:	89 54 24 04          	mov    %edx,0x4(%esp)
c010662a:	89 04 24             	mov    %eax,(%esp)
c010662d:	e8 c2 c8 ff ff       	call   c0102ef4 <strcpy>
    req->id = req_id_counter++;
c0106632:	a1 08 20 11 c0       	mov    0xc0112008,%eax
c0106637:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010663a:	89 02                	mov    %eax,(%edx)
c010663c:	83 c0 01             	add    $0x1,%eax
c010663f:	a3 08 20 11 c0       	mov    %eax,0xc0112008
    req->event_id = add_event_trigger(0, current_thread, port_accepted);
c0106644:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106649:	c7 44 24 08 4d 65 10 	movl   $0xc010654d,0x8(%esp)
c0106650:	c0 
c0106651:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106655:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010665c:	e8 ff 4b 00 00       	call   c010b260 <add_event_trigger>
c0106661:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0106664:	89 42 0c             	mov    %eax,0xc(%edx)

    list_push_back(proc->socket_requests, req);
c0106667:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010666a:	8b 40 20             	mov    0x20(%eax),%eax
c010666d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0106670:	89 54 24 04          	mov    %edx,0x4(%esp)
c0106674:	89 04 24             	mov    %eax,(%esp)
c0106677:	e8 e3 c3 ff ff       	call   c0102a5f <list_push_back>
    (*cpu)->CPU_ARG0 = (uint32_t) req;
c010667c:	8b 45 08             	mov    0x8(%ebp),%eax
c010667f:	8b 00                	mov    (%eax),%eax
c0106681:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0106684:	89 50 28             	mov    %edx,0x28(%eax)

    thread_suspend(current_thread);
c0106687:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010668c:	89 04 24             	mov    %eax,(%esp)
c010668f:	e8 f2 ef ff ff       	call   c0105686 <thread_suspend>
    *cpu = (struct cpu_state *)task_schedule(*cpu);
c0106694:	8b 45 08             	mov    0x8(%ebp),%eax
c0106697:	8b 00                	mov    (%eax),%eax
c0106699:	89 04 24             	mov    %eax,(%esp)
c010669c:	e8 c5 e4 ff ff       	call   c0104b66 <task_schedule>
c01066a1:	8b 55 08             	mov    0x8(%ebp),%edx
c01066a4:	89 02                	mov    %eax,(%edx)

    send_event(proc->socket_event_id);
c01066a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01066a9:	8b 40 24             	mov    0x24(%eax),%eax
c01066ac:	89 04 24             	mov    %eax,(%esp)
c01066af:	e8 f1 49 00 00       	call   c010b0a5 <send_event>
}
c01066b4:	c9                   	leave  
c01066b5:	c3                   	ret    

c01066b6 <usys_readport>:

void usys_readport(struct cpu_state **cpu)
{
c01066b6:	55                   	push   %ebp
c01066b7:	89 e5                	mov    %esp,%ebp
c01066b9:	53                   	push   %ebx
c01066ba:	83 ec 24             	sub    $0x24,%esp
    char *port = (char *) (*cpu)->CPU_ARG1;
c01066bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01066c0:	8b 00                	mov    (%eax),%eax
c01066c2:	8b 40 1c             	mov    0x1c(%eax),%eax
c01066c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(! list_is_empty(current_thread->process->socket_requests))
c01066c8:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01066cd:	8b 00                	mov    (%eax),%eax
c01066cf:	8b 40 20             	mov    0x20(%eax),%eax
c01066d2:	89 04 24             	mov    %eax,(%esp)
c01066d5:	e8 d0 c5 ff ff       	call   c0102caa <list_is_empty>
c01066da:	85 c0                	test   %eax,%eax
c01066dc:	0f 85 af 00 00 00    	jne    c0106791 <usys_readport+0xdb>
    {
        iterator_t i = iterator_create(current_thread->process->socket_requests);
c01066e2:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01066e7:	8b 00                	mov    (%eax),%eax
c01066e9:	8b 50 20             	mov    0x20(%eax),%edx
c01066ec:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01066ef:	89 54 24 04          	mov    %edx,0x4(%esp)
c01066f3:	89 04 24             	mov    %eax,(%esp)
c01066f6:	e8 f0 c5 ff ff       	call   c0102ceb <iterator_create>
c01066fb:	83 ec 04             	sub    $0x4,%esp
		list_set_first(&i);
c01066fe:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0106701:	89 04 24             	mov    %eax,(%esp)
c0106704:	e8 12 c7 ff ff       	call   c0102e1b <list_set_first>

        socket_request_t *req;
        while(!list_is_last(&i) && !list_is_empty(current_thread->process->socket_requests))
c0106709:	eb 19                	jmp    c0106724 <usys_readport+0x6e>
        {
            req = (socket_request_t*) list_get_current(&i);
c010670b:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010670e:	89 04 24             	mov    %eax,(%esp)
c0106711:	e8 9e c6 ff ff       	call   c0102db4 <list_get_current>
c0106716:	89 45 f0             	mov    %eax,-0x10(%ebp)
            //if(strcmp(req->port,port)== 0)
            //    break;

			list_next(&i);
c0106719:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010671c:	89 04 24             	mov    %eax,(%esp)
c010671f:	e8 b5 c6 ff ff       	call   c0102dd9 <list_next>
    {
        iterator_t i = iterator_create(current_thread->process->socket_requests);
		list_set_first(&i);

        socket_request_t *req;
        while(!list_is_last(&i) && !list_is_empty(current_thread->process->socket_requests))
c0106724:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0106727:	89 04 24             	mov    %eax,(%esp)
c010672a:	e8 d1 c6 ff ff       	call   c0102e00 <list_is_last>
c010672f:	85 c0                	test   %eax,%eax
c0106731:	75 16                	jne    c0106749 <usys_readport+0x93>
c0106733:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106738:	8b 00                	mov    (%eax),%eax
c010673a:	8b 40 20             	mov    0x20(%eax),%eax
c010673d:	89 04 24             	mov    %eax,(%esp)
c0106740:	e8 65 c5 ff ff       	call   c0102caa <list_is_empty>
c0106745:	85 c0                	test   %eax,%eax
c0106747:	74 c2                	je     c010670b <usys_readport+0x55>
        //{    
        //    (*cpu)->CPU_ARG0 = req->id;
        //}
        //else
        //{
            current_thread->process->socket_event_id = add_event_trigger(0, current_thread, usys_readport);
c0106749:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010674e:	8b 18                	mov    (%eax),%ebx
c0106750:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106755:	c7 44 24 08 b6 66 10 	movl   $0xc01066b6,0x8(%esp)
c010675c:	c0 
c010675d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106761:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0106768:	e8 f3 4a 00 00       	call   c010b260 <add_event_trigger>
c010676d:	89 43 24             	mov    %eax,0x24(%ebx)
            thread_suspend(current_thread);
c0106770:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106775:	89 04 24             	mov    %eax,(%esp)
c0106778:	e8 09 ef ff ff       	call   c0105686 <thread_suspend>
            *cpu = (struct cpu_state *)task_schedule(*cpu);
c010677d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106780:	8b 00                	mov    (%eax),%eax
c0106782:	89 04 24             	mov    %eax,(%esp)
c0106785:	e8 dc e3 ff ff       	call   c0104b66 <task_schedule>
c010678a:	8b 55 08             	mov    0x8(%ebp),%edx
c010678d:	89 02                	mov    %eax,(%edx)
c010678f:	eb 46                	jmp    c01067d7 <usys_readport+0x121>
        //}
    }
    else
    {
        current_thread->process->socket_event_id = add_event_trigger(0, current_thread, usys_readport);
c0106791:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106796:	8b 18                	mov    (%eax),%ebx
c0106798:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010679d:	c7 44 24 08 b6 66 10 	movl   $0xc01066b6,0x8(%esp)
c01067a4:	c0 
c01067a5:	89 44 24 04          	mov    %eax,0x4(%esp)
c01067a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c01067b0:	e8 ab 4a 00 00       	call   c010b260 <add_event_trigger>
c01067b5:	89 43 24             	mov    %eax,0x24(%ebx)
        thread_suspend(current_thread);
c01067b8:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01067bd:	89 04 24             	mov    %eax,(%esp)
c01067c0:	e8 c1 ee ff ff       	call   c0105686 <thread_suspend>
        *cpu = (struct cpu_state *)task_schedule(*cpu);
c01067c5:	8b 45 08             	mov    0x8(%ebp),%eax
c01067c8:	8b 00                	mov    (%eax),%eax
c01067ca:	89 04 24             	mov    %eax,(%esp)
c01067cd:	e8 94 e3 ff ff       	call   c0104b66 <task_schedule>
c01067d2:	8b 55 08             	mov    0x8(%ebp),%edx
c01067d5:	89 02                	mov    %eax,(%edx)
    }
}
c01067d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01067da:	c9                   	leave  
c01067db:	c3                   	ret    

c01067dc <usys_accept>:

void usys_accept(struct cpu_state **cpu)
{
c01067dc:	55                   	push   %ebp
c01067dd:	89 e5                	mov    %esp,%ebp
c01067df:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int id = (*cpu)->CPU_ARG1;
c01067e5:	8b 45 08             	mov    0x8(%ebp),%eax
c01067e8:	8b 00                	mov    (%eax),%eax
c01067ea:	8b 40 1c             	mov    0x1c(%eax),%eax
c01067ed:	89 45 f4             	mov    %eax,-0xc(%ebp)

    struct list_node *node = list_get_node_by_int(current_thread->process->socket_requests, offsetof(socket_request_t, id), id);
c01067f0:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01067f5:	8b 00                	mov    (%eax),%eax
c01067f7:	8b 40 20             	mov    0x20(%eax),%eax
c01067fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01067fd:	89 54 24 08          	mov    %edx,0x8(%esp)
c0106801:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106808:	00 
c0106809:	89 04 24             	mov    %eax,(%esp)
c010680c:	e8 0b c4 ff ff       	call   c0102c1c <list_get_node_by_int>
c0106811:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(node == NULL)
c0106814:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106818:	75 11                	jne    c010682b <usys_accept+0x4f>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c010681a:	8b 45 08             	mov    0x8(%ebp),%eax
c010681d:	8b 00                	mov    (%eax),%eax
c010681f:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0106826:	e9 c2 01 00 00       	jmp    c01069ed <usys_accept+0x211>
    }

    socket_request_t *req = (socket_request_t*) node->element;
c010682b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010682e:	8b 40 08             	mov    0x8(%eax),%eax
c0106831:	89 45 ec             	mov    %eax,-0x14(%ebp)
    list_remove_node(node);
c0106834:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106837:	89 04 24             	mov    %eax,(%esp)
c010683a:	e8 c3 c2 ff ff       	call   c0102b02 <list_remove_node>

    printf("%s\n",req->port);
c010683f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106842:	8b 40 08             	mov    0x8(%eax),%eax
c0106845:	89 04 24             	mov    %eax,(%esp)
c0106848:	e8 52 5a 00 00       	call   c010c29f <puts>

    vfs_dentry_t *dentry = vfs_get_dir_entry(current_thread->process->socket_inode, req->port);
c010684d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106850:	8b 50 08             	mov    0x8(%eax),%edx
c0106853:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106858:	8b 00                	mov    (%eax),%eax
c010685a:	8b 40 2c             	mov    0x2c(%eax),%eax
c010685d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0106861:	89 04 24             	mov    %eax,(%esp)
c0106864:	e8 89 15 00 00       	call   c0107df2 <vfs_get_dir_entry>
c0106869:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(dentry != NULL && dentry->inode != NULL)
c010686c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106870:	0f 84 5f 01 00 00    	je     c01069d5 <usys_accept+0x1f9>
c0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106879:	8b 40 04             	mov    0x4(%eax),%eax
c010687c:	85 c0                	test   %eax,%eax
c010687e:	0f 84 51 01 00 00    	je     c01069d5 <usys_accept+0x1f9>
    {
        char rstr[64], wstr[64];
        sprintf(rstr, "%d.in", req->pid);
c0106884:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106887:	8b 40 04             	mov    0x4(%eax),%eax
c010688a:	89 44 24 08          	mov    %eax,0x8(%esp)
c010688e:	c7 44 24 04 85 0b 11 	movl   $0xc0110b85,0x4(%esp)
c0106895:	c0 
c0106896:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
c010689c:	89 04 24             	mov    %eax,(%esp)
c010689f:	e8 ea cd ff ff       	call   c010368e <sprintf>
        sprintf(wstr, "%d.out", req->pid);
c01068a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01068a7:	8b 40 04             	mov    0x4(%eax),%eax
c01068aa:	89 44 24 08          	mov    %eax,0x8(%esp)
c01068ae:	c7 44 24 04 8b 0b 11 	movl   $0xc0110b8b,0x4(%esp)
c01068b5:	c0 
c01068b6:	8d 45 9c             	lea    -0x64(%ebp),%eax
c01068b9:	89 04 24             	mov    %eax,(%esp)
c01068bc:	e8 cd cd ff ff       	call   c010368e <sprintf>

        vfs_inode_t *r_in = vfs_create_inode(rstr, 0, dentry->inode, 0, 0);
c01068c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01068c4:	8b 40 04             	mov    0x4(%eax),%eax
c01068c7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c01068ce:	00 
c01068cf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c01068d6:	00 
c01068d7:	89 44 24 08          	mov    %eax,0x8(%esp)
c01068db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01068e2:	00 
c01068e3:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
c01068e9:	89 04 24             	mov    %eax,(%esp)
c01068ec:	e8 3d f5 ff ff       	call   c0105e2e <vfs_create_inode>
c01068f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        vfs_inode_t *w_in = vfs_create_inode(wstr, 0, dentry->inode, 0, 0);
c01068f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01068f7:	8b 40 04             	mov    0x4(%eax),%eax
c01068fa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0106901:	00 
c0106902:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0106909:	00 
c010690a:	89 44 24 08          	mov    %eax,0x8(%esp)
c010690e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106915:	00 
c0106916:	8d 45 9c             	lea    -0x64(%ebp),%eax
c0106919:	89 04 24             	mov    %eax,(%esp)
c010691c:	e8 0d f5 ff ff       	call   c0105e2e <vfs_create_inode>
c0106921:	89 45 e0             	mov    %eax,-0x20(%ebp)
        r_in->event_id = get_new_event_ID();
c0106924:	e8 20 49 00 00       	call   c010b249 <get_new_event_ID>
c0106929:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010692c:	89 42 44             	mov    %eax,0x44(%edx)
        r_in->handlers = list_create();
c010692f:	e8 47 c0 ff ff       	call   c010297b <list_create>
c0106934:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106937:	89 42 48             	mov    %eax,0x48(%edx)
        r_in->type = VFS_PIPE;
c010693a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010693d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        w_in->event_id = get_new_event_ID();
c0106944:	e8 00 49 00 00       	call   c010b249 <get_new_event_ID>
c0106949:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010694c:	89 42 44             	mov    %eax,0x44(%edx)
        w_in->handlers = list_create();
c010694f:	e8 27 c0 ff ff       	call   c010297b <list_create>
c0106954:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0106957:	89 42 48             	mov    %eax,0x48(%edx)
        w_in->type = VFS_PIPE;
c010695a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010695d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)

        struct fd *desc = create_fd(current_thread->process);
c0106964:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106969:	8b 00                	mov    (%eax),%eax
c010696b:	89 04 24             	mov    %eax,(%esp)
c010696e:	e8 a1 00 00 00       	call   c0106a14 <create_fd>
c0106973:	89 45 dc             	mov    %eax,-0x24(%ebp)
        desc->mode = 0;
c0106976:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0106979:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        desc->flags = O_RDWR;
c0106980:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0106983:	c7 40 08 04 00 00 00 	movl   $0x4,0x8(%eax)
        desc->permission = VFS_PERMISSION_READ | VFS_PERMISSION_WRITE;
c010698a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010698d:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
        desc->read_inode = r_in;
c0106994:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0106997:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010699a:	89 50 10             	mov    %edx,0x10(%eax)
        desc->write_inode = w_in;
c010699d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01069a0:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01069a3:	89 50 14             	mov    %edx,0x14(%eax)

        (*cpu)->CPU_ARG0 = desc->id;
c01069a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01069a9:	8b 00                	mov    (%eax),%eax
c01069ab:	8b 55 dc             	mov    -0x24(%ebp),%edx
c01069ae:	8b 12                	mov    (%edx),%edx
c01069b0:	89 50 28             	mov    %edx,0x28(%eax)

        req->inodes[0] = w_in;
c01069b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01069b6:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01069b9:	89 50 10             	mov    %edx,0x10(%eax)
        req->inodes[1] = r_in;
c01069bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01069bf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01069c2:	89 50 14             	mov    %edx,0x14(%eax)

        send_event(req->event_id);
c01069c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01069c8:	8b 40 0c             	mov    0xc(%eax),%eax
c01069cb:	89 04 24             	mov    %eax,(%esp)
c01069ce:	e8 d2 46 00 00       	call   c010b0a5 <send_event>
    printf("%s\n",req->port);

    vfs_dentry_t *dentry = vfs_get_dir_entry(current_thread->process->socket_inode, req->port);

    if(dentry != NULL && dentry->inode != NULL)
    {
c01069d3:	eb 18                	jmp    c01069ed <usys_accept+0x211>

        send_event(req->event_id);
    }
    else
    {
        printf("else\n");
c01069d5:	c7 04 24 92 0b 11 c0 	movl   $0xc0110b92,(%esp)
c01069dc:	e8 be 58 00 00       	call   c010c29f <puts>
        (*cpu)->CPU_ARG0 = _FAILURE;
c01069e1:	8b 45 08             	mov    0x8(%ebp),%eax
c01069e4:	8b 00                	mov    (%eax),%eax
c01069e6:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c01069ed:	c9                   	leave  
c01069ee:	c3                   	ret    

c01069ef <get_fd>:

extern struct thread_state *current_thread;
extern vfs_inode_t *root;

struct fd *get_fd(struct process_state *process, int fd)
{
c01069ef:	55                   	push   %ebp
c01069f0:	89 e5                	mov    %esp,%ebp
c01069f2:	83 ec 18             	sub    $0x18,%esp
    return (struct fd*) list_get_by_int(process->files, offsetof(struct fd, id), fd);
c01069f5:	8b 45 08             	mov    0x8(%ebp),%eax
c01069f8:	8b 40 18             	mov    0x18(%eax),%eax
c01069fb:	8b 55 0c             	mov    0xc(%ebp),%edx
c01069fe:	89 54 24 08          	mov    %edx,0x8(%esp)
c0106a02:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106a09:	00 
c0106a0a:	89 04 24             	mov    %eax,(%esp)
c0106a0d:	e8 b5 c1 ff ff       	call   c0102bc7 <list_get_by_int>
}
c0106a12:	c9                   	leave  
c0106a13:	c3                   	ret    

c0106a14 <create_fd>:

struct fd *create_fd(struct process_state *process)
{
c0106a14:	55                   	push   %ebp
c0106a15:	89 e5                	mov    %esp,%ebp
c0106a17:	83 ec 28             	sub    $0x28,%esp
    struct fd *desc = malloc(sizeof(struct fd));
c0106a1a:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0106a21:	e8 1f 55 00 00       	call   c010bf45 <malloc>
c0106a26:	89 45 f4             	mov    %eax,-0xc(%ebp)

    memset(desc, 0, sizeof(struct fd));
c0106a29:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
c0106a30:	00 
c0106a31:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0106a38:	00 
c0106a39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a3c:	89 04 24             	mov    %eax,(%esp)
c0106a3f:	e8 d5 c9 ff ff       	call   c0103419 <memset>
    desc->id = list_length(process->files);
c0106a44:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a47:	8b 40 18             	mov    0x18(%eax),%eax
c0106a4a:	89 04 24             	mov    %eax,(%esp)
c0106a4d:	e8 1c c2 ff ff       	call   c0102c6e <list_length>
c0106a52:	89 c2                	mov    %eax,%edx
c0106a54:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a57:	89 10                	mov    %edx,(%eax)

    list_push_back(process->files, desc);
c0106a59:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a5c:	8b 40 18             	mov    0x18(%eax),%eax
c0106a5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106a62:	89 54 24 04          	mov    %edx,0x4(%esp)
c0106a66:	89 04 24             	mov    %eax,(%esp)
c0106a69:	e8 f1 bf ff ff       	call   c0102a5f <list_push_back>

    return desc;
c0106a6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106a71:	c9                   	leave  
c0106a72:	c3                   	ret    

c0106a73 <sys_open>:

void sys_open(struct cpu_state **cpu)
{
c0106a73:	55                   	push   %ebp
c0106a74:	89 e5                	mov    %esp,%ebp
c0106a76:	83 ec 38             	sub    $0x38,%esp
    char *path = (char *) (*cpu)->CPU_ARG1;
c0106a79:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a7c:	8b 00                	mov    (%eax),%eax
c0106a7e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106a81:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int oflags = (*cpu)->CPU_ARG2;
c0106a84:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a87:	8b 00                	mov    (%eax),%eax
c0106a89:	8b 40 24             	mov    0x24(%eax),%eax
c0106a8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    mode_t mode = (*cpu)->CPU_ARG3;
c0106a8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a92:	8b 00                	mov    (%eax),%eax
c0106a94:	8b 40 20             	mov    0x20(%eax),%eax
c0106a97:	89 45 e8             	mov    %eax,-0x18(%ebp)
    vfs_inode_t *inode = vfs_lookup_path(path);
c0106a9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106a9d:	89 04 24             	mov    %eax,(%esp)
c0106aa0:	e8 fc 1f 00 00       	call   c0108aa1 <vfs_lookup_path>
c0106aa5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(inode == NULL)
c0106aa8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106aac:	75 63                	jne    c0106b11 <sys_open+0x9e>
    {
        if(oflags & O_CREAT)
c0106aae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106ab1:	83 e0 20             	and    $0x20,%eax
c0106ab4:	85 c0                	test   %eax,%eax
c0106ab6:	74 48                	je     c0106b00 <sys_open+0x8d>
        {
            // create inode
            inode = vfs_create_path(path, mode, current_thread->process->uid, current_thread->process->gid);
c0106ab8:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106abd:	8b 00                	mov    (%eax),%eax
c0106abf:	8b 50 08             	mov    0x8(%eax),%edx
c0106ac2:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106ac7:	8b 00                	mov    (%eax),%eax
c0106ac9:	8b 40 04             	mov    0x4(%eax),%eax
c0106acc:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0106ad0:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106ad4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106ad7:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106adb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106ade:	89 04 24             	mov    %eax,(%esp)
c0106ae1:	e8 25 21 00 00       	call   c0108c0b <vfs_create_path>
c0106ae6:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(inode == NULL)
c0106ae9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106aed:	75 3d                	jne    c0106b2c <sys_open+0xb9>
            {
                (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0106aef:	8b 45 08             	mov    0x8(%ebp),%eax
c0106af2:	8b 00                	mov    (%eax),%eax
c0106af4:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
                return;
c0106afb:	e9 93 01 00 00       	jmp    c0106c93 <sys_open+0x220>
            }
        }
        else
        {
            (*cpu)->CPU_ARG0 = _FAILURE;
c0106b00:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b03:	8b 00                	mov    (%eax),%eax
c0106b05:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
            return;
c0106b0c:	e9 82 01 00 00       	jmp    c0106c93 <sys_open+0x220>
        }
    }
    else
    {
        if(oflags & O_EXCL)
c0106b11:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106b14:	83 e0 40             	and    $0x40,%eax
c0106b17:	85 c0                	test   %eax,%eax
c0106b19:	74 11                	je     c0106b2c <sys_open+0xb9>
        {
            (*cpu)->CPU_ARG0 = _FAILURE;
c0106b1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b1e:	8b 00                	mov    (%eax),%eax
c0106b20:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
            return;
c0106b27:	e9 67 01 00 00       	jmp    c0106c93 <sys_open+0x220>
        }
    }

    if(oflags & O_TRUNC)
c0106b2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106b2f:	83 e0 10             	and    $0x10,%eax
c0106b32:	85 c0                	test   %eax,%eax
c0106b34:	74 44                	je     c0106b7a <sys_open+0x107>
    {
        if(vfs_access(inode, W_OK, current_thread->process->uid, current_thread->process->gid) == 0)
c0106b36:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106b3b:	8b 00                	mov    (%eax),%eax
c0106b3d:	8b 50 08             	mov    0x8(%eax),%edx
c0106b40:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106b45:	8b 00                	mov    (%eax),%eax
c0106b47:	8b 40 04             	mov    0x4(%eax),%eax
c0106b4a:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0106b4e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106b52:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c0106b59:	00 
c0106b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b5d:	89 04 24             	mov    %eax,(%esp)
c0106b60:	e8 47 f6 ff ff       	call   c01061ac <vfs_access>
c0106b65:	85 c0                	test   %eax,%eax
c0106b67:	74 11                	je     c0106b7a <sys_open+0x107>
        {
            // TODO: clear file
        }
        else
        {
            (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0106b69:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b6c:	8b 00                	mov    (%eax),%eax
c0106b6e:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
            return;
c0106b75:	e9 19 01 00 00       	jmp    c0106c93 <sys_open+0x220>
        }
    }

    struct fd *desc = create_fd(current_thread->process);
c0106b7a:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106b7f:	8b 00                	mov    (%eax),%eax
c0106b81:	89 04 24             	mov    %eax,(%esp)
c0106b84:	e8 8b fe ff ff       	call   c0106a14 <create_fd>
c0106b89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    desc->mode = mode;
c0106b8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106b8f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0106b92:	89 50 04             	mov    %edx,0x4(%eax)
    desc->flags = oflags;
c0106b95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106b98:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0106b9b:	89 50 08             	mov    %edx,0x8(%eax)

    if(oflags & O_APPEND)
c0106b9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106ba1:	83 e0 08             	and    $0x8,%eax
c0106ba4:	85 c0                	test   %eax,%eax
c0106ba6:	74 1c                	je     c0106bc4 <sys_open+0x151>
    {
        desc->read_pos = inode->length;
c0106ba8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106bab:	8b 40 08             	mov    0x8(%eax),%eax
c0106bae:	89 c2                	mov    %eax,%edx
c0106bb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106bb3:	89 50 18             	mov    %edx,0x18(%eax)
        desc->write_pos = inode->length;
c0106bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106bb9:	8b 40 08             	mov    0x8(%eax),%eax
c0106bbc:	89 c2                	mov    %eax,%edx
c0106bbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106bc1:	89 50 1c             	mov    %edx,0x1c(%eax)
    }

    if( (oflags & O_RDONLY || oflags & O_RDWR) && vfs_access(inode, R_OK, current_thread->process->uid, current_thread->process->gid) == 0)
c0106bc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106bc7:	83 e0 01             	and    $0x1,%eax
c0106bca:	85 c0                	test   %eax,%eax
c0106bcc:	75 0a                	jne    c0106bd8 <sys_open+0x165>
c0106bce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106bd1:	83 e0 04             	and    $0x4,%eax
c0106bd4:	85 c0                	test   %eax,%eax
c0106bd6:	74 4d                	je     c0106c25 <sys_open+0x1b2>
c0106bd8:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106bdd:	8b 00                	mov    (%eax),%eax
c0106bdf:	8b 50 08             	mov    0x8(%eax),%edx
c0106be2:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106be7:	8b 00                	mov    (%eax),%eax
c0106be9:	8b 40 04             	mov    0x4(%eax),%eax
c0106bec:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0106bf0:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106bf4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0106bfb:	00 
c0106bfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106bff:	89 04 24             	mov    %eax,(%esp)
c0106c02:	e8 a5 f5 ff ff       	call   c01061ac <vfs_access>
c0106c07:	85 c0                	test   %eax,%eax
c0106c09:	75 1a                	jne    c0106c25 <sys_open+0x1b2>
    {
        desc->permission |= VFS_PERMISSION_READ;
c0106c0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106c0e:	8b 40 0c             	mov    0xc(%eax),%eax
c0106c11:	89 c2                	mov    %eax,%edx
c0106c13:	83 ca 01             	or     $0x1,%edx
c0106c16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106c19:	89 50 0c             	mov    %edx,0xc(%eax)
        desc->read_inode = inode;
c0106c1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106c1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106c22:	89 50 10             	mov    %edx,0x10(%eax)
    }

    if( (oflags & O_WRONLY || oflags & O_RDWR) && vfs_access(inode, W_OK, current_thread->process->uid, current_thread->process->gid) == 0)
c0106c25:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106c28:	83 e0 02             	and    $0x2,%eax
c0106c2b:	85 c0                	test   %eax,%eax
c0106c2d:	75 0a                	jne    c0106c39 <sys_open+0x1c6>
c0106c2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106c32:	83 e0 04             	and    $0x4,%eax
c0106c35:	85 c0                	test   %eax,%eax
c0106c37:	74 4d                	je     c0106c86 <sys_open+0x213>
c0106c39:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106c3e:	8b 00                	mov    (%eax),%eax
c0106c40:	8b 50 08             	mov    0x8(%eax),%edx
c0106c43:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106c48:	8b 00                	mov    (%eax),%eax
c0106c4a:	8b 40 04             	mov    0x4(%eax),%eax
c0106c4d:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0106c51:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106c55:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c0106c5c:	00 
c0106c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c60:	89 04 24             	mov    %eax,(%esp)
c0106c63:	e8 44 f5 ff ff       	call   c01061ac <vfs_access>
c0106c68:	85 c0                	test   %eax,%eax
c0106c6a:	75 1a                	jne    c0106c86 <sys_open+0x213>
    {
        desc->permission |= VFS_PERMISSION_WRITE;
c0106c6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106c6f:	8b 40 0c             	mov    0xc(%eax),%eax
c0106c72:	89 c2                	mov    %eax,%edx
c0106c74:	83 ca 02             	or     $0x2,%edx
c0106c77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106c7a:	89 50 0c             	mov    %edx,0xc(%eax)
        desc->write_inode = inode;
c0106c7d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106c80:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106c83:	89 50 14             	mov    %edx,0x14(%eax)
    }

    (*cpu)->CPU_ARG0 = desc->id;
c0106c86:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c89:	8b 00                	mov    (%eax),%eax
c0106c8b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106c8e:	8b 12                	mov    (%edx),%edx
c0106c90:	89 50 28             	mov    %edx,0x28(%eax)
}
c0106c93:	c9                   	leave  
c0106c94:	c3                   	ret    

c0106c95 <sys_close>:

void sys_close(struct cpu_state **cpu)
{
c0106c95:	55                   	push   %ebp
c0106c96:	89 e5                	mov    %esp,%ebp
c0106c98:	83 ec 28             	sub    $0x28,%esp
    int fd = (*cpu)->CPU_ARG1;
c0106c9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c9e:	8b 00                	mov    (%eax),%eax
c0106ca0:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106ca3:	89 45 ec             	mov    %eax,-0x14(%ebp)

    struct list_node *node = current_thread->process->files->head->next;
c0106ca6:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106cab:	8b 00                	mov    (%eax),%eax
c0106cad:	8b 40 18             	mov    0x18(%eax),%eax
c0106cb0:	8b 40 04             	mov    0x4(%eax),%eax
c0106cb3:	8b 00                	mov    (%eax),%eax
c0106cb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i;
    for(i = 0; i < list_length(current_thread->process->files); i++)
c0106cb8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0106cbf:	eb 3a                	jmp    c0106cfb <sys_close+0x66>
    {
        struct fd *desc = node->element;
c0106cc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106cc4:	8b 40 08             	mov    0x8(%eax),%eax
c0106cc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(desc->id == fd)
c0106cca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106ccd:	8b 10                	mov    (%eax),%edx
c0106ccf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106cd2:	39 c2                	cmp    %eax,%edx
c0106cd4:	75 19                	jne    c0106cef <sys_close+0x5a>
        {
            list_remove_node(node);
c0106cd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106cd9:	89 04 24             	mov    %eax,(%esp)
c0106cdc:	e8 21 be ff ff       	call   c0102b02 <list_remove_node>
            (*cpu)->CPU_ARG0 = _SUCCESS;
c0106ce1:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ce4:	8b 00                	mov    (%eax),%eax
c0106ce6:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
            return;
c0106ced:	eb 2f                	jmp    c0106d1e <sys_close+0x89>
        }
        else
        {
            node = node->next;
c0106cef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106cf2:	8b 00                	mov    (%eax),%eax
c0106cf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
    int fd = (*cpu)->CPU_ARG1;

    struct list_node *node = current_thread->process->files->head->next;
    int i;
    for(i = 0; i < list_length(current_thread->process->files); i++)
c0106cf7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0106cfb:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106d00:	8b 00                	mov    (%eax),%eax
c0106d02:	8b 40 18             	mov    0x18(%eax),%eax
c0106d05:	89 04 24             	mov    %eax,(%esp)
c0106d08:	e8 61 bf ff ff       	call   c0102c6e <list_length>
c0106d0d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0106d10:	7f af                	jg     c0106cc1 <sys_close+0x2c>
        {
            node = node->next;
        }
    }

    (*cpu)->CPU_ARG0 = _FAILURE;
c0106d12:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d15:	8b 00                	mov    (%eax),%eax
c0106d17:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
}
c0106d1e:	c9                   	leave  
c0106d1f:	c3                   	ret    

c0106d20 <sys_read>:

extern struct thread_state *current_thread;
extern vfs_inode_t *root;

void sys_read(struct cpu_state **cpu)
{
c0106d20:	55                   	push   %ebp
c0106d21:	89 e5                	mov    %esp,%ebp
c0106d23:	83 ec 48             	sub    $0x48,%esp
    int fd = (*cpu)->CPU_ARG1;
c0106d26:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d29:	8b 00                	mov    (%eax),%eax
c0106d2b:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106d2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    void *buf = (void*) (*cpu)->CPU_ARG2;
c0106d31:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d34:	8b 00                	mov    (%eax),%eax
c0106d36:	8b 40 24             	mov    0x24(%eax),%eax
c0106d39:	89 45 ec             	mov    %eax,-0x14(%ebp)
    size_t len = (*cpu)->CPU_ARG3;
c0106d3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d3f:	8b 00                	mov    (%eax),%eax
c0106d41:	8b 40 20             	mov    0x20(%eax),%eax
c0106d44:	89 45 e8             	mov    %eax,-0x18(%ebp)

    struct fd *desc = get_fd(current_thread->process, fd);
c0106d47:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106d4c:	8b 00                	mov    (%eax),%eax
c0106d4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0106d51:	89 54 24 04          	mov    %edx,0x4(%esp)
c0106d55:	89 04 24             	mov    %eax,(%esp)
c0106d58:	e8 92 fc ff ff       	call   c01069ef <get_fd>
c0106d5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(desc != NULL)
c0106d60:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0106d64:	0f 84 81 01 00 00    	je     c0106eeb <sys_read+0x1cb>
    {
        if(desc->permission & VFS_PERMISSION_READ && desc->read_inode != NULL)
c0106d6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106d6d:	8b 40 0c             	mov    0xc(%eax),%eax
c0106d70:	83 e0 01             	and    $0x1,%eax
c0106d73:	85 c0                	test   %eax,%eax
c0106d75:	0f 84 62 01 00 00    	je     c0106edd <sys_read+0x1bd>
c0106d7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106d7e:	8b 40 10             	mov    0x10(%eax),%eax
c0106d81:	85 c0                	test   %eax,%eax
c0106d83:	0f 84 54 01 00 00    	je     c0106edd <sys_read+0x1bd>
        {
            vfs_inode_t *inode = desc->read_inode;
c0106d89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106d8c:	8b 40 10             	mov    0x10(%eax),%eax
c0106d8f:	89 45 e0             	mov    %eax,-0x20(%ebp)
            vfs_inode_t *real = inode;
c0106d92:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0106d95:	89 45 f4             	mov    %eax,-0xc(%ebp)
            GET_INODE(real);
c0106d98:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106d9b:	8b 40 04             	mov    0x4(%eax),%eax
c0106d9e:	83 f8 03             	cmp    $0x3,%eax
c0106da1:	75 09                	jne    c0106dac <sys_read+0x8c>
c0106da3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106da6:	8b 40 3c             	mov    0x3c(%eax),%eax
c0106da9:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(S_ISDIR(real->stat))
c0106dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106daf:	8b 40 0c             	mov    0xc(%eax),%eax
c0106db2:	83 e0 20             	and    $0x20,%eax
c0106db5:	85 c0                	test   %eax,%eax
c0106db7:	74 11                	je     c0106dca <sys_read+0xaa>
            {
                (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0106db9:	8b 45 08             	mov    0x8(%ebp),%eax
c0106dbc:	8b 00                	mov    (%eax),%eax
c0106dbe:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
                return;
c0106dc5:	e9 2d 01 00 00       	jmp    c0106ef7 <sys_read+0x1d7>
            }
            block_buffer_info_t *info = real->read_buffer;
c0106dca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106dcd:	8b 40 3c             	mov    0x3c(%eax),%eax
c0106dd0:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if(info == NULL)
c0106dd3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0106dd7:	75 11                	jne    c0106dea <sys_read+0xca>
            {
                (*cpu)->CPU_ARG0 = _FAILURE;
c0106dd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ddc:	8b 00                	mov    (%eax),%eax
c0106dde:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
                return;
c0106de5:	e9 0d 01 00 00       	jmp    c0106ef7 <sys_read+0x1d7>
            }

            int ret = vfs_read(inode, desc->read_pos, buf, len);
c0106dea:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0106ded:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106df0:	8b 40 18             	mov    0x18(%eax),%eax
c0106df3:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0106df7:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0106dfa:	89 54 24 08          	mov    %edx,0x8(%esp)
c0106dfe:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106e02:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0106e05:	89 04 24             	mov    %eax,(%esp)
c0106e08:	e8 11 f3 ff ff       	call   c010611e <vfs_read>
c0106e0d:	89 45 d8             	mov    %eax,-0x28(%ebp)

            if(ret == len)
c0106e10:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106e13:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0106e16:	75 45                	jne    c0106e5d <sys_read+0x13d>
            {
                desc->read_pos += len;
c0106e18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106e1b:	8b 40 18             	mov    0x18(%eax),%eax
c0106e1e:	89 c2                	mov    %eax,%edx
c0106e20:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106e23:	01 d0                	add    %edx,%eax
c0106e25:	89 c2                	mov    %eax,%edx
c0106e27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106e2a:	89 50 18             	mov    %edx,0x18(%eax)
                if(real->type != VFS_PIPE)
c0106e2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106e30:	8b 40 04             	mov    0x4(%eax),%eax
c0106e33:	83 f8 01             	cmp    $0x1,%eax
c0106e36:	74 15                	je     c0106e4d <sys_read+0x12d>
                {
                    desc->write_pos += len;
c0106e38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106e3b:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106e3e:	89 c2                	mov    %eax,%edx
c0106e40:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106e43:	01 d0                	add    %edx,%eax
c0106e45:	89 c2                	mov    %eax,%edx
c0106e47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106e4a:	89 50 1c             	mov    %edx,0x1c(%eax)
                }

                (*cpu)->CPU_ARG0 = len;
c0106e4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e50:	8b 00                	mov    (%eax),%eax
c0106e52:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0106e55:	89 50 28             	mov    %edx,0x28(%eax)

    struct fd *desc = get_fd(current_thread->process, fd);
    if(desc != NULL)
    {
        if(desc->permission & VFS_PERMISSION_READ && desc->read_inode != NULL)
        {
c0106e58:	e9 9a 00 00 00       	jmp    c0106ef7 <sys_read+0x1d7>

                (*cpu)->CPU_ARG0 = len;
            }
            else
            {
                if(real->type == VFS_PIPE)
c0106e5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106e60:	8b 40 04             	mov    0x4(%eax),%eax
c0106e63:	83 f8 01             	cmp    $0x1,%eax
c0106e66:	75 66                	jne    c0106ece <sys_read+0x1ae>
                {
					printf("read from %s..sleep\n", real->name);
c0106e68:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106e6b:	8b 00                	mov    (%eax),%eax
c0106e6d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106e71:	c7 04 24 97 0b 11 c0 	movl   $0xc0110b97,(%esp)
c0106e78:	e8 a4 c7 ff ff       	call   c0103621 <printf>

                    add_trigger(WAIT_EVENT, inode->event_id, 0, current_thread, sys_read);
c0106e7d:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c0106e83:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0106e86:	8b 40 44             	mov    0x44(%eax),%eax
c0106e89:	c7 44 24 10 20 6d 10 	movl   $0xc0106d20,0x10(%esp)
c0106e90:	c0 
c0106e91:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0106e95:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0106e9c:	00 
c0106e9d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0106ea1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c0106ea8:	e8 13 44 00 00       	call   c010b2c0 <add_trigger>
                    thread_suspend(current_thread);
c0106ead:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106eb2:	89 04 24             	mov    %eax,(%esp)
c0106eb5:	e8 cc e7 ff ff       	call   c0105686 <thread_suspend>
                    *cpu = (struct cpu_state *)task_schedule(*cpu);
c0106eba:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ebd:	8b 00                	mov    (%eax),%eax
c0106ebf:	89 04 24             	mov    %eax,(%esp)
c0106ec2:	e8 9f dc ff ff       	call   c0104b66 <task_schedule>
c0106ec7:	8b 55 08             	mov    0x8(%ebp),%edx
c0106eca:	89 02                	mov    %eax,(%edx)

    struct fd *desc = get_fd(current_thread->process, fd);
    if(desc != NULL)
    {
        if(desc->permission & VFS_PERMISSION_READ && desc->read_inode != NULL)
        {
c0106ecc:	eb 29                	jmp    c0106ef7 <sys_read+0x1d7>
                    thread_suspend(current_thread);
                    *cpu = (struct cpu_state *)task_schedule(*cpu);
                }
                else
                {
                    (*cpu)->CPU_ARG0 = _FAILURE;
c0106ece:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ed1:	8b 00                	mov    (%eax),%eax
c0106ed3:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)

    struct fd *desc = get_fd(current_thread->process, fd);
    if(desc != NULL)
    {
        if(desc->permission & VFS_PERMISSION_READ && desc->read_inode != NULL)
        {
c0106eda:	90                   	nop
c0106edb:	eb 1a                	jmp    c0106ef7 <sys_read+0x1d7>
                }
            }
        }
        else
        {
            (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0106edd:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ee0:	8b 00                	mov    (%eax),%eax
c0106ee2:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
c0106ee9:	eb 0c                	jmp    c0106ef7 <sys_read+0x1d7>
        }
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0106eeb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106eee:	8b 00                	mov    (%eax),%eax
c0106ef0:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c0106ef7:	c9                   	leave  
c0106ef8:	c3                   	ret    

c0106ef9 <sys_chdir>:
extern struct thread_state *current_thread;
extern vfs_inode_t *root;


void sys_chdir(struct cpu_state **cpu)
{
c0106ef9:	55                   	push   %ebp
c0106efa:	89 e5                	mov    %esp,%ebp
c0106efc:	83 ec 28             	sub    $0x28,%esp
    char *path = (char *)(*cpu)->CPU_ARG1;
c0106eff:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f02:	8b 00                	mov    (%eax),%eax
c0106f04:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106f07:	89 45 f0             	mov    %eax,-0x10(%ebp)

    vfs_inode_t *nwd = vfs_lookup_path(path);
c0106f0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f0d:	89 04 24             	mov    %eax,(%esp)
c0106f10:	e8 8c 1b 00 00       	call   c0108aa1 <vfs_lookup_path>
c0106f15:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(nwd != NULL)
c0106f18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106f1c:	0f 84 92 00 00 00    	je     c0106fb4 <sys_chdir+0xbb>
    {
        GET_INODE(nwd);
c0106f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106f25:	8b 40 04             	mov    0x4(%eax),%eax
c0106f28:	83 f8 03             	cmp    $0x3,%eax
c0106f2b:	75 09                	jne    c0106f36 <sys_chdir+0x3d>
c0106f2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106f30:	8b 40 3c             	mov    0x3c(%eax),%eax
c0106f33:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(nwd != NULL && S_ISDIR(nwd->stat))
c0106f36:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106f3a:	74 6a                	je     c0106fa6 <sys_chdir+0xad>
c0106f3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106f3f:	8b 40 0c             	mov    0xc(%eax),%eax
c0106f42:	83 e0 20             	and    $0x20,%eax
c0106f45:	85 c0                	test   %eax,%eax
c0106f47:	74 5d                	je     c0106fa6 <sys_chdir+0xad>
        {
            if(vfs_access(nwd, R_OK, current_thread->process->uid, current_thread->process->gid) == 0)
c0106f49:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106f4e:	8b 00                	mov    (%eax),%eax
c0106f50:	8b 50 08             	mov    0x8(%eax),%edx
c0106f53:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106f58:	8b 00                	mov    (%eax),%eax
c0106f5a:	8b 40 04             	mov    0x4(%eax),%eax
c0106f5d:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0106f61:	89 44 24 08          	mov    %eax,0x8(%esp)
c0106f65:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0106f6c:	00 
c0106f6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106f70:	89 04 24             	mov    %eax,(%esp)
c0106f73:	e8 34 f2 ff ff       	call   c01061ac <vfs_access>
c0106f78:	85 c0                	test   %eax,%eax
c0106f7a:	75 1b                	jne    c0106f97 <sys_chdir+0x9e>
            {
                current_thread->process->cwd = nwd;
c0106f7c:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106f81:	8b 00                	mov    (%eax),%eax
c0106f83:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106f86:	89 50 14             	mov    %edx,0x14(%eax)
                (*cpu)->CPU_ARG0 = _SUCCESS;
c0106f89:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f8c:	8b 00                	mov    (%eax),%eax
c0106f8e:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    if(nwd != NULL)
    {
        GET_INODE(nwd);
        if(nwd != NULL && S_ISDIR(nwd->stat))
        {
            if(vfs_access(nwd, R_OK, current_thread->process->uid, current_thread->process->gid) == 0)
c0106f95:	eb 29                	jmp    c0106fc0 <sys_chdir+0xc7>
                current_thread->process->cwd = nwd;
                (*cpu)->CPU_ARG0 = _SUCCESS;
            }
            else
            {
                (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0106f97:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f9a:	8b 00                	mov    (%eax),%eax
c0106f9c:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
    if(nwd != NULL)
    {
        GET_INODE(nwd);
        if(nwd != NULL && S_ISDIR(nwd->stat))
        {
            if(vfs_access(nwd, R_OK, current_thread->process->uid, current_thread->process->gid) == 0)
c0106fa3:	90                   	nop
c0106fa4:	eb 1a                	jmp    c0106fc0 <sys_chdir+0xc7>
                (*cpu)->CPU_ARG0 = _NO_PERMISSION;
            }
        }
        else
        {
            (*cpu)->CPU_ARG0 = _FAILURE;
c0106fa6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fa9:	8b 00                	mov    (%eax),%eax
c0106fab:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
c0106fb2:	eb 0c                	jmp    c0106fc0 <sys_chdir+0xc7>
        }
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0106fb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fb7:	8b 00                	mov    (%eax),%eax
c0106fb9:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c0106fc0:	c9                   	leave  
c0106fc1:	c3                   	ret    

c0106fc2 <sys_getdents>:

void sys_getdents(struct cpu_state **cpu)
{
c0106fc2:	55                   	push   %ebp
c0106fc3:	89 e5                	mov    %esp,%ebp
c0106fc5:	53                   	push   %ebx
c0106fc6:	83 ec 34             	sub    $0x34,%esp
    int fd = (*cpu)->CPU_ARG1;
c0106fc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fcc:	8b 00                	mov    (%eax),%eax
c0106fce:	8b 40 1c             	mov    0x1c(%eax),%eax
c0106fd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    dirent_t *dentry = (dirent_t *)(*cpu)->CPU_ARG2;
c0106fd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fd7:	8b 00                	mov    (%eax),%eax
c0106fd9:	8b 40 24             	mov    0x24(%eax),%eax
c0106fdc:	89 45 ec             	mov    %eax,-0x14(%ebp)

    vfs_inode_t *parent = get_fd(current_thread->process, fd)->read_inode;
c0106fdf:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0106fe4:	8b 00                	mov    (%eax),%eax
c0106fe6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0106fe9:	89 54 24 04          	mov    %edx,0x4(%esp)
c0106fed:	89 04 24             	mov    %eax,(%esp)
c0106ff0:	e8 fa f9 ff ff       	call   c01069ef <get_fd>
c0106ff5:	8b 40 10             	mov    0x10(%eax),%eax
c0106ff8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    GET_INODE(parent);
c0106ffb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106ffe:	8b 40 04             	mov    0x4(%eax),%eax
c0107001:	83 f8 03             	cmp    $0x3,%eax
c0107004:	75 09                	jne    c010700f <sys_getdents+0x4d>
c0107006:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107009:	8b 40 3c             	mov    0x3c(%eax),%eax
c010700c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(vfs_access(parent, R_OK, current_thread->process->uid, current_thread->process->gid) == 0)
c010700f:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107014:	8b 00                	mov    (%eax),%eax
c0107016:	8b 50 08             	mov    0x8(%eax),%edx
c0107019:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010701e:	8b 00                	mov    (%eax),%eax
c0107020:	8b 40 04             	mov    0x4(%eax),%eax
c0107023:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0107027:	89 44 24 08          	mov    %eax,0x8(%esp)
c010702b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0107032:	00 
c0107033:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107036:	89 04 24             	mov    %eax,(%esp)
c0107039:	e8 6e f1 ff ff       	call   c01061ac <vfs_access>
c010703e:	85 c0                	test   %eax,%eax
c0107040:	0f 85 23 01 00 00    	jne    c0107169 <sys_getdents+0x1a7>
    {
        if(! S_ISDIR(parent->stat))
c0107046:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107049:	8b 40 0c             	mov    0xc(%eax),%eax
c010704c:	83 e0 20             	and    $0x20,%eax
c010704f:	85 c0                	test   %eax,%eax
c0107051:	75 11                	jne    c0107064 <sys_getdents+0xa2>
        {
            (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0107053:	8b 45 08             	mov    0x8(%ebp),%eax
c0107056:	8b 00                	mov    (%eax),%eax
c0107058:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
            return;
c010705f:	e9 11 01 00 00       	jmp    c0107175 <sys_getdents+0x1b3>
        }

        block_buffer_info_t *info = parent->read_buffer;
c0107064:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107067:	8b 40 3c             	mov    0x3c(%eax),%eax
c010706a:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if(current_thread->getdents_pos < list_length(info->blocks) && (fd == current_thread->getdents_old_fd || current_thread->getdents_old_fd == -1))
c010706d:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107072:	8b 98 28 20 00 00    	mov    0x2028(%eax),%ebx
c0107078:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010707b:	8b 00                	mov    (%eax),%eax
c010707d:	89 04 24             	mov    %eax,(%esp)
c0107080:	e8 e9 bb ff ff       	call   c0102c6e <list_length>
c0107085:	39 c3                	cmp    %eax,%ebx
c0107087:	0f 8d b1 00 00 00    	jge    c010713e <sys_getdents+0x17c>
c010708d:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107092:	8b 80 2c 20 00 00    	mov    0x202c(%eax),%eax
c0107098:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c010709b:	74 14                	je     c01070b1 <sys_getdents+0xef>
c010709d:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01070a2:	8b 80 2c 20 00 00    	mov    0x202c(%eax),%eax
c01070a8:	83 f8 ff             	cmp    $0xffffffff,%eax
c01070ab:	0f 85 8d 00 00 00    	jne    c010713e <sys_getdents+0x17c>
        {
            buffer_block_t *block = buffer_block_get(info, current_thread->getdents_pos++);
c01070b1:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01070b6:	8b 90 28 20 00 00    	mov    0x2028(%eax),%edx
c01070bc:	89 d1                	mov    %edx,%ecx
c01070be:	83 c2 01             	add    $0x1,%edx
c01070c1:	89 90 28 20 00 00    	mov    %edx,0x2028(%eax)
c01070c7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c01070cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01070ce:	89 04 24             	mov    %eax,(%esp)
c01070d1:	e8 45 b4 ff ff       	call   c010251b <buffer_block_get>
c01070d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            vfs_dentry_t *entry = (vfs_dentry_t *)block->base;
c01070d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01070dc:	8b 40 04             	mov    0x4(%eax),%eax
c01070df:	89 45 e0             	mov    %eax,-0x20(%ebp)
            vfs_inode_t *ino = entry->inode;
c01070e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01070e5:	8b 40 04             	mov    0x4(%eax),%eax
c01070e8:	89 45 dc             	mov    %eax,-0x24(%ebp)

            strcpy(dentry->name, ino->name);
c01070eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01070ee:	8b 00                	mov    (%eax),%eax
c01070f0:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01070f3:	83 c2 04             	add    $0x4,%edx
c01070f6:	89 44 24 04          	mov    %eax,0x4(%esp)
c01070fa:	89 14 24             	mov    %edx,(%esp)
c01070fd:	e8 f2 bd ff ff       	call   c0102ef4 <strcpy>
            memcpy(&dentry->stat, &ino->stat, sizeof(struct stat));
c0107102:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107105:	8d 50 0c             	lea    0xc(%eax),%edx
c0107108:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010710b:	05 04 01 00 00       	add    $0x104,%eax
c0107110:	c7 44 24 08 2c 00 00 	movl   $0x2c,0x8(%esp)
c0107117:	00 
c0107118:	89 54 24 04          	mov    %edx,0x4(%esp)
c010711c:	89 04 24             	mov    %eax,(%esp)
c010711f:	e8 7f c1 ff ff       	call   c01032a3 <memcpy>
            dentry->id = ino->stat.st_ino;
c0107124:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107127:	8b 40 10             	mov    0x10(%eax),%eax
c010712a:	89 c2                	mov    %eax,%edx
c010712c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010712f:	89 10                	mov    %edx,(%eax)
            (*cpu)->CPU_ARG0 = (uint32_t) dentry;
c0107131:	8b 45 08             	mov    0x8(%ebp),%eax
c0107134:	8b 00                	mov    (%eax),%eax
c0107136:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0107139:	89 50 28             	mov    %edx,0x28(%eax)
        }

        block_buffer_info_t *info = parent->read_buffer;

        if(current_thread->getdents_pos < list_length(info->blocks) && (fd == current_thread->getdents_old_fd || current_thread->getdents_old_fd == -1))
        {
c010713c:	eb 1b                	jmp    c0107159 <sys_getdents+0x197>
            dentry->id = ino->stat.st_ino;
            (*cpu)->CPU_ARG0 = (uint32_t) dentry;
        }
        else
        {
            current_thread->getdents_pos = 0;
c010713e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107143:	c7 80 28 20 00 00 00 	movl   $0x0,0x2028(%eax)
c010714a:	00 00 00 
            (*cpu)->CPU_ARG0 = (uint32_t) NULL;
c010714d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107150:	8b 00                	mov    (%eax),%eax
c0107152:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        }

        current_thread->getdents_old_fd = fd;
c0107159:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010715e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107161:	89 90 2c 20 00 00    	mov    %edx,0x202c(%eax)
c0107167:	eb 0c                	jmp    c0107175 <sys_getdents+0x1b3>
    }
    else
    {
        (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0107169:	8b 45 08             	mov    0x8(%ebp),%eax
c010716c:	8b 00                	mov    (%eax),%eax
c010716e:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
    }
}
c0107175:	83 c4 34             	add    $0x34,%esp
c0107178:	5b                   	pop    %ebx
c0107179:	5d                   	pop    %ebp
c010717a:	c3                   	ret    

c010717b <sys_mkdir>:

void sys_mkdir(struct cpu_state **cpu)
{
c010717b:	55                   	push   %ebp
c010717c:	89 e5                	mov    %esp,%ebp
c010717e:	83 ec 28             	sub    $0x28,%esp
    char *path = (char *)(*cpu)->CPU_ARG1;
c0107181:	8b 45 08             	mov    0x8(%ebp),%eax
c0107184:	8b 00                	mov    (%eax),%eax
c0107186:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107189:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int mode = (int)(*cpu)->CPU_ARG2;
c010718c:	8b 45 08             	mov    0x8(%ebp),%eax
c010718f:	8b 00                	mov    (%eax),%eax
c0107191:	8b 40 24             	mov    0x24(%eax),%eax
c0107194:	89 45 f0             	mov    %eax,-0x10(%ebp)

    vfs_create_path(path, mode | S_IFDIR, current_thread->process->uid, current_thread->process->gid);
c0107197:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010719c:	8b 00                	mov    (%eax),%eax
c010719e:	8b 48 08             	mov    0x8(%eax),%ecx
c01071a1:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01071a6:	8b 00                	mov    (%eax),%eax
c01071a8:	8b 50 04             	mov    0x4(%eax),%edx
c01071ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01071ae:	83 c8 20             	or     $0x20,%eax
c01071b1:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c01071b5:	89 54 24 08          	mov    %edx,0x8(%esp)
c01071b9:	89 44 24 04          	mov    %eax,0x4(%esp)
c01071bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01071c0:	89 04 24             	mov    %eax,(%esp)
c01071c3:	e8 43 1a 00 00       	call   c0108c0b <vfs_create_path>

    (*cpu)->CPU_ARG0 = _SUCCESS;
c01071c8:	8b 45 08             	mov    0x8(%ebp),%eax
c01071cb:	8b 00                	mov    (%eax),%eax
c01071cd:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)

    return;
c01071d4:	90                   	nop
}
c01071d5:	c9                   	leave  
c01071d6:	c3                   	ret    

c01071d7 <sys_getcwd>:

void sys_getcwd(struct cpu_state **cpu)
{
c01071d7:	55                   	push   %ebp
c01071d8:	89 e5                	mov    %esp,%ebp
c01071da:	83 ec 38             	sub    $0x38,%esp
    char *buffer = (char *)(*cpu)->CPU_ARG1;
c01071dd:	8b 45 08             	mov    0x8(%ebp),%eax
c01071e0:	8b 00                	mov    (%eax),%eax
c01071e2:	8b 40 1c             	mov    0x1c(%eax),%eax
c01071e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int buffersize = (int)(*cpu)->CPU_ARG2;
c01071e8:	8b 45 08             	mov    0x8(%ebp),%eax
c01071eb:	8b 00                	mov    (%eax),%eax
c01071ed:	8b 40 24             	mov    0x24(%eax),%eax
c01071f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //int currentend = 0;
    int cwdsize = 0;				// the final size of the final '\0'
c01071f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    vfs_inode_t *inode = current_thread->process->cwd;
c01071fa:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01071ff:	8b 00                	mov    (%eax),%eax
c0107201:	8b 40 14             	mov    0x14(%eax),%eax
c0107204:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while(inode != root)
c0107207:	eb 21                	jmp    c010722a <sys_getcwd+0x53>
    {
        cwdsize += strlen((char*)inode->name) + 1;
c0107209:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010720c:	8b 00                	mov    (%eax),%eax
c010720e:	89 04 24             	mov    %eax,(%esp)
c0107211:	e8 b7 bc ff ff       	call   c0102ecd <strlen>
c0107216:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107219:	01 d0                	add    %edx,%eax
c010721b:	83 c0 01             	add    $0x1,%eax
c010721e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        inode = inode->parent;
c0107221:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107224:	8b 40 38             	mov    0x38(%eax),%eax
c0107227:	89 45 ec             	mov    %eax,-0x14(%ebp)
    //int currentend = 0;
    int cwdsize = 0;				// the final size of the final '\0'

    vfs_inode_t *inode = current_thread->process->cwd;

    while(inode != root)
c010722a:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c010722f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0107232:	75 d5                	jne    c0107209 <sys_getcwd+0x32>
    {
        cwdsize += strlen((char*)inode->name) + 1;
        inode = inode->parent;
    }

    if(buffer == NULL)
c0107234:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0107238:	75 11                	jne    c010724b <sys_getcwd+0x74>
    {
        (*cpu)->CPU_ARG0 = 0;
c010723a:	8b 45 08             	mov    0x8(%ebp),%eax
c010723d:	8b 00                	mov    (%eax),%eax
c010723f:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        return;
c0107246:	e9 c1 00 00 00       	jmp    c010730c <sys_getcwd+0x135>
    }

    if(buffersize < cwdsize)
c010724b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010724e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0107251:	7d 11                	jge    c0107264 <sys_getcwd+0x8d>
    {
        (*cpu)->CPU_ARG0 = 0;
c0107253:	8b 45 08             	mov    0x8(%ebp),%eax
c0107256:	8b 00                	mov    (%eax),%eax
c0107258:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        return;
c010725f:	e9 a8 00 00 00       	jmp    c010730c <sys_getcwd+0x135>
    }

    memset(buffer, 0, buffersize);
c0107264:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107267:	89 44 24 08          	mov    %eax,0x8(%esp)
c010726b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0107272:	00 
c0107273:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107276:	89 04 24             	mov    %eax,(%esp)
c0107279:	e8 9b c1 ff ff       	call   c0103419 <memset>
    if(cwdsize > 0)
c010727e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0107282:	7e 74                	jle    c01072f8 <sys_getcwd+0x121>
    {
        buffer += cwdsize+1;
c0107284:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107287:	83 c0 01             	add    $0x1,%eax
c010728a:	01 45 f4             	add    %eax,-0xc(%ebp)
        *--buffer = '\0';
c010728d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0107291:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107294:	c6 00 00             	movb   $0x0,(%eax)

        inode = current_thread->process->cwd;
c0107297:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010729c:	8b 00                	mov    (%eax),%eax
c010729e:	8b 40 14             	mov    0x14(%eax),%eax
c01072a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
        while(inode != root)
c01072a4:	eb 46                	jmp    c01072ec <sys_getcwd+0x115>
        {
            int len = strlen((char*)inode->name);
c01072a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01072a9:	8b 00                	mov    (%eax),%eax
c01072ab:	89 04 24             	mov    %eax,(%esp)
c01072ae:	e8 1a bc ff ff       	call   c0102ecd <strlen>
c01072b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            buffer -= len;
c01072b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01072b9:	f7 d8                	neg    %eax
c01072bb:	01 45 f4             	add    %eax,-0xc(%ebp)
            memcpy(buffer, inode->name, len);
c01072be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01072c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01072c4:	8b 00                	mov    (%eax),%eax
c01072c6:	89 54 24 08          	mov    %edx,0x8(%esp)
c01072ca:	89 44 24 04          	mov    %eax,0x4(%esp)
c01072ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072d1:	89 04 24             	mov    %eax,(%esp)
c01072d4:	e8 ca bf ff ff       	call   c01032a3 <memcpy>
            *--buffer = '/';
c01072d9:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c01072dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072e0:	c6 00 2f             	movb   $0x2f,(%eax)
            inode = inode->parent;
c01072e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01072e6:	8b 40 38             	mov    0x38(%eax),%eax
c01072e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    {
        buffer += cwdsize+1;
        *--buffer = '\0';

        inode = current_thread->process->cwd;
        while(inode != root)
c01072ec:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c01072f1:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c01072f4:	75 b0                	jne    c01072a6 <sys_getcwd+0xcf>
c01072f6:	eb 08                	jmp    c0107300 <sys_getcwd+0x129>
            inode = inode->parent;
        }
    }
    else
    {
        strcpy(buffer,"/");
c01072f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072fb:	66 c7 00 2f 00       	movw   $0x2f,(%eax)
    }

    (*cpu)->CPU_ARG0 =(unsigned int) buffer;
c0107300:	8b 45 08             	mov    0x8(%ebp),%eax
c0107303:	8b 00                	mov    (%eax),%eax
c0107305:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107308:	89 50 28             	mov    %edx,0x28(%eax)
    return;
c010730b:	90                   	nop
}
c010730c:	c9                   	leave  
c010730d:	c3                   	ret    

c010730e <sys_seek>:
extern struct thread_state *current_thread;
extern vfs_inode_t *root;

// Systemcalls
void sys_seek(struct cpu_state **cpu)
{
c010730e:	55                   	push   %ebp
c010730f:	89 e5                	mov    %esp,%ebp
c0107311:	83 ec 28             	sub    $0x28,%esp
    int fd = (*cpu)->CPU_ARG1;
c0107314:	8b 45 08             	mov    0x8(%ebp),%eax
c0107317:	8b 00                	mov    (%eax),%eax
c0107319:	8b 40 1c             	mov    0x1c(%eax),%eax
c010731c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int off = (*cpu)->CPU_ARG2;
c010731f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107322:	8b 00                	mov    (%eax),%eax
c0107324:	8b 40 24             	mov    0x24(%eax),%eax
c0107327:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int whence = (*cpu)->CPU_ARG3;
c010732a:	8b 45 08             	mov    0x8(%ebp),%eax
c010732d:	8b 00                	mov    (%eax),%eax
c010732f:	8b 40 20             	mov    0x20(%eax),%eax
c0107332:	89 45 ec             	mov    %eax,-0x14(%ebp)

    struct fd *file = get_fd(current_thread->process, fd);
c0107335:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010733a:	8b 00                	mov    (%eax),%eax
c010733c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010733f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107343:	89 04 24             	mov    %eax,(%esp)
c0107346:	e8 a4 f6 ff ff       	call   c01069ef <get_fd>
c010734b:	89 45 e8             	mov    %eax,-0x18(%ebp)

    switch(whence)
c010734e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107351:	83 f8 02             	cmp    $0x2,%eax
c0107354:	74 22                	je     c0107378 <sys_seek+0x6a>
c0107356:	83 f8 03             	cmp    $0x3,%eax
c0107359:	74 41                	je     c010739c <sys_seek+0x8e>
c010735b:	83 f8 01             	cmp    $0x1,%eax
c010735e:	0f 85 82 00 00 00    	jne    c01073e6 <sys_seek+0xd8>
    {
        case SEEK_SET: // absolute
            file->read_pos = off;
c0107364:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107367:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010736a:	89 50 18             	mov    %edx,0x18(%eax)
            file->write_pos = off;
c010736d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107370:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107373:	89 50 1c             	mov    %edx,0x1c(%eax)
            break;
c0107376:	eb 7d                	jmp    c01073f5 <sys_seek+0xe7>
        case SEEK_CUR: // relative from current position
            file->read_pos += off;
c0107378:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010737b:	8b 50 18             	mov    0x18(%eax),%edx
c010737e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107381:	01 c2                	add    %eax,%edx
c0107383:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107386:	89 50 18             	mov    %edx,0x18(%eax)
            file->write_pos += off;
c0107389:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010738c:	8b 50 1c             	mov    0x1c(%eax),%edx
c010738f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107392:	01 c2                	add    %eax,%edx
c0107394:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107397:	89 50 1c             	mov    %edx,0x1c(%eax)
            break;
c010739a:	eb 59                	jmp    c01073f5 <sys_seek+0xe7>
        case SEEK_END: // relative from end
            if(file->read_inode != NULL)
c010739c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010739f:	8b 40 10             	mov    0x10(%eax),%eax
c01073a2:	85 c0                	test   %eax,%eax
c01073a4:	74 1a                	je     c01073c0 <sys_seek+0xb2>
                file->read_pos = file->read_inode->length - off;
c01073a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01073a9:	8b 40 10             	mov    0x10(%eax),%eax
c01073ac:	8b 50 08             	mov    0x8(%eax),%edx
c01073af:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01073b2:	89 d1                	mov    %edx,%ecx
c01073b4:	29 c1                	sub    %eax,%ecx
c01073b6:	89 c8                	mov    %ecx,%eax
c01073b8:	89 c2                	mov    %eax,%edx
c01073ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01073bd:	89 50 18             	mov    %edx,0x18(%eax)
            if(file->write_inode != NULL)
c01073c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01073c3:	8b 40 14             	mov    0x14(%eax),%eax
c01073c6:	85 c0                	test   %eax,%eax
c01073c8:	74 2a                	je     c01073f4 <sys_seek+0xe6>
                file->write_pos = file->write_inode->length - off;
c01073ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01073cd:	8b 40 14             	mov    0x14(%eax),%eax
c01073d0:	8b 50 08             	mov    0x8(%eax),%edx
c01073d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01073d6:	89 d1                	mov    %edx,%ecx
c01073d8:	29 c1                	sub    %eax,%ecx
c01073da:	89 c8                	mov    %ecx,%eax
c01073dc:	89 c2                	mov    %eax,%edx
c01073de:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01073e1:	89 50 1c             	mov    %edx,0x1c(%eax)
            break;
c01073e4:	eb 0e                	jmp    c01073f4 <sys_seek+0xe6>
        default: // ???
            (*cpu)->CPU_ARG0 = _FAILURE;
c01073e6:	8b 45 08             	mov    0x8(%ebp),%eax
c01073e9:	8b 00                	mov    (%eax),%eax
c01073eb:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
            return;
c01073f2:	eb 0f                	jmp    c0107403 <sys_seek+0xf5>
        case SEEK_END: // relative from end
            if(file->read_inode != NULL)
                file->read_pos = file->read_inode->length - off;
            if(file->write_inode != NULL)
                file->write_pos = file->write_inode->length - off;
            break;
c01073f4:	90                   	nop
        default: // ???
            (*cpu)->CPU_ARG0 = _FAILURE;
            return;
    }

    (*cpu)->CPU_ARG0 = file->read_pos;
c01073f5:	8b 45 08             	mov    0x8(%ebp),%eax
c01073f8:	8b 00                	mov    (%eax),%eax
c01073fa:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01073fd:	8b 52 18             	mov    0x18(%edx),%edx
c0107400:	89 50 28             	mov    %edx,0x28(%eax)
}
c0107403:	c9                   	leave  
c0107404:	c3                   	ret    

c0107405 <sys_stat>:

void sys_stat(struct cpu_state **cpu)
{
c0107405:	55                   	push   %ebp
c0107406:	89 e5                	mov    %esp,%ebp
c0107408:	83 ec 28             	sub    $0x28,%esp
    if((*cpu)->CPU_ARG1 == 0 || (*cpu)->CPU_ARG2 == 0)
c010740b:	8b 45 08             	mov    0x8(%ebp),%eax
c010740e:	8b 00                	mov    (%eax),%eax
c0107410:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107413:	85 c0                	test   %eax,%eax
c0107415:	74 0c                	je     c0107423 <sys_stat+0x1e>
c0107417:	8b 45 08             	mov    0x8(%ebp),%eax
c010741a:	8b 00                	mov    (%eax),%eax
c010741c:	8b 40 24             	mov    0x24(%eax),%eax
c010741f:	85 c0                	test   %eax,%eax
c0107421:	75 0e                	jne    c0107431 <sys_stat+0x2c>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107423:	8b 45 08             	mov    0x8(%ebp),%eax
c0107426:	8b 00                	mov    (%eax),%eax
c0107428:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c010742f:	eb 55                	jmp    c0107486 <sys_stat+0x81>
    }

    vfs_inode_t *node = vfs_lookup_path((char*)(*cpu)->CPU_ARG1);
c0107431:	8b 45 08             	mov    0x8(%ebp),%eax
c0107434:	8b 00                	mov    (%eax),%eax
c0107436:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107439:	89 04 24             	mov    %eax,(%esp)
c010743c:	e8 60 16 00 00       	call   c0108aa1 <vfs_lookup_path>
c0107441:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(node == NULL)
c0107444:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0107448:	75 0e                	jne    c0107458 <sys_stat+0x53>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c010744a:	8b 45 08             	mov    0x8(%ebp),%eax
c010744d:	8b 00                	mov    (%eax),%eax
c010744f:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0107456:	eb 2e                	jmp    c0107486 <sys_stat+0x81>
    }

    memcpy((void *)(*cpu)->CPU_ARG2, (void*) &node->stat, sizeof(struct stat));
c0107458:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010745b:	8d 50 0c             	lea    0xc(%eax),%edx
c010745e:	8b 45 08             	mov    0x8(%ebp),%eax
c0107461:	8b 00                	mov    (%eax),%eax
c0107463:	8b 40 24             	mov    0x24(%eax),%eax
c0107466:	c7 44 24 08 2c 00 00 	movl   $0x2c,0x8(%esp)
c010746d:	00 
c010746e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107472:	89 04 24             	mov    %eax,(%esp)
c0107475:	e8 29 be ff ff       	call   c01032a3 <memcpy>
    (*cpu)->CPU_ARG0 = 0;
c010747a:	8b 45 08             	mov    0x8(%ebp),%eax
c010747d:	8b 00                	mov    (%eax),%eax
c010747f:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
}
c0107486:	c9                   	leave  
c0107487:	c3                   	ret    

c0107488 <sys_fstat>:


void sys_fstat(struct cpu_state **cpu)
{
c0107488:	55                   	push   %ebp
c0107489:	89 e5                	mov    %esp,%ebp
c010748b:	83 ec 28             	sub    $0x28,%esp
    if((*cpu)->CPU_ARG1 == 0)
c010748e:	8b 45 08             	mov    0x8(%ebp),%eax
c0107491:	8b 00                	mov    (%eax),%eax
c0107493:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107496:	85 c0                	test   %eax,%eax
c0107498:	75 11                	jne    c01074ab <sys_fstat+0x23>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c010749a:	8b 45 08             	mov    0x8(%ebp),%eax
c010749d:	8b 00                	mov    (%eax),%eax
c010749f:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
c01074a6:	e9 b0 00 00 00       	jmp    c010755b <sys_fstat+0xd3>
        return;
    }

    iterator_t file_it = iterator_create(current_thread->process->files);
c01074ab:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01074b0:	8b 00                	mov    (%eax),%eax
c01074b2:	8b 50 18             	mov    0x18(%eax),%edx
c01074b5:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01074b8:	89 54 24 04          	mov    %edx,0x4(%esp)
c01074bc:	89 04 24             	mov    %eax,(%esp)
c01074bf:	e8 27 b8 ff ff       	call   c0102ceb <iterator_create>
c01074c4:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_empty(current_thread->process->files) && !list_is_last(&file_it))
c01074c7:	eb 5d                	jmp    c0107526 <sys_fstat+0x9e>
    {
        struct fd *file = list_get_current(&file_it);
c01074c9:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01074cc:	89 04 24             	mov    %eax,(%esp)
c01074cf:	e8 e0 b8 ff ff       	call   c0102db4 <list_get_current>
c01074d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(file->id == (*cpu)->CPU_ARG1)
c01074d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01074da:	8b 10                	mov    (%eax),%edx
c01074dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01074df:	8b 00                	mov    (%eax),%eax
c01074e1:	8b 40 1c             	mov    0x1c(%eax),%eax
c01074e4:	39 c2                	cmp    %eax,%edx
c01074e6:	75 33                	jne    c010751b <sys_fstat+0x93>
        {
            memcpy((void *)(*cpu)->CPU_ARG2, (void*) &file->read_inode->stat, sizeof(struct stat));
c01074e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01074eb:	8b 40 10             	mov    0x10(%eax),%eax
c01074ee:	8d 50 0c             	lea    0xc(%eax),%edx
c01074f1:	8b 45 08             	mov    0x8(%ebp),%eax
c01074f4:	8b 00                	mov    (%eax),%eax
c01074f6:	8b 40 24             	mov    0x24(%eax),%eax
c01074f9:	c7 44 24 08 2c 00 00 	movl   $0x2c,0x8(%esp)
c0107500:	00 
c0107501:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107505:	89 04 24             	mov    %eax,(%esp)
c0107508:	e8 96 bd ff ff       	call   c01032a3 <memcpy>
            (*cpu)->CPU_ARG0 = 0;
c010750d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107510:	8b 00                	mov    (%eax),%eax
c0107512:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0107519:	eb 40                	jmp    c010755b <sys_fstat+0xd3>
            return;
        }
        list_next(&file_it);
c010751b:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010751e:	89 04 24             	mov    %eax,(%esp)
c0107521:	e8 b3 b8 ff ff       	call   c0102dd9 <list_next>
        (*cpu)->CPU_ARG0 = _FAILURE;
        return;
    }

    iterator_t file_it = iterator_create(current_thread->process->files);
    while(!list_is_empty(current_thread->process->files) && !list_is_last(&file_it))
c0107526:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010752b:	8b 00                	mov    (%eax),%eax
c010752d:	8b 40 18             	mov    0x18(%eax),%eax
c0107530:	89 04 24             	mov    %eax,(%esp)
c0107533:	e8 72 b7 ff ff       	call   c0102caa <list_is_empty>
c0107538:	85 c0                	test   %eax,%eax
c010753a:	75 13                	jne    c010754f <sys_fstat+0xc7>
c010753c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010753f:	89 04 24             	mov    %eax,(%esp)
c0107542:	e8 b9 b8 ff ff       	call   c0102e00 <list_is_last>
c0107547:	85 c0                	test   %eax,%eax
c0107549:	0f 84 7a ff ff ff    	je     c01074c9 <sys_fstat+0x41>
            return;
        }
        list_next(&file_it);
    }

    (*cpu)->CPU_ARG0 = _FAILURE;
c010754f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107552:	8b 00                	mov    (%eax),%eax
c0107554:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
}
c010755b:	c9                   	leave  
c010755c:	c3                   	ret    

c010755d <sys_chmod>:

void sys_chmod(struct cpu_state **cpu)
{
c010755d:	55                   	push   %ebp
c010755e:	89 e5                	mov    %esp,%ebp
c0107560:	83 ec 28             	sub    $0x28,%esp
    // Check if path is not NULL
    char *file = (char *)(*cpu)->CPU_ARG1;
c0107563:	8b 45 08             	mov    0x8(%ebp),%eax
c0107566:	8b 00                	mov    (%eax),%eax
c0107568:	8b 40 1c             	mov    0x1c(%eax),%eax
c010756b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(file == NULL)
c010756e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0107572:	75 0e                	jne    c0107582 <sys_chmod+0x25>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107574:	8b 45 08             	mov    0x8(%ebp),%eax
c0107577:	8b 00                	mov    (%eax),%eax
c0107579:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0107580:	eb 5e                	jmp    c01075e0 <sys_chmod+0x83>
    }
    // Lookup path
    vfs_inode_t *node = vfs_lookup_path(file);
c0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107585:	89 04 24             	mov    %eax,(%esp)
c0107588:	e8 14 15 00 00       	call   c0108aa1 <vfs_lookup_path>
c010758d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(node == NULL)
c0107590:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0107594:	75 0e                	jne    c01075a4 <sys_chmod+0x47>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107596:	8b 45 08             	mov    0x8(%ebp),%eax
c0107599:	8b 00                	mov    (%eax),%eax
c010759b:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c01075a2:	eb 3c                	jmp    c01075e0 <sys_chmod+0x83>
    }
    // Check permissions
    if(node->stat.st_uid != current_thread->process->uid)
c01075a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01075a7:	8b 50 18             	mov    0x18(%eax),%edx
c01075aa:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01075af:	8b 00                	mov    (%eax),%eax
c01075b1:	8b 40 04             	mov    0x4(%eax),%eax
c01075b4:	39 c2                	cmp    %eax,%edx
c01075b6:	74 0e                	je     c01075c6 <sys_chmod+0x69>
    {
        (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c01075b8:	8b 45 08             	mov    0x8(%ebp),%eax
c01075bb:	8b 00                	mov    (%eax),%eax
c01075bd:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
        return;
c01075c4:	eb 1a                	jmp    c01075e0 <sys_chmod+0x83>
    }
    // change mode
    node->stat.st_mode = (*cpu)->CPU_ARG2;
c01075c6:	8b 45 08             	mov    0x8(%ebp),%eax
c01075c9:	8b 00                	mov    (%eax),%eax
c01075cb:	8b 50 24             	mov    0x24(%eax),%edx
c01075ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01075d1:	89 50 0c             	mov    %edx,0xc(%eax)
    (*cpu)->CPU_ARG0 = _SUCCESS;
c01075d4:	8b 45 08             	mov    0x8(%ebp),%eax
c01075d7:	8b 00                	mov    (%eax),%eax
c01075d9:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
}
c01075e0:	c9                   	leave  
c01075e1:	c3                   	ret    

c01075e2 <sys_rename>:


void sys_rename(struct cpu_state **cpu)
{
c01075e2:	55                   	push   %ebp
c01075e3:	89 e5                	mov    %esp,%ebp
c01075e5:	83 ec 38             	sub    $0x38,%esp
    // Check if path is not NULL
    char *file = (char *)(*cpu)->CPU_ARG1;
c01075e8:	8b 45 08             	mov    0x8(%ebp),%eax
c01075eb:	8b 00                	mov    (%eax),%eax
c01075ed:	8b 40 1c             	mov    0x1c(%eax),%eax
c01075f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char *new_filename = (char *)(*cpu)->CPU_ARG2;
c01075f3:	8b 45 08             	mov    0x8(%ebp),%eax
c01075f6:	8b 00                	mov    (%eax),%eax
c01075f8:	8b 40 24             	mov    0x24(%eax),%eax
c01075fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(file == NULL)
c01075fe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0107602:	75 11                	jne    c0107615 <sys_rename+0x33>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107604:	8b 45 08             	mov    0x8(%ebp),%eax
c0107607:	8b 00                	mov    (%eax),%eax
c0107609:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0107610:	e9 ca 00 00 00       	jmp    c01076df <sys_rename+0xfd>
    }

    // Lookup path
    vfs_inode_t *node = vfs_lookup_path(file);
c0107615:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107618:	89 04 24             	mov    %eax,(%esp)
c010761b:	e8 81 14 00 00       	call   c0108aa1 <vfs_lookup_path>
c0107620:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(node == NULL)
c0107623:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0107627:	75 11                	jne    c010763a <sys_rename+0x58>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107629:	8b 45 08             	mov    0x8(%ebp),%eax
c010762c:	8b 00                	mov    (%eax),%eax
c010762e:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0107635:	e9 a5 00 00 00       	jmp    c01076df <sys_rename+0xfd>
    }

    if(vfs_access(node, W_OK, current_thread->process->uid, current_thread->process->gid) != 0)
c010763a:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010763f:	8b 00                	mov    (%eax),%eax
c0107641:	8b 50 08             	mov    0x8(%eax),%edx
c0107644:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107649:	8b 00                	mov    (%eax),%eax
c010764b:	8b 40 04             	mov    0x4(%eax),%eax
c010764e:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0107652:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107656:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c010765d:	00 
c010765e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107661:	89 04 24             	mov    %eax,(%esp)
c0107664:	e8 43 eb ff ff       	call   c01061ac <vfs_access>
c0107669:	85 c0                	test   %eax,%eax
c010766b:	74 0e                	je     c010767b <sys_rename+0x99>
    {
        (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c010766d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107670:	8b 00                	mov    (%eax),%eax
c0107672:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
        return;
c0107679:	eb 64                	jmp    c01076df <sys_rename+0xfd>
    }

    //creante new namebuffer
    size_t bufferlen = strlen(new_filename);
c010767b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010767e:	89 04 24             	mov    %eax,(%esp)
c0107681:	e8 47 b8 ff ff       	call   c0102ecd <strlen>
c0107686:	89 45 e8             	mov    %eax,-0x18(%ebp)
    char *namebuffer = (char *) malloc(bufferlen+1); // bufferlen + zero terminator
c0107689:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010768c:	83 c0 01             	add    $0x1,%eax
c010768f:	89 04 24             	mov    %eax,(%esp)
c0107692:	e8 ae 48 00 00       	call   c010bf45 <malloc>
c0107697:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    namebuffer[bufferlen] = '\0';
c010769a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010769d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01076a0:	01 d0                	add    %edx,%eax
c01076a2:	c6 00 00             	movb   $0x0,(%eax)
    strncpy(namebuffer,new_filename,bufferlen);
c01076a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01076a8:	89 44 24 08          	mov    %eax,0x8(%esp)
c01076ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01076af:	89 44 24 04          	mov    %eax,0x4(%esp)
c01076b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01076b6:	89 04 24             	mov    %eax,(%esp)
c01076b9:	e8 87 b8 ff ff       	call   c0102f45 <strncpy>
    free(node->name);
c01076be:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01076c1:	8b 00                	mov    (%eax),%eax
c01076c3:	89 04 24             	mov    %eax,(%esp)
c01076c6:	e8 88 49 00 00       	call   c010c053 <free>
    node->name = namebuffer;
c01076cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01076ce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01076d1:	89 10                	mov    %edx,(%eax)

    (*cpu)->CPU_ARG0 = _SUCCESS;
c01076d3:	8b 45 08             	mov    0x8(%ebp),%eax
c01076d6:	8b 00                	mov    (%eax),%eax
c01076d8:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
}
c01076df:	c9                   	leave  
c01076e0:	c3                   	ret    

c01076e1 <sys_lchown>:

void sys_lchown(struct cpu_state **cpu)
{
c01076e1:	55                   	push   %ebp
c01076e2:	89 e5                	mov    %esp,%ebp
c01076e4:	83 ec 28             	sub    $0x28,%esp
    char *file = (char *)(*cpu)->CPU_ARG1;
c01076e7:	8b 45 08             	mov    0x8(%ebp),%eax
c01076ea:	8b 00                	mov    (%eax),%eax
c01076ec:	8b 40 1c             	mov    0x1c(%eax),%eax
c01076ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(file == NULL)
c01076f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01076f6:	75 11                	jne    c0107709 <sys_lchown+0x28>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c01076f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01076fb:	8b 00                	mov    (%eax),%eax
c01076fd:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0107704:	e9 93 00 00 00       	jmp    c010779c <sys_lchown+0xbb>
    }
    // Lookup path
    vfs_inode_t *node = vfs_lookup_path(file);
c0107709:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010770c:	89 04 24             	mov    %eax,(%esp)
c010770f:	e8 8d 13 00 00       	call   c0108aa1 <vfs_lookup_path>
c0107714:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(node == NULL)
c0107717:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010771b:	75 0e                	jne    c010772b <sys_lchown+0x4a>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c010771d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107720:	8b 00                	mov    (%eax),%eax
c0107722:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0107729:	eb 71                	jmp    c010779c <sys_lchown+0xbb>
    }
    // Check permissions
    if(node->stat.st_uid != current_thread->process->uid || current_thread->process->uid == 0)
c010772b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010772e:	8b 50 18             	mov    0x18(%eax),%edx
c0107731:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107736:	8b 00                	mov    (%eax),%eax
c0107738:	8b 40 04             	mov    0x4(%eax),%eax
c010773b:	39 c2                	cmp    %eax,%edx
c010773d:	75 0e                	jne    c010774d <sys_lchown+0x6c>
c010773f:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107744:	8b 00                	mov    (%eax),%eax
c0107746:	8b 40 04             	mov    0x4(%eax),%eax
c0107749:	85 c0                	test   %eax,%eax
c010774b:	75 0e                	jne    c010775b <sys_lchown+0x7a>
    {
        (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c010774d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107750:	8b 00                	mov    (%eax),%eax
c0107752:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
        return;
c0107759:	eb 41                	jmp    c010779c <sys_lchown+0xbb>
    }

    // do to follow link
    if(node->type == VFS_LINK)
c010775b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010775e:	8b 40 04             	mov    0x4(%eax),%eax
c0107761:	83 f8 03             	cmp    $0x3,%eax
c0107764:	75 0e                	jne    c0107774 <sys_lchown+0x93>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107766:	8b 45 08             	mov    0x8(%ebp),%eax
c0107769:	8b 00                	mov    (%eax),%eax
c010776b:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0107772:	eb 28                	jmp    c010779c <sys_lchown+0xbb>
    }

    // TODO: change  the  permissions in filedescriptors
    node->stat.st_uid = (uid_t) (*cpu)->CPU_ARG2;
c0107774:	8b 45 08             	mov    0x8(%ebp),%eax
c0107777:	8b 00                	mov    (%eax),%eax
c0107779:	8b 50 24             	mov    0x24(%eax),%edx
c010777c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010777f:	89 50 18             	mov    %edx,0x18(%eax)
    node->stat.st_gid = (gid_t) (*cpu)->CPU_ARG3;
c0107782:	8b 45 08             	mov    0x8(%ebp),%eax
c0107785:	8b 00                	mov    (%eax),%eax
c0107787:	8b 50 20             	mov    0x20(%eax),%edx
c010778a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010778d:	89 50 1c             	mov    %edx,0x1c(%eax)
    (*cpu)->CPU_ARG0 = _SUCCESS;
c0107790:	8b 45 08             	mov    0x8(%ebp),%eax
c0107793:	8b 00                	mov    (%eax),%eax
c0107795:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
}
c010779c:	c9                   	leave  
c010779d:	c3                   	ret    

c010779e <sys_access>:

void sys_access(struct cpu_state **cpu)
{
c010779e:	55                   	push   %ebp
c010779f:	89 e5                	mov    %esp,%ebp
c01077a1:	53                   	push   %ebx
c01077a2:	83 ec 24             	sub    $0x24,%esp
    char *file = (char *) (*cpu)->CPU_ARG1;
c01077a5:	8b 45 08             	mov    0x8(%ebp),%eax
c01077a8:	8b 00                	mov    (%eax),%eax
c01077aa:	8b 40 1c             	mov    0x1c(%eax),%eax
c01077ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
    mode_t mode = (mode_t) (*cpu)->CPU_ARG2;
c01077b0:	8b 45 08             	mov    0x8(%ebp),%eax
c01077b3:	8b 00                	mov    (%eax),%eax
c01077b5:	8b 40 24             	mov    0x24(%eax),%eax
c01077b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(file == NULL)
c01077bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01077bf:	75 0e                	jne    c01077cf <sys_access+0x31>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c01077c1:	8b 45 08             	mov    0x8(%ebp),%eax
c01077c4:	8b 00                	mov    (%eax),%eax
c01077c6:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c01077cd:	eb 58                	jmp    c0107827 <sys_access+0x89>
    }

    vfs_inode_t *node = vfs_lookup_path(file);
c01077cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01077d2:	89 04 24             	mov    %eax,(%esp)
c01077d5:	e8 c7 12 00 00       	call   c0108aa1 <vfs_lookup_path>
c01077da:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(node == NULL)
c01077dd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c01077e1:	75 0e                	jne    c01077f1 <sys_access+0x53>
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c01077e3:	8b 45 08             	mov    0x8(%ebp),%eax
c01077e6:	8b 00                	mov    (%eax),%eax
c01077e8:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c01077ef:	eb 36                	jmp    c0107827 <sys_access+0x89>
    }

    (*cpu)->CPU_ARG0 = vfs_access(node, mode, current_thread->process->uid, current_thread->process->gid);
c01077f1:	8b 45 08             	mov    0x8(%ebp),%eax
c01077f4:	8b 18                	mov    (%eax),%ebx
c01077f6:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01077fb:	8b 00                	mov    (%eax),%eax
c01077fd:	8b 50 08             	mov    0x8(%eax),%edx
c0107800:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107805:	8b 00                	mov    (%eax),%eax
c0107807:	8b 40 04             	mov    0x4(%eax),%eax
c010780a:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010780e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0107812:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107815:	89 44 24 04          	mov    %eax,0x4(%esp)
c0107819:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010781c:	89 04 24             	mov    %eax,(%esp)
c010781f:	e8 88 e9 ff ff       	call   c01061ac <vfs_access>
c0107824:	89 43 28             	mov    %eax,0x28(%ebx)
}
c0107827:	83 c4 24             	add    $0x24,%esp
c010782a:	5b                   	pop    %ebx
c010782b:	5d                   	pop    %ebp
c010782c:	c3                   	ret    

c010782d <sys_pipe>:
extern struct thread_state *current_thread;
extern vfs_inode_t *root;


void sys_pipe(struct cpu_state **cpu)
{
c010782d:	55                   	push   %ebp
c010782e:	89 e5                	mov    %esp,%ebp
c0107830:	83 ec 28             	sub    $0x28,%esp
    int *id = (int *) (*cpu)->CPU_ARG1;
c0107833:	8b 45 08             	mov    0x8(%ebp),%eax
c0107836:	8b 00                	mov    (%eax),%eax
c0107838:	8b 40 1c             	mov    0x1c(%eax),%eax
c010783b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    vfs_inode_t *inode = vfs_create_pipe(current_thread->process->uid, current_thread->process->gid);
c010783e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107843:	8b 00                	mov    (%eax),%eax
c0107845:	8b 50 08             	mov    0x8(%eax),%edx
c0107848:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010784d:	8b 00                	mov    (%eax),%eax
c010784f:	8b 40 04             	mov    0x4(%eax),%eax
c0107852:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107856:	89 04 24             	mov    %eax,(%esp)
c0107859:	e8 9c e7 ff ff       	call   c0105ffa <vfs_create_pipe>
c010785e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // create read channel
    struct fd *desc0 = create_fd(current_thread->process);
c0107861:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107866:	8b 00                	mov    (%eax),%eax
c0107868:	89 04 24             	mov    %eax,(%esp)
c010786b:	e8 a4 f1 ff ff       	call   c0106a14 <create_fd>
c0107870:	89 45 ec             	mov    %eax,-0x14(%ebp)
    id[0] = desc0->id;
c0107873:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107876:	8b 00                	mov    (%eax),%eax
c0107878:	89 c2                	mov    %eax,%edx
c010787a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010787d:	89 10                	mov    %edx,(%eax)
    desc0->mode = O_APPEND;
c010787f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107882:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
    desc0->flags = O_RDONLY;
c0107889:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010788c:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
    desc0->permission =  VFS_PERMISSION_READ;
c0107893:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107896:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    desc0->read_inode = inode;
c010789d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01078a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01078a3:	89 50 10             	mov    %edx,0x10(%eax)

    // create write channel
    struct fd *desc1 = create_fd(current_thread->process);
c01078a6:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01078ab:	8b 00                	mov    (%eax),%eax
c01078ad:	89 04 24             	mov    %eax,(%esp)
c01078b0:	e8 5f f1 ff ff       	call   c0106a14 <create_fd>
c01078b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    id[1] = desc1->id;
c01078b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01078bb:	8d 50 04             	lea    0x4(%eax),%edx
c01078be:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01078c1:	8b 00                	mov    (%eax),%eax
c01078c3:	89 02                	mov    %eax,(%edx)
    desc1->mode = O_APPEND;
c01078c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01078c8:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
    desc1->flags = O_WRONLY;
c01078cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01078d2:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
    desc1->permission = VFS_PERMISSION_WRITE;
c01078d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01078dc:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
    desc1->write_inode = inode;
c01078e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01078e6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01078e9:	89 50 14             	mov    %edx,0x14(%eax)
    list_push_back(current_thread->process->files, desc1);
c01078ec:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c01078f1:	8b 00                	mov    (%eax),%eax
c01078f3:	8b 40 18             	mov    0x18(%eax),%eax
c01078f6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01078f9:	89 54 24 04          	mov    %edx,0x4(%esp)
c01078fd:	89 04 24             	mov    %eax,(%esp)
c0107900:	e8 5a b1 ff ff       	call   c0102a5f <list_push_back>

    //printf("kernel: piieeepe %d %d\n", desc0->id, desc1->id);

    if(desc0 != NULL && desc1 != NULL && inode != NULL)
c0107905:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0107909:	74 1a                	je     c0107925 <sys_pipe+0xf8>
c010790b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010790f:	74 14                	je     c0107925 <sys_pipe+0xf8>
c0107911:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0107915:	74 0e                	je     c0107925 <sys_pipe+0xf8>
    {
        (*cpu)->CPU_ARG0 = _SUCCESS;
c0107917:	8b 45 08             	mov    0x8(%ebp),%eax
c010791a:	8b 00                	mov    (%eax),%eax
c010791c:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0107923:	eb 0c                	jmp    c0107931 <sys_pipe+0x104>
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107925:	8b 45 08             	mov    0x8(%ebp),%eax
c0107928:	8b 00                	mov    (%eax),%eax
c010792a:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c0107931:	c9                   	leave  
c0107932:	c3                   	ret    

c0107933 <set_pipe_trigger>:


void set_pipe_trigger(struct cpu_state **cpu)
{
c0107933:	55                   	push   %ebp
c0107934:	89 e5                	mov    %esp,%ebp
c0107936:	83 ec 28             	sub    $0x28,%esp
    int fd = (*cpu)->CPU_ARG1;
c0107939:	8b 45 08             	mov    0x8(%ebp),%eax
c010793c:	8b 00                	mov    (%eax),%eax
c010793e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107941:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct fd *desc = get_fd(current_thread->process, fd);
c0107944:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107949:	8b 00                	mov    (%eax),%eax
c010794b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010794e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107952:	89 04 24             	mov    %eax,(%esp)
c0107955:	e8 95 f0 ff ff       	call   c01069ef <get_fd>
c010795a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    vfs_inode_t *inode = desc->read_inode;
c010795d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107960:	8b 40 10             	mov    0x10(%eax),%eax
c0107963:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(desc->permission & VFS_PERMISSION_READ)
c0107966:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107969:	8b 40 0c             	mov    0xc(%eax),%eax
c010796c:	83 e0 01             	and    $0x1,%eax
c010796f:	85 c0                	test   %eax,%eax
c0107971:	74 6f                	je     c01079e2 <set_pipe_trigger+0xaf>
    {
        //block_buffer_info_t *pipe = inode->read_buffer;

        vfs_pipe_trigger_t *trigger = malloc(sizeof(vfs_pipe_trigger_t));
c0107973:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c010797a:	e8 c6 45 00 00       	call   c010bf45 <malloc>
c010797f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        trigger->eip = (*cpu)->CPU_ARG2;
c0107982:	8b 45 08             	mov    0x8(%ebp),%eax
c0107985:	8b 00                	mov    (%eax),%eax
c0107987:	8b 50 24             	mov    0x24(%eax),%edx
c010798a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010798d:	89 10                	mov    %edx,(%eax)
        trigger->argc = (*cpu)->CPU_ARG3;
c010798f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107992:	8b 00                	mov    (%eax),%eax
c0107994:	8b 40 20             	mov    0x20(%eax),%eax
c0107997:	89 c2                	mov    %eax,%edx
c0107999:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010799c:	89 50 04             	mov    %edx,0x4(%eax)
        trigger->argv = (char**)(*cpu)->CPU_ARG4;
c010799f:	8b 45 08             	mov    0x8(%ebp),%eax
c01079a2:	8b 00                	mov    (%eax),%eax
c01079a4:	8b 40 14             	mov    0x14(%eax),%eax
c01079a7:	89 c2                	mov    %eax,%edx
c01079a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01079ac:	89 50 08             	mov    %edx,0x8(%eax)
        trigger->environ = (char**)(*cpu)->CPU_ARG5;
c01079af:	8b 45 08             	mov    0x8(%ebp),%eax
c01079b2:	8b 00                	mov    (%eax),%eax
c01079b4:	8b 40 10             	mov    0x10(%eax),%eax
c01079b7:	89 c2                	mov    %eax,%edx
c01079b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01079bc:	89 50 0c             	mov    %edx,0xc(%eax)
        list_push_back(inode->handlers, (void*) trigger);
c01079bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01079c2:	8b 40 48             	mov    0x48(%eax),%eax
c01079c5:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01079c8:	89 54 24 04          	mov    %edx,0x4(%esp)
c01079cc:	89 04 24             	mov    %eax,(%esp)
c01079cf:	e8 8b b0 ff ff       	call   c0102a5f <list_push_back>

        (*cpu)->CPU_ARG0 = _SUCCESS;
c01079d4:	8b 45 08             	mov    0x8(%ebp),%eax
c01079d7:	8b 00                	mov    (%eax),%eax
c01079d9:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c01079e0:	eb 0c                	jmp    c01079ee <set_pipe_trigger+0xbb>
    }
    else
    {
        (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c01079e2:	8b 45 08             	mov    0x8(%ebp),%eax
c01079e5:	8b 00                	mov    (%eax),%eax
c01079e7:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
    }
}
c01079ee:	c9                   	leave  
c01079ef:	c3                   	ret    

c01079f0 <sys_write>:

extern struct thread_state *current_thread;
extern vfs_inode_t *root;

void sys_write(struct cpu_state **cpu)
{
c01079f0:	55                   	push   %ebp
c01079f1:	89 e5                	mov    %esp,%ebp
c01079f3:	83 ec 38             	sub    $0x38,%esp
    int fd = (*cpu)->CPU_ARG1;
c01079f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01079f9:	8b 00                	mov    (%eax),%eax
c01079fb:	8b 40 1c             	mov    0x1c(%eax),%eax
c01079fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char *buf = (void*) (*cpu)->CPU_ARG2;
c0107a01:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a04:	8b 00                	mov    (%eax),%eax
c0107a06:	8b 40 24             	mov    0x24(%eax),%eax
c0107a09:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t len = (*cpu)->CPU_ARG3;
c0107a0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a0f:	8b 00                	mov    (%eax),%eax
c0107a11:	8b 40 20             	mov    0x20(%eax),%eax
c0107a14:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    if(fd == 2)   // TODO FIXME
c0107a17:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
c0107a1b:	75 3c                	jne    c0107a59 <sys_write+0x69>
    {
        int i;
        for(i = 0; i < len; i++)
c0107a1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0107a24:	eb 1a                	jmp    c0107a40 <sys_write+0x50>
        {
            printf("%c", buf[i]);
c0107a26:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107a29:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107a2c:	01 d0                	add    %edx,%eax
c0107a2e:	0f b6 00             	movzbl (%eax),%eax
c0107a31:	0f be c0             	movsbl %al,%eax
c0107a34:	89 04 24             	mov    %eax,(%esp)
c0107a37:	e8 02 47 00 00       	call   c010c13e <putchar>
    size_t len = (*cpu)->CPU_ARG3;

    if(fd == 2)   // TODO FIXME
    {
        int i;
        for(i = 0; i < len; i++)
c0107a3c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0107a40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107a43:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0107a46:	72 de                	jb     c0107a26 <sys_write+0x36>
        {
            printf("%c", buf[i]);
        }
        (*cpu)->CPU_ARG0 = _SUCCESS;
c0107a48:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a4b:	8b 00                	mov    (%eax),%eax
c0107a4d:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        return;
c0107a54:	e9 0f 01 00 00       	jmp    c0107b68 <sys_write+0x178>
    }

    struct fd *desc = get_fd(current_thread->process, fd);
c0107a59:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107a5e:	8b 00                	mov    (%eax),%eax
c0107a60:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0107a63:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107a67:	89 04 24             	mov    %eax,(%esp)
c0107a6a:	e8 80 ef ff ff       	call   c01069ef <get_fd>
c0107a6f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(desc != NULL)
c0107a72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0107a76:	0f 84 dd 00 00 00    	je     c0107b59 <sys_write+0x169>
    {
        if(desc->permission & VFS_PERMISSION_WRITE && desc->write_inode != NULL)
c0107a7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107a7f:	8b 40 0c             	mov    0xc(%eax),%eax
c0107a82:	83 e0 02             	and    $0x2,%eax
c0107a85:	85 c0                	test   %eax,%eax
c0107a87:	0f 84 be 00 00 00    	je     c0107b4b <sys_write+0x15b>
c0107a8d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107a90:	8b 40 14             	mov    0x14(%eax),%eax
c0107a93:	85 c0                	test   %eax,%eax
c0107a95:	0f 84 b0 00 00 00    	je     c0107b4b <sys_write+0x15b>
        {
            vfs_inode_t *inode = desc->write_inode;
c0107a9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107a9e:	8b 40 14             	mov    0x14(%eax),%eax
c0107aa1:	89 45 dc             	mov    %eax,-0x24(%ebp)
            vfs_inode_t *real = inode;
c0107aa4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107aa7:	89 45 f0             	mov    %eax,-0x10(%ebp)
            GET_INODE(real);
c0107aaa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107aad:	8b 40 04             	mov    0x4(%eax),%eax
c0107ab0:	83 f8 03             	cmp    $0x3,%eax
c0107ab3:	75 09                	jne    c0107abe <sys_write+0xce>
c0107ab5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107ab8:	8b 40 3c             	mov    0x3c(%eax),%eax
c0107abb:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if(S_ISDIR(real->stat))
c0107abe:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107ac1:	8b 40 0c             	mov    0xc(%eax),%eax
c0107ac4:	83 e0 20             	and    $0x20,%eax
c0107ac7:	85 c0                	test   %eax,%eax
c0107ac9:	74 11                	je     c0107adc <sys_write+0xec>
            {
                (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0107acb:	8b 45 08             	mov    0x8(%ebp),%eax
c0107ace:	8b 00                	mov    (%eax),%eax
c0107ad0:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
                return;
c0107ad7:	e9 8c 00 00 00       	jmp    c0107b68 <sys_write+0x178>
            }

            int ret = vfs_write(inode, desc->write_pos, buf, len);
c0107adc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0107adf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107ae2:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107ae5:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0107ae9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0107aec:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107af0:	89 44 24 04          	mov    %eax,0x4(%esp)
c0107af4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107af7:	89 04 24             	mov    %eax,(%esp)
c0107afa:	e8 53 e5 ff ff       	call   c0106052 <vfs_write>
c0107aff:	89 45 d8             	mov    %eax,-0x28(%ebp)
            (*cpu)->CPU_ARG0 = ret;
c0107b02:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b05:	8b 00                	mov    (%eax),%eax
c0107b07:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0107b0a:	89 50 28             	mov    %edx,0x28(%eax)

            if(ret > 0)
c0107b0d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0107b11:	7e 54                	jle    c0107b67 <sys_write+0x177>
            {
                desc->write_pos += len;
c0107b13:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107b16:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107b19:	89 c2                	mov    %eax,%edx
c0107b1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107b1e:	01 d0                	add    %edx,%eax
c0107b20:	89 c2                	mov    %eax,%edx
c0107b22:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107b25:	89 50 1c             	mov    %edx,0x1c(%eax)
                if(real->type != VFS_PIPE)
c0107b28:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107b2b:	8b 40 04             	mov    0x4(%eax),%eax
c0107b2e:	83 f8 01             	cmp    $0x1,%eax
c0107b31:	74 34                	je     c0107b67 <sys_write+0x177>
                {
                    desc->read_pos += len;
c0107b33:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107b36:	8b 40 18             	mov    0x18(%eax),%eax
c0107b39:	89 c2                	mov    %eax,%edx
c0107b3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107b3e:	01 d0                	add    %edx,%eax
c0107b40:	89 c2                	mov    %eax,%edx
c0107b42:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107b45:	89 50 18             	mov    %edx,0x18(%eax)

    struct fd *desc = get_fd(current_thread->process, fd);
    if(desc != NULL)
    {
        if(desc->permission & VFS_PERMISSION_WRITE && desc->write_inode != NULL)
        {
c0107b48:	90                   	nop
c0107b49:	eb 1c                	jmp    c0107b67 <sys_write+0x177>
                }
            }
        }
        else
        {
            (*cpu)->CPU_ARG0 = _NO_PERMISSION;
c0107b4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b4e:	8b 00                	mov    (%eax),%eax
c0107b50:	c7 40 28 fe ff ff ff 	movl   $0xfffffffe,0x28(%eax)
c0107b57:	eb 0f                	jmp    c0107b68 <sys_write+0x178>
        }
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107b59:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b5c:	8b 00                	mov    (%eax),%eax
c0107b5e:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
c0107b65:	eb 01                	jmp    c0107b68 <sys_write+0x178>

    struct fd *desc = get_fd(current_thread->process, fd);
    if(desc != NULL)
    {
        if(desc->permission & VFS_PERMISSION_WRITE && desc->write_inode != NULL)
        {
c0107b67:	90                   	nop
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
    }
}
c0107b68:	c9                   	leave  
c0107b69:	c3                   	ret    

c0107b6a <sys_mknod>:

extern struct thread_state *current_thread;
extern vfs_inode_t *root;

void sys_mknod(struct cpu_state **cpu)
{
c0107b6a:	55                   	push   %ebp
c0107b6b:	89 e5                	mov    %esp,%ebp
c0107b6d:	83 ec 28             	sub    $0x28,%esp
    char *path = (char *) (*cpu)->CPU_ARG1;
c0107b70:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b73:	8b 00                	mov    (%eax),%eax
c0107b75:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107b78:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int mode =(int) (*cpu)->CPU_ARG2;
c0107b7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b7e:	8b 00                	mov    (%eax),%eax
c0107b80:	8b 40 24             	mov    0x24(%eax),%eax
c0107b83:	89 45 f0             	mov    %eax,-0x10(%ebp)
    //int dev = (int)(*cpu)->CPU_ARG3; // unused

    vfs_inode_t *inode = vfs_create_path(path, mode, current_thread->process->uid, current_thread->process->gid);
c0107b86:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107b8b:	8b 00                	mov    (%eax),%eax
c0107b8d:	8b 48 08             	mov    0x8(%eax),%ecx
c0107b90:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107b95:	8b 00                	mov    (%eax),%eax
c0107b97:	8b 50 04             	mov    0x4(%eax),%edx
c0107b9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107b9d:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0107ba1:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107ba5:	89 44 24 04          	mov    %eax,0x4(%esp)
c0107ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107bac:	89 04 24             	mov    %eax,(%esp)
c0107baf:	e8 57 10 00 00       	call   c0108c0b <vfs_create_path>
c0107bb4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(inode != NULL)
c0107bb7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0107bbb:	74 3b                	je     c0107bf8 <sys_mknod+0x8e>
    {
        if(S_ISFIFO(inode->stat))
c0107bbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107bc0:	8b 40 0c             	mov    0xc(%eax),%eax
c0107bc3:	83 e0 08             	and    $0x8,%eax
c0107bc6:	85 c0                	test   %eax,%eax
c0107bc8:	74 20                	je     c0107bea <sys_mknod+0x80>
        {
            inode->event_id = get_new_event_ID();
c0107bca:	e8 7a 36 00 00       	call   c010b249 <get_new_event_ID>
c0107bcf:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0107bd2:	89 42 44             	mov    %eax,0x44(%edx)
            inode->handlers = list_create();
c0107bd5:	e8 a1 ad ff ff       	call   c010297b <list_create>
c0107bda:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0107bdd:	89 42 48             	mov    %eax,0x48(%edx)
            inode->type = VFS_PIPE;
c0107be0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107be3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        }

        (*cpu)->CPU_ARG0 = _SUCCESS;
c0107bea:	8b 45 08             	mov    0x8(%ebp),%eax
c0107bed:	8b 00                	mov    (%eax),%eax
c0107bef:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0107bf6:	eb 0c                	jmp    c0107c04 <sys_mknod+0x9a>
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107bf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0107bfb:	8b 00                	mov    (%eax),%eax
c0107bfd:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c0107c04:	c9                   	leave  
c0107c05:	c3                   	ret    

c0107c06 <sys_create>:

void sys_create(struct cpu_state **cpu)
{
c0107c06:	55                   	push   %ebp
c0107c07:	89 e5                	mov    %esp,%ebp
c0107c09:	83 ec 28             	sub    $0x28,%esp
    char *name = (char *)(*cpu)->CPU_ARG1;
c0107c0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0107c0f:	8b 00                	mov    (%eax),%eax
c0107c11:	8b 40 1c             	mov    0x1c(%eax),%eax
c0107c14:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int mode = (*cpu)->CPU_ARG2;
c0107c17:	8b 45 08             	mov    0x8(%ebp),%eax
c0107c1a:	8b 00                	mov    (%eax),%eax
c0107c1c:	8b 40 24             	mov    0x24(%eax),%eax
c0107c1f:	89 45 f0             	mov    %eax,-0x10(%ebp)

    vfs_inode_t *inode = vfs_create_path(name, mode, current_thread->process->uid, current_thread->process->gid);
c0107c22:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107c27:	8b 00                	mov    (%eax),%eax
c0107c29:	8b 48 08             	mov    0x8(%eax),%ecx
c0107c2c:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107c31:	8b 00                	mov    (%eax),%eax
c0107c33:	8b 50 04             	mov    0x4(%eax),%edx
c0107c36:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107c39:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0107c3d:	89 54 24 08          	mov    %edx,0x8(%esp)
c0107c41:	89 44 24 04          	mov    %eax,0x4(%esp)
c0107c45:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107c48:	89 04 24             	mov    %eax,(%esp)
c0107c4b:	e8 bb 0f 00 00       	call   c0108c0b <vfs_create_path>
c0107c50:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(inode != NULL)
c0107c53:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0107c57:	74 50                	je     c0107ca9 <sys_create+0xa3>
    {
        struct fd *desc = create_fd(current_thread->process);
c0107c59:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0107c5e:	8b 00                	mov    (%eax),%eax
c0107c60:	89 04 24             	mov    %eax,(%esp)
c0107c63:	e8 ac ed ff ff       	call   c0106a14 <create_fd>
c0107c68:	89 45 e8             	mov    %eax,-0x18(%ebp)
        desc->mode = mode;
c0107c6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0107c6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107c71:	89 50 04             	mov    %edx,0x4(%eax)
        desc->flags = O_RDWR;
c0107c74:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107c77:	c7 40 08 04 00 00 00 	movl   $0x4,0x8(%eax)
        desc->permission = VFS_PERMISSION_READ | VFS_PERMISSION_WRITE;
c0107c7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107c81:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
        desc->read_inode = inode;
c0107c88:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107c8b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0107c8e:	89 50 10             	mov    %edx,0x10(%eax)
        desc->write_inode = inode;
c0107c91:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107c94:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0107c97:	89 50 14             	mov    %edx,0x14(%eax)

        (*cpu)->CPU_ARG0 = desc->id;
c0107c9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0107c9d:	8b 00                	mov    (%eax),%eax
c0107c9f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0107ca2:	8b 12                	mov    (%edx),%edx
c0107ca4:	89 50 28             	mov    %edx,0x28(%eax)
c0107ca7:	eb 0c                	jmp    c0107cb5 <sys_create+0xaf>
    }
    else
    {
        (*cpu)->CPU_ARG0 = _FAILURE;
c0107ca9:	8b 45 08             	mov    0x8(%ebp),%eax
c0107cac:	8b 00                	mov    (%eax),%eax
c0107cae:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
    }
}
c0107cb5:	c9                   	leave  
c0107cb6:	c3                   	ret    

c0107cb7 <vfs_create_dir_entry>:
 *
 * @param entry_inode the node that will be entried
 * @return the new directory entry
 */
vfs_dentry_t* vfs_create_dir_entry(vfs_inode_t *entry_inode)
{
c0107cb7:	55                   	push   %ebp
c0107cb8:	89 e5                	mov    %esp,%ebp
c0107cba:	83 ec 28             	sub    $0x28,%esp
    vfs_dentry_t *dir_ent = malloc(sizeof(vfs_dentry_t));
c0107cbd:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0107cc4:	e8 7c 42 00 00       	call   c010bf45 <malloc>
c0107cc9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    dir_ent->ino = entry_inode->stat.st_ino;
c0107ccc:	8b 45 08             	mov    0x8(%ebp),%eax
c0107ccf:	8b 50 10             	mov    0x10(%eax),%edx
c0107cd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107cd5:	89 10                	mov    %edx,(%eax)
    dir_ent->inode = entry_inode;
c0107cd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107cda:	8b 55 08             	mov    0x8(%ebp),%edx
c0107cdd:	89 50 04             	mov    %edx,0x4(%eax)

    return dir_ent;
c0107ce0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0107ce3:	c9                   	leave  
c0107ce4:	c3                   	ret    

c0107ce5 <vfs_add_dir_entry>:

void vfs_add_dir_entry(vfs_inode_t *dir, vfs_dentry_t *entry)
{
c0107ce5:	55                   	push   %ebp
c0107ce6:	89 e5                	mov    %esp,%ebp
c0107ce8:	83 ec 28             	sub    $0x28,%esp
    if(! S_ISDIR(dir->stat))
c0107ceb:	8b 45 08             	mov    0x8(%ebp),%eax
c0107cee:	8b 40 0c             	mov    0xc(%eax),%eax
c0107cf1:	83 e0 20             	and    $0x20,%eax
c0107cf4:	85 c0                	test   %eax,%eax
c0107cf6:	74 41                	je     c0107d39 <vfs_add_dir_entry+0x54>
        return;

    if(dir->write_buffer == NULL)
c0107cf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0107cfb:	8b 40 40             	mov    0x40(%eax),%eax
c0107cfe:	85 c0                	test   %eax,%eax
c0107d00:	75 0e                	jne    c0107d10 <vfs_add_dir_entry+0x2b>
    {
        printf("leerer puffer\n");
c0107d02:	c7 04 24 ac 0b 11 c0 	movl   $0xc0110bac,(%esp)
c0107d09:	e8 91 45 00 00       	call   c010c29f <puts>
        return;
c0107d0e:	eb 2a                	jmp    c0107d3a <vfs_add_dir_entry+0x55>
    }

    buffer_block_t *block = buffer_block_create(dir->write_buffer, dir->write_buffer->block_counter);
c0107d10:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d13:	8b 40 40             	mov    0x40(%eax),%eax
c0107d16:	8b 50 08             	mov    0x8(%eax),%edx
c0107d19:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d1c:	8b 40 40             	mov    0x40(%eax),%eax
c0107d1f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107d23:	89 04 24             	mov    %eax,(%esp)
c0107d26:	e8 14 a8 ff ff       	call   c010253f <buffer_block_create>
c0107d2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    block->base = entry;
c0107d2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107d31:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107d34:	89 50 04             	mov    %edx,0x4(%eax)
c0107d37:	eb 01                	jmp    c0107d3a <vfs_add_dir_entry+0x55>
}

void vfs_add_dir_entry(vfs_inode_t *dir, vfs_dentry_t *entry)
{
    if(! S_ISDIR(dir->stat))
        return;
c0107d39:	90                   	nop
        return;
    }

    buffer_block_t *block = buffer_block_create(dir->write_buffer, dir->write_buffer->block_counter);
    block->base = entry;
}
c0107d3a:	c9                   	leave  
c0107d3b:	c3                   	ret    

c0107d3c <vfs_remove_dir_entry>:

void vfs_remove_dir_entry(vfs_inode_t *dir, vfs_inode_t *inode)
{
c0107d3c:	55                   	push   %ebp
c0107d3d:	89 e5                	mov    %esp,%ebp
c0107d3f:	83 ec 38             	sub    $0x38,%esp
    if(! S_ISDIR(dir->stat))
c0107d42:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d45:	8b 40 0c             	mov    0xc(%eax),%eax
c0107d48:	83 e0 20             	and    $0x20,%eax
c0107d4b:	85 c0                	test   %eax,%eax
c0107d4d:	0f 84 9d 00 00 00    	je     c0107df0 <vfs_remove_dir_entry+0xb4>
        return;

    if(dir->write_buffer == NULL)
c0107d53:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d56:	8b 40 40             	mov    0x40(%eax),%eax
c0107d59:	85 c0                	test   %eax,%eax
c0107d5b:	75 11                	jne    c0107d6e <vfs_remove_dir_entry+0x32>
    {
        printf("leerer puffer\n");
c0107d5d:	c7 04 24 ac 0b 11 c0 	movl   $0xc0110bac,(%esp)
c0107d64:	e8 36 45 00 00       	call   c010c29f <puts>
c0107d69:	e9 82 00 00 00       	jmp    c0107df0 <vfs_remove_dir_entry+0xb4>
        return;
    }

    block_buffer_info_t *info = inode->write_buffer;
c0107d6e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107d71:	8b 40 40             	mov    0x40(%eax),%eax
c0107d74:	89 45 f4             	mov    %eax,-0xc(%ebp)

    iterator_t it = iterator_create(info->blocks);
c0107d77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107d7a:	8b 10                	mov    (%eax),%edx
c0107d7c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107d7f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107d83:	89 04 24             	mov    %eax,(%esp)
c0107d86:	e8 60 af ff ff       	call   c0102ceb <iterator_create>
c0107d8b:	83 ec 04             	sub    $0x4,%esp
    list_set_first(&it);
c0107d8e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107d91:	89 04 24             	mov    %eax,(%esp)
c0107d94:	e8 82 b0 ff ff       	call   c0102e1b <list_set_first>

    while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0107d99:	eb 35                	jmp    c0107dd0 <vfs_remove_dir_entry+0x94>
    {
        buffer_block_t *block = (buffer_block_t*) it.current->element;
c0107d9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107d9e:	8b 40 08             	mov    0x8(%eax),%eax
c0107da1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        vfs_dentry_t *dentry = (vfs_dentry_t*) block->base;
c0107da4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107da7:	8b 40 04             	mov    0x4(%eax),%eax
c0107daa:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if(dentry->inode == inode)
c0107dad:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107db0:	8b 40 04             	mov    0x4(%eax),%eax
c0107db3:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0107db6:	75 0d                	jne    c0107dc5 <vfs_remove_dir_entry+0x89>
        {
            list_remove(&it);
c0107db8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107dbb:	89 04 24             	mov    %eax,(%esp)
c0107dbe:	e8 83 b0 ff ff       	call   c0102e46 <list_remove>
            break;
c0107dc3:	eb 2b                	jmp    c0107df0 <vfs_remove_dir_entry+0xb4>
        }

        list_next(&it);
c0107dc5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107dc8:	89 04 24             	mov    %eax,(%esp)
c0107dcb:	e8 09 b0 ff ff       	call   c0102dd9 <list_next>
    block_buffer_info_t *info = inode->write_buffer;

    iterator_t it = iterator_create(info->blocks);
    list_set_first(&it);

    while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0107dd0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107dd3:	89 04 24             	mov    %eax,(%esp)
c0107dd6:	e8 25 b0 ff ff       	call   c0102e00 <list_is_last>
c0107ddb:	85 c0                	test   %eax,%eax
c0107ddd:	75 11                	jne    c0107df0 <vfs_remove_dir_entry+0xb4>
c0107ddf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107de2:	8b 00                	mov    (%eax),%eax
c0107de4:	89 04 24             	mov    %eax,(%esp)
c0107de7:	e8 be ae ff ff       	call   c0102caa <list_is_empty>
c0107dec:	85 c0                	test   %eax,%eax
c0107dee:	74 ab                	je     c0107d9b <vfs_remove_dir_entry+0x5f>
            break;
        }

        list_next(&it);
    }
}
c0107df0:	c9                   	leave  
c0107df1:	c3                   	ret    

c0107df2 <vfs_get_dir_entry>:

vfs_dentry_t *vfs_get_dir_entry(vfs_inode_t *ino, const char *name)
{
c0107df2:	55                   	push   %ebp
c0107df3:	89 e5                	mov    %esp,%ebp
c0107df5:	83 ec 38             	sub    $0x38,%esp
    GET_INODE(ino);
c0107df8:	8b 45 08             	mov    0x8(%ebp),%eax
c0107dfb:	8b 40 04             	mov    0x4(%eax),%eax
c0107dfe:	83 f8 03             	cmp    $0x3,%eax
c0107e01:	75 09                	jne    c0107e0c <vfs_get_dir_entry+0x1a>
c0107e03:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e06:	8b 40 3c             	mov    0x3c(%eax),%eax
c0107e09:	89 45 08             	mov    %eax,0x8(%ebp)
    if(S_ISDIR(ino->stat))
c0107e0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e0f:	8b 40 0c             	mov    0xc(%eax),%eax
c0107e12:	83 e0 20             	and    $0x20,%eax
c0107e15:	85 c0                	test   %eax,%eax
c0107e17:	0f 84 8a 00 00 00    	je     c0107ea7 <vfs_get_dir_entry+0xb5>
    {
        block_buffer_info_t *info = ino->read_buffer;
c0107e1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e20:	8b 40 3c             	mov    0x3c(%eax),%eax
c0107e23:	89 45 f4             	mov    %eax,-0xc(%ebp)

        iterator_t it = iterator_create(info->blocks);
c0107e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e29:	8b 10                	mov    (%eax),%edx
c0107e2b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107e2e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107e32:	89 04 24             	mov    %eax,(%esp)
c0107e35:	e8 b1 ae ff ff       	call   c0102ceb <iterator_create>
c0107e3a:	83 ec 04             	sub    $0x4,%esp
        list_set_first(&it);
c0107e3d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107e40:	89 04 24             	mov    %eax,(%esp)
c0107e43:	e8 d3 af ff ff       	call   c0102e1b <list_set_first>

        while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0107e48:	eb 3d                	jmp    c0107e87 <vfs_get_dir_entry+0x95>
        {
            buffer_block_t *block = (buffer_block_t*) it.current->element;
c0107e4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107e4d:	8b 40 08             	mov    0x8(%eax),%eax
c0107e50:	89 45 f0             	mov    %eax,-0x10(%ebp)
            vfs_dentry_t *dentry = (vfs_dentry_t*) block->base;
c0107e53:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107e56:	8b 40 04             	mov    0x4(%eax),%eax
c0107e59:	89 45 ec             	mov    %eax,-0x14(%ebp)

            if(strcmp(name, dentry->inode->name) == 0)
c0107e5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107e5f:	8b 40 04             	mov    0x4(%eax),%eax
c0107e62:	8b 00                	mov    (%eax),%eax
c0107e64:	89 44 24 04          	mov    %eax,0x4(%esp)
c0107e68:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107e6b:	89 04 24             	mov    %eax,(%esp)
c0107e6e:	e8 9e b1 ff ff       	call   c0103011 <strcmp>
c0107e73:	85 c0                	test   %eax,%eax
c0107e75:	75 05                	jne    c0107e7c <vfs_get_dir_entry+0x8a>
            {
                return dentry;
c0107e77:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107e7a:	eb 30                	jmp    c0107eac <vfs_get_dir_entry+0xba>
            }

            list_next(&it);
c0107e7c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107e7f:	89 04 24             	mov    %eax,(%esp)
c0107e82:	e8 52 af ff ff       	call   c0102dd9 <list_next>
        block_buffer_info_t *info = ino->read_buffer;

        iterator_t it = iterator_create(info->blocks);
        list_set_first(&it);

        while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0107e87:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107e8a:	89 04 24             	mov    %eax,(%esp)
c0107e8d:	e8 6e af ff ff       	call   c0102e00 <list_is_last>
c0107e92:	85 c0                	test   %eax,%eax
c0107e94:	75 11                	jne    c0107ea7 <vfs_get_dir_entry+0xb5>
c0107e96:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107e99:	8b 00                	mov    (%eax),%eax
c0107e9b:	89 04 24             	mov    %eax,(%esp)
c0107e9e:	e8 07 ae ff ff       	call   c0102caa <list_is_empty>
c0107ea3:	85 c0                	test   %eax,%eax
c0107ea5:	74 a3                	je     c0107e4a <vfs_get_dir_entry+0x58>

            list_next(&it);
        }
    }

    return NULL;
c0107ea7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0107eac:	c9                   	leave  
c0107ead:	c3                   	ret    

c0107eae <USER_INIT>:

list_t *users;		// user list
list_t *groups;		// group list

void USER_INIT(void)
{
c0107eae:	55                   	push   %ebp
c0107eaf:	89 e5                	mov    %esp,%ebp
c0107eb1:	53                   	push   %ebx
c0107eb2:	83 ec 14             	sub    $0x14,%esp
    users = list_create();
c0107eb5:	e8 c1 aa ff ff       	call   c010297b <list_create>
c0107eba:	a3 20 f0 11 c0       	mov    %eax,0xc011f020
    groups = list_create();
c0107ebf:	e8 b7 aa ff ff       	call   c010297b <list_create>
c0107ec4:	a3 1c f0 11 c0       	mov    %eax,0xc011f01c

    add_group("root", 0);
c0107ec9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0107ed0:	00 
c0107ed1:	c7 04 24 ba 0b 11 c0 	movl   $0xc0110bba,(%esp)
c0107ed8:	e8 97 04 00 00       	call   c0108374 <add_group>
    add_user("root","","/",0);
c0107edd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0107ee4:	00 
c0107ee5:	c7 44 24 08 bf 0b 11 	movl   $0xc0110bbf,0x8(%esp)
c0107eec:	c0 
c0107eed:	c7 44 24 04 c1 0b 11 	movl   $0xc0110bc1,0x4(%esp)
c0107ef4:	c0 
c0107ef5:	c7 04 24 ba 0b 11 c0 	movl   $0xc0110bba,(%esp)
c0107efc:	e8 2c 00 00 00       	call   c0107f2d <add_user>
    add_user_to_group(get_user_by_id(0), get_group_by_id(0));
c0107f01:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0107f08:	e8 72 06 00 00       	call   c010857f <get_group_by_id>
c0107f0d:	89 c3                	mov    %eax,%ebx
c0107f0f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0107f16:	e8 30 03 00 00       	call   c010824b <get_user_by_id>
c0107f1b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0107f1f:	89 04 24             	mov    %eax,(%esp)
c0107f22:	e8 75 07 00 00       	call   c010869c <add_user_to_group>
}
c0107f27:	83 c4 14             	add    $0x14,%esp
c0107f2a:	5b                   	pop    %ebx
c0107f2b:	5d                   	pop    %ebp
c0107f2c:	c3                   	ret    

c0107f2d <add_user>:

int add_user(const char *uname, const char *upasswd, const char *uhome, uid_t uid)
{
c0107f2d:	55                   	push   %ebp
c0107f2e:	89 e5                	mov    %esp,%ebp
c0107f30:	83 ec 38             	sub    $0x38,%esp
    if(uname == NULL || uname[0] == '\0')
c0107f33:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0107f37:	74 0a                	je     c0107f43 <add_user+0x16>
c0107f39:	8b 45 08             	mov    0x8(%ebp),%eax
c0107f3c:	0f b6 00             	movzbl (%eax),%eax
c0107f3f:	84 c0                	test   %al,%al
c0107f41:	75 0a                	jne    c0107f4d <add_user+0x20>
        return FAILTURE;
c0107f43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0107f48:	e9 ad 01 00 00       	jmp    c01080fa <add_user+0x1cd>

    if(user_id_exists(uid))
c0107f4d:	8b 45 14             	mov    0x14(%ebp),%eax
c0107f50:	89 04 24             	mov    %eax,(%esp)
c0107f53:	e8 38 09 00 00       	call   c0108890 <user_id_exists>
c0107f58:	85 c0                	test   %eax,%eax
c0107f5a:	74 0a                	je     c0107f66 <add_user+0x39>
        return FAILTURE;
c0107f5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0107f61:	e9 94 01 00 00       	jmp    c01080fa <add_user+0x1cd>

    if(user_name_exists(uname))
c0107f66:	8b 45 08             	mov    0x8(%ebp),%eax
c0107f69:	89 04 24             	mov    %eax,(%esp)
c0107f6c:	e8 30 0a 00 00       	call   c01089a1 <user_name_exists>
c0107f71:	85 c0                	test   %eax,%eax
c0107f73:	74 0a                	je     c0107f7f <add_user+0x52>
        return FAILTURE;
c0107f75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0107f7a:	e9 7b 01 00 00       	jmp    c01080fa <add_user+0x1cd>

    user_t *new_user = (user_t *)malloc(sizeof(user_t));
c0107f7f:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c0107f86:	e8 ba 3f 00 00       	call   c010bf45 <malloc>
c0107f8b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    new_user->name = (char *)malloc(sizeof(char) * strlen(uname));
c0107f8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0107f91:	89 04 24             	mov    %eax,(%esp)
c0107f94:	e8 34 af ff ff       	call   c0102ecd <strlen>
c0107f99:	89 04 24             	mov    %eax,(%esp)
c0107f9c:	e8 a4 3f 00 00       	call   c010bf45 <malloc>
c0107fa1:	89 c2                	mov    %eax,%edx
c0107fa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107fa6:	89 10                	mov    %edx,(%eax)
    strcpy(new_user->name, uname);
c0107fa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107fab:	8b 00                	mov    (%eax),%eax
c0107fad:	8b 55 08             	mov    0x8(%ebp),%edx
c0107fb0:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107fb4:	89 04 24             	mov    %eax,(%esp)
c0107fb7:	e8 38 af ff ff       	call   c0102ef4 <strcpy>

    if(upasswd == NULL)
c0107fbc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0107fc0:	75 0c                	jne    c0107fce <add_user+0xa1>
        new_user->passwd = NULL;
c0107fc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107fc5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0107fcc:	eb 30                	jmp    c0107ffe <add_user+0xd1>
    else
    {
        new_user->passwd = (char *)malloc(sizeof(char) * strlen(upasswd));
c0107fce:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107fd1:	89 04 24             	mov    %eax,(%esp)
c0107fd4:	e8 f4 ae ff ff       	call   c0102ecd <strlen>
c0107fd9:	89 04 24             	mov    %eax,(%esp)
c0107fdc:	e8 64 3f 00 00       	call   c010bf45 <malloc>
c0107fe1:	89 c2                	mov    %eax,%edx
c0107fe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107fe6:	89 50 04             	mov    %edx,0x4(%eax)
        strcpy(new_user->passwd, upasswd);
c0107fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107fec:	8b 40 04             	mov    0x4(%eax),%eax
c0107fef:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107ff2:	89 54 24 04          	mov    %edx,0x4(%esp)
c0107ff6:	89 04 24             	mov    %eax,(%esp)
c0107ff9:	e8 f6 ae ff ff       	call   c0102ef4 <strcpy>
    }

    if(uhome != NULL)
c0107ffe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0108002:	74 32                	je     c0108036 <add_user+0x109>
    {
        new_user->home = (char *)malloc(sizeof(char) * strlen(uhome));
c0108004:	8b 45 10             	mov    0x10(%ebp),%eax
c0108007:	89 04 24             	mov    %eax,(%esp)
c010800a:	e8 be ae ff ff       	call   c0102ecd <strlen>
c010800f:	89 04 24             	mov    %eax,(%esp)
c0108012:	e8 2e 3f 00 00       	call   c010bf45 <malloc>
c0108017:	89 c2                	mov    %eax,%edx
c0108019:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010801c:	89 50 08             	mov    %edx,0x8(%eax)
        strcpy(new_user->home, uhome);
c010801f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108022:	8b 40 08             	mov    0x8(%eax),%eax
c0108025:	8b 55 10             	mov    0x10(%ebp),%edx
c0108028:	89 54 24 04          	mov    %edx,0x4(%esp)
c010802c:	89 04 24             	mov    %eax,(%esp)
c010802f:	e8 c0 ae ff ff       	call   c0102ef4 <strcpy>
c0108034:	eb 7d                	jmp    c01080b3 <add_user+0x186>
    }
    else
    {
        new_user->home = (char *)malloc(sizeof(char) * (strlen("/home/") + strlen(uname)));
c0108036:	8b 45 08             	mov    0x8(%ebp),%eax
c0108039:	89 04 24             	mov    %eax,(%esp)
c010803c:	e8 8c ae ff ff       	call   c0102ecd <strlen>
c0108041:	83 c0 06             	add    $0x6,%eax
c0108044:	89 04 24             	mov    %eax,(%esp)
c0108047:	e8 f9 3e 00 00       	call   c010bf45 <malloc>
c010804c:	89 c2                	mov    %eax,%edx
c010804e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108051:	89 50 08             	mov    %edx,0x8(%eax)
        strcpy(new_user->home, "/home/");
c0108054:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108057:	8b 40 08             	mov    0x8(%eax),%eax
c010805a:	c7 00 2f 68 6f 6d    	movl   $0x6d6f682f,(%eax)
c0108060:	66 c7 40 04 65 2f    	movw   $0x2f65,0x4(%eax)
c0108066:	c6 40 06 00          	movb   $0x0,0x6(%eax)
        strcat(new_user->home, uname);
c010806a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010806d:	8b 40 08             	mov    0x8(%eax),%eax
c0108070:	8b 55 08             	mov    0x8(%ebp),%edx
c0108073:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108077:	89 04 24             	mov    %eax,(%esp)
c010807a:	e8 2b af ff ff       	call   c0102faa <strcat>
        vfs_create_inode(new_user->name, S_IRUSR | S_IWUSR, vfs_lookup_path("/home/"), uid, 0);
c010807f:	c7 04 24 c2 0b 11 c0 	movl   $0xc0110bc2,(%esp)
c0108086:	e8 16 0a 00 00       	call   c0108aa1 <vfs_lookup_path>
c010808b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010808e:	8b 12                	mov    (%edx),%edx
c0108090:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0108097:	00 
c0108098:	8b 4d 14             	mov    0x14(%ebp),%ecx
c010809b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c010809f:	89 44 24 08          	mov    %eax,0x8(%esp)
c01080a3:	c7 44 24 04 00 03 00 	movl   $0x300,0x4(%esp)
c01080aa:	00 
c01080ab:	89 14 24             	mov    %edx,(%esp)
c01080ae:	e8 7b dd ff ff       	call   c0105e2e <vfs_create_inode>
    }

    new_user->id = uid;
c01080b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01080b6:	8b 55 14             	mov    0x14(%ebp),%edx
c01080b9:	89 50 0c             	mov    %edx,0xc(%eax)
    new_user->grps = list_create();
c01080bc:	e8 ba a8 ff ff       	call   c010297b <list_create>
c01080c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01080c4:	89 42 10             	mov    %eax,0x10(%edx)
    list_lock(users);
c01080c7:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01080cc:	89 04 24             	mov    %eax,(%esp)
c01080cf:	e8 f1 ab ff ff       	call   c0102cc5 <list_lock>
    list_push_back(users, new_user);
c01080d4:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01080d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01080dc:	89 54 24 04          	mov    %edx,0x4(%esp)
c01080e0:	89 04 24             	mov    %eax,(%esp)
c01080e3:	e8 77 a9 ff ff       	call   c0102a5f <list_push_back>
    list_unlock(users);
c01080e8:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01080ed:	89 04 24             	mov    %eax,(%esp)
c01080f0:	e8 e3 ab ff ff       	call   c0102cd8 <list_unlock>

    return SUCCESS;
c01080f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01080fa:	c9                   	leave  
c01080fb:	c3                   	ret    

c01080fc <remove_user>:

int remove_user(user_t *user)
{
c01080fc:	55                   	push   %ebp
c01080fd:	89 e5                	mov    %esp,%ebp
c01080ff:	83 ec 38             	sub    $0x38,%esp
    iterator_t user_itr = iterator_create(users);
c0108102:	8b 15 20 f0 11 c0    	mov    0xc011f020,%edx
c0108108:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010810b:	89 54 24 04          	mov    %edx,0x4(%esp)
c010810f:	89 04 24             	mov    %eax,(%esp)
c0108112:	e8 d4 ab ff ff       	call   c0102ceb <iterator_create>
c0108117:	83 ec 04             	sub    $0x4,%esp
    list_lock(users);
c010811a:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c010811f:	89 04 24             	mov    %eax,(%esp)
c0108122:	e8 9e ab ff ff       	call   c0102cc5 <list_lock>
    while(!list_is_last(&user_itr))
c0108127:	e9 f8 00 00 00       	jmp    c0108224 <remove_user+0x128>
    {
        if(((user_t *)list_get_current(&user_itr)) == user)
c010812c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010812f:	89 04 24             	mov    %eax,(%esp)
c0108132:	e8 7d ac ff ff       	call   c0102db4 <list_get_current>
c0108137:	3b 45 08             	cmp    0x8(%ebp),%eax
c010813a:	0f 85 d9 00 00 00    	jne    c0108219 <remove_user+0x11d>
        {
            user_t *usr = ((user_t *)list_get_current(&user_itr));
c0108140:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108143:	89 04 24             	mov    %eax,(%esp)
c0108146:	e8 69 ac ff ff       	call   c0102db4 <list_get_current>
c010814b:	89 45 f4             	mov    %eax,-0xc(%ebp)

            iterator_t grps_itr = iterator_create(usr->grps);
c010814e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108151:	8b 50 10             	mov    0x10(%eax),%edx
c0108154:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0108157:	89 54 24 04          	mov    %edx,0x4(%esp)
c010815b:	89 04 24             	mov    %eax,(%esp)
c010815e:	e8 88 ab ff ff       	call   c0102ceb <iterator_create>
c0108163:	83 ec 04             	sub    $0x4,%esp
            list_lock(usr->grps);
c0108166:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108169:	8b 40 10             	mov    0x10(%eax),%eax
c010816c:	89 04 24             	mov    %eax,(%esp)
c010816f:	e8 51 ab ff ff       	call   c0102cc5 <list_lock>
            while(!list_is_last(&grps_itr))
c0108174:	eb 25                	jmp    c010819b <remove_user+0x9f>
            {
                remove_user_from_group_lockfree(usr, (group_t *)list_get_current(&grps_itr));
c0108176:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0108179:	89 04 24             	mov    %eax,(%esp)
c010817c:	e8 33 ac ff ff       	call   c0102db4 <list_get_current>
c0108181:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108185:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108188:	89 04 24             	mov    %eax,(%esp)
c010818b:	e8 ca 05 00 00       	call   c010875a <remove_user_from_group_lockfree>

                list_next(&grps_itr);
c0108190:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0108193:	89 04 24             	mov    %eax,(%esp)
c0108196:	e8 3e ac ff ff       	call   c0102dd9 <list_next>
        {
            user_t *usr = ((user_t *)list_get_current(&user_itr));

            iterator_t grps_itr = iterator_create(usr->grps);
            list_lock(usr->grps);
            while(!list_is_last(&grps_itr))
c010819b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010819e:	89 04 24             	mov    %eax,(%esp)
c01081a1:	e8 5a ac ff ff       	call   c0102e00 <list_is_last>
c01081a6:	85 c0                	test   %eax,%eax
c01081a8:	74 cc                	je     c0108176 <remove_user+0x7a>
            {
                remove_user_from_group_lockfree(usr, (group_t *)list_get_current(&grps_itr));

                list_next(&grps_itr);
            }
            list_unlock(usr->grps);
c01081aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01081ad:	8b 40 10             	mov    0x10(%eax),%eax
c01081b0:	89 04 24             	mov    %eax,(%esp)
c01081b3:	e8 20 ab ff ff       	call   c0102cd8 <list_unlock>

            free(usr->name);
c01081b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01081bb:	8b 00                	mov    (%eax),%eax
c01081bd:	89 04 24             	mov    %eax,(%esp)
c01081c0:	e8 8e 3e 00 00       	call   c010c053 <free>
            free(usr->passwd);
c01081c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01081c8:	8b 40 04             	mov    0x4(%eax),%eax
c01081cb:	89 04 24             	mov    %eax,(%esp)
c01081ce:	e8 80 3e 00 00       	call   c010c053 <free>
            free(usr->home);
c01081d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01081d6:	8b 40 08             	mov    0x8(%eax),%eax
c01081d9:	89 04 24             	mov    %eax,(%esp)
c01081dc:	e8 72 3e 00 00       	call   c010c053 <free>
            list_destroy(usr->grps);
c01081e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01081e4:	8b 40 10             	mov    0x10(%eax),%eax
c01081e7:	89 04 24             	mov    %eax,(%esp)
c01081ea:	e8 e4 a7 ff ff       	call   c01029d3 <list_destroy>
            free(usr);
c01081ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01081f2:	89 04 24             	mov    %eax,(%esp)
c01081f5:	e8 59 3e 00 00       	call   c010c053 <free>

            list_remove(&user_itr);
c01081fa:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01081fd:	89 04 24             	mov    %eax,(%esp)
c0108200:	e8 41 ac ff ff       	call   c0102e46 <list_remove>
            list_unlock(users);
c0108205:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c010820a:	89 04 24             	mov    %eax,(%esp)
c010820d:	e8 c6 aa ff ff       	call   c0102cd8 <list_unlock>
            return SUCCESS;
c0108212:	b8 00 00 00 00       	mov    $0x0,%eax
c0108217:	eb 30                	jmp    c0108249 <remove_user+0x14d>
        }

        list_next(&user_itr);
c0108219:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010821c:	89 04 24             	mov    %eax,(%esp)
c010821f:	e8 b5 ab ff ff       	call   c0102dd9 <list_next>

int remove_user(user_t *user)
{
    iterator_t user_itr = iterator_create(users);
    list_lock(users);
    while(!list_is_last(&user_itr))
c0108224:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108227:	89 04 24             	mov    %eax,(%esp)
c010822a:	e8 d1 ab ff ff       	call   c0102e00 <list_is_last>
c010822f:	85 c0                	test   %eax,%eax
c0108231:	0f 84 f5 fe ff ff    	je     c010812c <remove_user+0x30>
        }

        list_next(&user_itr);
    }

    list_unlock(users);
c0108237:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c010823c:	89 04 24             	mov    %eax,(%esp)
c010823f:	e8 94 aa ff ff       	call   c0102cd8 <list_unlock>
    return FAILTURE;
c0108244:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0108249:	c9                   	leave  
c010824a:	c3                   	ret    

c010824b <get_user_by_id>:

user_t *get_user_by_id(uid_t id)
{
c010824b:	55                   	push   %ebp
c010824c:	89 e5                	mov    %esp,%ebp
c010824e:	83 ec 28             	sub    $0x28,%esp
    iterator_t user_itr = iterator_create(users);
c0108251:	8b 15 20 f0 11 c0    	mov    0xc011f020,%edx
c0108257:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010825a:	89 54 24 04          	mov    %edx,0x4(%esp)
c010825e:	89 04 24             	mov    %eax,(%esp)
c0108261:	e8 85 aa ff ff       	call   c0102ceb <iterator_create>
c0108266:	83 ec 04             	sub    $0x4,%esp
    list_lock(users);
c0108269:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c010826e:	89 04 24             	mov    %eax,(%esp)
c0108271:	e8 4f aa ff ff       	call   c0102cc5 <list_lock>
    while(!list_is_last(&user_itr))
c0108276:	eb 3e                	jmp    c01082b6 <get_user_by_id+0x6b>
    {
        if(((user_t *)list_get_current(&user_itr))->id == id)
c0108278:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010827b:	89 04 24             	mov    %eax,(%esp)
c010827e:	e8 31 ab ff ff       	call   c0102db4 <list_get_current>
c0108283:	8b 40 0c             	mov    0xc(%eax),%eax
c0108286:	3b 45 08             	cmp    0x8(%ebp),%eax
c0108289:	75 20                	jne    c01082ab <get_user_by_id+0x60>
        {
            user_t *target = (user_t *)list_get_current(&user_itr);
c010828b:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010828e:	89 04 24             	mov    %eax,(%esp)
c0108291:	e8 1e ab ff ff       	call   c0102db4 <list_get_current>
c0108296:	89 45 f4             	mov    %eax,-0xc(%ebp)
            list_unlock(users);
c0108299:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c010829e:	89 04 24             	mov    %eax,(%esp)
c01082a1:	e8 32 aa ff ff       	call   c0102cd8 <list_unlock>
            return target;
c01082a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01082a9:	eb 2c                	jmp    c01082d7 <get_user_by_id+0x8c>
        }

        list_next(&user_itr);
c01082ab:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01082ae:	89 04 24             	mov    %eax,(%esp)
c01082b1:	e8 23 ab ff ff       	call   c0102dd9 <list_next>

user_t *get_user_by_id(uid_t id)
{
    iterator_t user_itr = iterator_create(users);
    list_lock(users);
    while(!list_is_last(&user_itr))
c01082b6:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01082b9:	89 04 24             	mov    %eax,(%esp)
c01082bc:	e8 3f ab ff ff       	call   c0102e00 <list_is_last>
c01082c1:	85 c0                	test   %eax,%eax
c01082c3:	74 b3                	je     c0108278 <get_user_by_id+0x2d>
            return target;
        }

        list_next(&user_itr);
    }
    list_unlock(users);
c01082c5:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01082ca:	89 04 24             	mov    %eax,(%esp)
c01082cd:	e8 06 aa ff ff       	call   c0102cd8 <list_unlock>
    return NULL;
c01082d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01082d7:	c9                   	leave  
c01082d8:	c3                   	ret    

c01082d9 <get_user_by_name>:

user_t *get_user_by_name(const char *uname)
{
c01082d9:	55                   	push   %ebp
c01082da:	89 e5                	mov    %esp,%ebp
c01082dc:	83 ec 28             	sub    $0x28,%esp
    iterator_t user_itr = iterator_create(users);
c01082df:	8b 15 20 f0 11 c0    	mov    0xc011f020,%edx
c01082e5:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01082e8:	89 54 24 04          	mov    %edx,0x4(%esp)
c01082ec:	89 04 24             	mov    %eax,(%esp)
c01082ef:	e8 f7 a9 ff ff       	call   c0102ceb <iterator_create>
c01082f4:	83 ec 04             	sub    $0x4,%esp
    list_lock(users);
c01082f7:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01082fc:	89 04 24             	mov    %eax,(%esp)
c01082ff:	e8 c1 a9 ff ff       	call   c0102cc5 <list_lock>

    while(!list_is_last(&user_itr))
c0108304:	eb 4b                	jmp    c0108351 <get_user_by_name+0x78>
    {
        if(strcmp(((user_t *)list_get_current(&user_itr))->name, uname) == 0)
c0108306:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108309:	89 04 24             	mov    %eax,(%esp)
c010830c:	e8 a3 aa ff ff       	call   c0102db4 <list_get_current>
c0108311:	8b 00                	mov    (%eax),%eax
c0108313:	8b 55 08             	mov    0x8(%ebp),%edx
c0108316:	89 54 24 04          	mov    %edx,0x4(%esp)
c010831a:	89 04 24             	mov    %eax,(%esp)
c010831d:	e8 ef ac ff ff       	call   c0103011 <strcmp>
c0108322:	85 c0                	test   %eax,%eax
c0108324:	75 20                	jne    c0108346 <get_user_by_name+0x6d>
        {
            user_t *target = (user_t *)list_get_current(&user_itr);
c0108326:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108329:	89 04 24             	mov    %eax,(%esp)
c010832c:	e8 83 aa ff ff       	call   c0102db4 <list_get_current>
c0108331:	89 45 f4             	mov    %eax,-0xc(%ebp)
            list_unlock(users);
c0108334:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c0108339:	89 04 24             	mov    %eax,(%esp)
c010833c:	e8 97 a9 ff ff       	call   c0102cd8 <list_unlock>
            return target;
c0108341:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108344:	eb 2c                	jmp    c0108372 <get_user_by_name+0x99>
        }

        list_next(&user_itr);
c0108346:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108349:	89 04 24             	mov    %eax,(%esp)
c010834c:	e8 88 aa ff ff       	call   c0102dd9 <list_next>
user_t *get_user_by_name(const char *uname)
{
    iterator_t user_itr = iterator_create(users);
    list_lock(users);

    while(!list_is_last(&user_itr))
c0108351:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108354:	89 04 24             	mov    %eax,(%esp)
c0108357:	e8 a4 aa ff ff       	call   c0102e00 <list_is_last>
c010835c:	85 c0                	test   %eax,%eax
c010835e:	74 a6                	je     c0108306 <get_user_by_name+0x2d>
        }

        list_next(&user_itr);
    }

    list_unlock(users);
c0108360:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c0108365:	89 04 24             	mov    %eax,(%esp)
c0108368:	e8 6b a9 ff ff       	call   c0102cd8 <list_unlock>
    return NULL;
c010836d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0108372:	c9                   	leave  
c0108373:	c3                   	ret    

c0108374 <add_group>:

int add_group(const char *groupname, gid_t gid)
{
c0108374:	55                   	push   %ebp
c0108375:	89 e5                	mov    %esp,%ebp
c0108377:	83 ec 28             	sub    $0x28,%esp
    if(groupname == NULL || groupname[0] == '\0')
c010837a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010837e:	74 0a                	je     c010838a <add_group+0x16>
c0108380:	8b 45 08             	mov    0x8(%ebp),%eax
c0108383:	0f b6 00             	movzbl (%eax),%eax
c0108386:	84 c0                	test   %al,%al
c0108388:	75 0a                	jne    c0108394 <add_group+0x20>
        return FAILTURE;
c010838a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010838f:	e9 b6 00 00 00       	jmp    c010844a <add_group+0xd6>

    if(group_id_exists(gid))
c0108394:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108397:	89 04 24             	mov    %eax,(%esp)
c010839a:	e8 6f 04 00 00       	call   c010880e <group_id_exists>
c010839f:	85 c0                	test   %eax,%eax
c01083a1:	74 0a                	je     c01083ad <add_group+0x39>
        return FAILTURE;
c01083a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01083a8:	e9 9d 00 00 00       	jmp    c010844a <add_group+0xd6>

    if(group_name_exists(groupname))
c01083ad:	8b 45 08             	mov    0x8(%ebp),%eax
c01083b0:	89 04 24             	mov    %eax,(%esp)
c01083b3:	e8 5a 05 00 00       	call   c0108912 <group_name_exists>
c01083b8:	85 c0                	test   %eax,%eax
c01083ba:	74 0a                	je     c01083c6 <add_group+0x52>
        return FAILTURE;
c01083bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01083c1:	e9 84 00 00 00       	jmp    c010844a <add_group+0xd6>

    group_t *new_group = (group_t *)malloc(sizeof(group_t));
c01083c6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c01083cd:	e8 73 3b 00 00       	call   c010bf45 <malloc>
c01083d2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    new_group->name = (char *)malloc(sizeof(char) * strlen(groupname));
c01083d5:	8b 45 08             	mov    0x8(%ebp),%eax
c01083d8:	89 04 24             	mov    %eax,(%esp)
c01083db:	e8 ed aa ff ff       	call   c0102ecd <strlen>
c01083e0:	89 04 24             	mov    %eax,(%esp)
c01083e3:	e8 5d 3b 00 00       	call   c010bf45 <malloc>
c01083e8:	89 c2                	mov    %eax,%edx
c01083ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01083ed:	89 10                	mov    %edx,(%eax)
    strcpy(new_group->name, groupname);
c01083ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01083f2:	8b 00                	mov    (%eax),%eax
c01083f4:	8b 55 08             	mov    0x8(%ebp),%edx
c01083f7:	89 54 24 04          	mov    %edx,0x4(%esp)
c01083fb:	89 04 24             	mov    %eax,(%esp)
c01083fe:	e8 f1 aa ff ff       	call   c0102ef4 <strcpy>

    new_group->id = gid;
c0108403:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108406:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108409:	89 50 04             	mov    %edx,0x4(%eax)
    new_group->users = list_create();
c010840c:	e8 6a a5 ff ff       	call   c010297b <list_create>
c0108411:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108414:	89 42 08             	mov    %eax,0x8(%edx)
    list_lock(groups);
c0108417:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c010841c:	89 04 24             	mov    %eax,(%esp)
c010841f:	e8 a1 a8 ff ff       	call   c0102cc5 <list_lock>
    list_push_back(groups, new_group);
c0108424:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108429:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010842c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108430:	89 04 24             	mov    %eax,(%esp)
c0108433:	e8 27 a6 ff ff       	call   c0102a5f <list_push_back>
    list_unlock(groups);
c0108438:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c010843d:	89 04 24             	mov    %eax,(%esp)
c0108440:	e8 93 a8 ff ff       	call   c0102cd8 <list_unlock>

    return SUCCESS;
c0108445:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010844a:	c9                   	leave  
c010844b:	c3                   	ret    

c010844c <remove_group>:

int remove_group(group_t *group)
{
c010844c:	55                   	push   %ebp
c010844d:	89 e5                	mov    %esp,%ebp
c010844f:	83 ec 38             	sub    $0x38,%esp
    iterator_t grps_itr = iterator_create(groups);
c0108452:	8b 15 1c f0 11 c0    	mov    0xc011f01c,%edx
c0108458:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010845b:	89 54 24 04          	mov    %edx,0x4(%esp)
c010845f:	89 04 24             	mov    %eax,(%esp)
c0108462:	e8 84 a8 ff ff       	call   c0102ceb <iterator_create>
c0108467:	83 ec 04             	sub    $0x4,%esp
    list_lock(groups);
c010846a:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c010846f:	89 04 24             	mov    %eax,(%esp)
c0108472:	e8 4e a8 ff ff       	call   c0102cc5 <list_lock>
    while(!list_is_last(&grps_itr))
c0108477:	e9 dc 00 00 00       	jmp    c0108558 <remove_group+0x10c>
    {
        if(((group_t *)list_get_current(&grps_itr)) == group)
c010847c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010847f:	89 04 24             	mov    %eax,(%esp)
c0108482:	e8 2d a9 ff ff       	call   c0102db4 <list_get_current>
c0108487:	3b 45 08             	cmp    0x8(%ebp),%eax
c010848a:	0f 85 bd 00 00 00    	jne    c010854d <remove_group+0x101>
        {
            group_t *grp = ((group_t *)list_get_current(&grps_itr));
c0108490:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108493:	89 04 24             	mov    %eax,(%esp)
c0108496:	e8 19 a9 ff ff       	call   c0102db4 <list_get_current>
c010849b:	89 45 f4             	mov    %eax,-0xc(%ebp)

            iterator_t user_itr = iterator_create(grp->users);
c010849e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01084a1:	8b 50 08             	mov    0x8(%eax),%edx
c01084a4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01084a7:	89 54 24 04          	mov    %edx,0x4(%esp)
c01084ab:	89 04 24             	mov    %eax,(%esp)
c01084ae:	e8 38 a8 ff ff       	call   c0102ceb <iterator_create>
c01084b3:	83 ec 04             	sub    $0x4,%esp
            list_lock(grp->users);
c01084b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01084b9:	8b 40 08             	mov    0x8(%eax),%eax
c01084bc:	89 04 24             	mov    %eax,(%esp)
c01084bf:	e8 01 a8 ff ff       	call   c0102cc5 <list_lock>
            while(!list_is_last(&user_itr))
c01084c4:	eb 25                	jmp    c01084eb <remove_group+0x9f>
            {
                remove_user_from_group_lockfree((user_t *)list_get_current(&user_itr), grp);
c01084c6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01084c9:	89 04 24             	mov    %eax,(%esp)
c01084cc:	e8 e3 a8 ff ff       	call   c0102db4 <list_get_current>
c01084d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01084d4:	89 54 24 04          	mov    %edx,0x4(%esp)
c01084d8:	89 04 24             	mov    %eax,(%esp)
c01084db:	e8 7a 02 00 00       	call   c010875a <remove_user_from_group_lockfree>

                list_next(&user_itr);
c01084e0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01084e3:	89 04 24             	mov    %eax,(%esp)
c01084e6:	e8 ee a8 ff ff       	call   c0102dd9 <list_next>
        {
            group_t *grp = ((group_t *)list_get_current(&grps_itr));

            iterator_t user_itr = iterator_create(grp->users);
            list_lock(grp->users);
            while(!list_is_last(&user_itr))
c01084eb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01084ee:	89 04 24             	mov    %eax,(%esp)
c01084f1:	e8 0a a9 ff ff       	call   c0102e00 <list_is_last>
c01084f6:	85 c0                	test   %eax,%eax
c01084f8:	74 cc                	je     c01084c6 <remove_group+0x7a>
            {
                remove_user_from_group_lockfree((user_t *)list_get_current(&user_itr), grp);

                list_next(&user_itr);
            }
            list_unlock(grp->users);
c01084fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01084fd:	8b 40 08             	mov    0x8(%eax),%eax
c0108500:	89 04 24             	mov    %eax,(%esp)
c0108503:	e8 d0 a7 ff ff       	call   c0102cd8 <list_unlock>

            free(grp->name);
c0108508:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010850b:	8b 00                	mov    (%eax),%eax
c010850d:	89 04 24             	mov    %eax,(%esp)
c0108510:	e8 3e 3b 00 00       	call   c010c053 <free>
            list_destroy(grp->users);
c0108515:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108518:	8b 40 08             	mov    0x8(%eax),%eax
c010851b:	89 04 24             	mov    %eax,(%esp)
c010851e:	e8 b0 a4 ff ff       	call   c01029d3 <list_destroy>
            free(grp);
c0108523:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108526:	89 04 24             	mov    %eax,(%esp)
c0108529:	e8 25 3b 00 00       	call   c010c053 <free>

            list_remove(&grps_itr);
c010852e:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108531:	89 04 24             	mov    %eax,(%esp)
c0108534:	e8 0d a9 ff ff       	call   c0102e46 <list_remove>
            list_unlock(groups);
c0108539:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c010853e:	89 04 24             	mov    %eax,(%esp)
c0108541:	e8 92 a7 ff ff       	call   c0102cd8 <list_unlock>
            return SUCCESS;
c0108546:	b8 00 00 00 00       	mov    $0x0,%eax
c010854b:	eb 30                	jmp    c010857d <remove_group+0x131>
        }

        list_next(&grps_itr);
c010854d:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108550:	89 04 24             	mov    %eax,(%esp)
c0108553:	e8 81 a8 ff ff       	call   c0102dd9 <list_next>

int remove_group(group_t *group)
{
    iterator_t grps_itr = iterator_create(groups);
    list_lock(groups);
    while(!list_is_last(&grps_itr))
c0108558:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010855b:	89 04 24             	mov    %eax,(%esp)
c010855e:	e8 9d a8 ff ff       	call   c0102e00 <list_is_last>
c0108563:	85 c0                	test   %eax,%eax
c0108565:	0f 84 11 ff ff ff    	je     c010847c <remove_group+0x30>
            return SUCCESS;
        }

        list_next(&grps_itr);
    }
    list_unlock(groups);
c010856b:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108570:	89 04 24             	mov    %eax,(%esp)
c0108573:	e8 60 a7 ff ff       	call   c0102cd8 <list_unlock>
    return FAILTURE;
c0108578:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c010857d:	c9                   	leave  
c010857e:	c3                   	ret    

c010857f <get_group_by_id>:

group_t *get_group_by_id(gid_t id)
{
c010857f:	55                   	push   %ebp
c0108580:	89 e5                	mov    %esp,%ebp
c0108582:	83 ec 28             	sub    $0x28,%esp
    iterator_t grps_itr = iterator_create(groups);
c0108585:	8b 15 1c f0 11 c0    	mov    0xc011f01c,%edx
c010858b:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010858e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108592:	89 04 24             	mov    %eax,(%esp)
c0108595:	e8 51 a7 ff ff       	call   c0102ceb <iterator_create>
c010859a:	83 ec 04             	sub    $0x4,%esp
    list_lock(groups);
c010859d:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c01085a2:	89 04 24             	mov    %eax,(%esp)
c01085a5:	e8 1b a7 ff ff       	call   c0102cc5 <list_lock>

    while(!list_is_last(&grps_itr))
c01085aa:	eb 38                	jmp    c01085e4 <get_group_by_id+0x65>
    {
        if(((group_t *)list_get_current(&grps_itr))->id == id)
c01085ac:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01085af:	89 04 24             	mov    %eax,(%esp)
c01085b2:	e8 fd a7 ff ff       	call   c0102db4 <list_get_current>
c01085b7:	8b 40 04             	mov    0x4(%eax),%eax
c01085ba:	3b 45 08             	cmp    0x8(%ebp),%eax
c01085bd:	75 1a                	jne    c01085d9 <get_group_by_id+0x5a>
        {
            list_unlock(groups);
c01085bf:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c01085c4:	89 04 24             	mov    %eax,(%esp)
c01085c7:	e8 0c a7 ff ff       	call   c0102cd8 <list_unlock>
            return ((group_t *)list_get_current(&grps_itr));
c01085cc:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01085cf:	89 04 24             	mov    %eax,(%esp)
c01085d2:	e8 dd a7 ff ff       	call   c0102db4 <list_get_current>
c01085d7:	eb 2c                	jmp    c0108605 <get_group_by_id+0x86>
        }

        list_next(&grps_itr);
c01085d9:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01085dc:	89 04 24             	mov    %eax,(%esp)
c01085df:	e8 f5 a7 ff ff       	call   c0102dd9 <list_next>
group_t *get_group_by_id(gid_t id)
{
    iterator_t grps_itr = iterator_create(groups);
    list_lock(groups);

    while(!list_is_last(&grps_itr))
c01085e4:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01085e7:	89 04 24             	mov    %eax,(%esp)
c01085ea:	e8 11 a8 ff ff       	call   c0102e00 <list_is_last>
c01085ef:	85 c0                	test   %eax,%eax
c01085f1:	74 b9                	je     c01085ac <get_group_by_id+0x2d>
        }

        list_next(&grps_itr);
    }

    list_unlock(groups);
c01085f3:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c01085f8:	89 04 24             	mov    %eax,(%esp)
c01085fb:	e8 d8 a6 ff ff       	call   c0102cd8 <list_unlock>

    return NULL;
c0108600:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0108605:	c9                   	leave  
c0108606:	c3                   	ret    

c0108607 <get_group_by_name>:

group_t *get_group_by_name(const char *gname)
{
c0108607:	55                   	push   %ebp
c0108608:	89 e5                	mov    %esp,%ebp
c010860a:	83 ec 28             	sub    $0x28,%esp
    iterator_t grps_itr = iterator_create(groups);
c010860d:	8b 15 1c f0 11 c0    	mov    0xc011f01c,%edx
c0108613:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108616:	89 54 24 04          	mov    %edx,0x4(%esp)
c010861a:	89 04 24             	mov    %eax,(%esp)
c010861d:	e8 c9 a6 ff ff       	call   c0102ceb <iterator_create>
c0108622:	83 ec 04             	sub    $0x4,%esp
    list_lock(groups);
c0108625:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c010862a:	89 04 24             	mov    %eax,(%esp)
c010862d:	e8 93 a6 ff ff       	call   c0102cc5 <list_lock>

    while(!list_is_last(&grps_itr))
c0108632:	eb 45                	jmp    c0108679 <get_group_by_name+0x72>
    {
        if(strcmp(((group_t *)list_get_current(&grps_itr))->name, gname) == 0)
c0108634:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108637:	89 04 24             	mov    %eax,(%esp)
c010863a:	e8 75 a7 ff ff       	call   c0102db4 <list_get_current>
c010863f:	8b 00                	mov    (%eax),%eax
c0108641:	8b 55 08             	mov    0x8(%ebp),%edx
c0108644:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108648:	89 04 24             	mov    %eax,(%esp)
c010864b:	e8 c1 a9 ff ff       	call   c0103011 <strcmp>
c0108650:	85 c0                	test   %eax,%eax
c0108652:	75 1a                	jne    c010866e <get_group_by_name+0x67>
        {
            list_unlock(groups);
c0108654:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108659:	89 04 24             	mov    %eax,(%esp)
c010865c:	e8 77 a6 ff ff       	call   c0102cd8 <list_unlock>
            return ((group_t *)list_get_current(&grps_itr));
c0108661:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108664:	89 04 24             	mov    %eax,(%esp)
c0108667:	e8 48 a7 ff ff       	call   c0102db4 <list_get_current>
c010866c:	eb 2c                	jmp    c010869a <get_group_by_name+0x93>
        }

        list_next(&grps_itr);
c010866e:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108671:	89 04 24             	mov    %eax,(%esp)
c0108674:	e8 60 a7 ff ff       	call   c0102dd9 <list_next>
group_t *get_group_by_name(const char *gname)
{
    iterator_t grps_itr = iterator_create(groups);
    list_lock(groups);

    while(!list_is_last(&grps_itr))
c0108679:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010867c:	89 04 24             	mov    %eax,(%esp)
c010867f:	e8 7c a7 ff ff       	call   c0102e00 <list_is_last>
c0108684:	85 c0                	test   %eax,%eax
c0108686:	74 ac                	je     c0108634 <get_group_by_name+0x2d>
        }

        list_next(&grps_itr);
    }

    list_unlock(groups);
c0108688:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c010868d:	89 04 24             	mov    %eax,(%esp)
c0108690:	e8 43 a6 ff ff       	call   c0102cd8 <list_unlock>

    return NULL;
c0108695:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010869a:	c9                   	leave  
c010869b:	c3                   	ret    

c010869c <add_user_to_group>:

int add_user_to_group(user_t *user, group_t *group)
{
c010869c:	55                   	push   %ebp
c010869d:	89 e5                	mov    %esp,%ebp
c010869f:	83 ec 18             	sub    $0x18,%esp
    if(user == NULL || group == NULL)
c01086a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c01086a6:	74 06                	je     c01086ae <add_user_to_group+0x12>
c01086a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01086ac:	75 07                	jne    c01086b5 <add_user_to_group+0x19>
        return FAILTURE;
c01086ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01086b3:	eb 67                	jmp    c010871c <add_user_to_group+0x80>

    list_lock(user->grps);
c01086b5:	8b 45 08             	mov    0x8(%ebp),%eax
c01086b8:	8b 40 10             	mov    0x10(%eax),%eax
c01086bb:	89 04 24             	mov    %eax,(%esp)
c01086be:	e8 02 a6 ff ff       	call   c0102cc5 <list_lock>
    list_push_back(user->grps, group);
c01086c3:	8b 45 08             	mov    0x8(%ebp),%eax
c01086c6:	8b 40 10             	mov    0x10(%eax),%eax
c01086c9:	8b 55 0c             	mov    0xc(%ebp),%edx
c01086cc:	89 54 24 04          	mov    %edx,0x4(%esp)
c01086d0:	89 04 24             	mov    %eax,(%esp)
c01086d3:	e8 87 a3 ff ff       	call   c0102a5f <list_push_back>
    list_unlock(user->grps);
c01086d8:	8b 45 08             	mov    0x8(%ebp),%eax
c01086db:	8b 40 10             	mov    0x10(%eax),%eax
c01086de:	89 04 24             	mov    %eax,(%esp)
c01086e1:	e8 f2 a5 ff ff       	call   c0102cd8 <list_unlock>

    list_lock(group->users);
c01086e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c01086e9:	8b 40 08             	mov    0x8(%eax),%eax
c01086ec:	89 04 24             	mov    %eax,(%esp)
c01086ef:	e8 d1 a5 ff ff       	call   c0102cc5 <list_lock>
    list_push_back(group->users, user);
c01086f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c01086f7:	8b 40 08             	mov    0x8(%eax),%eax
c01086fa:	8b 55 08             	mov    0x8(%ebp),%edx
c01086fd:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108701:	89 04 24             	mov    %eax,(%esp)
c0108704:	e8 56 a3 ff ff       	call   c0102a5f <list_push_back>
    list_unlock(group->users);
c0108709:	8b 45 0c             	mov    0xc(%ebp),%eax
c010870c:	8b 40 08             	mov    0x8(%eax),%eax
c010870f:	89 04 24             	mov    %eax,(%esp)
c0108712:	e8 c1 a5 ff ff       	call   c0102cd8 <list_unlock>

    return SUCCESS;
c0108717:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010871c:	c9                   	leave  
c010871d:	c3                   	ret    

c010871e <remove_user_from_group>:

int remove_user_from_group(user_t *user, group_t *group)
{
c010871e:	55                   	push   %ebp
c010871f:	89 e5                	mov    %esp,%ebp
c0108721:	83 ec 28             	sub    $0x28,%esp
    list_lock(group->users);
c0108724:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108727:	8b 40 08             	mov    0x8(%eax),%eax
c010872a:	89 04 24             	mov    %eax,(%esp)
c010872d:	e8 93 a5 ff ff       	call   c0102cc5 <list_lock>
    int result = remove_user_from_group_lockfree(user, group);
c0108732:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108735:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108739:	8b 45 08             	mov    0x8(%ebp),%eax
c010873c:	89 04 24             	mov    %eax,(%esp)
c010873f:	e8 16 00 00 00       	call   c010875a <remove_user_from_group_lockfree>
c0108744:	89 45 f4             	mov    %eax,-0xc(%ebp)
    list_unlock(group->users);
c0108747:	8b 45 0c             	mov    0xc(%ebp),%eax
c010874a:	8b 40 08             	mov    0x8(%eax),%eax
c010874d:	89 04 24             	mov    %eax,(%esp)
c0108750:	e8 83 a5 ff ff       	call   c0102cd8 <list_unlock>

    return result;
c0108755:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108758:	c9                   	leave  
c0108759:	c3                   	ret    

c010875a <remove_user_from_group_lockfree>:

int remove_user_from_group_lockfree(user_t *user, group_t *group)
{
c010875a:	55                   	push   %ebp
c010875b:	89 e5                	mov    %esp,%ebp
c010875d:	83 ec 28             	sub    $0x28,%esp
    iterator_t grps_itr = iterator_create(user->grps);
c0108760:	8b 45 08             	mov    0x8(%ebp),%eax
c0108763:	8b 50 10             	mov    0x10(%eax),%edx
c0108766:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108769:	89 54 24 04          	mov    %edx,0x4(%esp)
c010876d:	89 04 24             	mov    %eax,(%esp)
c0108770:	e8 76 a5 ff ff       	call   c0102ceb <iterator_create>
c0108775:	83 ec 04             	sub    $0x4,%esp

    while(!list_is_last(&grps_itr))
c0108778:	eb 28                	jmp    c01087a2 <remove_user_from_group_lockfree+0x48>
    {
        if((group_t *)list_get_current(&grps_itr) == group)
c010877a:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010877d:	89 04 24             	mov    %eax,(%esp)
c0108780:	e8 2f a6 ff ff       	call   c0102db4 <list_get_current>
c0108785:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0108788:	75 0d                	jne    c0108797 <remove_user_from_group_lockfree+0x3d>
        {
            list_remove(&grps_itr);
c010878a:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010878d:	89 04 24             	mov    %eax,(%esp)
c0108790:	e8 b1 a6 ff ff       	call   c0102e46 <list_remove>
            break;
c0108795:	eb 1a                	jmp    c01087b1 <remove_user_from_group_lockfree+0x57>
        }

        list_next(&grps_itr);
c0108797:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010879a:	89 04 24             	mov    %eax,(%esp)
c010879d:	e8 37 a6 ff ff       	call   c0102dd9 <list_next>

int remove_user_from_group_lockfree(user_t *user, group_t *group)
{
    iterator_t grps_itr = iterator_create(user->grps);

    while(!list_is_last(&grps_itr))
c01087a2:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01087a5:	89 04 24             	mov    %eax,(%esp)
c01087a8:	e8 53 a6 ff ff       	call   c0102e00 <list_is_last>
c01087ad:	85 c0                	test   %eax,%eax
c01087af:	74 c9                	je     c010877a <remove_user_from_group_lockfree+0x20>
        }

        list_next(&grps_itr);
    }

    iterator_t user_itr = iterator_create(group->users);
c01087b1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01087b4:	8b 50 08             	mov    0x8(%eax),%edx
c01087b7:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01087ba:	89 54 24 04          	mov    %edx,0x4(%esp)
c01087be:	89 04 24             	mov    %eax,(%esp)
c01087c1:	e8 25 a5 ff ff       	call   c0102ceb <iterator_create>
c01087c6:	83 ec 04             	sub    $0x4,%esp

    while(!list_is_last(&user_itr))
c01087c9:	eb 2d                	jmp    c01087f8 <remove_user_from_group_lockfree+0x9e>
    {
        if((user_t *)list_get_current(&user_itr) == user)
c01087cb:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01087ce:	89 04 24             	mov    %eax,(%esp)
c01087d1:	e8 de a5 ff ff       	call   c0102db4 <list_get_current>
c01087d6:	3b 45 08             	cmp    0x8(%ebp),%eax
c01087d9:	75 12                	jne    c01087ed <remove_user_from_group_lockfree+0x93>
        {
            list_remove(&user_itr);
c01087db:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01087de:	89 04 24             	mov    %eax,(%esp)
c01087e1:	e8 60 a6 ff ff       	call   c0102e46 <list_remove>
            return SUCCESS;
c01087e6:	b8 00 00 00 00       	mov    $0x0,%eax
c01087eb:	eb 1f                	jmp    c010880c <remove_user_from_group_lockfree+0xb2>
        }

        list_next(&user_itr);
c01087ed:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01087f0:	89 04 24             	mov    %eax,(%esp)
c01087f3:	e8 e1 a5 ff ff       	call   c0102dd9 <list_next>
        list_next(&grps_itr);
    }

    iterator_t user_itr = iterator_create(group->users);

    while(!list_is_last(&user_itr))
c01087f8:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01087fb:	89 04 24             	mov    %eax,(%esp)
c01087fe:	e8 fd a5 ff ff       	call   c0102e00 <list_is_last>
c0108803:	85 c0                	test   %eax,%eax
c0108805:	74 c4                	je     c01087cb <remove_user_from_group_lockfree+0x71>
        }

        list_next(&user_itr);
    }

    return FAILTURE;
c0108807:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c010880c:	c9                   	leave  
c010880d:	c3                   	ret    

c010880e <group_id_exists>:

int group_id_exists(gid_t id)
{
c010880e:	55                   	push   %ebp
c010880f:	89 e5                	mov    %esp,%ebp
c0108811:	83 ec 28             	sub    $0x28,%esp
    iterator_t grps_itr = iterator_create(groups);
c0108814:	8b 15 1c f0 11 c0    	mov    0xc011f01c,%edx
c010881a:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010881d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108821:	89 04 24             	mov    %eax,(%esp)
c0108824:	e8 c2 a4 ff ff       	call   c0102ceb <iterator_create>
c0108829:	83 ec 04             	sub    $0x4,%esp
    list_lock(groups);
c010882c:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108831:	89 04 24             	mov    %eax,(%esp)
c0108834:	e8 8c a4 ff ff       	call   c0102cc5 <list_lock>

    while(!list_is_last(&grps_itr))
c0108839:	eb 32                	jmp    c010886d <group_id_exists+0x5f>
    {
        if(((group_t *)list_get_current(&grps_itr))->id == id)
c010883b:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010883e:	89 04 24             	mov    %eax,(%esp)
c0108841:	e8 6e a5 ff ff       	call   c0102db4 <list_get_current>
c0108846:	8b 40 04             	mov    0x4(%eax),%eax
c0108849:	3b 45 08             	cmp    0x8(%ebp),%eax
c010884c:	75 14                	jne    c0108862 <group_id_exists+0x54>
        {
            list_unlock(groups);
c010884e:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108853:	89 04 24             	mov    %eax,(%esp)
c0108856:	e8 7d a4 ff ff       	call   c0102cd8 <list_unlock>
            return YES;
c010885b:	b8 01 00 00 00       	mov    $0x1,%eax
c0108860:	eb 2c                	jmp    c010888e <group_id_exists+0x80>
        }

        list_next(&grps_itr);
c0108862:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108865:	89 04 24             	mov    %eax,(%esp)
c0108868:	e8 6c a5 ff ff       	call   c0102dd9 <list_next>
int group_id_exists(gid_t id)
{
    iterator_t grps_itr = iterator_create(groups);
    list_lock(groups);

    while(!list_is_last(&grps_itr))
c010886d:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108870:	89 04 24             	mov    %eax,(%esp)
c0108873:	e8 88 a5 ff ff       	call   c0102e00 <list_is_last>
c0108878:	85 c0                	test   %eax,%eax
c010887a:	74 bf                	je     c010883b <group_id_exists+0x2d>
        }

        list_next(&grps_itr);
    }

    list_unlock(groups);
c010887c:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108881:	89 04 24             	mov    %eax,(%esp)
c0108884:	e8 4f a4 ff ff       	call   c0102cd8 <list_unlock>

    return NO;
c0108889:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010888e:	c9                   	leave  
c010888f:	c3                   	ret    

c0108890 <user_id_exists>:

int user_id_exists(uid_t id)
{
c0108890:	55                   	push   %ebp
c0108891:	89 e5                	mov    %esp,%ebp
c0108893:	83 ec 28             	sub    $0x28,%esp
    iterator_t user_itr = iterator_create(users);
c0108896:	8b 15 20 f0 11 c0    	mov    0xc011f020,%edx
c010889c:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010889f:	89 54 24 04          	mov    %edx,0x4(%esp)
c01088a3:	89 04 24             	mov    %eax,(%esp)
c01088a6:	e8 40 a4 ff ff       	call   c0102ceb <iterator_create>
c01088ab:	83 ec 04             	sub    $0x4,%esp
    list_lock(users);
c01088ae:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01088b3:	89 04 24             	mov    %eax,(%esp)
c01088b6:	e8 0a a4 ff ff       	call   c0102cc5 <list_lock>

    while(!list_is_last(&user_itr))
c01088bb:	eb 32                	jmp    c01088ef <user_id_exists+0x5f>
    {
        if(((user_t *)list_get_current(&user_itr))->id == id)
c01088bd:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01088c0:	89 04 24             	mov    %eax,(%esp)
c01088c3:	e8 ec a4 ff ff       	call   c0102db4 <list_get_current>
c01088c8:	8b 40 0c             	mov    0xc(%eax),%eax
c01088cb:	3b 45 08             	cmp    0x8(%ebp),%eax
c01088ce:	75 14                	jne    c01088e4 <user_id_exists+0x54>
        {
            list_unlock(users);
c01088d0:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01088d5:	89 04 24             	mov    %eax,(%esp)
c01088d8:	e8 fb a3 ff ff       	call   c0102cd8 <list_unlock>
            return YES;
c01088dd:	b8 01 00 00 00       	mov    $0x1,%eax
c01088e2:	eb 2c                	jmp    c0108910 <user_id_exists+0x80>
        }

        list_next(&user_itr);
c01088e4:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01088e7:	89 04 24             	mov    %eax,(%esp)
c01088ea:	e8 ea a4 ff ff       	call   c0102dd9 <list_next>
int user_id_exists(uid_t id)
{
    iterator_t user_itr = iterator_create(users);
    list_lock(users);

    while(!list_is_last(&user_itr))
c01088ef:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01088f2:	89 04 24             	mov    %eax,(%esp)
c01088f5:	e8 06 a5 ff ff       	call   c0102e00 <list_is_last>
c01088fa:	85 c0                	test   %eax,%eax
c01088fc:	74 bf                	je     c01088bd <user_id_exists+0x2d>
        }

        list_next(&user_itr);
    }

    list_unlock(users);
c01088fe:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c0108903:	89 04 24             	mov    %eax,(%esp)
c0108906:	e8 cd a3 ff ff       	call   c0102cd8 <list_unlock>

    return NO;
c010890b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0108910:	c9                   	leave  
c0108911:	c3                   	ret    

c0108912 <group_name_exists>:

int group_name_exists(const char *name)
{
c0108912:	55                   	push   %ebp
c0108913:	89 e5                	mov    %esp,%ebp
c0108915:	83 ec 28             	sub    $0x28,%esp
    iterator_t grps_itr = iterator_create(groups);
c0108918:	8b 15 1c f0 11 c0    	mov    0xc011f01c,%edx
c010891e:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108921:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108925:	89 04 24             	mov    %eax,(%esp)
c0108928:	e8 be a3 ff ff       	call   c0102ceb <iterator_create>
c010892d:	83 ec 04             	sub    $0x4,%esp
    list_lock(groups);
c0108930:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108935:	89 04 24             	mov    %eax,(%esp)
c0108938:	e8 88 a3 ff ff       	call   c0102cc5 <list_lock>

    while(!list_is_last(&grps_itr))
c010893d:	eb 3f                	jmp    c010897e <group_name_exists+0x6c>
    {
        if(strcmp(((group_t *)list_get_current(&grps_itr))->name, name) == 0)
c010893f:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108942:	89 04 24             	mov    %eax,(%esp)
c0108945:	e8 6a a4 ff ff       	call   c0102db4 <list_get_current>
c010894a:	8b 00                	mov    (%eax),%eax
c010894c:	8b 55 08             	mov    0x8(%ebp),%edx
c010894f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108953:	89 04 24             	mov    %eax,(%esp)
c0108956:	e8 b6 a6 ff ff       	call   c0103011 <strcmp>
c010895b:	85 c0                	test   %eax,%eax
c010895d:	75 14                	jne    c0108973 <group_name_exists+0x61>
        {
            list_unlock(groups);
c010895f:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108964:	89 04 24             	mov    %eax,(%esp)
c0108967:	e8 6c a3 ff ff       	call   c0102cd8 <list_unlock>
            return YES;
c010896c:	b8 01 00 00 00       	mov    $0x1,%eax
c0108971:	eb 2c                	jmp    c010899f <group_name_exists+0x8d>
        }

        list_next(&grps_itr);
c0108973:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108976:	89 04 24             	mov    %eax,(%esp)
c0108979:	e8 5b a4 ff ff       	call   c0102dd9 <list_next>
int group_name_exists(const char *name)
{
    iterator_t grps_itr = iterator_create(groups);
    list_lock(groups);

    while(!list_is_last(&grps_itr))
c010897e:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108981:	89 04 24             	mov    %eax,(%esp)
c0108984:	e8 77 a4 ff ff       	call   c0102e00 <list_is_last>
c0108989:	85 c0                	test   %eax,%eax
c010898b:	74 b2                	je     c010893f <group_name_exists+0x2d>
        }

        list_next(&grps_itr);
    }

    list_unlock(groups);
c010898d:	a1 1c f0 11 c0       	mov    0xc011f01c,%eax
c0108992:	89 04 24             	mov    %eax,(%esp)
c0108995:	e8 3e a3 ff ff       	call   c0102cd8 <list_unlock>

    return NO;
c010899a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010899f:	c9                   	leave  
c01089a0:	c3                   	ret    

c01089a1 <user_name_exists>:

int user_name_exists(const char *name)
{
c01089a1:	55                   	push   %ebp
c01089a2:	89 e5                	mov    %esp,%ebp
c01089a4:	83 ec 28             	sub    $0x28,%esp
    iterator_t user_itr = iterator_create(users);
c01089a7:	8b 15 20 f0 11 c0    	mov    0xc011f020,%edx
c01089ad:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01089b0:	89 54 24 04          	mov    %edx,0x4(%esp)
c01089b4:	89 04 24             	mov    %eax,(%esp)
c01089b7:	e8 2f a3 ff ff       	call   c0102ceb <iterator_create>
c01089bc:	83 ec 04             	sub    $0x4,%esp
    list_lock(users);
c01089bf:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01089c4:	89 04 24             	mov    %eax,(%esp)
c01089c7:	e8 f9 a2 ff ff       	call   c0102cc5 <list_lock>

    while(!list_is_last(&user_itr))
c01089cc:	eb 3f                	jmp    c0108a0d <user_name_exists+0x6c>
    {
        if(strcmp(((user_t *)list_get_current(&user_itr))->name, name) == 0)
c01089ce:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01089d1:	89 04 24             	mov    %eax,(%esp)
c01089d4:	e8 db a3 ff ff       	call   c0102db4 <list_get_current>
c01089d9:	8b 00                	mov    (%eax),%eax
c01089db:	8b 55 08             	mov    0x8(%ebp),%edx
c01089de:	89 54 24 04          	mov    %edx,0x4(%esp)
c01089e2:	89 04 24             	mov    %eax,(%esp)
c01089e5:	e8 27 a6 ff ff       	call   c0103011 <strcmp>
c01089ea:	85 c0                	test   %eax,%eax
c01089ec:	75 14                	jne    c0108a02 <user_name_exists+0x61>
        {
            list_unlock(users);
c01089ee:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c01089f3:	89 04 24             	mov    %eax,(%esp)
c01089f6:	e8 dd a2 ff ff       	call   c0102cd8 <list_unlock>
            return YES;
c01089fb:	b8 01 00 00 00       	mov    $0x1,%eax
c0108a00:	eb 2c                	jmp    c0108a2e <user_name_exists+0x8d>
        }

        list_next(&user_itr);
c0108a02:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108a05:	89 04 24             	mov    %eax,(%esp)
c0108a08:	e8 cc a3 ff ff       	call   c0102dd9 <list_next>
int user_name_exists(const char *name)
{
    iterator_t user_itr = iterator_create(users);
    list_lock(users);

    while(!list_is_last(&user_itr))
c0108a0d:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108a10:	89 04 24             	mov    %eax,(%esp)
c0108a13:	e8 e8 a3 ff ff       	call   c0102e00 <list_is_last>
c0108a18:	85 c0                	test   %eax,%eax
c0108a1a:	74 b2                	je     c01089ce <user_name_exists+0x2d>
        }

        list_next(&user_itr);
    }

    list_unlock(users);
c0108a1c:	a1 20 f0 11 c0       	mov    0xc011f020,%eax
c0108a21:	89 04 24             	mov    %eax,(%esp)
c0108a24:	e8 af a2 ff ff       	call   c0102cd8 <list_unlock>

    return NO;
c0108a29:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0108a2e:	c9                   	leave  
c0108a2f:	c3                   	ret    

c0108a30 <sys_getuid>:


void sys_getuid(struct cpu_state **cpu)
{
c0108a30:	55                   	push   %ebp
c0108a31:	89 e5                	mov    %esp,%ebp
    (*cpu)->CPU_ARG0 = current_thread->process->uid;
c0108a33:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a36:	8b 00                	mov    (%eax),%eax
c0108a38:	8b 15 0c 90 11 c0    	mov    0xc011900c,%edx
c0108a3e:	8b 12                	mov    (%edx),%edx
c0108a40:	8b 52 04             	mov    0x4(%edx),%edx
c0108a43:	89 50 28             	mov    %edx,0x28(%eax)
}
c0108a46:	5d                   	pop    %ebp
c0108a47:	c3                   	ret    

c0108a48 <sys_setuid>:

void sys_setuid(struct cpu_state **cpu)
{
c0108a48:	55                   	push   %ebp
c0108a49:	89 e5                	mov    %esp,%ebp
c0108a4b:	83 ec 28             	sub    $0x28,%esp
    if(user_id_exists((*cpu)->CPU_ARG1))
c0108a4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a51:	8b 00                	mov    (%eax),%eax
c0108a53:	8b 40 1c             	mov    0x1c(%eax),%eax
c0108a56:	89 04 24             	mov    %eax,(%esp)
c0108a59:	e8 32 fe ff ff       	call   c0108890 <user_id_exists>
c0108a5e:	85 c0                	test   %eax,%eax
c0108a60:	74 0e                	je     c0108a70 <sys_setuid+0x28>
    {
        (*cpu)->CPU_ARG0 = -1;
c0108a62:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a65:	8b 00                	mov    (%eax),%eax
c0108a67:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)
        return;
c0108a6e:	eb 2f                	jmp    c0108a9f <sys_setuid+0x57>
    }

    user_t *user = get_user_by_id(current_thread->process->uid);
c0108a70:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0108a75:	8b 00                	mov    (%eax),%eax
c0108a77:	8b 40 04             	mov    0x4(%eax),%eax
c0108a7a:	89 04 24             	mov    %eax,(%esp)
c0108a7d:	e8 c9 f7 ff ff       	call   c010824b <get_user_by_id>
c0108a82:	89 45 f4             	mov    %eax,-0xc(%ebp)
    user->id = (*cpu)->CPU_ARG1;
c0108a85:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a88:	8b 00                	mov    (%eax),%eax
c0108a8a:	8b 50 1c             	mov    0x1c(%eax),%edx
c0108a8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108a90:	89 50 0c             	mov    %edx,0xc(%eax)
    //todo: change the uids of each process and file in the home durectory
    (*cpu)->CPU_ARG0 = 1;
c0108a93:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a96:	8b 00                	mov    (%eax),%eax
c0108a98:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
c0108a9f:	c9                   	leave  
c0108aa0:	c3                   	ret    

c0108aa1 <vfs_lookup_path>:
 *
 * @param path
 * @return inode
 */
vfs_inode_t *vfs_lookup_path(char *path)
{
c0108aa1:	55                   	push   %ebp
c0108aa2:	89 e5                	mov    %esp,%ebp
c0108aa4:	83 ec 48             	sub    $0x48,%esp
    vfs_inode_t *parent = root;
c0108aa7:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c0108aac:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(path[0] != '/')
c0108aaf:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ab2:	0f b6 00             	movzbl (%eax),%eax
c0108ab5:	3c 2f                	cmp    $0x2f,%al
c0108ab7:	74 0f                	je     c0108ac8 <vfs_lookup_path+0x27>
    {
        parent = current_thread->process->cwd;
c0108ab9:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0108abe:	8b 00                	mov    (%eax),%eax
c0108ac0:	8b 40 14             	mov    0x14(%eax),%eax
c0108ac3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0108ac6:	eb 04                	jmp    c0108acc <vfs_lookup_path+0x2b>
    }
    else
    {
        path++;
c0108ac8:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    }

    if(path[0] == '\0')
c0108acc:	8b 45 08             	mov    0x8(%ebp),%eax
c0108acf:	0f b6 00             	movzbl (%eax),%eax
c0108ad2:	84 c0                	test   %al,%al
c0108ad4:	75 08                	jne    c0108ade <vfs_lookup_path+0x3d>
        return parent;
c0108ad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ad9:	e9 2b 01 00 00       	jmp    c0108c09 <vfs_lookup_path+0x168>

    int len = strlen(path);
c0108ade:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ae1:	89 04 24             	mov    %eax,(%esp)
c0108ae4:	e8 e4 a3 ff ff       	call   c0102ecd <strlen>
c0108ae9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(path[len-1] == '/')
c0108aec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108aef:	8d 50 ff             	lea    -0x1(%eax),%edx
c0108af2:	8b 45 08             	mov    0x8(%ebp),%eax
c0108af5:	01 d0                	add    %edx,%eax
c0108af7:	0f b6 00             	movzbl (%eax),%eax
c0108afa:	3c 2f                	cmp    $0x2f,%al
c0108afc:	75 0e                	jne    c0108b0c <vfs_lookup_path+0x6b>
    {
        path[len-1] = '\0';
c0108afe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108b01:	8d 50 ff             	lea    -0x1(%eax),%edx
c0108b04:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b07:	01 d0                	add    %edx,%eax
c0108b09:	c6 00 00             	movb   $0x0,(%eax)
    }

    char delimiter[] = "/";
c0108b0c:	66 c7 45 d6 2f 00    	movw   $0x2f,-0x2a(%ebp)
    char *str = (char*) strtok(path, delimiter);
c0108b12:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0108b15:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108b19:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b1c:	89 04 24             	mov    %eax,(%esp)
c0108b1f:	e8 6a a6 ff ff       	call   c010318e <strtok>
c0108b24:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(str != NULL)
c0108b27:	e9 d0 00 00 00       	jmp    c0108bfc <vfs_lookup_path+0x15b>
    {
        vfs_inode_t *real = parent;
c0108b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108b2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        GET_INODE(real);
c0108b32:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108b35:	8b 40 04             	mov    0x4(%eax),%eax
c0108b38:	83 f8 03             	cmp    $0x3,%eax
c0108b3b:	75 09                	jne    c0108b46 <vfs_lookup_path+0xa5>
c0108b3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108b40:	8b 40 3c             	mov    0x3c(%eax),%eax
c0108b43:	89 45 ec             	mov    %eax,-0x14(%ebp)

        block_buffer_info_t *info = real->read_buffer;
c0108b46:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108b49:	8b 40 3c             	mov    0x3c(%eax),%eax
c0108b4c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        iterator_t it = iterator_create(info->blocks);
c0108b4f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108b52:	8b 10                	mov    (%eax),%edx
c0108b54:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0108b57:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108b5b:	89 04 24             	mov    %eax,(%esp)
c0108b5e:	e8 88 a1 ff ff       	call   c0102ceb <iterator_create>
c0108b63:	83 ec 04             	sub    $0x4,%esp

        int found = 0;
c0108b66:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0108b6d:	eb 4a                	jmp    c0108bb9 <vfs_lookup_path+0x118>
        {
            buffer_block_t *block = it.current->element;
c0108b6f:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0108b72:	8b 40 08             	mov    0x8(%eax),%eax
c0108b75:	89 45 dc             	mov    %eax,-0x24(%ebp)
            vfs_dentry_t *dentry = (vfs_dentry_t*) block->base;
c0108b78:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108b7b:	8b 40 04             	mov    0x4(%eax),%eax
c0108b7e:	89 45 d8             	mov    %eax,-0x28(%ebp)

            if(strcmp(str, dentry->inode->name) == 0)
c0108b81:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108b84:	8b 40 04             	mov    0x4(%eax),%eax
c0108b87:	8b 00                	mov    (%eax),%eax
c0108b89:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108b8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108b90:	89 04 24             	mov    %eax,(%esp)
c0108b93:	e8 79 a4 ff ff       	call   c0103011 <strcmp>
c0108b98:	85 c0                	test   %eax,%eax
c0108b9a:	75 12                	jne    c0108bae <vfs_lookup_path+0x10d>
            {
                parent = dentry->inode;
c0108b9c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108b9f:	8b 40 04             	mov    0x4(%eax),%eax
c0108ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
                found = 1;
c0108ba5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
                break;
c0108bac:	eb 2b                	jmp    c0108bd9 <vfs_lookup_path+0x138>
            }

            list_next(&it);
c0108bae:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0108bb1:	89 04 24             	mov    %eax,(%esp)
c0108bb4:	e8 20 a2 ff ff       	call   c0102dd9 <list_next>

        block_buffer_info_t *info = real->read_buffer;
        iterator_t it = iterator_create(info->blocks);

        int found = 0;
        while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0108bb9:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0108bbc:	89 04 24             	mov    %eax,(%esp)
c0108bbf:	e8 3c a2 ff ff       	call   c0102e00 <list_is_last>
c0108bc4:	85 c0                	test   %eax,%eax
c0108bc6:	75 11                	jne    c0108bd9 <vfs_lookup_path+0x138>
c0108bc8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108bcb:	8b 00                	mov    (%eax),%eax
c0108bcd:	89 04 24             	mov    %eax,(%esp)
c0108bd0:	e8 d5 a0 ff ff       	call   c0102caa <list_is_empty>
c0108bd5:	85 c0                	test   %eax,%eax
c0108bd7:	74 96                	je     c0108b6f <vfs_lookup_path+0xce>
            }

            list_next(&it);
        }

        if(!found)
c0108bd9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0108bdd:	75 07                	jne    c0108be6 <vfs_lookup_path+0x145>
        {
            return NULL;
c0108bdf:	b8 00 00 00 00       	mov    $0x0,%eax
c0108be4:	eb 23                	jmp    c0108c09 <vfs_lookup_path+0x168>
        }
        else
        {
            str = strtok(NULL, delimiter);
c0108be6:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0108be9:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108bed:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0108bf4:	e8 95 a5 ff ff       	call   c010318e <strtok>
c0108bf9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        path[len-1] = '\0';
    }

    char delimiter[] = "/";
    char *str = (char*) strtok(path, delimiter);
    while(str != NULL)
c0108bfc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0108c00:	0f 85 26 ff ff ff    	jne    c0108b2c <vfs_lookup_path+0x8b>
        {
            str = strtok(NULL, delimiter);
        }
    }

    return parent;
c0108c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108c09:	c9                   	leave  
c0108c0a:	c3                   	ret    

c0108c0b <vfs_create_path>:
 * @param uid
 * @param gid
 * @return inode
 */
vfs_inode_t *vfs_create_path(char *path, mode_t mode, uid_t uid, gid_t gid)
{
c0108c0b:	55                   	push   %ebp
c0108c0c:	89 e5                	mov    %esp,%ebp
c0108c0e:	83 ec 68             	sub    $0x68,%esp
    vfs_inode_t *parent = root;
c0108c11:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c0108c16:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(path[0] != '/')
c0108c19:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c1c:	0f b6 00             	movzbl (%eax),%eax
c0108c1f:	3c 2f                	cmp    $0x2f,%al
c0108c21:	74 0f                	je     c0108c32 <vfs_create_path+0x27>
    {
        parent = current_thread->process->cwd;
c0108c23:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c0108c28:	8b 00                	mov    (%eax),%eax
c0108c2a:	8b 40 14             	mov    0x14(%eax),%eax
c0108c2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0108c30:	eb 04                	jmp    c0108c36 <vfs_create_path+0x2b>
    }
    else
    {
        path++;
c0108c32:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    }

    if(path[0] == '\0')
c0108c36:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c39:	0f b6 00             	movzbl (%eax),%eax
c0108c3c:	84 c0                	test   %al,%al
c0108c3e:	75 08                	jne    c0108c48 <vfs_create_path+0x3d>
        return parent;
c0108c40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108c43:	e9 9e 01 00 00       	jmp    c0108de6 <vfs_create_path+0x1db>

    int len = strlen(path);
c0108c48:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c4b:	89 04 24             	mov    %eax,(%esp)
c0108c4e:	e8 7a a2 ff ff       	call   c0102ecd <strlen>
c0108c53:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(path[len-1] == '/')
c0108c56:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108c59:	8d 50 ff             	lea    -0x1(%eax),%edx
c0108c5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c5f:	01 d0                	add    %edx,%eax
c0108c61:	0f b6 00             	movzbl (%eax),%eax
c0108c64:	3c 2f                	cmp    $0x2f,%al
c0108c66:	75 0e                	jne    c0108c76 <vfs_create_path+0x6b>
    {
        path[len-1] = '\0';
c0108c68:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108c6b:	8d 50 ff             	lea    -0x1(%eax),%edx
c0108c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c71:	01 d0                	add    %edx,%eax
c0108c73:	c6 00 00             	movb   $0x0,(%eax)
    }

    char delimiter[] = "/";
c0108c76:	66 c7 45 ce 2f 00    	movw   $0x2f,-0x32(%ebp)
    char *str = (char*) strtok(path, delimiter);
c0108c7c:	8d 45 ce             	lea    -0x32(%ebp),%eax
c0108c7f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108c83:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c86:	89 04 24             	mov    %eax,(%esp)
c0108c89:	e8 00 a5 ff ff       	call   c010318e <strtok>
c0108c8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(str != NULL)
c0108c91:	e9 43 01 00 00       	jmp    c0108dd9 <vfs_create_path+0x1ce>
    {
        vfs_inode_t *real = parent;
c0108c96:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108c99:	89 45 ec             	mov    %eax,-0x14(%ebp)
        GET_INODE(real);
c0108c9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108c9f:	8b 40 04             	mov    0x4(%eax),%eax
c0108ca2:	83 f8 03             	cmp    $0x3,%eax
c0108ca5:	75 09                	jne    c0108cb0 <vfs_create_path+0xa5>
c0108ca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108caa:	8b 40 3c             	mov    0x3c(%eax),%eax
c0108cad:	89 45 ec             	mov    %eax,-0x14(%ebp)

        block_buffer_info_t *info = real->write_buffer;
c0108cb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108cb3:	8b 40 40             	mov    0x40(%eax),%eax
c0108cb6:	89 45 dc             	mov    %eax,-0x24(%ebp)
        iterator_t it = iterator_create(info->blocks);
c0108cb9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108cbc:	8b 10                	mov    (%eax),%edx
c0108cbe:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c0108cc1:	89 54 24 04          	mov    %edx,0x4(%esp)
c0108cc5:	89 04 24             	mov    %eax,(%esp)
c0108cc8:	e8 1e a0 ff ff       	call   c0102ceb <iterator_create>
c0108ccd:	83 ec 04             	sub    $0x4,%esp

        int found = 0;
c0108cd0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0108cd7:	eb 4a                	jmp    c0108d23 <vfs_create_path+0x118>
        {
            buffer_block_t *block = it.current->element;
c0108cd9:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0108cdc:	8b 40 08             	mov    0x8(%eax),%eax
c0108cdf:	89 45 d8             	mov    %eax,-0x28(%ebp)
            vfs_dentry_t *dentry = (vfs_dentry_t*) block->base;
c0108ce2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108ce5:	8b 40 04             	mov    0x4(%eax),%eax
c0108ce8:	89 45 d4             	mov    %eax,-0x2c(%ebp)

            if(strcmp(str, dentry->inode->name) == 0)
c0108ceb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108cee:	8b 40 04             	mov    0x4(%eax),%eax
c0108cf1:	8b 00                	mov    (%eax),%eax
c0108cf3:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108cf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108cfa:	89 04 24             	mov    %eax,(%esp)
c0108cfd:	e8 0f a3 ff ff       	call   c0103011 <strcmp>
c0108d02:	85 c0                	test   %eax,%eax
c0108d04:	75 12                	jne    c0108d18 <vfs_create_path+0x10d>
            {
                parent = dentry->inode;
c0108d06:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108d09:	8b 40 04             	mov    0x4(%eax),%eax
c0108d0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                found = 1;
c0108d0f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
                break;
c0108d16:	eb 2b                	jmp    c0108d43 <vfs_create_path+0x138>
            }

            list_next(&it);
c0108d18:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c0108d1b:	89 04 24             	mov    %eax,(%esp)
c0108d1e:	e8 b6 a0 ff ff       	call   c0102dd9 <list_next>

        block_buffer_info_t *info = real->write_buffer;
        iterator_t it = iterator_create(info->blocks);

        int found = 0;
        while(! list_is_last(&it) && ! list_is_empty(info->blocks))
c0108d23:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c0108d26:	89 04 24             	mov    %eax,(%esp)
c0108d29:	e8 d2 a0 ff ff       	call   c0102e00 <list_is_last>
c0108d2e:	85 c0                	test   %eax,%eax
c0108d30:	75 11                	jne    c0108d43 <vfs_create_path+0x138>
c0108d32:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108d35:	8b 00                	mov    (%eax),%eax
c0108d37:	89 04 24             	mov    %eax,(%esp)
c0108d3a:	e8 6b 9f ff ff       	call   c0102caa <list_is_empty>
c0108d3f:	85 c0                	test   %eax,%eax
c0108d41:	74 96                	je     c0108cd9 <vfs_create_path+0xce>
            }

            list_next(&it);
        }

        char *new_str = strtok(NULL, delimiter);
c0108d43:	8d 45 ce             	lea    -0x32(%ebp),%eax
c0108d46:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108d4a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0108d51:	e8 38 a4 ff ff       	call   c010318e <strtok>
c0108d56:	89 45 d0             	mov    %eax,-0x30(%ebp)
        if(!found)
c0108d59:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0108d5d:	75 74                	jne    c0108dd3 <vfs_create_path+0x1c8>
        {
            int n_mode;
            if(new_str != NULL)
c0108d5f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c0108d63:	74 10                	je     c0108d75 <vfs_create_path+0x16a>
                n_mode = mode & (S_IRWXU | S_IRWXG | S_IRWXO) | S_IFDIR;
c0108d65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108d68:	25 00 07 00 00       	and    $0x700,%eax
c0108d6d:	83 c8 20             	or     $0x20,%eax
c0108d70:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0108d73:	eb 06                	jmp    c0108d7b <vfs_create_path+0x170>
            else
                n_mode = mode;
c0108d75:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108d78:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            if(vfs_access(parent, W_OK, uid, gid) == 0)
c0108d7b:	8b 45 14             	mov    0x14(%ebp),%eax
c0108d7e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0108d82:	8b 45 10             	mov    0x10(%ebp),%eax
c0108d85:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108d89:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c0108d90:	00 
c0108d91:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d94:	89 04 24             	mov    %eax,(%esp)
c0108d97:	e8 10 d4 ff ff       	call   c01061ac <vfs_access>
c0108d9c:	85 c0                	test   %eax,%eax
c0108d9e:	75 2c                	jne    c0108dcc <vfs_create_path+0x1c1>
            {
                parent = vfs_create_inode(str, n_mode, parent, uid, gid);
c0108da0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108da3:	8b 55 14             	mov    0x14(%ebp),%edx
c0108da6:	89 54 24 10          	mov    %edx,0x10(%esp)
c0108daa:	8b 55 10             	mov    0x10(%ebp),%edx
c0108dad:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0108db1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108db4:	89 54 24 08          	mov    %edx,0x8(%esp)
c0108db8:	89 44 24 04          	mov    %eax,0x4(%esp)
c0108dbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108dbf:	89 04 24             	mov    %eax,(%esp)
c0108dc2:	e8 67 d0 ff ff       	call   c0105e2e <vfs_create_inode>
c0108dc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0108dca:	eb 07                	jmp    c0108dd3 <vfs_create_path+0x1c8>
            }
            else
            {
                return NULL;
c0108dcc:	b8 00 00 00 00       	mov    $0x0,%eax
c0108dd1:	eb 13                	jmp    c0108de6 <vfs_create_path+0x1db>
            }
        }
        str = new_str;
c0108dd3:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0108dd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
        path[len-1] = '\0';
    }

    char delimiter[] = "/";
    char *str = (char*) strtok(path, delimiter);
    while(str != NULL)
c0108dd9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0108ddd:	0f 85 b3 fe ff ff    	jne    c0108c96 <vfs_create_path+0x8b>
            }
        }
        str = new_str;
    }

    return parent;
c0108de3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0108de6:	c9                   	leave  
c0108de7:	c3                   	ret    

c0108de8 <test_vfs>:
#define COUNT 100
#define STEP (int)((float)COUNT/(float)20)
extern vfs_inode_t *root;

bool test_vfs()
{
c0108de8:	55                   	push   %ebp
c0108de9:	89 e5                	mov    %esp,%ebp
c0108deb:	53                   	push   %ebx
c0108dec:	81 ec 44 01 00 00    	sub    $0x144,%esp
    int i,j;
    char name[256];
    vfs_inode_t **inodes = malloc(sizeof(vfs_inode_t*) * COUNT);
c0108df2:	c7 04 24 90 01 00 00 	movl   $0x190,(%esp)
c0108df9:	e8 47 31 00 00       	call   c010bf45 <malloc>
c0108dfe:	89 45 e8             	mov    %eax,-0x18(%ebp)

    printf("creating %d inodes...\n", COUNT);
c0108e01:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
c0108e08:	00 
c0108e09:	c7 04 24 c9 0b 11 c0 	movl   $0xc0110bc9,(%esp)
c0108e10:	e8 0c a8 ff ff       	call   c0103621 <printf>
    for(i = 0; i < COUNT; i++)
c0108e15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0108e1c:	e9 92 00 00 00       	jmp    c0108eb3 <test_vfs+0xcb>
    {
        sprintf(name, "test_inode%d", i);
c0108e21:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e24:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108e28:	c7 44 24 04 e0 0b 11 	movl   $0xc0110be0,0x4(%esp)
c0108e2f:	c0 
c0108e30:	8d 85 df fe ff ff    	lea    -0x121(%ebp),%eax
c0108e36:	89 04 24             	mov    %eax,(%esp)
c0108e39:	e8 50 a8 ff ff       	call   c010368e <sprintf>
        inodes[i] = vfs_create_inode(name, S_IRUSR | S_IWUSR, root, 0, 0);
c0108e3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e41:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108e48:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108e4b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0108e4e:	a1 20 90 11 c0       	mov    0xc0119020,%eax
c0108e53:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0108e5a:	00 
c0108e5b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0108e62:	00 
c0108e63:	89 44 24 08          	mov    %eax,0x8(%esp)
c0108e67:	c7 44 24 04 00 03 00 	movl   $0x300,0x4(%esp)
c0108e6e:	00 
c0108e6f:	8d 85 df fe ff ff    	lea    -0x121(%ebp),%eax
c0108e75:	89 04 24             	mov    %eax,(%esp)
c0108e78:	e8 b1 cf ff ff       	call   c0105e2e <vfs_create_inode>
c0108e7d:	89 03                	mov    %eax,(%ebx)

        if((i % STEP) == 0)
c0108e7f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0108e82:	ba 67 66 66 66       	mov    $0x66666667,%edx
c0108e87:	89 c8                	mov    %ecx,%eax
c0108e89:	f7 ea                	imul   %edx
c0108e8b:	d1 fa                	sar    %edx
c0108e8d:	89 c8                	mov    %ecx,%eax
c0108e8f:	c1 f8 1f             	sar    $0x1f,%eax
c0108e92:	29 c2                	sub    %eax,%edx
c0108e94:	89 d0                	mov    %edx,%eax
c0108e96:	c1 e0 02             	shl    $0x2,%eax
c0108e99:	01 d0                	add    %edx,%eax
c0108e9b:	89 ca                	mov    %ecx,%edx
c0108e9d:	29 c2                	sub    %eax,%edx
c0108e9f:	85 d2                	test   %edx,%edx
c0108ea1:	75 0c                	jne    c0108eaf <test_vfs+0xc7>
        {
            printf("=");
c0108ea3:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp)
c0108eaa:	e8 8f 32 00 00       	call   c010c13e <putchar>
    int i,j;
    char name[256];
    vfs_inode_t **inodes = malloc(sizeof(vfs_inode_t*) * COUNT);

    printf("creating %d inodes...\n", COUNT);
    for(i = 0; i < COUNT; i++)
c0108eaf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0108eb3:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
c0108eb7:	0f 8e 64 ff ff ff    	jle    c0108e21 <test_vfs+0x39>
        if((i % STEP) == 0)
        {
            printf("=");
        }
    }
    printf("\n");
c0108ebd:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0108ec4:	e8 75 32 00 00       	call   c010c13e <putchar>

    printf("writing a lot in them...\n");
c0108ec9:	c7 04 24 ed 0b 11 c0 	movl   $0xc0110bed,(%esp)
c0108ed0:	e8 ca 33 00 00       	call   c010c29f <puts>
    for(i = 0; i < COUNT; i++)
c0108ed5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0108edc:	e9 ce 00 00 00       	jmp    c0108faf <test_vfs+0x1c7>
    {
        char *buffer = malloc(10000);
c0108ee1:	c7 04 24 10 27 00 00 	movl   $0x2710,(%esp)
c0108ee8:	e8 58 30 00 00       	call   c010bf45 <malloc>
c0108eed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        for(j = 0; j < 10000; j++)
c0108ef0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0108ef7:	eb 3e                	jmp    c0108f37 <test_vfs+0x14f>
        {
            buffer[j] = 'a' + j%25;
c0108ef9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0108efc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108eff:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0108f02:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0108f05:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0108f0a:	89 c8                	mov    %ecx,%eax
c0108f0c:	f7 ea                	imul   %edx
c0108f0e:	c1 fa 03             	sar    $0x3,%edx
c0108f11:	89 c8                	mov    %ecx,%eax
c0108f13:	c1 f8 1f             	sar    $0x1f,%eax
c0108f16:	29 c2                	sub    %eax,%edx
c0108f18:	89 d0                	mov    %edx,%eax
c0108f1a:	c1 e0 02             	shl    $0x2,%eax
c0108f1d:	01 d0                	add    %edx,%eax
c0108f1f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108f26:	01 d0                	add    %edx,%eax
c0108f28:	89 ca                	mov    %ecx,%edx
c0108f2a:	29 c2                	sub    %eax,%edx
c0108f2c:	89 d0                	mov    %edx,%eax
c0108f2e:	83 c0 61             	add    $0x61,%eax
c0108f31:	88 03                	mov    %al,(%ebx)

    printf("writing a lot in them...\n");
    for(i = 0; i < COUNT; i++)
    {
        char *buffer = malloc(10000);
        for(j = 0; j < 10000; j++)
c0108f33:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0108f37:	81 7d f0 0f 27 00 00 	cmpl   $0x270f,-0x10(%ebp)
c0108f3e:	7e b9                	jle    c0108ef9 <test_vfs+0x111>
        {
            buffer[j] = 'a' + j%25;
        }

        vfs_write(inodes[i], 0, buffer, 10000);
c0108f40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108f43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108f4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108f4d:	01 d0                	add    %edx,%eax
c0108f4f:	8b 00                	mov    (%eax),%eax
c0108f51:	c7 44 24 0c 10 27 00 	movl   $0x2710,0xc(%esp)
c0108f58:	00 
c0108f59:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0108f5c:	89 54 24 08          	mov    %edx,0x8(%esp)
c0108f60:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0108f67:	00 
c0108f68:	89 04 24             	mov    %eax,(%esp)
c0108f6b:	e8 e2 d0 ff ff       	call   c0106052 <vfs_write>

        free(buffer);
c0108f70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108f73:	89 04 24             	mov    %eax,(%esp)
c0108f76:	e8 d8 30 00 00       	call   c010c053 <free>

        if((i % STEP) == 0)
c0108f7b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0108f7e:	ba 67 66 66 66       	mov    $0x66666667,%edx
c0108f83:	89 c8                	mov    %ecx,%eax
c0108f85:	f7 ea                	imul   %edx
c0108f87:	d1 fa                	sar    %edx
c0108f89:	89 c8                	mov    %ecx,%eax
c0108f8b:	c1 f8 1f             	sar    $0x1f,%eax
c0108f8e:	29 c2                	sub    %eax,%edx
c0108f90:	89 d0                	mov    %edx,%eax
c0108f92:	c1 e0 02             	shl    $0x2,%eax
c0108f95:	01 d0                	add    %edx,%eax
c0108f97:	89 ca                	mov    %ecx,%edx
c0108f99:	29 c2                	sub    %eax,%edx
c0108f9b:	85 d2                	test   %edx,%edx
c0108f9d:	75 0c                	jne    c0108fab <test_vfs+0x1c3>
        {
            printf("=");
c0108f9f:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp)
c0108fa6:	e8 93 31 00 00       	call   c010c13e <putchar>
        }
    }
    printf("\n");

    printf("writing a lot in them...\n");
    for(i = 0; i < COUNT; i++)
c0108fab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0108faf:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
c0108fb3:	0f 8e 28 ff ff ff    	jle    c0108ee1 <test_vfs+0xf9>
        if((i % STEP) == 0)
        {
            printf("=");
        }
    }
    printf("\n");
c0108fb9:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0108fc0:	e8 79 31 00 00       	call   c010c13e <putchar>

    printf("read them out and check!\n");
c0108fc5:	c7 04 24 06 0c 11 c0 	movl   $0xc0110c06,(%esp)
c0108fcc:	e8 ce 32 00 00       	call   c010c29f <puts>
    int fails=0;
c0108fd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = 0; i < COUNT; i++)
c0108fd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0108fdf:	e9 ef 00 00 00       	jmp    c01090d3 <test_vfs+0x2eb>
    {
        char *buffer = malloc(10000);
c0108fe4:	c7 04 24 10 27 00 00 	movl   $0x2710,(%esp)
c0108feb:	e8 55 2f 00 00       	call   c010bf45 <malloc>
c0108ff0:	89 45 e0             	mov    %eax,-0x20(%ebp)
        vfs_read(inodes[i], 0, buffer, 10000);
c0108ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ff6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108ffd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109000:	01 d0                	add    %edx,%eax
c0109002:	8b 00                	mov    (%eax),%eax
c0109004:	c7 44 24 0c 10 27 00 	movl   $0x2710,0xc(%esp)
c010900b:	00 
c010900c:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010900f:	89 54 24 08          	mov    %edx,0x8(%esp)
c0109013:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010901a:	00 
c010901b:	89 04 24             	mov    %eax,(%esp)
c010901e:	e8 fb d0 ff ff       	call   c010611e <vfs_read>

        for(j = 0; j < 10000; j++)
c0109023:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010902a:	eb 5f                	jmp    c010908b <test_vfs+0x2a3>
        {
            char testchar = 'a' + j%25;
c010902c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c010902f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0109034:	89 c8                	mov    %ecx,%eax
c0109036:	f7 ea                	imul   %edx
c0109038:	c1 fa 03             	sar    $0x3,%edx
c010903b:	89 c8                	mov    %ecx,%eax
c010903d:	c1 f8 1f             	sar    $0x1f,%eax
c0109040:	29 c2                	sub    %eax,%edx
c0109042:	89 d0                	mov    %edx,%eax
c0109044:	c1 e0 02             	shl    $0x2,%eax
c0109047:	01 d0                	add    %edx,%eax
c0109049:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0109050:	01 d0                	add    %edx,%eax
c0109052:	89 ca                	mov    %ecx,%edx
c0109054:	29 c2                	sub    %eax,%edx
c0109056:	89 d0                	mov    %edx,%eax
c0109058:	83 c0 61             	add    $0x61,%eax
c010905b:	88 45 df             	mov    %al,-0x21(%ebp)
            if(buffer[j] != testchar)
c010905e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0109061:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109064:	01 d0                	add    %edx,%eax
c0109066:	0f b6 00             	movzbl (%eax),%eax
c0109069:	3a 45 df             	cmp    -0x21(%ebp),%al
c010906c:	74 19                	je     c0109087 <test_vfs+0x29f>
            {
                printf("failed at %d\n", j);
c010906e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109071:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109075:	c7 04 24 1f 0c 11 c0 	movl   $0xc0110c1f,(%esp)
c010907c:	e8 a0 a5 ff ff       	call   c0103621 <printf>
                fails ++;
c0109081:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
                break;
c0109085:	eb 0d                	jmp    c0109094 <test_vfs+0x2ac>
    for(i = 0; i < COUNT; i++)
    {
        char *buffer = malloc(10000);
        vfs_read(inodes[i], 0, buffer, 10000);

        for(j = 0; j < 10000; j++)
c0109087:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010908b:	81 7d f0 0f 27 00 00 	cmpl   $0x270f,-0x10(%ebp)
c0109092:	7e 98                	jle    c010902c <test_vfs+0x244>
                fails ++;
                break;
            }
        }

        free(buffer);
c0109094:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109097:	89 04 24             	mov    %eax,(%esp)
c010909a:	e8 b4 2f 00 00       	call   c010c053 <free>

        if((i % STEP) == 0)
c010909f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c01090a2:	ba 67 66 66 66       	mov    $0x66666667,%edx
c01090a7:	89 c8                	mov    %ecx,%eax
c01090a9:	f7 ea                	imul   %edx
c01090ab:	d1 fa                	sar    %edx
c01090ad:	89 c8                	mov    %ecx,%eax
c01090af:	c1 f8 1f             	sar    $0x1f,%eax
c01090b2:	29 c2                	sub    %eax,%edx
c01090b4:	89 d0                	mov    %edx,%eax
c01090b6:	c1 e0 02             	shl    $0x2,%eax
c01090b9:	01 d0                	add    %edx,%eax
c01090bb:	89 ca                	mov    %ecx,%edx
c01090bd:	29 c2                	sub    %eax,%edx
c01090bf:	85 d2                	test   %edx,%edx
c01090c1:	75 0c                	jne    c01090cf <test_vfs+0x2e7>
        {
            printf("=");
c01090c3:	c7 04 24 3d 00 00 00 	movl   $0x3d,(%esp)
c01090ca:	e8 6f 30 00 00       	call   c010c13e <putchar>
    }
    printf("\n");

    printf("read them out and check!\n");
    int fails=0;
    for(i = 0; i < COUNT; i++)
c01090cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01090d3:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
c01090d7:	0f 8e 07 ff ff ff    	jle    c0108fe4 <test_vfs+0x1fc>
        if((i % STEP) == 0)
        {
            printf("=");
        }
    }
    printf("\n");
c01090dd:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c01090e4:	e8 55 30 00 00       	call   c010c13e <putchar>

    printf("%d of %d inodes failed\n", fails, COUNT);
c01090e9:	c7 44 24 08 64 00 00 	movl   $0x64,0x8(%esp)
c01090f0:	00 
c01090f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01090f4:	89 44 24 04          	mov    %eax,0x4(%esp)
c01090f8:	c7 04 24 2d 0c 11 c0 	movl   $0xc0110c2d,(%esp)
c01090ff:	e8 1d a5 ff ff       	call   c0103621 <printf>

    free(inodes);
c0109104:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109107:	89 04 24             	mov    %eax,(%esp)
c010910a:	e8 44 2f 00 00       	call   c010c053 <free>
    if(fails)
c010910f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0109113:	74 07                	je     c010911c <test_vfs+0x334>
        return false;
c0109115:	b8 00 00 00 00       	mov    $0x0,%eax
c010911a:	eb 05                	jmp    c0109121 <test_vfs+0x339>
    return true;
c010911c:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0109121:	81 c4 44 01 00 00    	add    $0x144,%esp
c0109127:	5b                   	pop    %ebx
c0109128:	5d                   	pop    %ebp
c0109129:	c3                   	ret    

c010912a <xorshift32>:

#include <mm/heap.h>
#include <printf.h>

int xorshift32(int x)
{
c010912a:	55                   	push   %ebp
c010912b:	89 e5                	mov    %esp,%ebp
    x ^= x << 13;
c010912d:	8b 45 08             	mov    0x8(%ebp),%eax
c0109130:	c1 e0 0d             	shl    $0xd,%eax
c0109133:	31 45 08             	xor    %eax,0x8(%ebp)
    x ^= x >> 17;
c0109136:	8b 45 08             	mov    0x8(%ebp),%eax
c0109139:	c1 f8 11             	sar    $0x11,%eax
c010913c:	31 45 08             	xor    %eax,0x8(%ebp)
    x ^= x << 5;
c010913f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109142:	c1 e0 05             	shl    $0x5,%eax
c0109145:	31 45 08             	xor    %eax,0x8(%ebp)
    return x;
c0109148:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010914b:	5d                   	pop    %ebp
c010914c:	c3                   	ret    

c010914d <test_heap>:

bool test_heap(int n)
{
c010914d:	55                   	push   %ebp
c010914e:	89 e5                	mov    %esp,%ebp
c0109150:	53                   	push   %ebx
c0109151:	83 ec 24             	sub    $0x24,%esp
    int **vals = malloc(n * sizeof(int*));
c0109154:	8b 45 08             	mov    0x8(%ebp),%eax
c0109157:	c1 e0 02             	shl    $0x2,%eax
c010915a:	89 04 24             	mov    %eax,(%esp)
c010915d:	e8 e3 2d 00 00       	call   c010bf45 <malloc>
c0109162:	89 45 ec             	mov    %eax,-0x14(%ebp)

    int i,j;
    for(i = 0; i < n; i++)
c0109165:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010916c:	eb 6e                	jmp    c01091dc <test_heap+0x8f>
    {
        vals[i] = malloc((i+1) * sizeof(int));
c010916e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109171:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0109178:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010917b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c010917e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109181:	83 c0 01             	add    $0x1,%eax
c0109184:	c1 e0 02             	shl    $0x2,%eax
c0109187:	89 04 24             	mov    %eax,(%esp)
c010918a:	e8 b6 2d 00 00       	call   c010bf45 <malloc>
c010918f:	89 03                	mov    %eax,(%ebx)
        for(j = 0; j < (i+1); j++)
c0109191:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0109198:	eb 33                	jmp    c01091cd <test_heap+0x80>
        {
            vals[i][j] = xorshift32(n + i - j);
c010919a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010919d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01091a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01091a7:	01 d0                	add    %edx,%eax
c01091a9:	8b 00                	mov    (%eax),%eax
c01091ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01091ae:	c1 e2 02             	shl    $0x2,%edx
c01091b1:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
c01091b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01091b7:	8b 55 08             	mov    0x8(%ebp),%edx
c01091ba:	01 d0                	add    %edx,%eax
c01091bc:	2b 45 f0             	sub    -0x10(%ebp),%eax
c01091bf:	89 04 24             	mov    %eax,(%esp)
c01091c2:	e8 63 ff ff ff       	call   c010912a <xorshift32>
c01091c7:	89 03                	mov    %eax,(%ebx)

    int i,j;
    for(i = 0; i < n; i++)
    {
        vals[i] = malloc((i+1) * sizeof(int));
        for(j = 0; j < (i+1); j++)
c01091c9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01091cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01091d0:	83 c0 01             	add    $0x1,%eax
c01091d3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c01091d6:	7f c2                	jg     c010919a <test_heap+0x4d>
bool test_heap(int n)
{
    int **vals = malloc(n * sizeof(int*));

    int i,j;
    for(i = 0; i < n; i++)
c01091d8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01091dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01091df:	3b 45 08             	cmp    0x8(%ebp),%eax
c01091e2:	7c 8a                	jl     c010916e <test_heap+0x21>
        {
            vals[i][j] = xorshift32(n + i - j);
        }
    }

    printf("testing....");
c01091e4:	c7 04 24 45 0c 11 c0 	movl   $0xc0110c45,(%esp)
c01091eb:	e8 31 a4 ff ff       	call   c0103621 <printf>
    for(i = 0; i < n; i++)
c01091f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01091f7:	eb 65                	jmp    c010925e <test_heap+0x111>
    {
        for(j = 0; j < (i+1); j++)
c01091f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0109200:	eb 4d                	jmp    c010924f <test_heap+0x102>
        {
            int expected = xorshift32(n + i - j);
c0109202:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109205:	8b 55 08             	mov    0x8(%ebp),%edx
c0109208:	01 d0                	add    %edx,%eax
c010920a:	2b 45 f0             	sub    -0x10(%ebp),%eax
c010920d:	89 04 24             	mov    %eax,(%esp)
c0109210:	e8 15 ff ff ff       	call   c010912a <xorshift32>
c0109215:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if(vals[i][j] != expected)
c0109218:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010921b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0109222:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109225:	01 d0                	add    %edx,%eax
c0109227:	8b 00                	mov    (%eax),%eax
c0109229:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010922c:	c1 e2 02             	shl    $0x2,%edx
c010922f:	01 d0                	add    %edx,%eax
c0109231:	8b 00                	mov    (%eax),%eax
c0109233:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0109236:	74 13                	je     c010924b <test_heap+0xfe>
            {
                printf("FAILURE!\n");
c0109238:	c7 04 24 51 0c 11 c0 	movl   $0xc0110c51,(%esp)
c010923f:	e8 5b 30 00 00       	call   c010c29f <puts>
                return false;
c0109244:	b8 00 00 00 00       	mov    $0x0,%eax
c0109249:	eb 2c                	jmp    c0109277 <test_heap+0x12a>
    }

    printf("testing....");
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < (i+1); j++)
c010924b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010924f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109252:	83 c0 01             	add    $0x1,%eax
c0109255:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0109258:	7f a8                	jg     c0109202 <test_heap+0xb5>
            vals[i][j] = xorshift32(n + i - j);
        }
    }

    printf("testing....");
    for(i = 0; i < n; i++)
c010925a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010925e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109261:	3b 45 08             	cmp    0x8(%ebp),%eax
c0109264:	7c 93                	jl     c01091f9 <test_heap+0xac>
                return false;
            }
        }
    }

    printf("SUCCESS!\n");
c0109266:	c7 04 24 5a 0c 11 c0 	movl   $0xc0110c5a,(%esp)
c010926d:	e8 2d 30 00 00       	call   c010c29f <puts>

    return true;
c0109272:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0109277:	83 c4 24             	add    $0x24,%esp
c010927a:	5b                   	pop    %ebx
c010927b:	5d                   	pop    %ebp
c010927c:	c3                   	ret    

c010927d <test_list_create_destroy>:
 * @brief tests the create/destroy functions of the list module
 * @return 0 if success
 * @return 1 if failture
 */
int test_list_create_destroy()
{
c010927d:	55                   	push   %ebp
c010927e:	89 e5                	mov    %esp,%ebp
c0109280:	81 ec b8 01 00 00    	sub    $0x1b8,%esp
    list_t *firstList = NULL;
c0109286:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    if((firstList = list_create()) == NULL)
c010928d:	e8 e9 96 ff ff       	call   c010297b <list_create>
c0109292:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0109295:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0109299:	75 16                	jne    c01092b1 <test_list_create_destroy+0x34>
    {
        printf("create/delete one list: failture\n");
c010929b:	c7 04 24 64 0c 11 c0 	movl   $0xc0110c64,(%esp)
c01092a2:	e8 f8 2f 00 00       	call   c010c29f <puts>
        return 1;
c01092a7:	b8 01 00 00 00       	mov    $0x1,%eax
c01092ac:	e9 80 00 00 00       	jmp    c0109331 <test_list_create_destroy+0xb4>
    }

    list_destroy(firstList);
c01092b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01092b4:	89 04 24             	mov    %eax,(%esp)
c01092b7:	e8 17 97 ff ff       	call   c01029d3 <list_destroy>

    list_t *nextLists[CREATE_TEST_NUMBER];
    int i;

    for(i = 0; i < CREATE_TEST_NUMBER; i++)
c01092bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01092c3:	eb 3c                	jmp    c0109301 <test_list_create_destroy+0x84>
    {
        if((nextLists[i] = list_create()) == NULL)
c01092c5:	e8 b1 96 ff ff       	call   c010297b <list_create>
c01092ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01092cd:	89 84 95 60 fe ff ff 	mov    %eax,-0x1a0(%ebp,%edx,4)
c01092d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01092d7:	8b 84 85 60 fe ff ff 	mov    -0x1a0(%ebp,%eax,4),%eax
c01092de:	85 c0                	test   %eax,%eax
c01092e0:	75 1b                	jne    c01092fd <test_list_create_destroy+0x80>
        {
            printf("create/delete %d lists: failture\n", CREATE_TEST_NUMBER);
c01092e2:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
c01092e9:	00 
c01092ea:	c7 04 24 88 0c 11 c0 	movl   $0xc0110c88,(%esp)
c01092f1:	e8 2b a3 ff ff       	call   c0103621 <printf>
            return 1;
c01092f6:	b8 01 00 00 00       	mov    $0x1,%eax
c01092fb:	eb 34                	jmp    c0109331 <test_list_create_destroy+0xb4>
    list_destroy(firstList);

    list_t *nextLists[CREATE_TEST_NUMBER];
    int i;

    for(i = 0; i < CREATE_TEST_NUMBER; i++)
c01092fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0109301:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
c0109305:	7e be                	jle    c01092c5 <test_list_create_destroy+0x48>
            printf("create/delete %d lists: failture\n", CREATE_TEST_NUMBER);
            return 1;
        }
    }

    for(i = 0; i < CREATE_TEST_NUMBER; i++)
c0109307:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010930e:	eb 16                	jmp    c0109326 <test_list_create_destroy+0xa9>
        list_destroy(nextLists[i]);
c0109310:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109313:	8b 84 85 60 fe ff ff 	mov    -0x1a0(%ebp,%eax,4),%eax
c010931a:	89 04 24             	mov    %eax,(%esp)
c010931d:	e8 b1 96 ff ff       	call   c01029d3 <list_destroy>
            printf("create/delete %d lists: failture\n", CREATE_TEST_NUMBER);
            return 1;
        }
    }

    for(i = 0; i < CREATE_TEST_NUMBER; i++)
c0109322:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0109326:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
c010932a:	7e e4                	jle    c0109310 <test_list_create_destroy+0x93>
        list_destroy(nextLists[i]);

    return 0;
c010932c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0109331:	c9                   	leave  
c0109332:	c3                   	ret    

c0109333 <test_list_push_pop>:
 * @brief tests the push/pop functions of the list module
 * @return 0 if success
 * @return 1 if failture
 */
int test_list_push_pop()
{
c0109333:	55                   	push   %ebp
c0109334:	89 e5                	mov    %esp,%ebp
c0109336:	83 ec 48             	sub    $0x48,%esp
    list_t *testList = list_create();
c0109339:	e8 3d 96 ff ff       	call   c010297b <list_create>
c010933e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int a = 12345;
c0109341:	c7 45 e0 39 30 00 00 	movl   $0x3039,-0x20(%ebp)
    int b = 98765;
c0109348:	c7 45 dc cd 81 01 00 	movl   $0x181cd,-0x24(%ebp)
    int c = 54321;
c010934f:	c7 45 d8 31 d4 00 00 	movl   $0xd431,-0x28(%ebp)
    int d = 56789;
c0109356:	c7 45 d4 d5 dd 00 00 	movl   $0xddd5,-0x2c(%ebp)
    int *resa, *resb, *resc, *resd;

    list_push_front(testList, &b);
c010935d:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0109360:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109364:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109367:	89 04 24             	mov    %eax,(%esp)
c010936a:	e8 43 97 ff ff       	call   c0102ab2 <list_push_front>
    list_push_front(testList, &a);
c010936f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0109372:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109376:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109379:	89 04 24             	mov    %eax,(%esp)
c010937c:	e8 31 97 ff ff       	call   c0102ab2 <list_push_front>
    list_push_back(testList, &c);
c0109381:	8d 45 d8             	lea    -0x28(%ebp),%eax
c0109384:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109388:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010938b:	89 04 24             	mov    %eax,(%esp)
c010938e:	e8 cc 96 ff ff       	call   c0102a5f <list_push_back>
    list_push_back(testList, &d);
c0109393:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c0109396:	89 44 24 04          	mov    %eax,0x4(%esp)
c010939a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010939d:	89 04 24             	mov    %eax,(%esp)
c01093a0:	e8 ba 96 ff ff       	call   c0102a5f <list_push_back>

    resa = list_pop_front(testList);
c01093a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01093a8:	89 04 24             	mov    %eax,(%esp)
c01093ab:	e8 d2 97 ff ff       	call   c0102b82 <list_pop_front>
c01093b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    resb = list_pop_front(testList);
c01093b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01093b6:	89 04 24             	mov    %eax,(%esp)
c01093b9:	e8 c4 97 ff ff       	call   c0102b82 <list_pop_front>
c01093be:	89 45 ec             	mov    %eax,-0x14(%ebp)
    resd = list_pop_back(testList);
c01093c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01093c4:	89 04 24             	mov    %eax,(%esp)
c01093c7:	e8 70 97 ff ff       	call   c0102b3c <list_pop_back>
c01093cc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    resc = list_pop_back(testList);
c01093cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01093d2:	89 04 24             	mov    %eax,(%esp)
c01093d5:	e8 62 97 ff ff       	call   c0102b3c <list_pop_back>
c01093da:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    if(*resa != a || *resb != b || *resc != c || *resd != d)
c01093dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01093e0:	8b 10                	mov    (%eax),%edx
c01093e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01093e5:	39 c2                	cmp    %eax,%edx
c01093e7:	75 24                	jne    c010940d <test_list_push_pop+0xda>
c01093e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01093ec:	8b 10                	mov    (%eax),%edx
c01093ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01093f1:	39 c2                	cmp    %eax,%edx
c01093f3:	75 18                	jne    c010940d <test_list_push_pop+0xda>
c01093f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01093f8:	8b 10                	mov    (%eax),%edx
c01093fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01093fd:	39 c2                	cmp    %eax,%edx
c01093ff:	75 0c                	jne    c010940d <test_list_push_pop+0xda>
c0109401:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109404:	8b 10                	mov    (%eax),%edx
c0109406:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0109409:	39 c2                	cmp    %eax,%edx
c010940b:	74 13                	je     c0109420 <test_list_push_pop+0xed>
    {
        printf("list push and pop front and back: failture\n");
c010940d:	c7 04 24 ac 0c 11 c0 	movl   $0xc0110cac,(%esp)
c0109414:	e8 86 2e 00 00       	call   c010c29f <puts>
        return 1;
c0109419:	b8 01 00 00 00       	mov    $0x1,%eax
c010941e:	eb 10                	jmp    c0109430 <test_list_push_pop+0xfd>
    }

    list_destroy(testList);
c0109420:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109423:	89 04 24             	mov    %eax,(%esp)
c0109426:	e8 a8 95 ff ff       	call   c01029d3 <list_destroy>

    return 0;
c010942b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0109430:	c9                   	leave  
c0109431:	c3                   	ret    

c0109432 <test_list_is_empty>:
 * @brief tests the is_empty function of the list module
 * @return 0 if success
 * @return 1 if failture
 */
int test_list_is_empty()
{
c0109432:	55                   	push   %ebp
c0109433:	89 e5                	mov    %esp,%ebp
c0109435:	83 ec 28             	sub    $0x28,%esp
    list_t *testList = list_create();
c0109438:	e8 3e 95 ff ff       	call   c010297b <list_create>
c010943d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(!list_is_empty(testList))
c0109440:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109443:	89 04 24             	mov    %eax,(%esp)
c0109446:	e8 5f 98 ff ff       	call   c0102caa <list_is_empty>
c010944b:	85 c0                	test   %eax,%eax
c010944d:	75 13                	jne    c0109462 <test_list_is_empty+0x30>
    {
        printf("list is empty: failture\n");
c010944f:	c7 04 24 d7 0c 11 c0 	movl   $0xc0110cd7,(%esp)
c0109456:	e8 44 2e 00 00       	call   c010c29f <puts>
        return 1;
c010945b:	b8 01 00 00 00       	mov    $0x1,%eax
c0109460:	eb 75                	jmp    c01094d7 <test_list_is_empty+0xa5>
    }

    int i;

    for(i = 0; i < FILL_TEST_NUMBER; i++)
c0109462:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0109469:	eb 16                	jmp    c0109481 <test_list_is_empty+0x4f>
        list_push_front(testList, testList);
c010946b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010946e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109472:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109475:	89 04 24             	mov    %eax,(%esp)
c0109478:	e8 35 96 ff ff       	call   c0102ab2 <list_push_front>
        return 1;
    }

    int i;

    for(i = 0; i < FILL_TEST_NUMBER; i++)
c010947d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0109481:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0109485:	7e e4                	jle    c010946b <test_list_is_empty+0x39>
        list_push_front(testList, testList);

    for(i = 0; i < FILL_TEST_NUMBER; i++)
c0109487:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010948e:	eb 0f                	jmp    c010949f <test_list_is_empty+0x6d>
        list_pop_front(testList);
c0109490:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109493:	89 04 24             	mov    %eax,(%esp)
c0109496:	e8 e7 96 ff ff       	call   c0102b82 <list_pop_front>
    int i;

    for(i = 0; i < FILL_TEST_NUMBER; i++)
        list_push_front(testList, testList);

    for(i = 0; i < FILL_TEST_NUMBER; i++)
c010949b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010949f:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c01094a3:	7e eb                	jle    c0109490 <test_list_is_empty+0x5e>
        list_pop_front(testList);

    if(!list_is_empty(testList))
c01094a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01094a8:	89 04 24             	mov    %eax,(%esp)
c01094ab:	e8 fa 97 ff ff       	call   c0102caa <list_is_empty>
c01094b0:	85 c0                	test   %eax,%eax
c01094b2:	75 13                	jne    c01094c7 <test_list_is_empty+0x95>
    {
        printf("list is empty: failture\n");
c01094b4:	c7 04 24 d7 0c 11 c0 	movl   $0xc0110cd7,(%esp)
c01094bb:	e8 df 2d 00 00       	call   c010c29f <puts>
        return 1;
c01094c0:	b8 01 00 00 00       	mov    $0x1,%eax
c01094c5:	eb 10                	jmp    c01094d7 <test_list_is_empty+0xa5>
    }

    list_destroy(testList);
c01094c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01094ca:	89 04 24             	mov    %eax,(%esp)
c01094cd:	e8 01 95 ff ff       	call   c01029d3 <list_destroy>

    return 0;
c01094d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01094d7:	c9                   	leave  
c01094d8:	c3                   	ret    

c01094d9 <test_list_length>:
* @brief tests the length function of the list module
* @return 0 if success
* @return 1 if failture
*/
int test_list_length()
{
c01094d9:	55                   	push   %ebp
c01094da:	89 e5                	mov    %esp,%ebp
c01094dc:	83 ec 28             	sub    $0x28,%esp
    list_t *testList = list_create();
c01094df:	e8 97 94 ff ff       	call   c010297b <list_create>
c01094e4:	89 45 f0             	mov    %eax,-0x10(%ebp)

    int i;

    for(i = 0; i < SIZE_TEST_NUMBER; i++)
c01094e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01094ee:	eb 16                	jmp    c0109506 <test_list_length+0x2d>
        list_push_front(testList, testList);
c01094f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01094f3:	89 44 24 04          	mov    %eax,0x4(%esp)
c01094f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01094fa:	89 04 24             	mov    %eax,(%esp)
c01094fd:	e8 b0 95 ff ff       	call   c0102ab2 <list_push_front>
{
    list_t *testList = list_create();

    int i;

    for(i = 0; i < SIZE_TEST_NUMBER; i++)
c0109502:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0109506:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
c010950a:	7e e4                	jle    c01094f0 <test_list_length+0x17>
        list_push_front(testList, testList);

    if(list_length(testList) != SIZE_TEST_NUMBER)
c010950c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010950f:	89 04 24             	mov    %eax,(%esp)
c0109512:	e8 57 97 ff ff       	call   c0102c6e <list_length>
c0109517:	83 f8 64             	cmp    $0x64,%eax
c010951a:	74 13                	je     c010952f <test_list_length+0x56>
    {
        printf("list length: failture\n");
c010951c:	c7 04 24 ef 0c 11 c0 	movl   $0xc0110cef,(%esp)
c0109523:	e8 77 2d 00 00       	call   c010c29f <puts>
        return 1;
c0109528:	b8 01 00 00 00       	mov    $0x1,%eax
c010952d:	eb 10                	jmp    c010953f <test_list_length+0x66>
    }

    list_destroy(testList);
c010952f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109532:	89 04 24             	mov    %eax,(%esp)
c0109535:	e8 99 94 ff ff       	call   c01029d3 <list_destroy>

    return 0;
c010953a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010953f:	c9                   	leave  
c0109540:	c3                   	ret    

c0109541 <test_list>:
 * @brief tests the list module
 * @return 0 if success
 * @return 1 if failture
 */
int test_list()
{
c0109541:	55                   	push   %ebp
c0109542:	89 e5                	mov    %esp,%ebp
c0109544:	83 ec 18             	sub    $0x18,%esp
    if(test_list_create_destroy())
c0109547:	e8 31 fd ff ff       	call   c010927d <test_list_create_destroy>
c010954c:	85 c0                	test   %eax,%eax
c010954e:	74 07                	je     c0109557 <test_list+0x16>
        return 1;
c0109550:	b8 01 00 00 00       	mov    $0x1,%eax
c0109555:	eb 41                	jmp    c0109598 <test_list+0x57>

    if(test_list_push_pop())
c0109557:	e8 d7 fd ff ff       	call   c0109333 <test_list_push_pop>
c010955c:	85 c0                	test   %eax,%eax
c010955e:	74 07                	je     c0109567 <test_list+0x26>
        return 1;
c0109560:	b8 01 00 00 00       	mov    $0x1,%eax
c0109565:	eb 31                	jmp    c0109598 <test_list+0x57>

    if(test_list_is_empty())
c0109567:	e8 c6 fe ff ff       	call   c0109432 <test_list_is_empty>
c010956c:	85 c0                	test   %eax,%eax
c010956e:	74 07                	je     c0109577 <test_list+0x36>
        return 1;
c0109570:	b8 01 00 00 00       	mov    $0x1,%eax
c0109575:	eb 21                	jmp    c0109598 <test_list+0x57>

    if(test_list_length())
c0109577:	e8 5d ff ff ff       	call   c01094d9 <test_list_length>
c010957c:	85 c0                	test   %eax,%eax
c010957e:	74 07                	je     c0109587 <test_list+0x46>
        return 1;
c0109580:	b8 01 00 00 00       	mov    $0x1,%eax
c0109585:	eb 11                	jmp    c0109598 <test_list+0x57>

    printf("list test: all successful\n");
c0109587:	c7 04 24 05 0d 11 c0 	movl   $0xc0110d05,(%esp)
c010958e:	e8 0c 2d 00 00       	call   c010c29f <puts>

    return 0;
c0109593:	b8 00 00 00 00       	mov    $0x0,%eax
c0109598:	c9                   	leave  
c0109599:	c3                   	ret    

c010959a <usys_identify_os>:
extern struct process_state *kernel_state;



void usys_identify_os(struct cpu_state **cpu)
{
c010959a:	55                   	push   %ebp
c010959b:	89 e5                	mov    %esp,%ebp
    (*cpu)->CPU_ARG0 = 'u' | ('n' << 8) | ('i' << 16) | (OS_VERSION << 24);
c010959d:	8b 45 08             	mov    0x8(%ebp),%eax
c01095a0:	8b 00                	mov    (%eax),%eax
c01095a2:	c7 40 28 75 6e 69 01 	movl   $0x1696e75,0x28(%eax)
};
c01095a9:	5d                   	pop    %ebp
c01095aa:	c3                   	ret    

c01095ab <linux_syscall_handler>:
    sys_getdents, NULL, NULL, NULL,
    /*FIXME: getcwd kommt weiter hinten (183)*/ sys_getcwd
};

void linux_syscall_handler(struct cpu_state **cpu)
{
c01095ab:	55                   	push   %ebp
c01095ac:	89 e5                	mov    %esp,%ebp
c01095ae:	83 ec 18             	sub    $0x18,%esp
    if( (*cpu)->CPU_ARG0 < DEFINED_LINUX_FUNCTIONS)
c01095b1:	8b 45 08             	mov    0x8(%ebp),%eax
c01095b4:	8b 00                	mov    (%eax),%eax
c01095b6:	8b 40 28             	mov    0x28(%eax),%eax
c01095b9:	83 f8 3b             	cmp    $0x3b,%eax
c01095bc:	77 2a                	ja     c01095e8 <linux_syscall_handler+0x3d>
    {
        if(linux_functions[(*cpu)->CPU_ARG0] != NULL)
c01095be:	8b 45 08             	mov    0x8(%ebp),%eax
c01095c1:	8b 00                	mov    (%eax),%eax
c01095c3:	8b 40 28             	mov    0x28(%eax),%eax
c01095c6:	8b 04 85 20 20 11 c0 	mov    -0x3feedfe0(,%eax,4),%eax
c01095cd:	85 c0                	test   %eax,%eax
c01095cf:	74 17                	je     c01095e8 <linux_syscall_handler+0x3d>
            linux_functions[(*cpu)->CPU_ARG0](cpu);
c01095d1:	8b 45 08             	mov    0x8(%ebp),%eax
c01095d4:	8b 00                	mov    (%eax),%eax
c01095d6:	8b 40 28             	mov    0x28(%eax),%eax
c01095d9:	8b 04 85 20 20 11 c0 	mov    -0x3feedfe0(,%eax,4),%eax
c01095e0:	8b 55 08             	mov    0x8(%ebp),%edx
c01095e3:	89 14 24             	mov    %edx,(%esp)
c01095e6:	ff d0                	call   *%eax
    }
}
c01095e8:	c9                   	leave  
c01095e9:	c3                   	ret    

c01095ea <universe_syscall_handler>:
    usys_thread_exit,usys_thread_launch,alloc_memory,usys_identify_os,set_pipe_trigger,usys_connect,usys_readport,usys_accept
};


void universe_syscall_handler(struct cpu_state **cpu)
{
c01095ea:	55                   	push   %ebp
c01095eb:	89 e5                	mov    %esp,%ebp
c01095ed:	83 ec 18             	sub    $0x18,%esp
    if( (*cpu)->CPU_ARG0 < DEFINED_UNIVERSE_FUNCTIONS)
c01095f0:	8b 45 08             	mov    0x8(%ebp),%eax
c01095f3:	8b 00                	mov    (%eax),%eax
c01095f5:	8b 40 28             	mov    0x28(%eax),%eax
c01095f8:	83 f8 07             	cmp    $0x7,%eax
c01095fb:	77 2a                	ja     c0109627 <universe_syscall_handler+0x3d>
    {
        if(universe_functions[(*cpu)->CPU_ARG0] != NULL)
c01095fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0109600:	8b 00                	mov    (%eax),%eax
c0109602:	8b 40 28             	mov    0x28(%eax),%eax
c0109605:	8b 04 85 00 21 11 c0 	mov    -0x3feedf00(,%eax,4),%eax
c010960c:	85 c0                	test   %eax,%eax
c010960e:	74 17                	je     c0109627 <universe_syscall_handler+0x3d>
            universe_functions[(*cpu)->CPU_ARG0](cpu);
c0109610:	8b 45 08             	mov    0x8(%ebp),%eax
c0109613:	8b 00                	mov    (%eax),%eax
c0109615:	8b 40 28             	mov    0x28(%eax),%eax
c0109618:	8b 04 85 00 21 11 c0 	mov    -0x3feedf00(,%eax,4),%eax
c010961f:	8b 55 08             	mov    0x8(%ebp),%edx
c0109622:	89 14 24             	mov    %edx,(%esp)
c0109625:	ff d0                	call   *%eax
    }
}
c0109627:	c9                   	leave  
c0109628:	c3                   	ret    

c0109629 <new_pckmgr>:
#include <udrcp/udrcp.h>



pckmgr *new_pckmgr(vfs_inode_t *in, vfs_inode_t *out, vfs_inode_t *err)
{
c0109629:	55                   	push   %ebp
c010962a:	89 e5                	mov    %esp,%ebp
c010962c:	83 ec 28             	sub    $0x28,%esp
    pckmgr *mgr = malloc(sizeof(pckmgr));
c010962f:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
c0109636:	e8 0a 29 00 00       	call   c010bf45 <malloc>
c010963b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    mgr->counter = 0;
c010963e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109641:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    mgr->used_ids = list_create();
c0109647:	e8 2f 93 ff ff       	call   c010297b <list_create>
c010964c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010964f:	89 42 04             	mov    %eax,0x4(%edx)
    mgr->pset.stdin = in;
c0109652:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109655:	8b 55 08             	mov    0x8(%ebp),%edx
c0109658:	89 50 08             	mov    %edx,0x8(%eax)
    mgr->pset.stdout = out;
c010965b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010965e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0109661:	89 50 0c             	mov    %edx,0xc(%eax)
    mgr->pset.stderr = err;
c0109664:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109667:	8b 55 10             	mov    0x10(%ebp),%edx
c010966a:	89 50 10             	mov    %edx,0x10(%eax)
    mgr->recieved_pcks = list_create();
c010966d:	e8 09 93 ff ff       	call   c010297b <list_create>
c0109672:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0109675:	89 42 1c             	mov    %eax,0x1c(%edx)
    mgr->stdout_seeker = out->length;
c0109678:	8b 45 0c             	mov    0xc(%ebp),%eax
c010967b:	8b 40 08             	mov    0x8(%eax),%eax
c010967e:	89 c2                	mov    %eax,%edx
c0109680:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109683:	89 50 14             	mov    %edx,0x14(%eax)
    mgr->stderr_seeker = err->length;
c0109686:	8b 45 10             	mov    0x10(%ebp),%eax
c0109689:	8b 40 08             	mov    0x8(%eax),%eax
c010968c:	89 c2                	mov    %eax,%edx
c010968e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109691:	89 50 18             	mov    %edx,0x18(%eax)
    return mgr;
c0109694:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0109697:	c9                   	leave  
c0109698:	c3                   	ret    

c0109699 <reset_conn>:

void reset_conn(pckmgr *mgr)
{
c0109699:	55                   	push   %ebp
c010969a:	89 e5                	mov    %esp,%ebp
c010969c:	83 ec 18             	sub    $0x18,%esp
    mgr->counter = 0;
c010969f:	8b 45 08             	mov    0x8(%ebp),%eax
c01096a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    while(!list_is_empty(mgr->used_ids))
c01096a8:	eb 0e                	jmp    c01096b8 <reset_conn+0x1f>
        list_pop_front(mgr->used_ids);
c01096aa:	8b 45 08             	mov    0x8(%ebp),%eax
c01096ad:	8b 40 04             	mov    0x4(%eax),%eax
c01096b0:	89 04 24             	mov    %eax,(%esp)
c01096b3:	e8 ca 94 ff ff       	call   c0102b82 <list_pop_front>
}

void reset_conn(pckmgr *mgr)
{
    mgr->counter = 0;
    while(!list_is_empty(mgr->used_ids))
c01096b8:	8b 45 08             	mov    0x8(%ebp),%eax
c01096bb:	8b 40 04             	mov    0x4(%eax),%eax
c01096be:	89 04 24             	mov    %eax,(%esp)
c01096c1:	e8 e4 95 ff ff       	call   c0102caa <list_is_empty>
c01096c6:	85 c0                	test   %eax,%eax
c01096c8:	74 e0                	je     c01096aa <reset_conn+0x11>
        list_pop_front(mgr->used_ids);
    while(!list_is_empty(mgr->recieved_pcks))
c01096ca:	eb 0e                	jmp    c01096da <reset_conn+0x41>
        list_pop_front(mgr->recieved_pcks);
c01096cc:	8b 45 08             	mov    0x8(%ebp),%eax
c01096cf:	8b 40 1c             	mov    0x1c(%eax),%eax
c01096d2:	89 04 24             	mov    %eax,(%esp)
c01096d5:	e8 a8 94 ff ff       	call   c0102b82 <list_pop_front>
void reset_conn(pckmgr *mgr)
{
    mgr->counter = 0;
    while(!list_is_empty(mgr->used_ids))
        list_pop_front(mgr->used_ids);
    while(!list_is_empty(mgr->recieved_pcks))
c01096da:	8b 45 08             	mov    0x8(%ebp),%eax
c01096dd:	8b 40 1c             	mov    0x1c(%eax),%eax
c01096e0:	89 04 24             	mov    %eax,(%esp)
c01096e3:	e8 c2 95 ff ff       	call   c0102caa <list_is_empty>
c01096e8:	85 c0                	test   %eax,%eax
c01096ea:	74 e0                	je     c01096cc <reset_conn+0x33>
        list_pop_front(mgr->recieved_pcks);
}
c01096ec:	c9                   	leave  
c01096ed:	c3                   	ret    

c01096ee <gen_pckid>:


pckid_t gen_pckid(pckmgr *mgr)
{
c01096ee:	55                   	push   %ebp
c01096ef:	89 e5                	mov    %esp,%ebp
c01096f1:	83 ec 28             	sub    $0x28,%esp
    iterator_t used_id_it = iterator_create(mgr->used_ids);
c01096f4:	8b 45 08             	mov    0x8(%ebp),%eax
c01096f7:	8b 50 04             	mov    0x4(%eax),%edx
c01096fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01096fd:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109701:	89 04 24             	mov    %eax,(%esp)
c0109704:	e8 e2 95 ff ff       	call   c0102ceb <iterator_create>
c0109709:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_empty(mgr->used_ids) && !list_is_last(&used_id_it))
c010970c:	eb 50                	jmp    c010975e <gen_pckid+0x70>
    {
        if((pckid_t)list_get_current(&used_id_it) == mgr->counter )
c010970e:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0109711:	89 04 24             	mov    %eax,(%esp)
c0109714:	e8 9b 96 ff ff       	call   c0102db4 <list_get_current>
c0109719:	89 c2                	mov    %eax,%edx
c010971b:	8b 45 08             	mov    0x8(%ebp),%eax
c010971e:	8b 00                	mov    (%eax),%eax
c0109720:	39 c2                	cmp    %eax,%edx
c0109722:	75 2f                	jne    c0109753 <gen_pckid+0x65>
        {
            if(mgr->counter == MAX_ID)
c0109724:	8b 45 08             	mov    0x8(%ebp),%eax
c0109727:	8b 00                	mov    (%eax),%eax
c0109729:	83 f8 ff             	cmp    $0xffffffff,%eax
c010972c:	75 0b                	jne    c0109739 <gen_pckid+0x4b>
                mgr->counter = 0;
c010972e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109731:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0109737:	eb 0d                	jmp    c0109746 <gen_pckid+0x58>
            else
                mgr->counter++;
c0109739:	8b 45 08             	mov    0x8(%ebp),%eax
c010973c:	8b 00                	mov    (%eax),%eax
c010973e:	8d 50 01             	lea    0x1(%eax),%edx
c0109741:	8b 45 08             	mov    0x8(%ebp),%eax
c0109744:	89 10                	mov    %edx,(%eax)

            list_set_first(&used_id_it);
c0109746:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0109749:	89 04 24             	mov    %eax,(%esp)
c010974c:	e8 ca 96 ff ff       	call   c0102e1b <list_set_first>
c0109751:	eb 0b                	jmp    c010975e <gen_pckid+0x70>
        }
        else
            list_next(&used_id_it);
c0109753:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0109756:	89 04 24             	mov    %eax,(%esp)
c0109759:	e8 7b 96 ff ff       	call   c0102dd9 <list_next>


pckid_t gen_pckid(pckmgr *mgr)
{
    iterator_t used_id_it = iterator_create(mgr->used_ids);
    while(!list_is_empty(mgr->used_ids) && !list_is_last(&used_id_it))
c010975e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109761:	8b 40 04             	mov    0x4(%eax),%eax
c0109764:	89 04 24             	mov    %eax,(%esp)
c0109767:	e8 3e 95 ff ff       	call   c0102caa <list_is_empty>
c010976c:	85 c0                	test   %eax,%eax
c010976e:	75 0f                	jne    c010977f <gen_pckid+0x91>
c0109770:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0109773:	89 04 24             	mov    %eax,(%esp)
c0109776:	e8 85 96 ff ff       	call   c0102e00 <list_is_last>
c010977b:	85 c0                	test   %eax,%eax
c010977d:	74 8f                	je     c010970e <gen_pckid+0x20>
            list_set_first(&used_id_it);
        }
        else
            list_next(&used_id_it);
    }
    list_push_front(mgr->used_ids,(void*)mgr->counter);
c010977f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109782:	8b 00                	mov    (%eax),%eax
c0109784:	89 c2                	mov    %eax,%edx
c0109786:	8b 45 08             	mov    0x8(%ebp),%eax
c0109789:	8b 40 04             	mov    0x4(%eax),%eax
c010978c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109790:	89 04 24             	mov    %eax,(%esp)
c0109793:	e8 1a 93 ff ff       	call   c0102ab2 <list_push_front>
    return mgr->counter++;
c0109798:	8b 45 08             	mov    0x8(%ebp),%eax
c010979b:	8b 00                	mov    (%eax),%eax
c010979d:	89 c2                	mov    %eax,%edx
c010979f:	8d 48 01             	lea    0x1(%eax),%ecx
c01097a2:	8b 45 08             	mov    0x8(%ebp),%eax
c01097a5:	89 08                	mov    %ecx,(%eax)
c01097a7:	89 d0                	mov    %edx,%eax
}
c01097a9:	c9                   	leave  
c01097aa:	c3                   	ret    

c01097ab <free_pckid>:


bool free_pckid(pckmgr *mgr, pckid_t id)
{
c01097ab:	55                   	push   %ebp
c01097ac:	89 e5                	mov    %esp,%ebp
c01097ae:	83 ec 28             	sub    $0x28,%esp
    iterator_t used_id_it = iterator_create(mgr->used_ids);
c01097b1:	8b 45 08             	mov    0x8(%ebp),%eax
c01097b4:	8b 50 04             	mov    0x4(%eax),%edx
c01097b7:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01097ba:	89 54 24 04          	mov    %edx,0x4(%esp)
c01097be:	89 04 24             	mov    %eax,(%esp)
c01097c1:	e8 25 95 ff ff       	call   c0102ceb <iterator_create>
c01097c6:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_empty(mgr->used_ids) && !list_is_last(&used_id_it))
c01097c9:	eb 2d                	jmp    c01097f8 <free_pckid+0x4d>
    {
        if((pckid_t)list_get_current(&used_id_it) == id )
c01097cb:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01097ce:	89 04 24             	mov    %eax,(%esp)
c01097d1:	e8 de 95 ff ff       	call   c0102db4 <list_get_current>
c01097d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c01097d9:	75 12                	jne    c01097ed <free_pckid+0x42>
        {
            list_remove(&used_id_it);
c01097db:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01097de:	89 04 24             	mov    %eax,(%esp)
c01097e1:	e8 60 96 ff ff       	call   c0102e46 <list_remove>
            return true;
c01097e6:	b8 01 00 00 00       	mov    $0x1,%eax
c01097eb:	eb 31                	jmp    c010981e <free_pckid+0x73>
        }
        else
            list_next(&used_id_it);
c01097ed:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01097f0:	89 04 24             	mov    %eax,(%esp)
c01097f3:	e8 e1 95 ff ff       	call   c0102dd9 <list_next>


bool free_pckid(pckmgr *mgr, pckid_t id)
{
    iterator_t used_id_it = iterator_create(mgr->used_ids);
    while(!list_is_empty(mgr->used_ids) && !list_is_last(&used_id_it))
c01097f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01097fb:	8b 40 04             	mov    0x4(%eax),%eax
c01097fe:	89 04 24             	mov    %eax,(%esp)
c0109801:	e8 a4 94 ff ff       	call   c0102caa <list_is_empty>
c0109806:	85 c0                	test   %eax,%eax
c0109808:	75 0f                	jne    c0109819 <free_pckid+0x6e>
c010980a:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010980d:	89 04 24             	mov    %eax,(%esp)
c0109810:	e8 eb 95 ff ff       	call   c0102e00 <list_is_last>
c0109815:	85 c0                	test   %eax,%eax
c0109817:	74 b2                	je     c01097cb <free_pckid+0x20>
        }
        else
            list_next(&used_id_it);
    }

    return false;
c0109819:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010981e:	c9                   	leave  
c010981f:	c3                   	ret    

c0109820 <send_package>:

pckid_t send_package(pckmgr *mgr, pcktype_t type, size_t size, void *data)
{
c0109820:	55                   	push   %ebp
c0109821:	89 e5                	mov    %esp,%ebp
c0109823:	83 ec 28             	sub    $0x28,%esp
    pckhead_t *header = malloc(sizeof(pckhead_t));
c0109826:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c010982d:	e8 13 27 00 00       	call   c010bf45 <malloc>
c0109832:	89 45 f4             	mov    %eax,-0xc(%ebp)
    pckid_t id = gen_pckid(mgr);
c0109835:	8b 45 08             	mov    0x8(%ebp),%eax
c0109838:	89 04 24             	mov    %eax,(%esp)
c010983b:	e8 ae fe ff ff       	call   c01096ee <gen_pckid>
c0109840:	89 45 f0             	mov    %eax,-0x10(%ebp)
    header->id = id;
c0109843:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109846:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0109849:	89 10                	mov    %edx,(%eax)
    header->size = size+sizeof(pckhead_t);
c010984b:	8b 45 10             	mov    0x10(%ebp),%eax
c010984e:	8d 50 0c             	lea    0xc(%eax),%edx
c0109851:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109854:	89 50 04             	mov    %edx,0x4(%eax)
    header->type = type;
c0109857:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010985a:	8b 55 0c             	mov    0xc(%ebp),%edx
c010985d:	89 50 08             	mov    %edx,0x8(%eax)
    vfs_write(mgr->pset.stdin,mgr->pset.stdin->length,header,sizeof(pckhead_t));
c0109860:	8b 45 08             	mov    0x8(%ebp),%eax
c0109863:	8b 40 08             	mov    0x8(%eax),%eax
c0109866:	8b 40 08             	mov    0x8(%eax),%eax
c0109869:	89 c2                	mov    %eax,%edx
c010986b:	8b 45 08             	mov    0x8(%ebp),%eax
c010986e:	8b 40 08             	mov    0x8(%eax),%eax
c0109871:	c7 44 24 0c 0c 00 00 	movl   $0xc,0xc(%esp)
c0109878:	00 
c0109879:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010987c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0109880:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109884:	89 04 24             	mov    %eax,(%esp)
c0109887:	e8 c6 c7 ff ff       	call   c0106052 <vfs_write>
    if(size)
c010988c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0109890:	74 2b                	je     c01098bd <send_package+0x9d>
        vfs_write(mgr->pset.stdin,mgr->pset.stdin->length,data,size);
c0109892:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0109895:	8b 45 08             	mov    0x8(%ebp),%eax
c0109898:	8b 40 08             	mov    0x8(%eax),%eax
c010989b:	8b 40 08             	mov    0x8(%eax),%eax
c010989e:	89 c2                	mov    %eax,%edx
c01098a0:	8b 45 08             	mov    0x8(%ebp),%eax
c01098a3:	8b 40 08             	mov    0x8(%eax),%eax
c01098a6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c01098aa:	8b 4d 14             	mov    0x14(%ebp),%ecx
c01098ad:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c01098b1:	89 54 24 04          	mov    %edx,0x4(%esp)
c01098b5:	89 04 24             	mov    %eax,(%esp)
c01098b8:	e8 95 c7 ff ff       	call   c0106052 <vfs_write>
    free(header);
c01098bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098c0:	89 04 24             	mov    %eax,(%esp)
c01098c3:	e8 8b 27 00 00       	call   c010c053 <free>
    return id;
c01098c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c01098cb:	c9                   	leave  
c01098cc:	c3                   	ret    

c01098cd <respond>:


void respond(pckmgr *mgr,pckid_t id,pcktype_t type, size_t size, void *data)
{
c01098cd:	55                   	push   %ebp
c01098ce:	89 e5                	mov    %esp,%ebp
c01098d0:	83 ec 28             	sub    $0x28,%esp
    pckhead_t *header = malloc(sizeof(pckhead_t));
c01098d3:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c01098da:	e8 66 26 00 00       	call   c010bf45 <malloc>
c01098df:	89 45 f4             	mov    %eax,-0xc(%ebp)
    header->id = id;
c01098e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098e5:	8b 55 0c             	mov    0xc(%ebp),%edx
c01098e8:	89 10                	mov    %edx,(%eax)
    header->size = size+12;
c01098ea:	8b 45 14             	mov    0x14(%ebp),%eax
c01098ed:	8d 50 0c             	lea    0xc(%eax),%edx
c01098f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098f3:	89 50 04             	mov    %edx,0x4(%eax)
    header->type = type;
c01098f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098f9:	8b 55 10             	mov    0x10(%ebp),%edx
c01098fc:	89 50 08             	mov    %edx,0x8(%eax)
    vfs_write(mgr->pset.stdin,mgr->pset.stdin->length,header,sizeof(pckhead_t));
c01098ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0109902:	8b 40 08             	mov    0x8(%eax),%eax
c0109905:	8b 40 08             	mov    0x8(%eax),%eax
c0109908:	89 c2                	mov    %eax,%edx
c010990a:	8b 45 08             	mov    0x8(%ebp),%eax
c010990d:	8b 40 08             	mov    0x8(%eax),%eax
c0109910:	c7 44 24 0c 0c 00 00 	movl   $0xc,0xc(%esp)
c0109917:	00 
c0109918:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010991b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010991f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109923:	89 04 24             	mov    %eax,(%esp)
c0109926:	e8 27 c7 ff ff       	call   c0106052 <vfs_write>
    if(size)
c010992b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c010992f:	74 2b                	je     c010995c <respond+0x8f>
        vfs_write(mgr->pset.stdin,mgr->pset.stdin->length,data,size);
c0109931:	8b 4d 14             	mov    0x14(%ebp),%ecx
c0109934:	8b 45 08             	mov    0x8(%ebp),%eax
c0109937:	8b 40 08             	mov    0x8(%eax),%eax
c010993a:	8b 40 08             	mov    0x8(%eax),%eax
c010993d:	89 c2                	mov    %eax,%edx
c010993f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109942:	8b 40 08             	mov    0x8(%eax),%eax
c0109945:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0109949:	8b 4d 18             	mov    0x18(%ebp),%ecx
c010994c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0109950:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109954:	89 04 24             	mov    %eax,(%esp)
c0109957:	e8 f6 c6 ff ff       	call   c0106052 <vfs_write>
    free(header);
c010995c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010995f:	89 04 24             	mov    %eax,(%esp)
c0109962:	e8 ec 26 00 00       	call   c010c053 <free>
}
c0109967:	c9                   	leave  
c0109968:	c3                   	ret    

c0109969 <poll_next>:

pck_t *poll_next(pckmgr *mgr)
{
c0109969:	55                   	push   %ebp
c010996a:	89 e5                	mov    %esp,%ebp
c010996c:	53                   	push   %ebx
c010996d:	83 ec 24             	sub    $0x24,%esp
    pck_t *pck = malloc(sizeof(pck_t));
c0109970:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c0109977:	e8 c9 25 00 00       	call   c010bf45 <malloc>
c010997c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while((mgr->pset.stdout->length - mgr->stdout_seeker) < sizeof(pckhead_t));
c010997f:	90                   	nop
c0109980:	8b 45 08             	mov    0x8(%ebp),%eax
c0109983:	8b 40 0c             	mov    0xc(%eax),%eax
c0109986:	8b 50 08             	mov    0x8(%eax),%edx
c0109989:	8b 45 08             	mov    0x8(%ebp),%eax
c010998c:	8b 40 14             	mov    0x14(%eax),%eax
c010998f:	89 d1                	mov    %edx,%ecx
c0109991:	29 c1                	sub    %eax,%ecx
c0109993:	89 c8                	mov    %ecx,%eax
c0109995:	83 f8 0b             	cmp    $0xb,%eax
c0109998:	76 e6                	jbe    c0109980 <poll_next+0x17>
    vfs_read(mgr->pset.stdout,mgr->stdout_seeker,pck, sizeof(pckhead_t));
c010999a:	8b 45 08             	mov    0x8(%ebp),%eax
c010999d:	8b 50 14             	mov    0x14(%eax),%edx
c01099a0:	8b 45 08             	mov    0x8(%ebp),%eax
c01099a3:	8b 40 0c             	mov    0xc(%eax),%eax
c01099a6:	c7 44 24 0c 0c 00 00 	movl   $0xc,0xc(%esp)
c01099ad:	00 
c01099ae:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c01099b1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c01099b5:	89 54 24 04          	mov    %edx,0x4(%esp)
c01099b9:	89 04 24             	mov    %eax,(%esp)
c01099bc:	e8 5d c7 ff ff       	call   c010611e <vfs_read>
    mgr->stdout_seeker += sizeof(pckhead_t);
c01099c1:	8b 45 08             	mov    0x8(%ebp),%eax
c01099c4:	8b 40 14             	mov    0x14(%eax),%eax
c01099c7:	83 c0 0c             	add    $0xc,%eax
c01099ca:	89 c2                	mov    %eax,%edx
c01099cc:	8b 45 08             	mov    0x8(%ebp),%eax
c01099cf:	89 50 14             	mov    %edx,0x14(%eax)
    if(pck->size > 12)
c01099d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01099d5:	8b 40 04             	mov    0x4(%eax),%eax
c01099d8:	83 f8 0c             	cmp    $0xc,%eax
c01099db:	76 74                	jbe    c0109a51 <poll_next+0xe8>
    {
        int data_size = pck->size-12;
c01099dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01099e0:	8b 40 04             	mov    0x4(%eax),%eax
c01099e3:	83 e8 0c             	sub    $0xc,%eax
c01099e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
        pck->data = malloc(data_size);
c01099e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01099ec:	89 04 24             	mov    %eax,(%esp)
c01099ef:	e8 51 25 00 00       	call   c010bf45 <malloc>
c01099f4:	89 c2                	mov    %eax,%edx
c01099f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01099f9:	89 50 0c             	mov    %edx,0xc(%eax)
        while((mgr->pset.stdout->length - mgr->stdout_seeker) < data_size);
c01099fc:	90                   	nop
c01099fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a00:	8b 40 0c             	mov    0xc(%eax),%eax
c0109a03:	8b 50 08             	mov    0x8(%eax),%edx
c0109a06:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a09:	8b 40 14             	mov    0x14(%eax),%eax
c0109a0c:	29 c2                	sub    %eax,%edx
c0109a0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109a11:	39 c2                	cmp    %eax,%edx
c0109a13:	72 e8                	jb     c01099fd <poll_next+0x94>
        vfs_read(mgr->pset.stdout,mgr->stdout_seeker, pck->data,data_size);
c0109a15:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109a18:	8b 48 0c             	mov    0xc(%eax),%ecx
c0109a1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a1e:	8b 50 14             	mov    0x14(%eax),%edx
c0109a21:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a24:	8b 40 0c             	mov    0xc(%eax),%eax
c0109a27:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0109a2a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c0109a2e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0109a32:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109a36:	89 04 24             	mov    %eax,(%esp)
c0109a39:	e8 e0 c6 ff ff       	call   c010611e <vfs_read>
        mgr->stdout_seeker += data_size;
c0109a3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a41:	8b 50 14             	mov    0x14(%eax),%edx
c0109a44:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109a47:	01 c2                	add    %eax,%edx
c0109a49:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a4c:	89 50 14             	mov    %edx,0x14(%eax)
c0109a4f:	eb 0a                	jmp    c0109a5b <poll_next+0xf2>
    }
    else
        pck->data = NULL;
c0109a51:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109a54:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return pck;
c0109a5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0109a5e:	83 c4 24             	add    $0x24,%esp
c0109a61:	5b                   	pop    %ebx
c0109a62:	5d                   	pop    %ebp
c0109a63:	c3                   	ret    

c0109a64 <poll_queue>:

void poll_queue(pckmgr *mgr)
{
c0109a64:	55                   	push   %ebp
c0109a65:	89 e5                	mov    %esp,%ebp
c0109a67:	83 ec 18             	sub    $0x18,%esp
    list_push_front(mgr->recieved_pcks,poll_next(mgr));
c0109a6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a6d:	89 04 24             	mov    %eax,(%esp)
c0109a70:	e8 f4 fe ff ff       	call   c0109969 <poll_next>
c0109a75:	8b 55 08             	mov    0x8(%ebp),%edx
c0109a78:	8b 52 1c             	mov    0x1c(%edx),%edx
c0109a7b:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109a7f:	89 14 24             	mov    %edx,(%esp)
c0109a82:	e8 2b 90 ff ff       	call   c0102ab2 <list_push_front>
}
c0109a87:	c9                   	leave  
c0109a88:	c3                   	ret    

c0109a89 <fetch_queue>:

pck_t *fetch_queue(pckmgr *mgr,pckid_t id)
{
c0109a89:	55                   	push   %ebp
c0109a8a:	89 e5                	mov    %esp,%ebp
c0109a8c:	83 ec 28             	sub    $0x28,%esp
    iterator_t recieved_pck_it = iterator_create(mgr->recieved_pcks);
c0109a8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a92:	8b 50 1c             	mov    0x1c(%eax),%edx
c0109a95:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109a98:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109a9c:	89 04 24             	mov    %eax,(%esp)
c0109a9f:	e8 47 92 ff ff       	call   c0102ceb <iterator_create>
c0109aa4:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_last(&recieved_pck_it) && !list_is_empty(mgr->recieved_pcks))
c0109aa7:	eb 33                	jmp    c0109adc <fetch_queue+0x53>
    {
        pck_t *current = list_get_current(&recieved_pck_it);
c0109aa9:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109aac:	89 04 24             	mov    %eax,(%esp)
c0109aaf:	e8 00 93 ff ff       	call   c0102db4 <list_get_current>
c0109ab4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(current->id == id)
c0109ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109aba:	8b 00                	mov    (%eax),%eax
c0109abc:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0109abf:	75 10                	jne    c0109ad1 <fetch_queue+0x48>
        {
            list_remove(&recieved_pck_it);
c0109ac1:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109ac4:	89 04 24             	mov    %eax,(%esp)
c0109ac7:	e8 7a 93 ff ff       	call   c0102e46 <list_remove>
            return current;
c0109acc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109acf:	eb 31                	jmp    c0109b02 <fetch_queue+0x79>
        }
        list_next(&recieved_pck_it);
c0109ad1:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109ad4:	89 04 24             	mov    %eax,(%esp)
c0109ad7:	e8 fd 92 ff ff       	call   c0102dd9 <list_next>
}

pck_t *fetch_queue(pckmgr *mgr,pckid_t id)
{
    iterator_t recieved_pck_it = iterator_create(mgr->recieved_pcks);
    while(!list_is_last(&recieved_pck_it) && !list_is_empty(mgr->recieved_pcks))
c0109adc:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109adf:	89 04 24             	mov    %eax,(%esp)
c0109ae2:	e8 19 93 ff ff       	call   c0102e00 <list_is_last>
c0109ae7:	85 c0                	test   %eax,%eax
c0109ae9:	75 12                	jne    c0109afd <fetch_queue+0x74>
c0109aeb:	8b 45 08             	mov    0x8(%ebp),%eax
c0109aee:	8b 40 1c             	mov    0x1c(%eax),%eax
c0109af1:	89 04 24             	mov    %eax,(%esp)
c0109af4:	e8 b1 91 ff ff       	call   c0102caa <list_is_empty>
c0109af9:	85 c0                	test   %eax,%eax
c0109afb:	74 ac                	je     c0109aa9 <fetch_queue+0x20>
            list_remove(&recieved_pck_it);
            return current;
        }
        list_next(&recieved_pck_it);
    }
    return NULL;
c0109afd:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0109b02:	c9                   	leave  
c0109b03:	c3                   	ret    

c0109b04 <pck_poll>:


pck_t *pck_poll(pckmgr *mgr, pckid_t id)
{
c0109b04:	55                   	push   %ebp
c0109b05:	89 e5                	mov    %esp,%ebp
c0109b07:	83 ec 28             	sub    $0x28,%esp
    pck_t *pck = fetch_queue(mgr,id);
c0109b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109b0d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109b11:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b14:	89 04 24             	mov    %eax,(%esp)
c0109b17:	e8 6d ff ff ff       	call   c0109a89 <fetch_queue>
c0109b1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(pck)
c0109b1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0109b23:	74 05                	je     c0109b2a <pck_poll+0x26>
        return pck;
c0109b25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109b28:	eb 40                	jmp    c0109b6a <pck_poll+0x66>

    pck = poll_next(mgr);
c0109b2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b2d:	89 04 24             	mov    %eax,(%esp)
c0109b30:	e8 34 fe ff ff       	call   c0109969 <poll_next>
c0109b35:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(pck->id != id)
c0109b38:	eb 23                	jmp    c0109b5d <pck_poll+0x59>
    {
        list_push_front(mgr->recieved_pcks,pck);
c0109b3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b3d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0109b40:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0109b43:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109b47:	89 04 24             	mov    %eax,(%esp)
c0109b4a:	e8 63 8f ff ff       	call   c0102ab2 <list_push_front>
        pck = poll_next(mgr);
c0109b4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b52:	89 04 24             	mov    %eax,(%esp)
c0109b55:	e8 0f fe ff ff       	call   c0109969 <poll_next>
c0109b5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    pck_t *pck = fetch_queue(mgr,id);
    if(pck)
        return pck;

    pck = poll_next(mgr);
    while(pck->id != id)
c0109b5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109b60:	8b 00                	mov    (%eax),%eax
c0109b62:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0109b65:	75 d3                	jne    c0109b3a <pck_poll+0x36>
    {
        list_push_front(mgr->recieved_pcks,pck);
        pck = poll_next(mgr);
    }
    return pck;
c0109b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0109b6a:	c9                   	leave  
c0109b6b:	c3                   	ret    

c0109b6c <fetch_pipe>:



pck_t *fetch_pipe(pckmgr *mgr)
{
c0109b6c:	55                   	push   %ebp
c0109b6d:	89 e5                	mov    %esp,%ebp
c0109b6f:	83 ec 18             	sub    $0x18,%esp
    if((mgr->pset.stdout->length - mgr->stdout_seeker) < sizeof(pckhead_t))
c0109b72:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b75:	8b 40 0c             	mov    0xc(%eax),%eax
c0109b78:	8b 50 08             	mov    0x8(%eax),%edx
c0109b7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b7e:	8b 40 14             	mov    0x14(%eax),%eax
c0109b81:	89 d1                	mov    %edx,%ecx
c0109b83:	29 c1                	sub    %eax,%ecx
c0109b85:	89 c8                	mov    %ecx,%eax
c0109b87:	83 f8 0b             	cmp    $0xb,%eax
c0109b8a:	77 07                	ja     c0109b93 <fetch_pipe+0x27>
        return NULL;
c0109b8c:	b8 00 00 00 00       	mov    $0x0,%eax
c0109b91:	eb 0b                	jmp    c0109b9e <fetch_pipe+0x32>
    return poll_next(mgr);
c0109b93:	8b 45 08             	mov    0x8(%ebp),%eax
c0109b96:	89 04 24             	mov    %eax,(%esp)
c0109b99:	e8 cb fd ff ff       	call   c0109969 <poll_next>
}
c0109b9e:	c9                   	leave  
c0109b9f:	c3                   	ret    

c0109ba0 <subsystem_isr>:

list_t *subdrivers;
list_t *interrupts;

void subsystem_isr(struct cpu_state **cpu)
{
c0109ba0:	55                   	push   %ebp
c0109ba1:	89 e5                	mov    %esp,%ebp
c0109ba3:	83 ec 28             	sub    $0x28,%esp
    iterator_t int_it = iterator_create(interrupts);
c0109ba6:	8b 15 24 f0 11 c0    	mov    0xc011f024,%edx
c0109bac:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109baf:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109bb3:	89 04 24             	mov    %eax,(%esp)
c0109bb6:	e8 30 91 ff ff       	call   c0102ceb <iterator_create>
c0109bbb:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_last(&int_it) && !list_is_empty(interrupts))
c0109bbe:	eb 53                	jmp    c0109c13 <subsystem_isr+0x73>
    {
        struct int_relation *rel = list_get_current(&int_it);
c0109bc0:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109bc3:	89 04 24             	mov    %eax,(%esp)
c0109bc6:	e8 e9 91 ff ff       	call   c0102db4 <list_get_current>
c0109bcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(rel->intnr == (*cpu)->intr-32)
c0109bce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109bd1:	8b 10                	mov    (%eax),%edx
c0109bd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0109bd6:	8b 00                	mov    (%eax),%eax
c0109bd8:	8b 40 2c             	mov    0x2c(%eax),%eax
c0109bdb:	83 e8 20             	sub    $0x20,%eax
c0109bde:	39 c2                	cmp    %eax,%edx
c0109be0:	75 26                	jne    c0109c08 <subsystem_isr+0x68>
        {
            send_package(rel->drv, INTSIG, 0, NULL);
c0109be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109be5:	8b 40 04             	mov    0x4(%eax),%eax
c0109be8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0109bef:	00 
c0109bf0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0109bf7:	00 
c0109bf8:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
c0109bff:	00 
c0109c00:	89 04 24             	mov    %eax,(%esp)
c0109c03:	e8 18 fc ff ff       	call   c0109820 <send_package>
        }
        list_next(&int_it);
c0109c08:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109c0b:	89 04 24             	mov    %eax,(%esp)
c0109c0e:	e8 c6 91 ff ff       	call   c0102dd9 <list_next>
list_t *interrupts;

void subsystem_isr(struct cpu_state **cpu)
{
    iterator_t int_it = iterator_create(interrupts);
    while(!list_is_last(&int_it) && !list_is_empty(interrupts))
c0109c13:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0109c16:	89 04 24             	mov    %eax,(%esp)
c0109c19:	e8 e2 91 ff ff       	call   c0102e00 <list_is_last>
c0109c1e:	85 c0                	test   %eax,%eax
c0109c20:	75 11                	jne    c0109c33 <subsystem_isr+0x93>
c0109c22:	a1 24 f0 11 c0       	mov    0xc011f024,%eax
c0109c27:	89 04 24             	mov    %eax,(%esp)
c0109c2a:	e8 7b 90 ff ff       	call   c0102caa <list_is_empty>
c0109c2f:	85 c0                	test   %eax,%eax
c0109c31:	74 8d                	je     c0109bc0 <subsystem_isr+0x20>
        {
            send_package(rel->drv, INTSIG, 0, NULL);
        }
        list_next(&int_it);
    }
}
c0109c33:	c9                   	leave  
c0109c34:	c3                   	ret    

c0109c35 <INIT_HYPERVISOR>:

int INIT_HYPERVISOR(int argc, char **argv, char **environ)
{
c0109c35:	55                   	push   %ebp
c0109c36:	89 e5                	mov    %esp,%ebp
c0109c38:	56                   	push   %esi
c0109c39:	53                   	push   %ebx
c0109c3a:	83 ec 50             	sub    $0x50,%esp
    subdrivers = list_create();
c0109c3d:	e8 39 8d ff ff       	call   c010297b <list_create>
c0109c42:	a3 28 f0 11 c0       	mov    %eax,0xc011f028
    interrupts = list_create();
c0109c47:	e8 2f 8d ff ff       	call   c010297b <list_create>
c0109c4c:	a3 24 f0 11 c0       	mov    %eax,0xc011f024
    struct section *current_section = (struct section *)argv[0];
c0109c51:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109c54:	8b 00                	mov    (%eax),%eax
c0109c56:	89 45 f4             	mov    %eax,-0xc(%ebp)
    pckmgr *pman;
    printf("hypervisor subsystems:\n");
c0109c59:	c7 04 24 20 0d 11 c0 	movl   $0xc0110d20,(%esp)
c0109c60:	e8 3a 26 00 00       	call   c010c29f <puts>
    iterator_t i = iterator_create(current_section->subtree);
c0109c65:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109c68:	8b 50 08             	mov    0x8(%eax),%edx
c0109c6b:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0109c6e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109c72:	89 04 24             	mov    %eax,(%esp)
c0109c75:	e8 71 90 ff ff       	call   c0102ceb <iterator_create>
c0109c7a:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_last(&i))
c0109c7d:	e9 15 01 00 00       	jmp    c0109d97 <INIT_HYPERVISOR+0x162>
    {
        char *path = ((struct pnode *)list_get_current(&i))->file;
c0109c82:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0109c85:	89 04 24             	mov    %eax,(%esp)
c0109c88:	e8 27 91 ff ff       	call   c0102db4 <list_get_current>
c0109c8d:	8b 00                	mov    (%eax),%eax
c0109c8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        vfs_inode_t *driver_inode = vfs_lookup_path(path);
c0109c92:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109c95:	89 04 24             	mov    %eax,(%esp)
c0109c98:	e8 04 ee ff ff       	call   c0108aa1 <vfs_lookup_path>
c0109c9d:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if(driver_inode != NULL)
c0109ca0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0109ca4:	0f 84 e2 00 00 00    	je     c0109d8c <INIT_HYPERVISOR+0x157>
        {
            printf("load %s\n", path);
c0109caa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109cad:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109cb1:	c7 04 24 37 0d 11 c0 	movl   $0xc0110d37,(%esp)
c0109cb8:	e8 64 99 ff ff       	call   c0103621 <printf>
            pman = new_pckmgr(vfs_create_pipe(0, 0), vfs_create_pipe(0, 0), vfs_create_pipe(0, 0));
c0109cbd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0109cc4:	00 
c0109cc5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0109ccc:	e8 29 c3 ff ff       	call   c0105ffa <vfs_create_pipe>
c0109cd1:	89 c6                	mov    %eax,%esi
c0109cd3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0109cda:	00 
c0109cdb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0109ce2:	e8 13 c3 ff ff       	call   c0105ffa <vfs_create_pipe>
c0109ce7:	89 c3                	mov    %eax,%ebx
c0109ce9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0109cf0:	00 
c0109cf1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0109cf8:	e8 fd c2 ff ff       	call   c0105ffa <vfs_create_pipe>
c0109cfd:	89 74 24 08          	mov    %esi,0x8(%esp)
c0109d01:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0109d05:	89 04 24             	mov    %eax,(%esp)
c0109d08:	e8 1c f9 ff ff       	call   c0109629 <new_pckmgr>
c0109d0d:	89 45 e8             	mov    %eax,-0x18(%ebp)

            struct driver *new_driver = malloc(sizeof(struct driver));
c0109d10:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c0109d17:	e8 29 22 00 00       	call   c010bf45 <malloc>
c0109d1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            new_driver->pman = pman;
c0109d1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109d22:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0109d25:	89 50 0c             	mov    %edx,0xc(%eax)
            new_driver->process = load_elf_from_file(driver_inode, 0, 0, &pman->pset, NULL, NULL);
c0109d28:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109d2b:	83 c0 08             	add    $0x8,%eax
c0109d2e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0109d35:	00 
c0109d36:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0109d3d:	00 
c0109d3e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0109d42:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0109d49:	00 
c0109d4a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0109d51:	00 
c0109d52:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109d55:	89 04 24             	mov    %eax,(%esp)
c0109d58:	e8 2e a0 ff ff       	call   c0103d8b <load_elf_from_file>
c0109d5d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0109d60:	89 02                	mov    %eax,(%edx)
            new_driver->ports = list_create();
c0109d62:	e8 14 8c ff ff       	call   c010297b <list_create>
c0109d67:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0109d6a:	89 42 08             	mov    %eax,0x8(%edx)
            new_driver->memory = list_create();
c0109d6d:	e8 09 8c ff ff       	call   c010297b <list_create>
c0109d72:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0109d75:	89 42 04             	mov    %eax,0x4(%edx)
            list_push_front(subdrivers,new_driver);
c0109d78:	a1 28 f0 11 c0       	mov    0xc011f028,%eax
c0109d7d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0109d80:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109d84:	89 04 24             	mov    %eax,(%esp)
c0109d87:	e8 26 8d ff ff       	call   c0102ab2 <list_push_front>
        }
        list_next(&i);
c0109d8c:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0109d8f:	89 04 24             	mov    %eax,(%esp)
c0109d92:	e8 42 90 ff ff       	call   c0102dd9 <list_next>
    interrupts = list_create();
    struct section *current_section = (struct section *)argv[0];
    pckmgr *pman;
    printf("hypervisor subsystems:\n");
    iterator_t i = iterator_create(current_section->subtree);
    while(!list_is_last(&i))
c0109d97:	8d 45 d0             	lea    -0x30(%ebp),%eax
c0109d9a:	89 04 24             	mov    %eax,(%esp)
c0109d9d:	e8 5e 90 ff ff       	call   c0102e00 <list_is_last>
c0109da2:	85 c0                	test   %eax,%eax
c0109da4:	0f 84 d8 fe ff ff    	je     c0109c82 <INIT_HYPERVISOR+0x4d>
            new_driver->memory = list_create();
            list_push_front(subdrivers,new_driver);
        }
        list_next(&i);
    }
    printf("\n");
c0109daa:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0109db1:	e8 88 23 00 00       	call   c010c13e <putchar>
    //Poll packages
    if(list_is_empty(subdrivers))
c0109db6:	a1 28 f0 11 c0       	mov    0xc011f028,%eax
c0109dbb:	89 04 24             	mov    %eax,(%esp)
c0109dbe:	e8 e7 8e ff ff       	call   c0102caa <list_is_empty>
c0109dc3:	85 c0                	test   %eax,%eax
c0109dc5:	74 0e                	je     c0109dd5 <INIT_HYPERVISOR+0x1a0>
    {
        printf("could not load any subsystem!\n");
c0109dc7:	c7 04 24 40 0d 11 c0 	movl   $0xc0110d40,(%esp)
c0109dce:	e8 cc 24 00 00       	call   c010c29f <puts>
        while(1);
c0109dd3:	eb fe                	jmp    c0109dd3 <INIT_HYPERVISOR+0x19e>
    }

    iterator_t subdriver_it = iterator_create(subdrivers);
c0109dd5:	8b 15 28 f0 11 c0    	mov    0xc011f028,%edx
c0109ddb:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0109dde:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109de2:	89 04 24             	mov    %eax,(%esp)
c0109de5:	e8 01 8f ff ff       	call   c0102ceb <iterator_create>
c0109dea:	83 ec 04             	sub    $0x4,%esp

    /** NOTE: current implementation is based on polling. Switch to pipetrigger as fast as possible**/

    while(1)
    {
        struct driver *current_driver = list_get_current(&subdriver_it);
c0109ded:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0109df0:	89 04 24             	mov    %eax,(%esp)
c0109df3:	e8 bc 8f ff ff       	call   c0102db4 <list_get_current>
c0109df8:	89 45 e0             	mov    %eax,-0x20(%ebp)
        pman = current_driver->pman;
c0109dfb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109dfe:	8b 40 0c             	mov    0xc(%eax),%eax
c0109e01:	89 45 e8             	mov    %eax,-0x18(%ebp)
        pck_t *pck = fetch_pipe(pman);
c0109e04:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109e07:	89 04 24             	mov    %eax,(%esp)
c0109e0a:	e8 5d fd ff ff       	call   c0109b6c <fetch_pipe>
c0109e0f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(!pck)
c0109e12:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0109e16:	75 2e                	jne    c0109e46 <INIT_HYPERVISOR+0x211>
        {
            list_next(&subdriver_it);
c0109e18:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0109e1b:	89 04 24             	mov    %eax,(%esp)
c0109e1e:	e8 b6 8f ff ff       	call   c0102dd9 <list_next>
            if(list_is_last(&subdriver_it))
c0109e23:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0109e26:	89 04 24             	mov    %eax,(%esp)
c0109e29:	e8 d2 8f ff ff       	call   c0102e00 <list_is_last>
c0109e2e:	85 c0                	test   %eax,%eax
c0109e30:	0f 84 63 01 00 00    	je     c0109f99 <INIT_HYPERVISOR+0x364>
                list_set_first(&subdriver_it);
c0109e36:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0109e39:	89 04 24             	mov    %eax,(%esp)
c0109e3c:	e8 da 8f ff ff       	call   c0102e1b <list_set_first>
            continue;
c0109e41:	e9 53 01 00 00       	jmp    c0109f99 <INIT_HYPERVISOR+0x364>
        }

        //printf("host: recieved package %d    size:%d    type:%x\n",pck->id,pck->size,pck->type);
        struct int_relation *r;
        switch(pck->type)
c0109e46:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109e49:	8b 40 08             	mov    0x8(%eax),%eax
c0109e4c:	83 f8 07             	cmp    $0x7,%eax
c0109e4f:	0f 87 19 01 00 00    	ja     c0109f6e <INIT_HYPERVISOR+0x339>
c0109e55:	8b 04 85 a8 0d 11 c0 	mov    -0x3feef258(,%eax,4),%eax
c0109e5c:	ff e0                	jmp    *%eax

            case PING:
#ifdef DEBUG
                printf("host: recieved ping -> sending pong\n");
#endif
                respond(pman,pck->id,PONG,UHOST_DEFAULT_ASYNCHRON_SIZE,UHOST_DEFAULT_ASYNCHRON);
c0109e5e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109e61:	8b 00                	mov    (%eax),%eax
c0109e63:	c7 44 24 10 5e 0d 11 	movl   $0xc0110d5e,0x10(%esp)
c0109e6a:	c0 
c0109e6b:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0109e72:	00 
c0109e73:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c0109e7a:	00 
c0109e7b:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109e7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109e82:	89 04 24             	mov    %eax,(%esp)
c0109e85:	e8 43 fa ff ff       	call   c01098cd <respond>
                break;
c0109e8a:	e9 0e 01 00 00       	jmp    c0109f9d <INIT_HYPERVISOR+0x368>

            case PORT_ALLOC:
#ifdef DEBUG
                printf("host: allocationg Port 0x%x\n",*((unsigned int*)pck->data));
#endif
                handle_port_alloc(current_driver, pck);
c0109e8f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109e92:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109e96:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109e99:	89 04 24             	mov    %eax,(%esp)
c0109e9c:	e8 1c 02 00 00       	call   c010a0bd <handle_port_alloc>
                break;
c0109ea1:	e9 f7 00 00 00       	jmp    c0109f9d <INIT_HYPERVISOR+0x368>

            case INT_REQ:
#ifdef DEBUG
                printf("host: setting up interrupt signal 0x%x\n",*((unsigned int*)pck->data));
#endif // DEBUG
                r = malloc(sizeof(struct int_relation));
c0109ea6:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c0109ead:	e8 93 20 00 00       	call   c010bf45 <malloc>
c0109eb2:	89 45 d8             	mov    %eax,-0x28(%ebp)
                r->intnr = *((unsigned int*)pck->data);
c0109eb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109eb8:	8b 40 0c             	mov    0xc(%eax),%eax
c0109ebb:	8b 10                	mov    (%eax),%edx
c0109ebd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0109ec0:	89 10                	mov    %edx,(%eax)
                r->drv = pman;
c0109ec2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0109ec5:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0109ec8:	89 50 04             	mov    %edx,0x4(%eax)
                list_push_front(interrupts,r);
c0109ecb:	a1 24 f0 11 c0       	mov    0xc011f024,%eax
c0109ed0:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0109ed3:	89 54 24 04          	mov    %edx,0x4(%esp)
c0109ed7:	89 04 24             	mov    %eax,(%esp)
c0109eda:	e8 d3 8b ff ff       	call   c0102ab2 <list_push_front>
                add_trigger(WAIT_INT, r->intnr, false, NULL, subsystem_isr);
c0109edf:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0109ee2:	8b 00                	mov    (%eax),%eax
c0109ee4:	c7 44 24 10 a0 9b 10 	movl   $0xc0109ba0,0x10(%esp)
c0109eeb:	c0 
c0109eec:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0109ef3:	00 
c0109ef4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0109efb:	00 
c0109efc:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109f00:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c0109f07:	e8 b4 13 00 00       	call   c010b2c0 <add_trigger>
                respond(pman,pck->id,SUCCESS,0,NULL);
c0109f0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109f0f:	8b 00                	mov    (%eax),%eax
c0109f11:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0109f18:	00 
c0109f19:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0109f20:	00 
c0109f21:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0109f28:	00 
c0109f29:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109f2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109f30:	89 04 24             	mov    %eax,(%esp)
c0109f33:	e8 95 f9 ff ff       	call   c01098cd <respond>
                break;
c0109f38:	eb 63                	jmp    c0109f9d <INIT_HYPERVISOR+0x368>

            case PMA_ALLOC:
#ifdef DEBUG
                printf("PMA-Alloc\n");
#endif
                handle_pma_alloc(current_driver, pck);
c0109f3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109f3d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109f41:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109f44:	89 04 24             	mov    %eax,(%esp)
c0109f47:	e8 56 00 00 00       	call   c0109fa2 <handle_pma_alloc>

                break;
c0109f4c:	eb 4f                	jmp    c0109f9d <INIT_HYPERVISOR+0x368>

            case PMA_FREE:
                printf("PMA-Free\n");
c0109f4e:	c7 04 24 63 0d 11 c0 	movl   $0xc0110d63,(%esp)
c0109f55:	e8 45 23 00 00       	call   c010c29f <puts>
                handle_pma_free(current_driver, pck);
c0109f5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109f5d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109f61:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109f64:	89 04 24             	mov    %eax,(%esp)
c0109f67:	e8 4c 01 00 00       	call   c010a0b8 <handle_pma_free>
                break;
c0109f6c:	eb 2f                	jmp    c0109f9d <INIT_HYPERVISOR+0x368>



            default:
                printf("host: recieved unknown package %d    size:%d    type:%x\n",pck->id,pck->size,pck->type);
c0109f6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109f71:	8b 48 08             	mov    0x8(%eax),%ecx
c0109f74:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109f77:	8b 50 04             	mov    0x4(%eax),%edx
c0109f7a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109f7d:	8b 00                	mov    (%eax),%eax
c0109f7f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0109f83:	89 54 24 08          	mov    %edx,0x8(%esp)
c0109f87:	89 44 24 04          	mov    %eax,0x4(%esp)
c0109f8b:	c7 04 24 6c 0d 11 c0 	movl   $0xc0110d6c,(%esp)
c0109f92:	e8 8a 96 ff ff       	call   c0103621 <printf>
                break;
c0109f97:	eb 04                	jmp    c0109f9d <INIT_HYPERVISOR+0x368>
        if(!pck)
        {
            list_next(&subdriver_it);
            if(list_is_last(&subdriver_it))
                list_set_first(&subdriver_it);
            continue;
c0109f99:	90                   	nop
c0109f9a:	eb 01                	jmp    c0109f9d <INIT_HYPERVISOR+0x368>
        {
            case RESET_CON:
#ifdef DEBUG
                printf("host: connection reset\n");
#endif
                break;
c0109f9c:	90                   	nop
                break;

        };


    }
c0109f9d:	e9 4b fe ff ff       	jmp    c0109ded <INIT_HYPERVISOR+0x1b8>

c0109fa2 <handle_pma_alloc>:
 * @brief Handles a PMA_ALLOC request
 * @param drv pointer to the driver struct
 * @param req pointer to the request package
 */
void handle_pma_alloc(struct driver *drv, pck_t *req)
{
c0109fa2:	55                   	push   %ebp
c0109fa3:	89 e5                	mov    %esp,%ebp
c0109fa5:	53                   	push   %ebx
c0109fa6:	83 ec 44             	sub    $0x44,%esp
    struct pma_request *pma_req = (struct pma_request*) req->data;
c0109fa9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109fac:	8b 40 0c             	mov    0xc(%eax),%eax
c0109faf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    paddr_t phys_base;

    switch(pma_req->type)
c0109fb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109fb5:	8b 00                	mov    (%eax),%eax
c0109fb7:	83 f8 02             	cmp    $0x2,%eax
c0109fba:	74 20                	je     c0109fdc <handle_pma_alloc+0x3a>
c0109fbc:	83 f8 03             	cmp    $0x3,%eax
c0109fbf:	74 26                	je     c0109fe7 <handle_pma_alloc+0x45>
c0109fc1:	83 f8 01             	cmp    $0x1,%eax
c0109fc4:	75 34                	jne    c0109ffa <handle_pma_alloc+0x58>
    {
        case PMA_ALLOC_RANDOM:
            phys_base = pmm_alloc_page_range(pma_req->size/PAGE_SIZE);
c0109fc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109fc9:	8b 40 04             	mov    0x4(%eax),%eax
c0109fcc:	c1 e8 0c             	shr    $0xc,%eax
c0109fcf:	89 04 24             	mov    %eax,(%esp)
c0109fd2:	e8 bc 55 00 00       	call   c010f593 <pmm_alloc_page_range>
c0109fd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
c0109fda:	eb 52                	jmp    c010a02e <handle_pma_alloc+0x8c>
             {
                 respond(drv->pman, req->id, ERROR, 0, NULL);
                 return;
             }*/

            phys_base = pma_req->phys_base;
c0109fdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109fdf:	8b 40 08             	mov    0x8(%eax),%eax
c0109fe2:	89 45 f4             	mov    %eax,-0xc(%ebp)
            //pmm_mark_page_range_as_used(phys_base, pma_req->size/PAGE_SIZE);
            break;
c0109fe5:	eb 47                	jmp    c010a02e <handle_pma_alloc+0x8c>

        case PMA_ALLOC_LOWER:
            phys_base = pmm_alloc_page_limit(pma_req->phys_base);
c0109fe7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109fea:	8b 40 08             	mov    0x8(%eax),%eax
c0109fed:	89 04 24             	mov    %eax,(%esp)
c0109ff0:	e8 fc 54 00 00       	call   c010f4f1 <pmm_alloc_page_limit>
c0109ff5:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
c0109ff8:	eb 34                	jmp    c010a02e <handle_pma_alloc+0x8c>

        default:
            respond(drv->pman, req->id, ERROR, 0, NULL);
c0109ffa:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109ffd:	8b 10                	mov    (%eax),%edx
c0109fff:	8b 45 08             	mov    0x8(%ebp),%eax
c010a002:	8b 40 0c             	mov    0xc(%eax),%eax
c010a005:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010a00c:	00 
c010a00d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010a014:	00 
c010a015:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c010a01c:	00 
c010a01d:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a021:	89 04 24             	mov    %eax,(%esp)
c010a024:	e8 a4 f8 ff ff       	call   c01098cd <respond>
c010a029:	e9 85 00 00 00       	jmp    c010a0b3 <handle_pma_alloc+0x111>
            return;
            break;
    }


    iterator_t i = iterator_create(drv->process->threads);
c010a02e:	8b 45 08             	mov    0x8(%ebp),%eax
c010a031:	8b 00                	mov    (%eax),%eax
c010a033:	8b 50 34             	mov    0x34(%eax),%edx
c010a036:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010a039:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a03d:	89 04 24             	mov    %eax,(%esp)
c010a040:	e8 a6 8c ff ff       	call   c0102ceb <iterator_create>
c010a045:	83 ec 04             	sub    $0x4,%esp
    struct pma_response resp;
    resp.mem_base = vmm_automap_user_range( &((struct thread_state*)list_get_current(&i))->context.memory, phys_base, pma_req->size/PAGE_SIZE, VMM_PRESENT | VMM_WRITABLE | VMM_USER);
c010a048:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a04b:	8b 40 04             	mov    0x4(%eax),%eax
c010a04e:	c1 e8 0c             	shr    $0xc,%eax
c010a051:	89 c3                	mov    %eax,%ebx
c010a053:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010a056:	89 04 24             	mov    %eax,(%esp)
c010a059:	e8 56 8d ff ff       	call   c0102db4 <list_get_current>
c010a05e:	8d 50 24             	lea    0x24(%eax),%edx
c010a061:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c010a068:	00 
c010a069:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c010a06d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a070:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a074:	89 14 24             	mov    %edx,(%esp)
c010a077:	e8 4d 1a 00 00       	call   c010bac9 <vmm_automap_user_range>
c010a07c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    resp.phys_base = phys_base;
c010a07f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a082:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    respond(drv->pman, req->id, SUCCESS, sizeof(struct pma_response), &resp);
c010a085:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a088:	8b 10                	mov    (%eax),%edx
c010a08a:	8b 45 08             	mov    0x8(%ebp),%eax
c010a08d:	8b 40 0c             	mov    0xc(%eax),%eax
c010a090:	8d 4d e0             	lea    -0x20(%ebp),%ecx
c010a093:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c010a097:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
c010a09e:	00 
c010a09f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c010a0a6:	00 
c010a0a7:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a0ab:	89 04 24             	mov    %eax,(%esp)
c010a0ae:	e8 1a f8 ff ff       	call   c01098cd <respond>
}
c010a0b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010a0b6:	c9                   	leave  
c010a0b7:	c3                   	ret    

c010a0b8 <handle_pma_free>:
 * @brief Handles a PMA_FREE request
 * @param drv pointer to the driver struct
 * @param req pointer to the request package
 */
void handle_pma_free(struct driver *drv, pck_t *req)
{
c010a0b8:	55                   	push   %ebp
c010a0b9:	89 e5                	mov    %esp,%ebp
    /*TODO: free in HW resource list or free the page in PMM*/

c010a0bb:	5d                   	pop    %ebp
c010a0bc:	c3                   	ret    

c010a0bd <handle_port_alloc>:
 * @brief handles PORT_ALLOC call
 * @param drv pointer to the driver struct
 * @param req pointer to the request package
 */
void handle_port_alloc(struct driver *drv, pck_t *req)
{
c010a0bd:	55                   	push   %ebp
c010a0be:	89 e5                	mov    %esp,%ebp
c010a0c0:	83 ec 38             	sub    $0x38,%esp
    //validate package
    if(req->size != sizeof(portpck_t)+12)
c010a0c3:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a0c6:	8b 40 04             	mov    0x4(%eax),%eax
c010a0c9:	83 f8 10             	cmp    $0x10,%eax
c010a0cc:	74 5d                	je     c010a12b <handle_port_alloc+0x6e>
    {
        printf("invalid package! %d  %d\n",req->size,(int)sizeof(portpck_t));
c010a0ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a0d1:	8b 40 04             	mov    0x4(%eax),%eax
c010a0d4:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
c010a0db:	00 
c010a0dc:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a0e0:	c7 04 24 c8 0d 11 c0 	movl   $0xc0110dc8,(%esp)
c010a0e7:	e8 35 95 ff ff       	call   c0103621 <printf>
        respond(drv->pman, req->id, INVALID_REQUEST, 0, 0);
c010a0ec:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a0ef:	8b 10                	mov    (%eax),%edx
c010a0f1:	8b 45 08             	mov    0x8(%ebp),%eax
c010a0f4:	8b 40 0c             	mov    0xc(%eax),%eax
c010a0f7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010a0fe:	00 
c010a0ff:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010a106:	00 
c010a107:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
c010a10e:	00 
c010a10f:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a113:	89 04 24             	mov    %eax,(%esp)
c010a116:	e8 b2 f7 ff ff       	call   c01098cd <respond>
        free(req);
c010a11b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a11e:	89 04 24             	mov    %eax,(%esp)
c010a121:	e8 2d 1f 00 00       	call   c010c053 <free>
        return;
c010a126:	e9 af 00 00 00       	jmp    c010a1da <handle_port_alloc+0x11d>
    }

    portid_t port = (portid_t) *((unsigned int*)req->data);
c010a12b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a12e:	8b 40 0c             	mov    0xc(%eax),%eax
c010a131:	8b 00                	mov    (%eax),%eax
c010a133:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    if(alloc_port(&drv->process->main_thread->context, port))
c010a137:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c010a13b:	8b 55 08             	mov    0x8(%ebp),%edx
c010a13e:	8b 12                	mov    (%edx),%edx
c010a140:	8b 52 30             	mov    0x30(%edx),%edx
c010a143:	83 c2 18             	add    $0x18,%edx
c010a146:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a14a:	89 14 24             	mov    %edx,(%esp)
c010a14d:	e8 a6 29 00 00       	call   c010caf8 <alloc_port>
c010a152:	85 c0                	test   %eax,%eax
c010a154:	74 4f                	je     c010a1a5 <handle_port_alloc+0xe8>
    {
        list_push_front(drv->ports,req->data);
c010a156:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a159:	8b 50 0c             	mov    0xc(%eax),%edx
c010a15c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a15f:	8b 40 08             	mov    0x8(%eax),%eax
c010a162:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a166:	89 04 24             	mov    %eax,(%esp)
c010a169:	e8 44 89 ff ff       	call   c0102ab2 <list_push_front>
        port_type p = hw_port;
c010a16e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        respond(drv->pman, req->id, SUCCESS, sizeof(port_type), &p);
c010a175:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a178:	8b 10                	mov    (%eax),%edx
c010a17a:	8b 45 08             	mov    0x8(%ebp),%eax
c010a17d:	8b 40 0c             	mov    0xc(%eax),%eax
c010a180:	8d 4d f0             	lea    -0x10(%ebp),%ecx
c010a183:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c010a187:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c010a18e:	00 
c010a18f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c010a196:	00 
c010a197:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a19b:	89 04 24             	mov    %eax,(%esp)
c010a19e:	e8 2a f7 ff ff       	call   c01098cd <respond>
c010a1a3:	eb 35                	jmp    c010a1da <handle_port_alloc+0x11d>
    }
    else
    {
        unsigned int resp = 0;
c010a1a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        respond(drv->pman, req->id, ERROR, sizeof(port_type), &resp );
c010a1ac:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a1af:	8b 10                	mov    (%eax),%edx
c010a1b1:	8b 45 08             	mov    0x8(%ebp),%eax
c010a1b4:	8b 40 0c             	mov    0xc(%eax),%eax
c010a1b7:	8d 4d ec             	lea    -0x14(%ebp),%ecx
c010a1ba:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c010a1be:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c010a1c5:	00 
c010a1c6:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c010a1cd:	00 
c010a1ce:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a1d2:	89 04 24             	mov    %eax,(%esp)
c010a1d5:	e8 f3 f6 ff ff       	call   c01098cd <respond>
    }


}
c010a1da:	c9                   	leave  
c010a1db:	c3                   	ret    

c010a1dc <handle_port_free>:
 * @brief handles PORT_FREE call
 * @param drv pointer to the driver struct
 * @param req pointer to the request package
 */
void handle_port_free(struct driver *drv, pck_t *req)
{
c010a1dc:	55                   	push   %ebp
c010a1dd:	89 e5                	mov    %esp,%ebp
c010a1df:	83 ec 38             	sub    $0x38,%esp
    iterator_t i = iterator_create(drv->ports);
c010a1e2:	8b 45 08             	mov    0x8(%ebp),%eax
c010a1e5:	8b 50 08             	mov    0x8(%eax),%edx
c010a1e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010a1eb:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a1ef:	89 04 24             	mov    %eax,(%esp)
c010a1f2:	e8 f4 8a ff ff       	call   c0102ceb <iterator_create>
c010a1f7:	83 ec 04             	sub    $0x4,%esp
    portpck_t *free_port = (portpck_t*) req->data;
c010a1fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a1fd:	8b 40 0c             	mov    0xc(%eax),%eax
c010a200:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(!list_is_last(&i))
c010a203:	eb 65                	jmp    c010a26a <handle_port_free+0x8e>
    {
        if(((portpck_t*)list_get_current(&i))->port == free_port->port)
c010a205:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010a208:	89 04 24             	mov    %eax,(%esp)
c010a20b:	e8 a4 8b ff ff       	call   c0102db4 <list_get_current>
c010a210:	8b 10                	mov    (%eax),%edx
c010a212:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a215:	8b 00                	mov    (%eax),%eax
c010a217:	39 c2                	cmp    %eax,%edx
c010a219:	75 44                	jne    c010a25f <handle_port_free+0x83>
        {
            free(list_remove(&i));
c010a21b:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010a21e:	89 04 24             	mov    %eax,(%esp)
c010a221:	e8 20 8c ff ff       	call   c0102e46 <list_remove>
c010a226:	89 04 24             	mov    %eax,(%esp)
c010a229:	e8 25 1e 00 00       	call   c010c053 <free>
            respond(drv->pman, req->id, SUCCESS, 0, 0);
c010a22e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a231:	8b 10                	mov    (%eax),%edx
c010a233:	8b 45 08             	mov    0x8(%ebp),%eax
c010a236:	8b 40 0c             	mov    0xc(%eax),%eax
c010a239:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010a240:	00 
c010a241:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010a248:	00 
c010a249:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c010a250:	00 
c010a251:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a255:	89 04 24             	mov    %eax,(%esp)
c010a258:	e8 70 f6 ff ff       	call   c01098cd <respond>
c010a25d:	eb 49                	jmp    c010a2a8 <handle_port_free+0xcc>
            return;
        }
        list_next(&i);
c010a25f:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010a262:	89 04 24             	mov    %eax,(%esp)
c010a265:	e8 6f 8b ff ff       	call   c0102dd9 <list_next>
 */
void handle_port_free(struct driver *drv, pck_t *req)
{
    iterator_t i = iterator_create(drv->ports);
    portpck_t *free_port = (portpck_t*) req->data;
    while(!list_is_last(&i))
c010a26a:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010a26d:	89 04 24             	mov    %eax,(%esp)
c010a270:	e8 8b 8b ff ff       	call   c0102e00 <list_is_last>
c010a275:	85 c0                	test   %eax,%eax
c010a277:	74 8c                	je     c010a205 <handle_port_free+0x29>
            return;
        }
        list_next(&i);
    }

    respond(drv->pman, req->id, ERROR, 0, 0);
c010a279:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a27c:	8b 10                	mov    (%eax),%edx
c010a27e:	8b 45 08             	mov    0x8(%ebp),%eax
c010a281:	8b 40 0c             	mov    0xc(%eax),%eax
c010a284:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010a28b:	00 
c010a28c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010a293:	00 
c010a294:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c010a29b:	00 
c010a29c:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a2a0:	89 04 24             	mov    %eax,(%esp)
c010a2a3:	e8 25 f6 ff ff       	call   c01098cd <respond>
}
c010a2a8:	c9                   	leave  
c010a2a9:	c3                   	ret    

c010a2aa <pfp>:
 * @brief parsers a pipeline file
 * @param pipelines the pipeline file as a ascii string
 * @return a list of the sections
 */
list_t *pfp(char *pipelines)
{
c010a2aa:	55                   	push   %ebp
c010a2ab:	89 e5                	mov    %esp,%ebp
c010a2ad:	83 ec 38             	sub    $0x38,%esp
    bool valid = validate_pf(pipelines);
c010a2b0:	8b 45 08             	mov    0x8(%ebp),%eax
c010a2b3:	89 04 24             	mov    %eax,(%esp)
c010a2b6:	e8 82 00 00 00       	call   c010a33d <validate_pf>
c010a2bb:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(valid == true)
c010a2be:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c010a2c2:	75 72                	jne    c010a336 <pfp+0x8c>
    {
        list_t *pipes = list_create();
c010a2c4:	e8 b2 86 ff ff       	call   c010297b <list_create>
c010a2c9:	89 45 ec             	mov    %eax,-0x14(%ebp)

        int sections_nr = count_sections(pipelines);
c010a2cc:	8b 45 08             	mov    0x8(%ebp),%eax
c010a2cf:	89 04 24             	mov    %eax,(%esp)
c010a2d2:	e8 70 00 00 00       	call   c010a347 <count_sections>
c010a2d7:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if(sections_nr == 0)
c010a2da:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010a2de:	75 07                	jne    c010a2e7 <pfp+0x3d>
            return NULL;
c010a2e0:	b8 00 00 00 00       	mov    $0x0,%eax
c010a2e5:	eb 54                	jmp    c010a33b <pfp+0x91>

        int i = 0;
c010a2e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        int current_position = 0;
c010a2ee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

        for(i = 0; i < sections_nr; i++)
c010a2f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010a2fc:	eb 2b                	jmp    c010a329 <pfp+0x7f>
        {
            struct section *current_section = parser_section(pipelines, &current_position);
c010a2fe:	8d 45 e0             	lea    -0x20(%ebp),%eax
c010a301:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a305:	8b 45 08             	mov    0x8(%ebp),%eax
c010a308:	89 04 24             	mov    %eax,(%esp)
c010a30b:	e8 bb 00 00 00       	call   c010a3cb <parser_section>
c010a310:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            list_push_back(pipes, current_section);
c010a313:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a316:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a31a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a31d:	89 04 24             	mov    %eax,(%esp)
c010a320:	e8 3a 87 ff ff       	call   c0102a5f <list_push_back>
            return NULL;

        int i = 0;
        int current_position = 0;

        for(i = 0; i < sections_nr; i++)
c010a325:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a329:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a32c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c010a32f:	7c cd                	jl     c010a2fe <pfp+0x54>
        {
            struct section *current_section = parser_section(pipelines, &current_position);
            list_push_back(pipes, current_section);
        }

        return pipes;
c010a331:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a334:	eb 05                	jmp    c010a33b <pfp+0x91>
    }
    else
    {
        return NULL;
c010a336:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c010a33b:	c9                   	leave  
c010a33c:	c3                   	ret    

c010a33d <validate_pf>:
 * @param pipelines the pipeline file as a ascii string
 * @return true if the pipeline file is valid
 * @return false if the pipeline file is invalid
 */
bool validate_pf(char *pipelines)
{
c010a33d:	55                   	push   %ebp
c010a33e:	89 e5                	mov    %esp,%ebp
    // TODO

    return true;
c010a340:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010a345:	5d                   	pop    %ebp
c010a346:	c3                   	ret    

c010a347 <count_sections>:
 * @brief counts the number of sections in a pipeline file
 * @param pipelines the pipeline file as a ascii string
 * @return the number of sections
 */
int count_sections(char *pipelines)
{
c010a347:	55                   	push   %ebp
c010a348:	89 e5                	mov    %esp,%ebp
c010a34a:	83 ec 28             	sub    $0x28,%esp
    int i = 0;
c010a34d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int nr = 0;
c010a354:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    for(i = 0; pipelines[i + STRING_SECTION_LEN] != '\0'; i++)
c010a35b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010a362:	eb 50                	jmp    c010a3b4 <count_sections+0x6d>
    {
        if(pipelines[i] == '#')
c010a364:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a367:	8b 45 08             	mov    0x8(%ebp),%eax
c010a36a:	01 d0                	add    %edx,%eax
c010a36c:	0f b6 00             	movzbl (%eax),%eax
c010a36f:	3c 23                	cmp    $0x23,%al
c010a371:	75 15                	jne    c010a388 <count_sections+0x41>
            for(; pipelines[i] != '\n'; i++);
c010a373:	eb 04                	jmp    c010a379 <count_sections+0x32>
c010a375:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a379:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a37c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a37f:	01 d0                	add    %edx,%eax
c010a381:	0f b6 00             	movzbl (%eax),%eax
c010a384:	3c 0a                	cmp    $0xa,%al
c010a386:	75 ed                	jne    c010a375 <count_sections+0x2e>

        if(!strncmp(&pipelines[i], "section", STRING_SECTION_LEN))
c010a388:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a38b:	8b 45 08             	mov    0x8(%ebp),%eax
c010a38e:	01 d0                	add    %edx,%eax
c010a390:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
c010a397:	00 
c010a398:	c7 44 24 04 e1 0d 11 	movl   $0xc0110de1,0x4(%esp)
c010a39f:	c0 
c010a3a0:	89 04 24             	mov    %eax,(%esp)
c010a3a3:	e8 cf 8c ff ff       	call   c0103077 <strncmp>
c010a3a8:	85 c0                	test   %eax,%eax
c010a3aa:	75 04                	jne    c010a3b0 <count_sections+0x69>
            nr++;
c010a3ac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
int count_sections(char *pipelines)
{
    int i = 0;
    int nr = 0;

    for(i = 0; pipelines[i + STRING_SECTION_LEN] != '\0'; i++)
c010a3b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a3b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a3b7:	8d 50 06             	lea    0x6(%eax),%edx
c010a3ba:	8b 45 08             	mov    0x8(%ebp),%eax
c010a3bd:	01 d0                	add    %edx,%eax
c010a3bf:	0f b6 00             	movzbl (%eax),%eax
c010a3c2:	84 c0                	test   %al,%al
c010a3c4:	75 9e                	jne    c010a364 <count_sections+0x1d>
        if(!strncmp(&pipelines[i], "section", STRING_SECTION_LEN))
            nr++;
    }


    return nr;
c010a3c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010a3c9:	c9                   	leave  
c010a3ca:	c3                   	ret    

c010a3cb <parser_section>:
 * @brief parsers a section of a pipeline file
 * @param pipelines the pipeline file as a ascii string
 * @param section_pos the position in the string where the section starts
 */
struct section *parser_section(char *pipelines, int *section_pos)
{
c010a3cb:	55                   	push   %ebp
c010a3cc:	89 e5                	mov    %esp,%ebp
c010a3ce:	83 ec 28             	sub    $0x28,%esp
    find_next_section(pipelines, section_pos);
c010a3d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a3d4:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a3d8:	8b 45 08             	mov    0x8(%ebp),%eax
c010a3db:	89 04 24             	mov    %eax,(%esp)
c010a3de:	e8 b8 01 00 00       	call   c010a59b <find_next_section>

    (*section_pos) += 7;
c010a3e3:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a3e6:	8b 00                	mov    (%eax),%eax
c010a3e8:	8d 50 07             	lea    0x7(%eax),%edx
c010a3eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a3ee:	89 10                	mov    %edx,(%eax)

    skip_whitespaces(pipelines, section_pos);
c010a3f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a3f3:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a3f7:	8b 45 08             	mov    0x8(%ebp),%eax
c010a3fa:	89 04 24             	mov    %eax,(%esp)
c010a3fd:	e8 cb 02 00 00       	call   c010a6cd <skip_whitespaces>

    int section_name_length = count_sectionname_length(pipelines, section_pos);
c010a402:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a405:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a409:	8b 45 08             	mov    0x8(%ebp),%eax
c010a40c:	89 04 24             	mov    %eax,(%esp)
c010a40f:	e8 f3 02 00 00       	call   c010a707 <count_sectionname_length>
c010a414:	89 45 f4             	mov    %eax,-0xc(%ebp)

    struct section *this = (struct section *)malloc(sizeof(struct section));
c010a417:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c010a41e:	e8 22 1b 00 00       	call   c010bf45 <malloc>
c010a423:	89 45 f0             	mov    %eax,-0x10(%ebp)
    this->name = (char *)malloc(sizeof(char) * (section_name_length + 1));
c010a426:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a429:	83 c0 01             	add    $0x1,%eax
c010a42c:	89 04 24             	mov    %eax,(%esp)
c010a42f:	e8 11 1b 00 00       	call   c010bf45 <malloc>
c010a434:	89 c2                	mov    %eax,%edx
c010a436:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a439:	89 50 04             	mov    %edx,0x4(%eax)
    memset(this->name, '\0',sizeof(char) * (section_name_length + 1));
c010a43c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a43f:	83 c0 01             	add    $0x1,%eax
c010a442:	89 c2                	mov    %eax,%edx
c010a444:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a447:	8b 40 04             	mov    0x4(%eax),%eax
c010a44a:	89 54 24 08          	mov    %edx,0x8(%esp)
c010a44e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010a455:	00 
c010a456:	89 04 24             	mov    %eax,(%esp)
c010a459:	e8 bb 8f ff ff       	call   c0103419 <memset>
    strncpy(this->name, &pipelines[(*section_pos)], section_name_length);
c010a45e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a461:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a464:	8b 00                	mov    (%eax),%eax
c010a466:	89 c1                	mov    %eax,%ecx
c010a468:	8b 45 08             	mov    0x8(%ebp),%eax
c010a46b:	01 c1                	add    %eax,%ecx
c010a46d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a470:	8b 40 04             	mov    0x4(%eax),%eax
c010a473:	89 54 24 08          	mov    %edx,0x8(%esp)
c010a477:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c010a47b:	89 04 24             	mov    %eax,(%esp)
c010a47e:	e8 c2 8a ff ff       	call   c0102f45 <strncpy>
    (*section_pos) += section_name_length;
c010a483:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a486:	8b 10                	mov    (%eax),%edx
c010a488:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a48b:	01 c2                	add    %eax,%edx
c010a48d:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a490:	89 10                	mov    %edx,(%eax)
    this->type = get_section_type(pipelines, section_pos);
c010a492:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a495:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a499:	8b 45 08             	mov    0x8(%ebp),%eax
c010a49c:	89 04 24             	mov    %eax,(%esp)
c010a49f:	e8 a8 02 00 00       	call   c010a74c <get_section_type>
c010a4a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010a4a7:	89 02                	mov    %eax,(%edx)
    skip_until_colon(pipelines, section_pos);
c010a4a9:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a4ac:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a4b0:	8b 45 08             	mov    0x8(%ebp),%eax
c010a4b3:	89 04 24             	mov    %eax,(%esp)
c010a4b6:	e8 e8 03 00 00       	call   c010a8a3 <skip_until_colon>
    int section_end = find_end_of_section(pipelines, section_pos);
c010a4bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a4be:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a4c2:	8b 45 08             	mov    0x8(%ebp),%eax
c010a4c5:	89 04 24             	mov    %eax,(%esp)
c010a4c8:	e8 5e 01 00 00       	call   c010a62b <find_end_of_section>
c010a4cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    this->subtree = list_create();
c010a4d0:	e8 a6 84 ff ff       	call   c010297b <list_create>
c010a4d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010a4d8:	89 42 08             	mov    %eax,0x8(%edx)

    for(; (*section_pos) < section_end; (*section_pos)++)
c010a4db:	e9 a8 00 00 00       	jmp    c010a588 <parser_section+0x1bd>
    {
        if(pipelines[(*section_pos)] == '#')
c010a4e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a4e3:	8b 00                	mov    (%eax),%eax
c010a4e5:	89 c2                	mov    %eax,%edx
c010a4e7:	8b 45 08             	mov    0x8(%ebp),%eax
c010a4ea:	01 d0                	add    %edx,%eax
c010a4ec:	0f b6 00             	movzbl (%eax),%eax
c010a4ef:	3c 23                	cmp    $0x23,%al
c010a4f1:	75 41                	jne    c010a534 <parser_section+0x169>
        {
            while(pipelines[(*section_pos)] != '\n' && pipelines[(*section_pos)] != '\0' && (*section_pos) <= section_end)
c010a4f3:	eb 0d                	jmp    c010a502 <parser_section+0x137>
                (*section_pos)++;
c010a4f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a4f8:	8b 00                	mov    (%eax),%eax
c010a4fa:	8d 50 01             	lea    0x1(%eax),%edx
c010a4fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a500:	89 10                	mov    %edx,(%eax)

    for(; (*section_pos) < section_end; (*section_pos)++)
    {
        if(pipelines[(*section_pos)] == '#')
        {
            while(pipelines[(*section_pos)] != '\n' && pipelines[(*section_pos)] != '\0' && (*section_pos) <= section_end)
c010a502:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a505:	8b 00                	mov    (%eax),%eax
c010a507:	89 c2                	mov    %eax,%edx
c010a509:	8b 45 08             	mov    0x8(%ebp),%eax
c010a50c:	01 d0                	add    %edx,%eax
c010a50e:	0f b6 00             	movzbl (%eax),%eax
c010a511:	3c 0a                	cmp    $0xa,%al
c010a513:	74 66                	je     c010a57b <parser_section+0x1b0>
c010a515:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a518:	8b 00                	mov    (%eax),%eax
c010a51a:	89 c2                	mov    %eax,%edx
c010a51c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a51f:	01 d0                	add    %edx,%eax
c010a521:	0f b6 00             	movzbl (%eax),%eax
c010a524:	84 c0                	test   %al,%al
c010a526:	74 53                	je     c010a57b <parser_section+0x1b0>
c010a528:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a52b:	8b 00                	mov    (%eax),%eax
c010a52d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c010a530:	7e c3                	jle    c010a4f5 <parser_section+0x12a>
c010a532:	eb 47                	jmp    c010a57b <parser_section+0x1b0>
                (*section_pos)++;
        }
        else if(pipelines[(*section_pos)] == '<')
c010a534:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a537:	8b 00                	mov    (%eax),%eax
c010a539:	89 c2                	mov    %eax,%edx
c010a53b:	8b 45 08             	mov    0x8(%ebp),%eax
c010a53e:	01 d0                	add    %edx,%eax
c010a540:	0f b6 00             	movzbl (%eax),%eax
c010a543:	3c 3c                	cmp    $0x3c,%al
c010a545:	75 34                	jne    c010a57b <parser_section+0x1b0>
        {
            struct pnode *node = parser_pnode(pipelines, section_pos, this->subtree);
c010a547:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a54a:	8b 40 08             	mov    0x8(%eax),%eax
c010a54d:	89 44 24 08          	mov    %eax,0x8(%esp)
c010a551:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a554:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a558:	8b 45 08             	mov    0x8(%ebp),%eax
c010a55b:	89 04 24             	mov    %eax,(%esp)
c010a55e:	e8 7f 03 00 00       	call   c010a8e2 <parser_pnode>
c010a563:	89 45 e8             	mov    %eax,-0x18(%ebp)

            list_push_front(this->subtree, node);
c010a566:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a569:	8b 40 08             	mov    0x8(%eax),%eax
c010a56c:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010a56f:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a573:	89 04 24             	mov    %eax,(%esp)
c010a576:	e8 37 85 ff ff       	call   c0102ab2 <list_push_front>
    this->type = get_section_type(pipelines, section_pos);
    skip_until_colon(pipelines, section_pos);
    int section_end = find_end_of_section(pipelines, section_pos);
    this->subtree = list_create();

    for(; (*section_pos) < section_end; (*section_pos)++)
c010a57b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a57e:	8b 00                	mov    (%eax),%eax
c010a580:	8d 50 01             	lea    0x1(%eax),%edx
c010a583:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a586:	89 10                	mov    %edx,(%eax)
c010a588:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a58b:	8b 00                	mov    (%eax),%eax
c010a58d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c010a590:	0f 8c 4a ff ff ff    	jl     c010a4e0 <parser_section+0x115>

            list_push_front(this->subtree, node);
        }
    }

    return this;
c010a596:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010a599:	c9                   	leave  
c010a59a:	c3                   	ret    

c010a59b <find_next_section>:
 * @param pipelines the pipeline file as a ascii string
 * @param search_begin the point in the string where i should start searching
 * @return the position of the next section
 */
int find_next_section(char *pipelines, int *search_begin)
{
c010a59b:	55                   	push   %ebp
c010a59c:	89 e5                	mov    %esp,%ebp
c010a59e:	83 ec 18             	sub    $0x18,%esp
    for(; pipelines[(*search_begin) + STRING_SECTION_LEN] != '\0'; (*search_begin)++)
c010a5a1:	eb 6a                	jmp    c010a60d <find_next_section+0x72>
    {
        if(pipelines[(*search_begin)] == '#')
c010a5a3:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a5a6:	8b 00                	mov    (%eax),%eax
c010a5a8:	89 c2                	mov    %eax,%edx
c010a5aa:	8b 45 08             	mov    0x8(%ebp),%eax
c010a5ad:	01 d0                	add    %edx,%eax
c010a5af:	0f b6 00             	movzbl (%eax),%eax
c010a5b2:	3c 23                	cmp    $0x23,%al
c010a5b4:	75 22                	jne    c010a5d8 <find_next_section+0x3d>
            for(; pipelines[(*search_begin)] != '\n'; (*search_begin)++);
c010a5b6:	eb 0d                	jmp    c010a5c5 <find_next_section+0x2a>
c010a5b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a5bb:	8b 00                	mov    (%eax),%eax
c010a5bd:	8d 50 01             	lea    0x1(%eax),%edx
c010a5c0:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a5c3:	89 10                	mov    %edx,(%eax)
c010a5c5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a5c8:	8b 00                	mov    (%eax),%eax
c010a5ca:	89 c2                	mov    %eax,%edx
c010a5cc:	8b 45 08             	mov    0x8(%ebp),%eax
c010a5cf:	01 d0                	add    %edx,%eax
c010a5d1:	0f b6 00             	movzbl (%eax),%eax
c010a5d4:	3c 0a                	cmp    $0xa,%al
c010a5d6:	75 e0                	jne    c010a5b8 <find_next_section+0x1d>

        if(strncmp(&pipelines[(*search_begin)], "section", STRING_SECTION_LEN) == 0)
c010a5d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a5db:	8b 00                	mov    (%eax),%eax
c010a5dd:	89 c2                	mov    %eax,%edx
c010a5df:	8b 45 08             	mov    0x8(%ebp),%eax
c010a5e2:	01 d0                	add    %edx,%eax
c010a5e4:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
c010a5eb:	00 
c010a5ec:	c7 44 24 04 e1 0d 11 	movl   $0xc0110de1,0x4(%esp)
c010a5f3:	c0 
c010a5f4:	89 04 24             	mov    %eax,(%esp)
c010a5f7:	e8 7b 8a ff ff       	call   c0103077 <strncmp>
c010a5fc:	85 c0                	test   %eax,%eax
c010a5fe:	74 23                	je     c010a623 <find_next_section+0x88>
 * @param search_begin the point in the string where i should start searching
 * @return the position of the next section
 */
int find_next_section(char *pipelines, int *search_begin)
{
    for(; pipelines[(*search_begin) + STRING_SECTION_LEN] != '\0'; (*search_begin)++)
c010a600:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a603:	8b 00                	mov    (%eax),%eax
c010a605:	8d 50 01             	lea    0x1(%eax),%edx
c010a608:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a60b:	89 10                	mov    %edx,(%eax)
c010a60d:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a610:	8b 00                	mov    (%eax),%eax
c010a612:	8d 50 06             	lea    0x6(%eax),%edx
c010a615:	8b 45 08             	mov    0x8(%ebp),%eax
c010a618:	01 d0                	add    %edx,%eax
c010a61a:	0f b6 00             	movzbl (%eax),%eax
c010a61d:	84 c0                	test   %al,%al
c010a61f:	75 82                	jne    c010a5a3 <find_next_section+0x8>
c010a621:	eb 01                	jmp    c010a624 <find_next_section+0x89>
    {
        if(pipelines[(*search_begin)] == '#')
            for(; pipelines[(*search_begin)] != '\n'; (*search_begin)++);

        if(strncmp(&pipelines[(*search_begin)], "section", STRING_SECTION_LEN) == 0)
            break;
c010a623:	90                   	nop
    }


    return (*search_begin);
c010a624:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a627:	8b 00                	mov    (%eax),%eax
}
c010a629:	c9                   	leave  
c010a62a:	c3                   	ret    

c010a62b <find_end_of_section>:
 * @param pipelines the pipeline file as a ascii string
 * @param search_begin the point in the string where i should start searching
 * @return the point of the end of the current section
 */
int find_end_of_section(char *pipelines, int *search_begin)
{
c010a62b:	55                   	push   %ebp
c010a62c:	89 e5                	mov    %esp,%ebp
c010a62e:	83 ec 28             	sub    $0x28,%esp
    int i;

    for(i = (*search_begin); pipelines[i + STRING_SECTION_LEN] != '\0'; i++)
c010a631:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a634:	8b 00                	mov    (%eax),%eax
c010a636:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010a639:	eb 4c                	jmp    c010a687 <find_end_of_section+0x5c>
    {
        if(pipelines[i] == '#')
c010a63b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a63e:	8b 45 08             	mov    0x8(%ebp),%eax
c010a641:	01 d0                	add    %edx,%eax
c010a643:	0f b6 00             	movzbl (%eax),%eax
c010a646:	3c 23                	cmp    $0x23,%al
c010a648:	75 15                	jne    c010a65f <find_end_of_section+0x34>
            for(; pipelines[i] != '\n'; i++);
c010a64a:	eb 04                	jmp    c010a650 <find_end_of_section+0x25>
c010a64c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a650:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a653:	8b 45 08             	mov    0x8(%ebp),%eax
c010a656:	01 d0                	add    %edx,%eax
c010a658:	0f b6 00             	movzbl (%eax),%eax
c010a65b:	3c 0a                	cmp    $0xa,%al
c010a65d:	75 ed                	jne    c010a64c <find_end_of_section+0x21>

        if(strncmp(&pipelines[i], "section", STRING_SECTION_LEN) == 0)
c010a65f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010a662:	8b 45 08             	mov    0x8(%ebp),%eax
c010a665:	01 d0                	add    %edx,%eax
c010a667:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
c010a66e:	00 
c010a66f:	c7 44 24 04 e1 0d 11 	movl   $0xc0110de1,0x4(%esp)
c010a676:	c0 
c010a677:	89 04 24             	mov    %eax,(%esp)
c010a67a:	e8 f8 89 ff ff       	call   c0103077 <strncmp>
c010a67f:	85 c0                	test   %eax,%eax
c010a681:	74 18                	je     c010a69b <find_end_of_section+0x70>
 */
int find_end_of_section(char *pipelines, int *search_begin)
{
    int i;

    for(i = (*search_begin); pipelines[i + STRING_SECTION_LEN] != '\0'; i++)
c010a683:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a687:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a68a:	8d 50 06             	lea    0x6(%eax),%edx
c010a68d:	8b 45 08             	mov    0x8(%ebp),%eax
c010a690:	01 d0                	add    %edx,%eax
c010a692:	0f b6 00             	movzbl (%eax),%eax
c010a695:	84 c0                	test   %al,%al
c010a697:	75 a2                	jne    c010a63b <find_end_of_section+0x10>
c010a699:	eb 01                	jmp    c010a69c <find_end_of_section+0x71>
    {
        if(pipelines[i] == '#')
            for(; pipelines[i] != '\n'; i++);

        if(strncmp(&pipelines[i], "section", STRING_SECTION_LEN) == 0)
            break;
c010a69b:	90                   	nop
    }

    return i;
c010a69c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010a69f:	c9                   	leave  
c010a6a0:	c3                   	ret    

c010a6a1 <is_whitespace>:
 * @brief checks if a character is a whitespace
 * @param character the character
 * @return true or false
 */
bool is_whitespace(char character)
{
c010a6a1:	55                   	push   %ebp
c010a6a2:	89 e5                	mov    %esp,%ebp
c010a6a4:	83 ec 04             	sub    $0x4,%esp
c010a6a7:	8b 45 08             	mov    0x8(%ebp),%eax
c010a6aa:	88 45 fc             	mov    %al,-0x4(%ebp)
    return ((character == ' ' || character == '\t' || character == '\n') ? true : false);
c010a6ad:	80 7d fc 20          	cmpb   $0x20,-0x4(%ebp)
c010a6b1:	74 0c                	je     c010a6bf <is_whitespace+0x1e>
c010a6b3:	80 7d fc 09          	cmpb   $0x9,-0x4(%ebp)
c010a6b7:	74 06                	je     c010a6bf <is_whitespace+0x1e>
c010a6b9:	80 7d fc 0a          	cmpb   $0xa,-0x4(%ebp)
c010a6bd:	75 07                	jne    c010a6c6 <is_whitespace+0x25>
c010a6bf:	b8 01 00 00 00       	mov    $0x1,%eax
c010a6c4:	eb 05                	jmp    c010a6cb <is_whitespace+0x2a>
c010a6c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010a6cb:	c9                   	leave  
c010a6cc:	c3                   	ret    

c010a6cd <skip_whitespaces>:
 * @param pipelines the string
 * @param start the current position in the string
 * @return the new position in the string
 */
int skip_whitespaces(char *pipelines, int *start)
{
c010a6cd:	55                   	push   %ebp
c010a6ce:	89 e5                	mov    %esp,%ebp
c010a6d0:	83 ec 04             	sub    $0x4,%esp
    for(; is_whitespace(pipelines[(*start)]); (*start)++);
c010a6d3:	eb 0d                	jmp    c010a6e2 <skip_whitespaces+0x15>
c010a6d5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a6d8:	8b 00                	mov    (%eax),%eax
c010a6da:	8d 50 01             	lea    0x1(%eax),%edx
c010a6dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a6e0:	89 10                	mov    %edx,(%eax)
c010a6e2:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a6e5:	8b 00                	mov    (%eax),%eax
c010a6e7:	89 c2                	mov    %eax,%edx
c010a6e9:	8b 45 08             	mov    0x8(%ebp),%eax
c010a6ec:	01 d0                	add    %edx,%eax
c010a6ee:	0f b6 00             	movzbl (%eax),%eax
c010a6f1:	0f be c0             	movsbl %al,%eax
c010a6f4:	89 04 24             	mov    %eax,(%esp)
c010a6f7:	e8 a5 ff ff ff       	call   c010a6a1 <is_whitespace>
c010a6fc:	85 c0                	test   %eax,%eax
c010a6fe:	75 d5                	jne    c010a6d5 <skip_whitespaces+0x8>

    return (*start);
c010a700:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a703:	8b 00                	mov    (%eax),%eax
}
c010a705:	c9                   	leave  
c010a706:	c3                   	ret    

c010a707 <count_sectionname_length>:
 * @param pipelines the string in which the section name is
 * @param start the position of the section name
 * @return the length of the sections name
 */
int count_sectionname_length(char *pipelines, int *start)
{
c010a707:	55                   	push   %ebp
c010a708:	89 e5                	mov    %esp,%ebp
c010a70a:	83 ec 14             	sub    $0x14,%esp
    int i = (*start);
c010a70d:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a710:	8b 00                	mov    (%eax),%eax
c010a712:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int nr = 0;
c010a715:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    for(nr = 0; !is_whitespace(pipelines[i]); i++)
c010a71c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c010a723:	eb 08                	jmp    c010a72d <count_sectionname_length+0x26>
        nr++;
c010a725:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
int count_sectionname_length(char *pipelines, int *start)
{
    int i = (*start);
    int nr = 0;

    for(nr = 0; !is_whitespace(pipelines[i]); i++)
c010a729:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010a72d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010a730:	8b 45 08             	mov    0x8(%ebp),%eax
c010a733:	01 d0                	add    %edx,%eax
c010a735:	0f b6 00             	movzbl (%eax),%eax
c010a738:	0f be c0             	movsbl %al,%eax
c010a73b:	89 04 24             	mov    %eax,(%esp)
c010a73e:	e8 5e ff ff ff       	call   c010a6a1 <is_whitespace>
c010a743:	85 c0                	test   %eax,%eax
c010a745:	74 de                	je     c010a725 <count_sectionname_length+0x1e>
        nr++;

    return nr;
c010a747:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c010a74a:	c9                   	leave  
c010a74b:	c3                   	ret    

c010a74c <get_section_type>:
 * @param pipelines the string in which i should look up the section type
 * @param start the position of the section type definition
 * @return the type of the section
 */
ptype get_section_type(char *pipelines, int *start)
{
c010a74c:	55                   	push   %ebp
c010a74d:	89 e5                	mov    %esp,%ebp
c010a74f:	83 ec 28             	sub    $0x28,%esp
    ptype t = NOTHING;
c010a752:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if(check_section_type_given(pipelines, start) == false)
c010a759:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a75c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a760:	8b 45 08             	mov    0x8(%ebp),%eax
c010a763:	89 04 24             	mov    %eax,(%esp)
c010a766:	e8 be 00 00 00       	call   c010a829 <check_section_type_given>
c010a76b:	85 c0                	test   %eax,%eax
c010a76d:	75 0a                	jne    c010a779 <get_section_type+0x2d>
        return UNDEFINED;
c010a76f:	b8 20 00 00 00       	mov    $0x20,%eax
c010a774:	e9 ae 00 00 00       	jmp    c010a827 <get_section_type+0xdb>

    skip_whitespaces(pipelines, start);
c010a779:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a77c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a780:	8b 45 08             	mov    0x8(%ebp),%eax
c010a783:	89 04 24             	mov    %eax,(%esp)
c010a786:	e8 42 ff ff ff       	call   c010a6cd <skip_whitespaces>
    (*start)++;
c010a78b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a78e:	8b 00                	mov    (%eax),%eax
c010a790:	8d 50 01             	lea    0x1(%eax),%edx
c010a793:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a796:	89 10                	mov    %edx,(%eax)

    if(strncmp(&pipelines[(*start)], "replace", STRING_REPLACE_LEN) == 0)
c010a798:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a79b:	8b 00                	mov    (%eax),%eax
c010a79d:	89 c2                	mov    %eax,%edx
c010a79f:	8b 45 08             	mov    0x8(%ebp),%eax
c010a7a2:	01 d0                	add    %edx,%eax
c010a7a4:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
c010a7ab:	00 
c010a7ac:	c7 44 24 04 e9 0d 11 	movl   $0xc0110de9,0x4(%esp)
c010a7b3:	c0 
c010a7b4:	89 04 24             	mov    %eax,(%esp)
c010a7b7:	e8 bb 88 ff ff       	call   c0103077 <strncmp>
c010a7bc:	85 c0                	test   %eax,%eax
c010a7be:	75 13                	jne    c010a7d3 <get_section_type+0x87>
    {
        t |= REPLACE;
c010a7c0:	83 4d f4 08          	orl    $0x8,-0xc(%ebp)
        (*start) += (STRING_REPLACE_LEN + 1);
c010a7c4:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a7c7:	8b 00                	mov    (%eax),%eax
c010a7c9:	8d 50 07             	lea    0x7(%eax),%edx
c010a7cc:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a7cf:	89 10                	mov    %edx,(%eax)
c010a7d1:	eb 51                	jmp    c010a824 <get_section_type+0xd8>
    }
    else if(strncmp(&pipelines[(*start)], "append", STRING_APPEND_LEN) == 0)
c010a7d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a7d6:	8b 00                	mov    (%eax),%eax
c010a7d8:	89 c2                	mov    %eax,%edx
c010a7da:	8b 45 08             	mov    0x8(%ebp),%eax
c010a7dd:	01 d0                	add    %edx,%eax
c010a7df:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
c010a7e6:	00 
c010a7e7:	c7 44 24 04 f1 0d 11 	movl   $0xc0110df1,0x4(%esp)
c010a7ee:	c0 
c010a7ef:	89 04 24             	mov    %eax,(%esp)
c010a7f2:	e8 80 88 ff ff       	call   c0103077 <strncmp>
c010a7f7:	85 c0                	test   %eax,%eax
c010a7f9:	75 13                	jne    c010a80e <get_section_type+0xc2>
    {
        t |= APPEND;
c010a7fb:	83 4d f4 10          	orl    $0x10,-0xc(%ebp)
        (*start) += (STRING_APPEND_LEN + 1);
c010a7ff:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a802:	8b 00                	mov    (%eax),%eax
c010a804:	8d 50 06             	lea    0x6(%eax),%edx
c010a807:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a80a:	89 10                	mov    %edx,(%eax)
c010a80c:	eb 16                	jmp    c010a824 <get_section_type+0xd8>
    }
    else
    {
        t |= FAILTURE;
c010a80e:	83 4d f4 40          	orl    $0x40,-0xc(%ebp)
        skip_until_whitespace(pipelines, start);
c010a812:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a815:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a819:	8b 45 08             	mov    0x8(%ebp),%eax
c010a81c:	89 04 24             	mov    %eax,(%esp)
c010a81f:	e8 45 00 00 00       	call   c010a869 <skip_until_whitespace>
    }

    return t;
c010a824:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010a827:	c9                   	leave  
c010a828:	c3                   	ret    

c010a829 <check_section_type_given>:
 * @param pipelines the string in which the section type could be
 * @param start the position where i should look for a section type
 * @return true or false
 */
bool check_section_type_given(char *pipelines, int *start)
{
c010a829:	55                   	push   %ebp
c010a82a:	89 e5                	mov    %esp,%ebp
c010a82c:	83 ec 10             	sub    $0x10,%esp
    int i = (*start);
c010a82f:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a832:	8b 00                	mov    (%eax),%eax
c010a834:	89 45 fc             	mov    %eax,-0x4(%ebp)

    for(; pipelines[i] != ':'; i++)
c010a837:	eb 1a                	jmp    c010a853 <check_section_type_given+0x2a>
        if(pipelines[i] == '(')
c010a839:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010a83c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a83f:	01 d0                	add    %edx,%eax
c010a841:	0f b6 00             	movzbl (%eax),%eax
c010a844:	3c 28                	cmp    $0x28,%al
c010a846:	75 07                	jne    c010a84f <check_section_type_given+0x26>
            return true;
c010a848:	b8 01 00 00 00       	mov    $0x1,%eax
c010a84d:	eb 18                	jmp    c010a867 <check_section_type_given+0x3e>
 */
bool check_section_type_given(char *pipelines, int *start)
{
    int i = (*start);

    for(; pipelines[i] != ':'; i++)
c010a84f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010a853:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010a856:	8b 45 08             	mov    0x8(%ebp),%eax
c010a859:	01 d0                	add    %edx,%eax
c010a85b:	0f b6 00             	movzbl (%eax),%eax
c010a85e:	3c 3a                	cmp    $0x3a,%al
c010a860:	75 d7                	jne    c010a839 <check_section_type_given+0x10>
        if(pipelines[i] == '(')
            return true;

    return false;
c010a862:	b8 00 00 00 00       	mov    $0x0,%eax

}
c010a867:	c9                   	leave  
c010a868:	c3                   	ret    

c010a869 <skip_until_whitespace>:
 * @param pipelines the string
 * @param start the current position
 * @return the position after skipping the characters
 */
int skip_until_whitespace(char *pipelines, int *start)
{
c010a869:	55                   	push   %ebp
c010a86a:	89 e5                	mov    %esp,%ebp
c010a86c:	83 ec 04             	sub    $0x4,%esp
    for(; !is_whitespace(pipelines[(*start)]); (*start)++);
c010a86f:	eb 0d                	jmp    c010a87e <skip_until_whitespace+0x15>
c010a871:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a874:	8b 00                	mov    (%eax),%eax
c010a876:	8d 50 01             	lea    0x1(%eax),%edx
c010a879:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a87c:	89 10                	mov    %edx,(%eax)
c010a87e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a881:	8b 00                	mov    (%eax),%eax
c010a883:	89 c2                	mov    %eax,%edx
c010a885:	8b 45 08             	mov    0x8(%ebp),%eax
c010a888:	01 d0                	add    %edx,%eax
c010a88a:	0f b6 00             	movzbl (%eax),%eax
c010a88d:	0f be c0             	movsbl %al,%eax
c010a890:	89 04 24             	mov    %eax,(%esp)
c010a893:	e8 09 fe ff ff       	call   c010a6a1 <is_whitespace>
c010a898:	85 c0                	test   %eax,%eax
c010a89a:	74 d5                	je     c010a871 <skip_until_whitespace+0x8>

    return (*start);
c010a89c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a89f:	8b 00                	mov    (%eax),%eax
}
c010a8a1:	c9                   	leave  
c010a8a2:	c3                   	ret    

c010a8a3 <skip_until_colon>:
 * @param pipelines the string
 * @param start the current position
 * @return the position after skipping the characters
 */
int skip_until_colon(char *pipelines, int *start)
{
c010a8a3:	55                   	push   %ebp
c010a8a4:	89 e5                	mov    %esp,%ebp
    for(; pipelines[(*start)] != ':' && pipelines[(*start)] != '\0'; (*start)++);
c010a8a6:	eb 0d                	jmp    c010a8b5 <skip_until_colon+0x12>
c010a8a8:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a8ab:	8b 00                	mov    (%eax),%eax
c010a8ad:	8d 50 01             	lea    0x1(%eax),%edx
c010a8b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a8b3:	89 10                	mov    %edx,(%eax)
c010a8b5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a8b8:	8b 00                	mov    (%eax),%eax
c010a8ba:	89 c2                	mov    %eax,%edx
c010a8bc:	8b 45 08             	mov    0x8(%ebp),%eax
c010a8bf:	01 d0                	add    %edx,%eax
c010a8c1:	0f b6 00             	movzbl (%eax),%eax
c010a8c4:	3c 3a                	cmp    $0x3a,%al
c010a8c6:	74 13                	je     c010a8db <skip_until_colon+0x38>
c010a8c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a8cb:	8b 00                	mov    (%eax),%eax
c010a8cd:	89 c2                	mov    %eax,%edx
c010a8cf:	8b 45 08             	mov    0x8(%ebp),%eax
c010a8d2:	01 d0                	add    %edx,%eax
c010a8d4:	0f b6 00             	movzbl (%eax),%eax
c010a8d7:	84 c0                	test   %al,%al
c010a8d9:	75 cd                	jne    c010a8a8 <skip_until_colon+0x5>

    return (*start);
c010a8db:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a8de:	8b 00                	mov    (%eax),%eax
}
c010a8e0:	5d                   	pop    %ebp
c010a8e1:	c3                   	ret    

c010a8e2 <parser_pnode>:
 * @param start the position of the pnode
 * @param other a list of all pnodes until here (for services)
 * @return a pointer to the pnode struct
 */
struct pnode *parser_pnode(char *pipelines, int *start, list_t *other)
{
c010a8e2:	55                   	push   %ebp
c010a8e3:	89 e5                	mov    %esp,%ebp
c010a8e5:	83 ec 38             	sub    $0x38,%esp
    struct pnode *node = (struct pnode *)malloc(sizeof(struct pnode));
c010a8e8:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c010a8ef:	e8 51 16 00 00       	call   c010bf45 <malloc>
c010a8f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int pnode_end = find_pnode_end(pipelines, start);
c010a8f7:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a8fa:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a8fe:	8b 45 08             	mov    0x8(%ebp),%eax
c010a901:	89 04 24             	mov    %eax,(%esp)
c010a904:	e8 76 02 00 00       	call   c010ab7f <find_pnode_end>
c010a909:	89 45 ec             	mov    %eax,-0x14(%ebp)
    node->type = get_ptype(pipelines, (*start), pnode_end);
c010a90c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a90f:	8b 00                	mov    (%eax),%eax
c010a911:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010a914:	89 54 24 08          	mov    %edx,0x8(%esp)
c010a918:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a91c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a91f:	89 04 24             	mov    %eax,(%esp)
c010a922:	e8 59 03 00 00       	call   c010ac80 <get_ptype>
c010a927:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010a92a:	89 42 04             	mov    %eax,0x4(%edx)
    node->file = get_pnode_filename(pipelines, (*start), pnode_end);
c010a92d:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a930:	8b 00                	mov    (%eax),%eax
c010a932:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010a935:	89 54 24 08          	mov    %edx,0x8(%esp)
c010a939:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a93d:	8b 45 08             	mov    0x8(%ebp),%eax
c010a940:	89 04 24             	mov    %eax,(%esp)
c010a943:	e8 8c 03 00 00       	call   c010acd4 <get_pnode_filename>
c010a948:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010a94b:	89 02                	mov    %eax,(%edx)
    node->subtree = list_create();
c010a94d:	e8 29 80 ff ff       	call   c010297b <list_create>
c010a952:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010a955:	89 42 0c             	mov    %eax,0xc(%edx)

    (*start) = pnode_end;
c010a958:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a95b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010a95e:	89 10                	mov    %edx,(%eax)

    for(; pipelines[(*start)] != ';'; (*start)++)
c010a960:	e9 fe 01 00 00       	jmp    c010ab63 <parser_pnode+0x281>
    {
        if(pipelines[(*start)] == '|')
c010a965:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a968:	8b 00                	mov    (%eax),%eax
c010a96a:	89 c2                	mov    %eax,%edx
c010a96c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a96f:	01 d0                	add    %edx,%eax
c010a971:	0f b6 00             	movzbl (%eax),%eax
c010a974:	3c 7c                	cmp    $0x7c,%al
c010a976:	0f 85 ee 00 00 00    	jne    c010aa6a <parser_pnode+0x188>
        {
            for(; pipelines[(*start)] != '<' && pipelines[(*start)] != '['; (*start)++);
c010a97c:	eb 0d                	jmp    c010a98b <parser_pnode+0xa9>
c010a97e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a981:	8b 00                	mov    (%eax),%eax
c010a983:	8d 50 01             	lea    0x1(%eax),%edx
c010a986:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a989:	89 10                	mov    %edx,(%eax)
c010a98b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a98e:	8b 00                	mov    (%eax),%eax
c010a990:	89 c2                	mov    %eax,%edx
c010a992:	8b 45 08             	mov    0x8(%ebp),%eax
c010a995:	01 d0                	add    %edx,%eax
c010a997:	0f b6 00             	movzbl (%eax),%eax
c010a99a:	3c 3c                	cmp    $0x3c,%al
c010a99c:	74 13                	je     c010a9b1 <parser_pnode+0xcf>
c010a99e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a9a1:	8b 00                	mov    (%eax),%eax
c010a9a3:	89 c2                	mov    %eax,%edx
c010a9a5:	8b 45 08             	mov    0x8(%ebp),%eax
c010a9a8:	01 d0                	add    %edx,%eax
c010a9aa:	0f b6 00             	movzbl (%eax),%eax
c010a9ad:	3c 5b                	cmp    $0x5b,%al
c010a9af:	75 cd                	jne    c010a97e <parser_pnode+0x9c>

            if(pipelines[(*start)] == '<')
c010a9b1:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a9b4:	8b 00                	mov    (%eax),%eax
c010a9b6:	89 c2                	mov    %eax,%edx
c010a9b8:	8b 45 08             	mov    0x8(%ebp),%eax
c010a9bb:	01 d0                	add    %edx,%eax
c010a9bd:	0f b6 00             	movzbl (%eax),%eax
c010a9c0:	3c 3c                	cmp    $0x3c,%al
c010a9c2:	0f 85 89 00 00 00    	jne    c010aa51 <parser_pnode+0x16f>
            {
                struct pnode *subnode = parser_pnode(pipelines, start, other);
c010a9c8:	8b 45 10             	mov    0x10(%ebp),%eax
c010a9cb:	89 44 24 08          	mov    %eax,0x8(%esp)
c010a9cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a9d2:	89 44 24 04          	mov    %eax,0x4(%esp)
c010a9d6:	8b 45 08             	mov    0x8(%ebp),%eax
c010a9d9:	89 04 24             	mov    %eax,(%esp)
c010a9dc:	e8 01 ff ff ff       	call   c010a8e2 <parser_pnode>
c010a9e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
                list_push_front(node->subtree, subnode);
c010a9e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a9e7:	8b 40 0c             	mov    0xc(%eax),%eax
c010a9ea:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010a9ed:	89 54 24 04          	mov    %edx,0x4(%esp)
c010a9f1:	89 04 24             	mov    %eax,(%esp)
c010a9f4:	e8 b9 80 ff ff       	call   c0102ab2 <list_push_front>
c010a9f9:	e9 58 01 00 00       	jmp    c010ab56 <parser_pnode+0x274>
            }
            else
            {
                for(; pipelines[(*start)] != ']'; (*start)++)
                {
                    if(pipelines[(*start)] == '<')
c010a9fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa01:	8b 00                	mov    (%eax),%eax
c010aa03:	89 c2                	mov    %eax,%edx
c010aa05:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa08:	01 d0                	add    %edx,%eax
c010aa0a:	0f b6 00             	movzbl (%eax),%eax
c010aa0d:	3c 3c                	cmp    $0x3c,%al
c010aa0f:	75 31                	jne    c010aa42 <parser_pnode+0x160>
                    {
                        struct pnode *subnode = parser_pnode(pipelines, start, other);
c010aa11:	8b 45 10             	mov    0x10(%ebp),%eax
c010aa14:	89 44 24 08          	mov    %eax,0x8(%esp)
c010aa18:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa1b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010aa1f:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa22:	89 04 24             	mov    %eax,(%esp)
c010aa25:	e8 b8 fe ff ff       	call   c010a8e2 <parser_pnode>
c010aa2a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                        list_push_front(node->subtree, subnode);
c010aa2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aa30:	8b 40 0c             	mov    0xc(%eax),%eax
c010aa33:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010aa36:	89 54 24 04          	mov    %edx,0x4(%esp)
c010aa3a:	89 04 24             	mov    %eax,(%esp)
c010aa3d:	e8 70 80 ff ff       	call   c0102ab2 <list_push_front>

                //if(pipelines[(*start)] == ';')
            }
            else
            {
                for(; pipelines[(*start)] != ']'; (*start)++)
c010aa42:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa45:	8b 00                	mov    (%eax),%eax
c010aa47:	8d 50 01             	lea    0x1(%eax),%edx
c010aa4a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa4d:	89 10                	mov    %edx,(%eax)
c010aa4f:	eb 01                	jmp    c010aa52 <parser_pnode+0x170>
c010aa51:	90                   	nop
c010aa52:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa55:	8b 00                	mov    (%eax),%eax
c010aa57:	89 c2                	mov    %eax,%edx
c010aa59:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa5c:	01 d0                	add    %edx,%eax
c010aa5e:	0f b6 00             	movzbl (%eax),%eax
c010aa61:	3c 5d                	cmp    $0x5d,%al
c010aa63:	75 99                	jne    c010a9fe <parser_pnode+0x11c>
c010aa65:	e9 ec 00 00 00       	jmp    c010ab56 <parser_pnode+0x274>
                        list_push_front(node->subtree, subnode);
                    }
                }
            }
        }
        else if(pipelines[(*start)] == '~')
c010aa6a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa6d:	8b 00                	mov    (%eax),%eax
c010aa6f:	89 c2                	mov    %eax,%edx
c010aa71:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa74:	01 d0                	add    %edx,%eax
c010aa76:	0f b6 00             	movzbl (%eax),%eax
c010aa79:	3c 7e                	cmp    $0x7e,%al
c010aa7b:	0f 85 d5 00 00 00    	jne    c010ab56 <parser_pnode+0x274>
        {
            for(; pipelines[(*start)] != '<' && pipelines[(*start)] != '{'; (*start)++);
c010aa81:	eb 0d                	jmp    c010aa90 <parser_pnode+0x1ae>
c010aa83:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa86:	8b 00                	mov    (%eax),%eax
c010aa88:	8d 50 01             	lea    0x1(%eax),%edx
c010aa8b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa8e:	89 10                	mov    %edx,(%eax)
c010aa90:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aa93:	8b 00                	mov    (%eax),%eax
c010aa95:	89 c2                	mov    %eax,%edx
c010aa97:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa9a:	01 d0                	add    %edx,%eax
c010aa9c:	0f b6 00             	movzbl (%eax),%eax
c010aa9f:	3c 3c                	cmp    $0x3c,%al
c010aaa1:	74 13                	je     c010aab6 <parser_pnode+0x1d4>
c010aaa3:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aaa6:	8b 00                	mov    (%eax),%eax
c010aaa8:	89 c2                	mov    %eax,%edx
c010aaaa:	8b 45 08             	mov    0x8(%ebp),%eax
c010aaad:	01 d0                	add    %edx,%eax
c010aaaf:	0f b6 00             	movzbl (%eax),%eax
c010aab2:	3c 7b                	cmp    $0x7b,%al
c010aab4:	75 cd                	jne    c010aa83 <parser_pnode+0x1a1>

            if(pipelines[(*start)] == '<')
c010aab6:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aab9:	8b 00                	mov    (%eax),%eax
c010aabb:	89 c2                	mov    %eax,%edx
c010aabd:	8b 45 08             	mov    0x8(%ebp),%eax
c010aac0:	01 d0                	add    %edx,%eax
c010aac2:	0f b6 00             	movzbl (%eax),%eax
c010aac5:	3c 3c                	cmp    $0x3c,%al
c010aac7:	75 27                	jne    c010aaf0 <parser_pnode+0x20e>
            {
                struct pnode *subnode = parser_pnode(pipelines, start, other);
c010aac9:	8b 45 10             	mov    0x10(%ebp),%eax
c010aacc:	89 44 24 08          	mov    %eax,0x8(%esp)
c010aad0:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aad3:	89 44 24 04          	mov    %eax,0x4(%esp)
c010aad7:	8b 45 08             	mov    0x8(%ebp),%eax
c010aada:	89 04 24             	mov    %eax,(%esp)
c010aadd:	e8 00 fe ff ff       	call   c010a8e2 <parser_pnode>
c010aae2:	89 45 e0             	mov    %eax,-0x20(%ebp)
                node->fallback = subnode;
c010aae5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aae8:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010aaeb:	89 50 08             	mov    %edx,0x8(%eax)
c010aaee:	eb 66                	jmp    c010ab56 <parser_pnode+0x274>
            }
            else
            {
                struct pnode *currentnode = node;
c010aaf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aaf3:	89 45 f4             	mov    %eax,-0xc(%ebp)

                for(; pipelines[(*start)] != '}'; (*start)++)
c010aaf6:	eb 4b                	jmp    c010ab43 <parser_pnode+0x261>
                {
                    if(pipelines[(*start)] == '<')
c010aaf8:	8b 45 0c             	mov    0xc(%ebp),%eax
c010aafb:	8b 00                	mov    (%eax),%eax
c010aafd:	89 c2                	mov    %eax,%edx
c010aaff:	8b 45 08             	mov    0x8(%ebp),%eax
c010ab02:	01 d0                	add    %edx,%eax
c010ab04:	0f b6 00             	movzbl (%eax),%eax
c010ab07:	3c 3c                	cmp    $0x3c,%al
c010ab09:	75 2b                	jne    c010ab36 <parser_pnode+0x254>
                    {
                        struct pnode *subnode = parser_pnode(pipelines, start, other);
c010ab0b:	8b 45 10             	mov    0x10(%ebp),%eax
c010ab0e:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ab12:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab15:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ab19:	8b 45 08             	mov    0x8(%ebp),%eax
c010ab1c:	89 04 24             	mov    %eax,(%esp)
c010ab1f:	e8 be fd ff ff       	call   c010a8e2 <parser_pnode>
c010ab24:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        currentnode->fallback = subnode;
c010ab27:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ab2a:	8b 55 dc             	mov    -0x24(%ebp),%edx
c010ab2d:	89 50 08             	mov    %edx,0x8(%eax)
                        currentnode = subnode;
c010ab30:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010ab33:	89 45 f4             	mov    %eax,-0xc(%ebp)
            }
            else
            {
                struct pnode *currentnode = node;

                for(; pipelines[(*start)] != '}'; (*start)++)
c010ab36:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab39:	8b 00                	mov    (%eax),%eax
c010ab3b:	8d 50 01             	lea    0x1(%eax),%edx
c010ab3e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab41:	89 10                	mov    %edx,(%eax)
c010ab43:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab46:	8b 00                	mov    (%eax),%eax
c010ab48:	89 c2                	mov    %eax,%edx
c010ab4a:	8b 45 08             	mov    0x8(%ebp),%eax
c010ab4d:	01 d0                	add    %edx,%eax
c010ab4f:	0f b6 00             	movzbl (%eax),%eax
c010ab52:	3c 7d                	cmp    $0x7d,%al
c010ab54:	75 a2                	jne    c010aaf8 <parser_pnode+0x216>
    node->file = get_pnode_filename(pipelines, (*start), pnode_end);
    node->subtree = list_create();

    (*start) = pnode_end;

    for(; pipelines[(*start)] != ';'; (*start)++)
c010ab56:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab59:	8b 00                	mov    (%eax),%eax
c010ab5b:	8d 50 01             	lea    0x1(%eax),%edx
c010ab5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab61:	89 10                	mov    %edx,(%eax)
c010ab63:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab66:	8b 00                	mov    (%eax),%eax
c010ab68:	89 c2                	mov    %eax,%edx
c010ab6a:	8b 45 08             	mov    0x8(%ebp),%eax
c010ab6d:	01 d0                	add    %edx,%eax
c010ab6f:	0f b6 00             	movzbl (%eax),%eax
c010ab72:	3c 3b                	cmp    $0x3b,%al
c010ab74:	0f 85 eb fd ff ff    	jne    c010a965 <parser_pnode+0x83>
                }
            }
        }
    }

    return node;
c010ab7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010ab7d:	c9                   	leave  
c010ab7e:	c3                   	ret    

c010ab7f <find_pnode_end>:
 * @param pipelines the string in which the pnode is located
 * @param start the current position
 * @return the end of the pnode
 */
int find_pnode_end(char *pipelines, int *start)
{
c010ab7f:	55                   	push   %ebp
c010ab80:	89 e5                	mov    %esp,%ebp
c010ab82:	83 ec 10             	sub    $0x10,%esp
    int i;

    for(i = (*start); pipelines[i] != '\0'; i++)
c010ab85:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ab88:	8b 00                	mov    (%eax),%eax
c010ab8a:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010ab8d:	eb 49                	jmp    c010abd8 <find_pnode_end+0x59>
    {
        if(pipelines[i] == '#')
c010ab8f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010ab92:	8b 45 08             	mov    0x8(%ebp),%eax
c010ab95:	01 d0                	add    %edx,%eax
c010ab97:	0f b6 00             	movzbl (%eax),%eax
c010ab9a:	3c 23                	cmp    $0x23,%al
c010ab9c:	75 15                	jne    c010abb3 <find_pnode_end+0x34>
            for(; pipelines[i] != '\n'; i++);
c010ab9e:	eb 04                	jmp    c010aba4 <find_pnode_end+0x25>
c010aba0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010aba4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010aba7:	8b 45 08             	mov    0x8(%ebp),%eax
c010abaa:	01 d0                	add    %edx,%eax
c010abac:	0f b6 00             	movzbl (%eax),%eax
c010abaf:	3c 0a                	cmp    $0xa,%al
c010abb1:	75 ed                	jne    c010aba0 <find_pnode_end+0x21>

        if(pipelines[i-1] != '-' && pipelines[i] == '>')
c010abb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010abb6:	8d 50 ff             	lea    -0x1(%eax),%edx
c010abb9:	8b 45 08             	mov    0x8(%ebp),%eax
c010abbc:	01 d0                	add    %edx,%eax
c010abbe:	0f b6 00             	movzbl (%eax),%eax
c010abc1:	3c 2d                	cmp    $0x2d,%al
c010abc3:	74 0f                	je     c010abd4 <find_pnode_end+0x55>
c010abc5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010abc8:	8b 45 08             	mov    0x8(%ebp),%eax
c010abcb:	01 d0                	add    %edx,%eax
c010abcd:	0f b6 00             	movzbl (%eax),%eax
c010abd0:	3c 3e                	cmp    $0x3e,%al
c010abd2:	74 15                	je     c010abe9 <find_pnode_end+0x6a>
 */
int find_pnode_end(char *pipelines, int *start)
{
    int i;

    for(i = (*start); pipelines[i] != '\0'; i++)
c010abd4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010abd8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010abdb:	8b 45 08             	mov    0x8(%ebp),%eax
c010abde:	01 d0                	add    %edx,%eax
c010abe0:	0f b6 00             	movzbl (%eax),%eax
c010abe3:	84 c0                	test   %al,%al
c010abe5:	75 a8                	jne    c010ab8f <find_pnode_end+0x10>
c010abe7:	eb 01                	jmp    c010abea <find_pnode_end+0x6b>
    {
        if(pipelines[i] == '#')
            for(; pipelines[i] != '\n'; i++);

        if(pipelines[i-1] != '-' && pipelines[i] == '>')
            break;
c010abe9:	90                   	nop
    }

    return i;
c010abea:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010abed:	c9                   	leave  
c010abee:	c3                   	ret    

c010abef <is_service>:
 * @param start the start of the pnode
 * @param end the end of the pnode
 * @return true or false
 */
bool is_service(char *pipelines, int start, int end)
{
c010abef:	55                   	push   %ebp
c010abf0:	89 e5                	mov    %esp,%ebp
c010abf2:	83 ec 28             	sub    $0x28,%esp
    int i;

    for(i = start; i < (end - STRING_SERVICE_LEN); i++)
c010abf5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010abf8:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010abfb:	eb 2f                	jmp    c010ac2c <is_service+0x3d>
        if(strncmp(&pipelines[i], "service", STRING_SERVICE_LEN) == 0)
c010abfd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010ac00:	8b 45 08             	mov    0x8(%ebp),%eax
c010ac03:	01 d0                	add    %edx,%eax
c010ac05:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
c010ac0c:	00 
c010ac0d:	c7 44 24 04 f8 0d 11 	movl   $0xc0110df8,0x4(%esp)
c010ac14:	c0 
c010ac15:	89 04 24             	mov    %eax,(%esp)
c010ac18:	e8 5a 84 ff ff       	call   c0103077 <strncmp>
c010ac1d:	85 c0                	test   %eax,%eax
c010ac1f:	75 07                	jne    c010ac28 <is_service+0x39>
            return true;
c010ac21:	b8 01 00 00 00       	mov    $0x1,%eax
c010ac26:	eb 14                	jmp    c010ac3c <is_service+0x4d>
 */
bool is_service(char *pipelines, int start, int end)
{
    int i;

    for(i = start; i < (end - STRING_SERVICE_LEN); i++)
c010ac28:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010ac2c:	8b 45 10             	mov    0x10(%ebp),%eax
c010ac2f:	83 e8 06             	sub    $0x6,%eax
c010ac32:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010ac35:	7f c6                	jg     c010abfd <is_service+0xe>
        if(strncmp(&pipelines[i], "service", STRING_SERVICE_LEN) == 0)
            return true;

    return false;
c010ac37:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010ac3c:	c9                   	leave  
c010ac3d:	c3                   	ret    

c010ac3e <is_kernelroot>:
 * @param start the start of the pnode
 * @param end the end of the pnode
 * @return true or false
 */
bool is_kernelroot(char *pipelines, int start, int end)
{
c010ac3e:	55                   	push   %ebp
c010ac3f:	89 e5                	mov    %esp,%ebp
c010ac41:	83 ec 10             	sub    $0x10,%esp
    int i;

    for(i = start; i < (end - ARROW_LEN); i++)
c010ac44:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ac47:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010ac4a:	eb 22                	jmp    c010ac6e <is_kernelroot+0x30>
        if(strncmp(&pipelines[i], "->", ARROW_LEN) == 0)
c010ac4c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010ac4f:	8b 45 08             	mov    0x8(%ebp),%eax
c010ac52:	01 d0                	add    %edx,%eax
c010ac54:	0f b6 10             	movzbl (%eax),%edx
c010ac57:	b8 00 0e 11 c0       	mov    $0xc0110e00,%eax
c010ac5c:	0f b6 00             	movzbl (%eax),%eax
c010ac5f:	38 c2                	cmp    %al,%dl
c010ac61:	75 07                	jne    c010ac6a <is_kernelroot+0x2c>
            return true;
c010ac63:	b8 01 00 00 00       	mov    $0x1,%eax
c010ac68:	eb 14                	jmp    c010ac7e <is_kernelroot+0x40>
 */
bool is_kernelroot(char *pipelines, int start, int end)
{
    int i;

    for(i = start; i < (end - ARROW_LEN); i++)
c010ac6a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010ac6e:	8b 45 10             	mov    0x10(%ebp),%eax
c010ac71:	83 e8 01             	sub    $0x1,%eax
c010ac74:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c010ac77:	7f d3                	jg     c010ac4c <is_kernelroot+0xe>
        if(strncmp(&pipelines[i], "->", ARROW_LEN) == 0)
            return true;

    return false;
c010ac79:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010ac7e:	c9                   	leave  
c010ac7f:	c3                   	ret    

c010ac80 <get_ptype>:
 * @param start the start of the pnode
 * @param end the end of the pnode
 * @return the type of a pnode
 */
ptype get_ptype(char *pipelines, int start, int end)
{
c010ac80:	55                   	push   %ebp
c010ac81:	89 e5                	mov    %esp,%ebp
c010ac83:	83 ec 28             	sub    $0x28,%esp
    ptype result = NOTHING;
c010ac86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if(is_service(pipelines, start, end))
c010ac8d:	8b 45 10             	mov    0x10(%ebp),%eax
c010ac90:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ac94:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ac97:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ac9b:	8b 45 08             	mov    0x8(%ebp),%eax
c010ac9e:	89 04 24             	mov    %eax,(%esp)
c010aca1:	e8 49 ff ff ff       	call   c010abef <is_service>
c010aca6:	85 c0                	test   %eax,%eax
c010aca8:	74 04                	je     c010acae <get_ptype+0x2e>
        result |= SERVICE;
c010acaa:	83 4d f4 02          	orl    $0x2,-0xc(%ebp)

    if(is_kernelroot(pipelines, start, end))
c010acae:	8b 45 10             	mov    0x10(%ebp),%eax
c010acb1:	89 44 24 08          	mov    %eax,0x8(%esp)
c010acb5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010acb8:	89 44 24 04          	mov    %eax,0x4(%esp)
c010acbc:	8b 45 08             	mov    0x8(%ebp),%eax
c010acbf:	89 04 24             	mov    %eax,(%esp)
c010acc2:	e8 77 ff ff ff       	call   c010ac3e <is_kernelroot>
c010acc7:	85 c0                	test   %eax,%eax
c010acc9:	74 04                	je     c010accf <get_ptype+0x4f>
        result |= KERNELROOT;
c010accb:	83 4d f4 04          	orl    $0x4,-0xc(%ebp)

    return result;
c010accf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010acd2:	c9                   	leave  
c010acd3:	c3                   	ret    

c010acd4 <get_pnode_filename>:
 * @param start the start of the pnode
 * @param end the end of the pnode
 * @return the name of a pnode
 */
char *get_pnode_filename(char *pipelines, int start, int end)
{
c010acd4:	55                   	push   %ebp
c010acd5:	89 e5                	mov    %esp,%ebp
c010acd7:	83 ec 28             	sub    $0x28,%esp
    int i;

    for(i = start; pipelines[i] != '>'; i++)
c010acda:	8b 45 0c             	mov    0xc(%ebp),%eax
c010acdd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010ace0:	e9 ba 00 00 00       	jmp    c010ad9f <get_pnode_filename+0xcb>
    {
        if(!strncmp(&pipelines[i], "->", ARROW_LEN))
c010ace5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010ace8:	8b 45 08             	mov    0x8(%ebp),%eax
c010aceb:	01 d0                	add    %edx,%eax
c010aced:	0f b6 10             	movzbl (%eax),%edx
c010acf0:	b8 00 0e 11 c0       	mov    $0xc0110e00,%eax
c010acf5:	0f b6 00             	movzbl (%eax),%eax
c010acf8:	38 c2                	cmp    %al,%dl
c010acfa:	75 09                	jne    c010ad05 <get_pnode_filename+0x31>
            i += ARROW_LEN;
c010acfc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010ad00:	e9 96 00 00 00       	jmp    c010ad9b <get_pnode_filename+0xc7>
        else if(!strncmp(&pipelines[i], "service", STRING_SERVICE_LEN))
c010ad05:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010ad08:	8b 45 08             	mov    0x8(%ebp),%eax
c010ad0b:	01 d0                	add    %edx,%eax
c010ad0d:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
c010ad14:	00 
c010ad15:	c7 44 24 04 f8 0d 11 	movl   $0xc0110df8,0x4(%esp)
c010ad1c:	c0 
c010ad1d:	89 04 24             	mov    %eax,(%esp)
c010ad20:	e8 52 83 ff ff       	call   c0103077 <strncmp>
c010ad25:	85 c0                	test   %eax,%eax
c010ad27:	75 06                	jne    c010ad2f <get_pnode_filename+0x5b>
            i += STRING_SERVICE_LEN;
c010ad29:	83 45 f4 06          	addl   $0x6,-0xc(%ebp)
c010ad2d:	eb 6c                	jmp    c010ad9b <get_pnode_filename+0xc7>
        else if(!is_whitespace(pipelines[i]) && pipelines[i] != '<')
c010ad2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010ad32:	8b 45 08             	mov    0x8(%ebp),%eax
c010ad35:	01 d0                	add    %edx,%eax
c010ad37:	0f b6 00             	movzbl (%eax),%eax
c010ad3a:	0f be c0             	movsbl %al,%eax
c010ad3d:	89 04 24             	mov    %eax,(%esp)
c010ad40:	e8 5c f9 ff ff       	call   c010a6a1 <is_whitespace>
c010ad45:	85 c0                	test   %eax,%eax
c010ad47:	75 52                	jne    c010ad9b <get_pnode_filename+0xc7>
c010ad49:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010ad4c:	8b 45 08             	mov    0x8(%ebp),%eax
c010ad4f:	01 d0                	add    %edx,%eax
c010ad51:	0f b6 00             	movzbl (%eax),%eax
c010ad54:	3c 3c                	cmp    $0x3c,%al
c010ad56:	74 43                	je     c010ad9b <get_pnode_filename+0xc7>
        {
            int len = end - i;
c010ad58:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ad5b:	8b 55 10             	mov    0x10(%ebp),%edx
c010ad5e:	89 d1                	mov    %edx,%ecx
c010ad60:	29 c1                	sub    %eax,%ecx
c010ad62:	89 c8                	mov    %ecx,%eax
c010ad64:	89 45 f0             	mov    %eax,-0x10(%ebp)
            char *name = (char *)malloc(sizeof(char) * (len + 1));
c010ad67:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ad6a:	83 c0 01             	add    $0x1,%eax
c010ad6d:	89 04 24             	mov    %eax,(%esp)
c010ad70:	e8 d0 11 00 00       	call   c010bf45 <malloc>
c010ad75:	89 45 ec             	mov    %eax,-0x14(%ebp)
            strncpy(name, &pipelines[i], len);
c010ad78:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ad7b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010ad7e:	8b 55 08             	mov    0x8(%ebp),%edx
c010ad81:	01 ca                	add    %ecx,%edx
c010ad83:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ad87:	89 54 24 04          	mov    %edx,0x4(%esp)
c010ad8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ad8e:	89 04 24             	mov    %eax,(%esp)
c010ad91:	e8 af 81 ff ff       	call   c0102f45 <strncpy>
            return name;
c010ad96:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ad99:	eb 1c                	jmp    c010adb7 <get_pnode_filename+0xe3>
 */
char *get_pnode_filename(char *pipelines, int start, int end)
{
    int i;

    for(i = start; pipelines[i] != '>'; i++)
c010ad9b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010ad9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010ada2:	8b 45 08             	mov    0x8(%ebp),%eax
c010ada5:	01 d0                	add    %edx,%eax
c010ada7:	0f b6 00             	movzbl (%eax),%eax
c010adaa:	3c 3e                	cmp    $0x3e,%al
c010adac:	0f 85 33 ff ff ff    	jne    c010ace5 <get_pnode_filename+0x11>
            strncpy(name, &pipelines[i], len);
            return name;
        }
    }

    return NULL;
c010adb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010adb7:	c9                   	leave  
c010adb8:	c3                   	ret    

c010adb9 <find_module>:
* @param mb_info multiboot struct
* @param name module name
* @return moduel information
*/
struct mods_add* find_module(struct multiboot_struct *mb_info, char *name)
{
c010adb9:	55                   	push   %ebp
c010adba:	89 e5                	mov    %esp,%ebp
c010adbc:	83 ec 28             	sub    $0x28,%esp
    int i;
    while(*name == ' ' || *name == '\t')
c010adbf:	eb 04                	jmp    c010adc5 <find_module+0xc>
        name++;
c010adc1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
* @return moduel information
*/
struct mods_add* find_module(struct multiboot_struct *mb_info, char *name)
{
    int i;
    while(*name == ' ' || *name == '\t')
c010adc5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010adc8:	0f b6 00             	movzbl (%eax),%eax
c010adcb:	3c 20                	cmp    $0x20,%al
c010adcd:	74 f2                	je     c010adc1 <find_module+0x8>
c010adcf:	8b 45 0c             	mov    0xc(%ebp),%eax
c010add2:	0f b6 00             	movzbl (%eax),%eax
c010add5:	3c 09                	cmp    $0x9,%al
c010add7:	74 e8                	je     c010adc1 <find_module+0x8>
        name++;
    int n = 0;
c010add9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(name[n] != ' ' && name[n] != '\0')
c010ade0:	eb 04                	jmp    c010ade6 <find_module+0x2d>

        n++;
c010ade2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
{
    int i;
    while(*name == ' ' || *name == '\t')
        name++;
    int n = 0;
    while(name[n] != ' ' && name[n] != '\0')
c010ade6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010ade9:	8b 45 0c             	mov    0xc(%ebp),%eax
c010adec:	01 d0                	add    %edx,%eax
c010adee:	0f b6 00             	movzbl (%eax),%eax
c010adf1:	3c 20                	cmp    $0x20,%al
c010adf3:	74 0f                	je     c010ae04 <find_module+0x4b>
c010adf5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010adf8:	8b 45 0c             	mov    0xc(%ebp),%eax
c010adfb:	01 d0                	add    %edx,%eax
c010adfd:	0f b6 00             	movzbl (%eax),%eax
c010ae00:	84 c0                	test   %al,%al
c010ae02:	75 de                	jne    c010ade2 <find_module+0x29>

        n++;

    struct mods_add* modules = (struct mods_add*) mb_info->mods_addr;
c010ae04:	8b 45 08             	mov    0x8(%ebp),%eax
c010ae07:	8b 40 18             	mov    0x18(%eax),%eax
c010ae0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(i = 0; i < mb_info->mods_count; i++)
c010ae0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010ae14:	eb 3d                	jmp    c010ae53 <find_module+0x9a>
    {
        if(! strncmp(name, modules[i].string, n))
c010ae16:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010ae19:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ae1c:	89 c1                	mov    %eax,%ecx
c010ae1e:	c1 e1 04             	shl    $0x4,%ecx
c010ae21:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ae24:	01 c8                	add    %ecx,%eax
c010ae26:	8b 40 08             	mov    0x8(%eax),%eax
c010ae29:	89 54 24 08          	mov    %edx,0x8(%esp)
c010ae2d:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ae31:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ae34:	89 04 24             	mov    %eax,(%esp)
c010ae37:	e8 3b 82 ff ff       	call   c0103077 <strncmp>
c010ae3c:	85 c0                	test   %eax,%eax
c010ae3e:	75 0f                	jne    c010ae4f <find_module+0x96>
        {
            return &modules[i];
c010ae40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ae43:	89 c2                	mov    %eax,%edx
c010ae45:	c1 e2 04             	shl    $0x4,%edx
c010ae48:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ae4b:	01 d0                	add    %edx,%eax
c010ae4d:	eb 16                	jmp    c010ae65 <find_module+0xac>
    while(name[n] != ' ' && name[n] != '\0')

        n++;

    struct mods_add* modules = (struct mods_add*) mb_info->mods_addr;
    for(i = 0; i < mb_info->mods_count; i++)
c010ae4f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010ae53:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010ae56:	8b 45 08             	mov    0x8(%ebp),%eax
c010ae59:	8b 40 14             	mov    0x14(%eax),%eax
c010ae5c:	39 c2                	cmp    %eax,%edx
c010ae5e:	72 b6                	jb     c010ae16 <find_module+0x5d>
        {
            return &modules[i];
        }

    }
    return NULL;
c010ae60:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010ae65:	c9                   	leave  
c010ae66:	c3                   	ret    

c010ae67 <INIT_TRIGGER>:
 *  @brief Initiates the lists of the trigger module
 *  @param void
 *  @return void
 **/
void INIT_TRIGGER(void)
{
c010ae67:	55                   	push   %ebp
c010ae68:	89 e5                	mov    %esp,%ebp
c010ae6a:	83 ec 08             	sub    $0x8,%esp
    trigger_list = list_create();
c010ae6d:	e8 09 7b ff ff       	call   c010297b <list_create>
c010ae72:	a3 28 90 11 c0       	mov    %eax,0xc0119028
    event_id_list = list_create();
c010ae77:	e8 ff 7a ff ff       	call   c010297b <list_create>
c010ae7c:	a3 2c 90 11 c0       	mov    %eax,0xc011902c
}
c010ae81:	c9                   	leave  
c010ae82:	c3                   	ret    

c010ae83 <remove_event_trigger>:
 * @param 0 pointer to thread/process state
 * @param 1 optional event ID (0 = don't care)
 * @return number or removed triggers
 **/
int remove_event_trigger(void *object, uint32_t ID)
{
c010ae83:	55                   	push   %ebp
c010ae84:	89 e5                	mov    %esp,%ebp
c010ae86:	83 ec 38             	sub    $0x38,%esp
    int removed_elements = 0;
c010ae89:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    iterator_t it = iterator_create(trigger_list);
c010ae90:	8b 15 28 90 11 c0    	mov    0xc0119028,%edx
c010ae96:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010ae99:	89 54 24 04          	mov    %edx,0x4(%esp)
c010ae9d:	89 04 24             	mov    %eax,(%esp)
c010aea0:	e8 46 7e ff ff       	call   c0102ceb <iterator_create>
c010aea5:	83 ec 04             	sub    $0x4,%esp
    list_set_first(&it);
c010aea8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010aeab:	89 04 24             	mov    %eax,(%esp)
c010aeae:	e8 68 7f ff ff       	call   c0102e1b <list_set_first>
    if(ID == 0)
c010aeb3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010aeb7:	0f 85 00 01 00 00    	jne    c010afbd <remove_event_trigger+0x13a>
    {
        while(!list_is_last(&it) && !list_is_empty(trigger_list))
c010aebd:	eb 61                	jmp    c010af20 <remove_event_trigger+0x9d>
        {
            struct trigger_entry *current_entry = list_get_current(&it);
c010aebf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010aec2:	89 04 24             	mov    %eax,(%esp)
c010aec5:	e8 ea 7e ff ff       	call   c0102db4 <list_get_current>
c010aeca:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if(current_entry->object == object)
c010aecd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aed0:	8b 40 0c             	mov    0xc(%eax),%eax
c010aed3:	3b 45 08             	cmp    0x8(%ebp),%eax
c010aed6:	75 3d                	jne    c010af15 <remove_event_trigger+0x92>
            {
                list_remove(&it);
c010aed8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010aedb:	89 04 24             	mov    %eax,(%esp)
c010aede:	e8 63 7f ff ff       	call   c0102e46 <list_remove>
                if(current_entry->type == WAIT_EVENT)
c010aee3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aee6:	8b 00                	mov    (%eax),%eax
c010aee8:	83 f8 02             	cmp    $0x2,%eax
c010aeeb:	75 19                	jne    c010af06 <remove_event_trigger+0x83>
                    list_push_front(event_id_list,(void*)current_entry->ID);
c010aeed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aef0:	8b 40 04             	mov    0x4(%eax),%eax
c010aef3:	89 c2                	mov    %eax,%edx
c010aef5:	a1 2c 90 11 c0       	mov    0xc011902c,%eax
c010aefa:	89 54 24 04          	mov    %edx,0x4(%esp)
c010aefe:	89 04 24             	mov    %eax,(%esp)
c010af01:	e8 ac 7b ff ff       	call   c0102ab2 <list_push_front>
                free(current_entry);
c010af06:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010af09:	89 04 24             	mov    %eax,(%esp)
c010af0c:	e8 42 11 00 00       	call   c010c053 <free>
                removed_elements++;
c010af11:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            }
            list_next(&it);
c010af15:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010af18:	89 04 24             	mov    %eax,(%esp)
c010af1b:	e8 b9 7e ff ff       	call   c0102dd9 <list_next>
    int removed_elements = 0;
    iterator_t it = iterator_create(trigger_list);
    list_set_first(&it);
    if(ID == 0)
    {
        while(!list_is_last(&it) && !list_is_empty(trigger_list))
c010af20:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010af23:	89 04 24             	mov    %eax,(%esp)
c010af26:	e8 d5 7e ff ff       	call   c0102e00 <list_is_last>
c010af2b:	85 c0                	test   %eax,%eax
c010af2d:	0f 85 af 00 00 00    	jne    c010afe2 <remove_event_trigger+0x15f>
c010af33:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010af38:	89 04 24             	mov    %eax,(%esp)
c010af3b:	e8 6a 7d ff ff       	call   c0102caa <list_is_empty>
c010af40:	85 c0                	test   %eax,%eax
c010af42:	0f 84 77 ff ff ff    	je     c010aebf <remove_event_trigger+0x3c>
c010af48:	e9 95 00 00 00       	jmp    c010afe2 <remove_event_trigger+0x15f>
    }
    else
    {
        while(!list_is_last(&it) && !list_is_empty(trigger_list))
        {
            struct trigger_entry *current_entry = list_get_current(&it);
c010af4d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010af50:	89 04 24             	mov    %eax,(%esp)
c010af53:	e8 5c 7e ff ff       	call   c0102db4 <list_get_current>
c010af58:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if(current_entry->object == object && current_entry->ID == ID)
c010af5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010af5e:	8b 40 0c             	mov    0xc(%eax),%eax
c010af61:	3b 45 08             	cmp    0x8(%ebp),%eax
c010af64:	75 4a                	jne    c010afb0 <remove_event_trigger+0x12d>
c010af66:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010af69:	8b 40 04             	mov    0x4(%eax),%eax
c010af6c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010af6f:	75 3f                	jne    c010afb0 <remove_event_trigger+0x12d>
            {
                list_remove(&it);
c010af71:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010af74:	89 04 24             	mov    %eax,(%esp)
c010af77:	e8 ca 7e ff ff       	call   c0102e46 <list_remove>
                if(current_entry->type == WAIT_EVENT)
c010af7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010af7f:	8b 00                	mov    (%eax),%eax
c010af81:	83 f8 02             	cmp    $0x2,%eax
c010af84:	75 19                	jne    c010af9f <remove_event_trigger+0x11c>
                    list_push_front(event_id_list,(void*)current_entry->ID);
c010af86:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010af89:	8b 40 04             	mov    0x4(%eax),%eax
c010af8c:	89 c2                	mov    %eax,%edx
c010af8e:	a1 2c 90 11 c0       	mov    0xc011902c,%eax
c010af93:	89 54 24 04          	mov    %edx,0x4(%esp)
c010af97:	89 04 24             	mov    %eax,(%esp)
c010af9a:	e8 13 7b ff ff       	call   c0102ab2 <list_push_front>
                free(current_entry);
c010af9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010afa2:	89 04 24             	mov    %eax,(%esp)
c010afa5:	e8 a9 10 00 00       	call   c010c053 <free>
                removed_elements++;
c010afaa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                break;
c010afae:	eb 32                	jmp    c010afe2 <remove_event_trigger+0x15f>
            }
            list_next(&it);
c010afb0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010afb3:	89 04 24             	mov    %eax,(%esp)
c010afb6:	e8 1e 7e ff ff       	call   c0102dd9 <list_next>
c010afbb:	eb 01                	jmp    c010afbe <remove_event_trigger+0x13b>
            list_next(&it);
        }
    }
    else
    {
        while(!list_is_last(&it) && !list_is_empty(trigger_list))
c010afbd:	90                   	nop
c010afbe:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010afc1:	89 04 24             	mov    %eax,(%esp)
c010afc4:	e8 37 7e ff ff       	call   c0102e00 <list_is_last>
c010afc9:	85 c0                	test   %eax,%eax
c010afcb:	75 15                	jne    c010afe2 <remove_event_trigger+0x15f>
c010afcd:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010afd2:	89 04 24             	mov    %eax,(%esp)
c010afd5:	e8 d0 7c ff ff       	call   c0102caa <list_is_empty>
c010afda:	85 c0                	test   %eax,%eax
c010afdc:	0f 84 6b ff ff ff    	je     c010af4d <remove_event_trigger+0xca>
                break;
            }
            list_next(&it);
        }
    }
    return removed_elements;
c010afe2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010afe5:	c9                   	leave  
c010afe6:	c3                   	ret    

c010afe7 <remove_event>:
 * Removes every trigger with the given ID
 * @param 0 event ID
 * @return number of removed triggers, 0 if there was no trigger with the given ID
 **/
int remove_event(uint32_t ID)
{
c010afe7:	55                   	push   %ebp
c010afe8:	89 e5                	mov    %esp,%ebp
c010afea:	83 ec 28             	sub    $0x28,%esp
    int removed_elements = 0;
c010afed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    iterator_t it = iterator_create(trigger_list);
c010aff4:	8b 15 28 90 11 c0    	mov    0xc0119028,%edx
c010affa:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010affd:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b001:	89 04 24             	mov    %eax,(%esp)
c010b004:	e8 e2 7c ff ff       	call   c0102ceb <iterator_create>
c010b009:	83 ec 04             	sub    $0x4,%esp
    list_set_first(&it);
c010b00c:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b00f:	89 04 24             	mov    %eax,(%esp)
c010b012:	e8 04 7e ff ff       	call   c0102e1b <list_set_first>
    while(!list_is_last(&it) && !list_is_empty(trigger_list))
c010b017:	eb 63                	jmp    c010b07c <remove_event+0x95>
    {
        struct trigger_entry *current_entry = list_get_current(&it);
c010b019:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b01c:	89 04 24             	mov    %eax,(%esp)
c010b01f:	e8 90 7d ff ff       	call   c0102db4 <list_get_current>
c010b024:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(current_entry->ID == ID)
c010b027:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b02a:	8b 40 04             	mov    0x4(%eax),%eax
c010b02d:	3b 45 08             	cmp    0x8(%ebp),%eax
c010b030:	75 3f                	jne    c010b071 <remove_event+0x8a>
        {
            list_remove(&it);
c010b032:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b035:	89 04 24             	mov    %eax,(%esp)
c010b038:	e8 09 7e ff ff       	call   c0102e46 <list_remove>
            if(current_entry->type == WAIT_EVENT)
c010b03d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b040:	8b 00                	mov    (%eax),%eax
c010b042:	83 f8 02             	cmp    $0x2,%eax
c010b045:	75 19                	jne    c010b060 <remove_event+0x79>
                list_push_front(event_id_list,(void*)current_entry->ID);
c010b047:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b04a:	8b 40 04             	mov    0x4(%eax),%eax
c010b04d:	89 c2                	mov    %eax,%edx
c010b04f:	a1 2c 90 11 c0       	mov    0xc011902c,%eax
c010b054:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b058:	89 04 24             	mov    %eax,(%esp)
c010b05b:	e8 52 7a ff ff       	call   c0102ab2 <list_push_front>
            free(current_entry);
c010b060:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b063:	89 04 24             	mov    %eax,(%esp)
c010b066:	e8 e8 0f 00 00       	call   c010c053 <free>
            removed_elements++;
c010b06b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            break;
c010b06f:	eb 2f                	jmp    c010b0a0 <remove_event+0xb9>
        }

        list_next(&it);
c010b071:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b074:	89 04 24             	mov    %eax,(%esp)
c010b077:	e8 5d 7d ff ff       	call   c0102dd9 <list_next>
int remove_event(uint32_t ID)
{
    int removed_elements = 0;
    iterator_t it = iterator_create(trigger_list);
    list_set_first(&it);
    while(!list_is_last(&it) && !list_is_empty(trigger_list))
c010b07c:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b07f:	89 04 24             	mov    %eax,(%esp)
c010b082:	e8 79 7d ff ff       	call   c0102e00 <list_is_last>
c010b087:	85 c0                	test   %eax,%eax
c010b089:	75 15                	jne    c010b0a0 <remove_event+0xb9>
c010b08b:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010b090:	89 04 24             	mov    %eax,(%esp)
c010b093:	e8 12 7c ff ff       	call   c0102caa <list_is_empty>
c010b098:	85 c0                	test   %eax,%eax
c010b09a:	0f 84 79 ff ff ff    	je     c010b019 <remove_event+0x32>
            break;
        }

        list_next(&it);
    }
    return removed_elements;
c010b0a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010b0a3:	c9                   	leave  
c010b0a4:	c3                   	ret    

c010b0a5 <send_event>:
 * Send a event which can lauch a event trigger
 * @param  0 event ID
 * @return true if the trigger was pulled, false if there's no trigger with the given ID
 */
int send_event(uint32_t ID)
{
c010b0a5:	55                   	push   %ebp
c010b0a6:	89 e5                	mov    %esp,%ebp
c010b0a8:	83 ec 38             	sub    $0x38,%esp
    int ret = false;
c010b0ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    iterator_t it = iterator_create(trigger_list);
c010b0b2:	8b 15 28 90 11 c0    	mov    0xc0119028,%edx
c010b0b8:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010b0bb:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b0bf:	89 04 24             	mov    %eax,(%esp)
c010b0c2:	e8 24 7c ff ff       	call   c0102ceb <iterator_create>
c010b0c7:	83 ec 04             	sub    $0x4,%esp
    while(!list_is_last(&it) && !list_is_empty(trigger_list))
c010b0ca:	e9 51 01 00 00       	jmp    c010b220 <send_event+0x17b>
    {
        struct trigger_entry *current_entry = list_get_current(&it);
c010b0cf:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010b0d2:	89 04 24             	mov    %eax,(%esp)
c010b0d5:	e8 da 7c ff ff       	call   c0102db4 <list_get_current>
c010b0da:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(current_entry->ID == ID && current_entry->type == WAIT_EVENT)
c010b0dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b0e0:	8b 40 04             	mov    0x4(%eax),%eax
c010b0e3:	3b 45 08             	cmp    0x8(%ebp),%eax
c010b0e6:	0f 85 29 01 00 00    	jne    c010b215 <send_event+0x170>
c010b0ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b0ef:	8b 00                	mov    (%eax),%eax
c010b0f1:	83 f8 02             	cmp    $0x2,%eax
c010b0f4:	0f 85 1b 01 00 00    	jne    c010b215 <send_event+0x170>
        {
            if(current_entry->proc)
c010b0fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b0fd:	8b 40 08             	mov    0x8(%eax),%eax
c010b100:	85 c0                	test   %eax,%eax
c010b102:	74 2b                	je     c010b12f <send_event+0x8a>
            {
                process_wakeup(current_entry->object);
c010b104:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b107:	8b 40 0c             	mov    0xc(%eax),%eax
c010b10a:	89 04 24             	mov    %eax,(%esp)
c010b10d:	e8 7e 97 ff ff       	call   c0104890 <process_wakeup>
                remove_event_trigger(current_entry->object, current_entry->ID);
c010b112:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b115:	8b 50 04             	mov    0x4(%eax),%edx
c010b118:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b11b:	8b 40 0c             	mov    0xc(%eax),%eax
c010b11e:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b122:	89 04 24             	mov    %eax,(%esp)
c010b125:	e8 59 fd ff ff       	call   c010ae83 <remove_event_trigger>
c010b12a:	e9 85 00 00 00       	jmp    c010b1b4 <send_event+0x10f>
            }
            else
            {
                struct thread_state *thread = current_entry->object;
c010b12f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b132:	8b 40 0c             	mov    0xc(%eax),%eax
c010b135:	89 45 ec             	mov    %eax,-0x14(%ebp)
                remove_event_trigger(current_entry->object, current_entry->ID);
c010b138:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b13b:	8b 50 04             	mov    0x4(%eax),%edx
c010b13e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b141:	8b 40 0c             	mov    0xc(%eax),%eax
c010b144:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b148:	89 04 24             	mov    %eax,(%esp)
c010b14b:	e8 33 fd ff ff       	call   c010ae83 <remove_event_trigger>
                thread_wakeup(thread);
c010b150:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b153:	89 04 24             	mov    %eax,(%esp)
c010b156:	e8 bb a5 ff ff       	call   c0105716 <thread_wakeup>

                if(current_entry->callback != NULL)
c010b15b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b15e:	8b 40 10             	mov    0x10(%eax),%eax
c010b161:	85 c0                	test   %eax,%eax
c010b163:	74 4f                	je     c010b1b4 <send_event+0x10f>
                {
                    // save current thread
                    struct thread_state *tmp = current_thread;
c010b165:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010b16a:	89 45 e8             	mov    %eax,-0x18(%ebp)

                    struct cpu_state **cpu = &thread->context.state;
c010b16d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b170:	83 c0 18             	add    $0x18,%eax
c010b173:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    current_thread = thread;
c010b176:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b179:	a3 0c 90 11 c0       	mov    %eax,0xc011900c
                    vmm_switch_context(&current_thread->context.memory);
c010b17e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010b183:	83 c0 24             	add    $0x24,%eax
c010b186:	89 04 24             	mov    %eax,(%esp)
c010b189:	e8 da 06 00 00       	call   c010b868 <vmm_switch_context>

                    current_entry->callback(cpu);
c010b18e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b191:	8b 40 10             	mov    0x10(%eax),%eax
c010b194:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010b197:	89 14 24             	mov    %edx,(%esp)
c010b19a:	ff d0                	call   *%eax

                    current_thread = tmp;
c010b19c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010b19f:	a3 0c 90 11 c0       	mov    %eax,0xc011900c
                    vmm_switch_context(&current_thread->context.memory);
c010b1a4:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010b1a9:	83 c0 24             	add    $0x24,%eax
c010b1ac:	89 04 24             	mov    %eax,(%esp)
c010b1af:	e8 b4 06 00 00       	call   c010b868 <vmm_switch_context>
                }
            }
            // that's a temporary workaround. I have to fix it later.
            // the problems are caused by blitzbasics list ports.
            ret = true;
c010b1b4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
            list_remove(&it);
c010b1bb:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010b1be:	89 04 24             	mov    %eax,(%esp)
c010b1c1:	e8 80 7c ff ff       	call   c0102e46 <list_remove>
            if(current_entry->type == WAIT_EVENT)
c010b1c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b1c9:	8b 00                	mov    (%eax),%eax
c010b1cb:	83 f8 02             	cmp    $0x2,%eax
c010b1ce:	75 19                	jne    c010b1e9 <send_event+0x144>
                list_push_front(event_id_list,(void*)current_entry->ID);
c010b1d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b1d3:	8b 40 04             	mov    0x4(%eax),%eax
c010b1d6:	89 c2                	mov    %eax,%edx
c010b1d8:	a1 2c 90 11 c0       	mov    0xc011902c,%eax
c010b1dd:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b1e1:	89 04 24             	mov    %eax,(%esp)
c010b1e4:	e8 c9 78 ff ff       	call   c0102ab2 <list_push_front>
            free(current_entry);
c010b1e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b1ec:	89 04 24             	mov    %eax,(%esp)
c010b1ef:	e8 5f 0e 00 00       	call   c010c053 <free>
            if(list_is_last(&it))
c010b1f4:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010b1f7:	89 04 24             	mov    %eax,(%esp)
c010b1fa:	e8 01 7c ff ff       	call   c0102e00 <list_is_last>
c010b1ff:	85 c0                	test   %eax,%eax
c010b201:	74 05                	je     c010b208 <send_event+0x163>
                return ret;
c010b203:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b206:	eb 3f                	jmp    c010b247 <send_event+0x1a2>
            list_set_first(&it);
c010b208:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010b20b:	89 04 24             	mov    %eax,(%esp)
c010b20e:	e8 08 7c ff ff       	call   c0102e1b <list_set_first>
c010b213:	eb 0b                	jmp    c010b220 <send_event+0x17b>
        }
        else
            list_next(&it);
c010b215:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010b218:	89 04 24             	mov    %eax,(%esp)
c010b21b:	e8 b9 7b ff ff       	call   c0102dd9 <list_next>
 */
int send_event(uint32_t ID)
{
    int ret = false;
    iterator_t it = iterator_create(trigger_list);
    while(!list_is_last(&it) && !list_is_empty(trigger_list))
c010b220:	8d 45 dc             	lea    -0x24(%ebp),%eax
c010b223:	89 04 24             	mov    %eax,(%esp)
c010b226:	e8 d5 7b ff ff       	call   c0102e00 <list_is_last>
c010b22b:	85 c0                	test   %eax,%eax
c010b22d:	75 15                	jne    c010b244 <send_event+0x19f>
c010b22f:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010b234:	89 04 24             	mov    %eax,(%esp)
c010b237:	e8 6e 7a ff ff       	call   c0102caa <list_is_empty>
c010b23c:	85 c0                	test   %eax,%eax
c010b23e:	0f 84 8b fe ff ff    	je     c010b0cf <send_event+0x2a>
            list_set_first(&it);
        }
        else
            list_next(&it);
    }
    return ret;
c010b244:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010b247:	c9                   	leave  
c010b248:	c3                   	ret    

c010b249 <get_new_event_ID>:
 * returns a new, unused event ID
 * @param void
 * @return new event ID
 */
uint32_t get_new_event_ID(void)
{
c010b249:	55                   	push   %ebp
c010b24a:	89 e5                	mov    %esp,%ebp
//    if(list_is_empty(event_id_list))
    return event_id_counter++;
c010b24c:	a1 20 21 11 c0       	mov    0xc0112120,%eax
c010b251:	89 c2                	mov    %eax,%edx
c010b253:	83 c0 01             	add    $0x1,%eax
c010b256:	a3 20 21 11 c0       	mov    %eax,0xc0112120
c010b25b:	90                   	nop
c010b25c:	89 d0                	mov    %edx,%eax

    return (uint32_t) list_pop_back(event_id_list);
}
c010b25e:	5d                   	pop    %ebp
c010b25f:	c3                   	ret    

c010b260 <add_event_trigger>:
 * @param 1 pointer to process/thread state
 * @param 2 pointer to callback function (will be called before the thread/process wakes up) or NULL if there is no need for a callback
 * @return event ID
 **/
uint32_t add_event_trigger(bool proc, void *object, void (*callback)(struct cpu_state **cpu))
{
c010b260:	55                   	push   %ebp
c010b261:	89 e5                	mov    %esp,%ebp
c010b263:	83 ec 28             	sub    $0x28,%esp
    struct trigger_entry *new_entry = (struct trigger_entry*) malloc(sizeof(struct trigger_entry));
c010b266:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c010b26d:	e8 d3 0c 00 00       	call   c010bf45 <malloc>
c010b272:	89 45 f4             	mov    %eax,-0xc(%ebp)
    new_entry->type = WAIT_EVENT;
c010b275:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b278:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    new_entry->ID = get_new_event_ID();
c010b27e:	e8 c6 ff ff ff       	call   c010b249 <get_new_event_ID>
c010b283:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010b286:	89 42 04             	mov    %eax,0x4(%edx)
    new_entry->proc = proc;
c010b289:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b28c:	8b 55 08             	mov    0x8(%ebp),%edx
c010b28f:	89 50 08             	mov    %edx,0x8(%eax)
    new_entry->object = object;
c010b292:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b295:	8b 55 0c             	mov    0xc(%ebp),%edx
c010b298:	89 50 0c             	mov    %edx,0xc(%eax)
    new_entry->callback = callback;
c010b29b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b29e:	8b 55 10             	mov    0x10(%ebp),%edx
c010b2a1:	89 50 10             	mov    %edx,0x10(%eax)

    list_push_front(trigger_list,new_entry);
c010b2a4:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010b2a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010b2ac:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b2b0:	89 04 24             	mov    %eax,(%esp)
c010b2b3:	e8 fa 77 ff ff       	call   c0102ab2 <list_push_front>
    return new_entry->ID;
c010b2b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b2bb:	8b 40 04             	mov    0x4(%eax),%eax
}
c010b2be:	c9                   	leave  
c010b2bf:	c3                   	ret    

c010b2c0 <add_trigger>:
 * @param 3 pointer to process/thread state
 * @param 4 pointer to callback function (will be called before the thread/process wakes up) or NULL if there is no need for a callback
 * @return void
 **/
void add_trigger(trigger_t type, uint32_t ID, bool proc, void *object, void (*callback)(struct cpu_state **cpu))
{
c010b2c0:	55                   	push   %ebp
c010b2c1:	89 e5                	mov    %esp,%ebp
c010b2c3:	83 ec 28             	sub    $0x28,%esp
    struct trigger_entry *new_entry = (struct trigger_entry*) malloc(sizeof(struct trigger_entry));
c010b2c6:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c010b2cd:	e8 73 0c 00 00       	call   c010bf45 <malloc>
c010b2d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    new_entry->type   = type;
c010b2d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b2d8:	8b 55 08             	mov    0x8(%ebp),%edx
c010b2db:	89 10                	mov    %edx,(%eax)
    new_entry->ID     = ID;
c010b2dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b2e0:	8b 55 0c             	mov    0xc(%ebp),%edx
c010b2e3:	89 50 04             	mov    %edx,0x4(%eax)
    new_entry->proc   = proc;
c010b2e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b2e9:	8b 55 10             	mov    0x10(%ebp),%edx
c010b2ec:	89 50 08             	mov    %edx,0x8(%eax)
    new_entry->object = object;
c010b2ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b2f2:	8b 55 14             	mov    0x14(%ebp),%edx
c010b2f5:	89 50 0c             	mov    %edx,0xc(%eax)
    new_entry->callback = callback;
c010b2f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b2fb:	8b 55 18             	mov    0x18(%ebp),%edx
c010b2fe:	89 50 10             	mov    %edx,0x10(%eax)
    list_push_front(trigger_list,new_entry);
c010b301:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010b306:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010b309:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b30d:	89 04 24             	mov    %eax,(%esp)
c010b310:	e8 9d 77 ff ff       	call   c0102ab2 <list_push_front>
}
c010b315:	c9                   	leave  
c010b316:	c3                   	ret    

c010b317 <handle_interupts>:
 * pulls a interrupt trigger
 * @param 0 cpu-state of the current process
 * @return 0 = no handle found; number of called triggers
 **/
int handle_interupts(struct cpu_state **cpu)
{
c010b317:	55                   	push   %ebp
c010b318:	89 e5                	mov    %esp,%ebp
c010b31a:	83 ec 38             	sub    $0x38,%esp
    if(trigger_list == NULL)
c010b31d:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010b322:	85 c0                	test   %eax,%eax
c010b324:	75 0a                	jne    c010b330 <handle_interupts+0x19>
        return 0;
c010b326:	b8 00 00 00 00       	mov    $0x0,%eax
c010b32b:	e9 52 01 00 00       	jmp    c010b482 <handle_interupts+0x16b>


    iterator_t it = iterator_create(trigger_list);
c010b330:	8b 15 28 90 11 c0    	mov    0xc0119028,%edx
c010b336:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010b339:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b33d:	89 04 24             	mov    %eax,(%esp)
c010b340:	e8 a6 79 ff ff       	call   c0102ceb <iterator_create>
c010b345:	83 ec 04             	sub    $0x4,%esp
    list_set_first(&it);
c010b348:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010b34b:	89 04 24             	mov    %eax,(%esp)
c010b34e:	e8 c8 7a ff ff       	call   c0102e1b <list_set_first>


    uint32_t id;
    size_t num = 0;
c010b353:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)


    if((*cpu)->intr < IRQ_OFFSET)
c010b35a:	8b 45 08             	mov    0x8(%ebp),%eax
c010b35d:	8b 00                	mov    (%eax),%eax
c010b35f:	8b 40 2c             	mov    0x2c(%eax),%eax
c010b362:	83 f8 1f             	cmp    $0x1f,%eax
c010b365:	77 10                	ja     c010b377 <handle_interupts+0x60>
        id = (*cpu)->intr;
c010b367:	8b 45 08             	mov    0x8(%ebp),%eax
c010b36a:	8b 00                	mov    (%eax),%eax
c010b36c:	8b 40 2c             	mov    0x2c(%eax),%eax
c010b36f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    else
        id = (*cpu)->intr-IRQ_OFFSET;


    while(!list_is_empty(trigger_list) && !list_is_last(&it))
c010b372:	e9 e4 00 00 00       	jmp    c010b45b <handle_interupts+0x144>


    if((*cpu)->intr < IRQ_OFFSET)
        id = (*cpu)->intr;
    else
        id = (*cpu)->intr-IRQ_OFFSET;
c010b377:	8b 45 08             	mov    0x8(%ebp),%eax
c010b37a:	8b 00                	mov    (%eax),%eax
c010b37c:	8b 40 2c             	mov    0x2c(%eax),%eax
c010b37f:	83 e8 20             	sub    $0x20,%eax
c010b382:	89 45 f4             	mov    %eax,-0xc(%ebp)


    while(!list_is_empty(trigger_list) && !list_is_last(&it))
c010b385:	e9 d1 00 00 00       	jmp    c010b45b <handle_interupts+0x144>
    {
        struct trigger_entry *trg = list_get_current(&it);
c010b38a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010b38d:	89 04 24             	mov    %eax,(%esp)
c010b390:	e8 1f 7a ff ff       	call   c0102db4 <list_get_current>
c010b395:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if((trg->type == WAIT_INT || trg->type == WAIT_EXC) && trg->ID == id)
c010b398:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b39b:	8b 00                	mov    (%eax),%eax
c010b39d:	83 f8 05             	cmp    $0x5,%eax
c010b3a0:	74 0e                	je     c010b3b0 <handle_interupts+0x99>
c010b3a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b3a5:	8b 00                	mov    (%eax),%eax
c010b3a7:	83 f8 06             	cmp    $0x6,%eax
c010b3aa:	0f 85 a0 00 00 00    	jne    c010b450 <handle_interupts+0x139>
c010b3b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b3b3:	8b 40 04             	mov    0x4(%eax),%eax
c010b3b6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010b3b9:	0f 85 91 00 00 00    	jne    c010b450 <handle_interupts+0x139>
        {

            if(trg->callback)
c010b3bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b3c2:	8b 40 10             	mov    0x10(%eax),%eax
c010b3c5:	85 c0                	test   %eax,%eax
c010b3c7:	74 0e                	je     c010b3d7 <handle_interupts+0xc0>
                trg->callback(cpu);
c010b3c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b3cc:	8b 40 10             	mov    0x10(%eax),%eax
c010b3cf:	8b 55 08             	mov    0x8(%ebp),%edx
c010b3d2:	89 14 24             	mov    %edx,(%esp)
c010b3d5:	ff d0                	call   *%eax

            if(trg->object && ! (((struct thread_state *)trg->object)->flags & THREAD_ACTIVE))
c010b3d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b3da:	8b 40 0c             	mov    0xc(%eax),%eax
c010b3dd:	85 c0                	test   %eax,%eax
c010b3df:	74 6b                	je     c010b44c <handle_interupts+0x135>
c010b3e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b3e4:	8b 40 0c             	mov    0xc(%eax),%eax
c010b3e7:	0f b7 40 10          	movzwl 0x10(%eax),%eax
c010b3eb:	0f b7 c0             	movzwl %ax,%eax
c010b3ee:	83 e0 01             	and    $0x1,%eax
c010b3f1:	85 c0                	test   %eax,%eax
c010b3f3:	75 57                	jne    c010b44c <handle_interupts+0x135>
            {
                ((struct thread_state *)trg->object)->flags |= THREAD_ACTIVE;
c010b3f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b3f8:	8b 40 0c             	mov    0xc(%eax),%eax
c010b3fb:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010b3fe:	8b 52 0c             	mov    0xc(%edx),%edx
c010b401:	0f b7 52 10          	movzwl 0x10(%edx),%edx
c010b405:	83 ca 01             	or     $0x1,%edx
c010b408:	66 89 50 10          	mov    %dx,0x10(%eax)
                list_insert_after(&it,trg->object);
c010b40c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b40f:	8b 40 0c             	mov    0xc(%eax),%eax
c010b412:	89 44 24 04          	mov    %eax,0x4(%esp)
c010b416:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010b419:	89 04 24             	mov    %eax,(%esp)
c010b41c:	e8 f6 78 ff ff       	call   c0102d17 <list_insert_after>
                ((struct thread_state *)trg->object)->ticks = 10;
c010b421:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010b424:	8b 40 0c             	mov    0xc(%eax),%eax
c010b427:	c7 40 0c 0a 00 00 00 	movl   $0xa,0xc(%eax)
                current_thread->ticks = 0;
c010b42e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010b433:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
                *cpu = task_schedule(*cpu);
c010b43a:	8b 45 08             	mov    0x8(%ebp),%eax
c010b43d:	8b 00                	mov    (%eax),%eax
c010b43f:	89 04 24             	mov    %eax,(%esp)
c010b442:	e8 1f 97 ff ff       	call   c0104b66 <task_schedule>
c010b447:	8b 55 08             	mov    0x8(%ebp),%edx
c010b44a:	89 02                	mov    %eax,(%edx)
            }
            num++;
c010b44c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

        }
        list_next(&it);
c010b450:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010b453:	89 04 24             	mov    %eax,(%esp)
c010b456:	e8 7e 79 ff ff       	call   c0102dd9 <list_next>
        id = (*cpu)->intr;
    else
        id = (*cpu)->intr-IRQ_OFFSET;


    while(!list_is_empty(trigger_list) && !list_is_last(&it))
c010b45b:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010b460:	89 04 24             	mov    %eax,(%esp)
c010b463:	e8 42 78 ff ff       	call   c0102caa <list_is_empty>
c010b468:	85 c0                	test   %eax,%eax
c010b46a:	75 13                	jne    c010b47f <handle_interupts+0x168>
c010b46c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010b46f:	89 04 24             	mov    %eax,(%esp)
c010b472:	e8 89 79 ff ff       	call   c0102e00 <list_is_last>
c010b477:	85 c0                	test   %eax,%eax
c010b479:	0f 84 0b ff ff ff    	je     c010b38a <handle_interupts+0x73>
        }
        list_next(&it);

    }

    return num;
c010b47f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010b482:	c9                   	leave  
c010b483:	c3                   	ret    

c010b484 <send_killed_process>:
 * pulls waitpid triggers when a process has been killed
 * @param pointer to process state
 * @return void
 **/
void send_killed_process(struct process_state *proc)
{
c010b484:	55                   	push   %ebp
c010b485:	89 e5                	mov    %esp,%ebp
c010b487:	83 ec 38             	sub    $0x38,%esp
    iterator_t it = iterator_create(trigger_list);
c010b48a:	8b 15 28 90 11 c0    	mov    0xc0119028,%edx
c010b490:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b493:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b497:	89 04 24             	mov    %eax,(%esp)
c010b49a:	e8 4c 78 ff ff       	call   c0102ceb <iterator_create>
c010b49f:	83 ec 04             	sub    $0x4,%esp
    list_set_first(&it);
c010b4a2:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b4a5:	89 04 24             	mov    %eax,(%esp)
c010b4a8:	e8 6e 79 ff ff       	call   c0102e1b <list_set_first>
    while(!list_is_empty(trigger_list) && !list_is_last(&it))
c010b4ad:	e9 9c 01 00 00       	jmp    c010b64e <send_killed_process+0x1ca>
    {
        struct trigger_entry *current_entry = list_get_current(&it);
c010b4b2:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b4b5:	89 04 24             	mov    %eax,(%esp)
c010b4b8:	e8 f7 78 ff ff       	call   c0102db4 <list_get_current>
c010b4bd:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(current_entry->ID == proc->pid && current_entry->type == WAIT_PID) // pid > 0
c010b4c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b4c3:	8b 50 04             	mov    0x4(%eax),%edx
c010b4c6:	8b 45 08             	mov    0x8(%ebp),%eax
c010b4c9:	8b 00                	mov    (%eax),%eax
c010b4cb:	39 c2                	cmp    %eax,%edx
c010b4cd:	75 7c                	jne    c010b54b <send_killed_process+0xc7>
c010b4cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b4d2:	8b 00                	mov    (%eax),%eax
c010b4d4:	85 c0                	test   %eax,%eax
c010b4d6:	75 73                	jne    c010b54b <send_killed_process+0xc7>
        {
            if(current_entry->proc)
c010b4d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b4db:	8b 40 08             	mov    0x8(%eax),%eax
c010b4de:	85 c0                	test   %eax,%eax
c010b4e0:	74 28                	je     c010b50a <send_killed_process+0x86>
            {
                process_wakeup(current_entry->object);
c010b4e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b4e5:	8b 40 0c             	mov    0xc(%eax),%eax
c010b4e8:	89 04 24             	mov    %eax,(%esp)
c010b4eb:	e8 a0 93 ff ff       	call   c0104890 <process_wakeup>
                remove_event_trigger(current_entry->object, current_entry->ID);
c010b4f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b4f3:	8b 50 04             	mov    0x4(%eax),%edx
c010b4f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b4f9:	8b 40 0c             	mov    0xc(%eax),%eax
c010b4fc:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b500:	89 04 24             	mov    %eax,(%esp)
c010b503:	e8 7b f9 ff ff       	call   c010ae83 <remove_event_trigger>
c010b508:	eb 26                	jmp    c010b530 <send_killed_process+0xac>
            }
            else
            {
                thread_wakeup(current_entry->object);
c010b50a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b50d:	8b 40 0c             	mov    0xc(%eax),%eax
c010b510:	89 04 24             	mov    %eax,(%esp)
c010b513:	e8 fe a1 ff ff       	call   c0105716 <thread_wakeup>
                remove_event_trigger(current_entry->object, current_entry->ID);
c010b518:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b51b:	8b 50 04             	mov    0x4(%eax),%edx
c010b51e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b521:	8b 40 0c             	mov    0xc(%eax),%eax
c010b524:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b528:	89 04 24             	mov    %eax,(%esp)
c010b52b:	e8 53 f9 ff ff       	call   c010ae83 <remove_event_trigger>
            }

            list_remove(&it);
c010b530:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b533:	89 04 24             	mov    %eax,(%esp)
c010b536:	e8 0b 79 ff ff       	call   c0102e46 <list_remove>
            free(current_entry);
c010b53b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b53e:	89 04 24             	mov    %eax,(%esp)
c010b541:	e8 0d 0b 00 00       	call   c010c053 <free>
            continue;
c010b546:	e9 03 01 00 00       	jmp    c010b64e <send_killed_process+0x1ca>
        }

        if(current_entry->ID == 0 && current_entry->type == WAIT_PID) // pid = 0
c010b54b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b54e:	8b 40 04             	mov    0x4(%eax),%eax
c010b551:	85 c0                	test   %eax,%eax
                Please rewrite this case.
            */

        }

        if((int)current_entry->ID == -1 && current_entry->type == WAIT_PID) // pid = -1
c010b553:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b556:	8b 40 04             	mov    0x4(%eax),%eax
c010b559:	83 f8 ff             	cmp    $0xffffffff,%eax
c010b55c:	0f 85 d8 00 00 00    	jne    c010b63a <send_killed_process+0x1b6>
c010b562:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b565:	8b 00                	mov    (%eax),%eax
c010b567:	85 c0                	test   %eax,%eax
c010b569:	0f 85 cb 00 00 00    	jne    c010b63a <send_killed_process+0x1b6>
        {
            if(current_entry->object == proc->parent)
c010b56f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b572:	8b 50 0c             	mov    0xc(%eax),%edx
c010b575:	8b 45 08             	mov    0x8(%ebp),%eax
c010b578:	8b 40 10             	mov    0x10(%eax),%eax
c010b57b:	39 c2                	cmp    %eax,%edx
c010b57d:	75 2b                	jne    c010b5aa <send_killed_process+0x126>
            {
                process_wakeup(proc->parent);
c010b57f:	8b 45 08             	mov    0x8(%ebp),%eax
c010b582:	8b 40 10             	mov    0x10(%eax),%eax
c010b585:	89 04 24             	mov    %eax,(%esp)
c010b588:	e8 03 93 ff ff       	call   c0104890 <process_wakeup>
                remove_event_trigger(proc->parent, current_entry->ID);
c010b58d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b590:	8b 50 04             	mov    0x4(%eax),%edx
c010b593:	8b 45 08             	mov    0x8(%ebp),%eax
c010b596:	8b 40 10             	mov    0x10(%eax),%eax
c010b599:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b59d:	89 04 24             	mov    %eax,(%esp)
c010b5a0:	e8 de f8 ff ff       	call   c010ae83 <remove_event_trigger>
c010b5a5:	e9 90 00 00 00       	jmp    c010b63a <send_killed_process+0x1b6>
            }
            else
            {
                iterator_t thread_it = iterator_create(proc->parent->threads);
c010b5aa:	8b 45 08             	mov    0x8(%ebp),%eax
c010b5ad:	8b 40 10             	mov    0x10(%eax),%eax
c010b5b0:	8b 50 34             	mov    0x34(%eax),%edx
c010b5b3:	8d 45 e0             	lea    -0x20(%ebp),%eax
c010b5b6:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b5ba:	89 04 24             	mov    %eax,(%esp)
c010b5bd:	e8 29 77 ff ff       	call   c0102ceb <iterator_create>
c010b5c2:	83 ec 04             	sub    $0x4,%esp
                list_set_first(&thread_it);
c010b5c5:	8d 45 e0             	lea    -0x20(%ebp),%eax
c010b5c8:	89 04 24             	mov    %eax,(%esp)
c010b5cb:	e8 4b 78 ff ff       	call   c0102e1b <list_set_first>
                while(!list_is_empty(proc->parent->threads) && !list_is_last(&thread_it))
c010b5d0:	eb 44                	jmp    c010b616 <send_killed_process+0x192>
                {
                    struct thread_state *thread = list_get_current(&thread_it);
c010b5d2:	8d 45 e0             	lea    -0x20(%ebp),%eax
c010b5d5:	89 04 24             	mov    %eax,(%esp)
c010b5d8:	e8 d7 77 ff ff       	call   c0102db4 <list_get_current>
c010b5dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
                    if(thread == current_entry->object)
c010b5e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b5e3:	8b 40 0c             	mov    0xc(%eax),%eax
c010b5e6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c010b5e9:	75 20                	jne    c010b60b <send_killed_process+0x187>
                    {
                        thread_wakeup(thread);
c010b5eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b5ee:	89 04 24             	mov    %eax,(%esp)
c010b5f1:	e8 20 a1 ff ff       	call   c0105716 <thread_wakeup>
                        remove_event_trigger(thread, current_entry->ID);
c010b5f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b5f9:	8b 40 04             	mov    0x4(%eax),%eax
c010b5fc:	89 44 24 04          	mov    %eax,0x4(%esp)
c010b600:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b603:	89 04 24             	mov    %eax,(%esp)
c010b606:	e8 78 f8 ff ff       	call   c010ae83 <remove_event_trigger>
                    }
                    list_next(&thread_it);
c010b60b:	8d 45 e0             	lea    -0x20(%ebp),%eax
c010b60e:	89 04 24             	mov    %eax,(%esp)
c010b611:	e8 c3 77 ff ff       	call   c0102dd9 <list_next>
            }
            else
            {
                iterator_t thread_it = iterator_create(proc->parent->threads);
                list_set_first(&thread_it);
                while(!list_is_empty(proc->parent->threads) && !list_is_last(&thread_it))
c010b616:	8b 45 08             	mov    0x8(%ebp),%eax
c010b619:	8b 40 10             	mov    0x10(%eax),%eax
c010b61c:	8b 40 34             	mov    0x34(%eax),%eax
c010b61f:	89 04 24             	mov    %eax,(%esp)
c010b622:	e8 83 76 ff ff       	call   c0102caa <list_is_empty>
c010b627:	85 c0                	test   %eax,%eax
c010b629:	75 0f                	jne    c010b63a <send_killed_process+0x1b6>
c010b62b:	8d 45 e0             	lea    -0x20(%ebp),%eax
c010b62e:	89 04 24             	mov    %eax,(%esp)
c010b631:	e8 ca 77 ff ff       	call   c0102e00 <list_is_last>
c010b636:	85 c0                	test   %eax,%eax
c010b638:	74 98                	je     c010b5d2 <send_killed_process+0x14e>
                    list_next(&thread_it);
                }
            }
        }

        if((int)current_entry->ID < -1 && current_entry->type == WAIT_PID) // pid < -1
c010b63a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b63d:	8b 40 04             	mov    0x4(%eax),%eax
c010b640:	83 f8 ff             	cmp    $0xffffffff,%eax
                TODO:
                Process groups aren't implemented yet.
                Please rewrite this case.
            */
        }
        list_next(&it);
c010b643:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b646:	89 04 24             	mov    %eax,(%esp)
c010b649:	e8 8b 77 ff ff       	call   c0102dd9 <list_next>
 **/
void send_killed_process(struct process_state *proc)
{
    iterator_t it = iterator_create(trigger_list);
    list_set_first(&it);
    while(!list_is_empty(trigger_list) && !list_is_last(&it))
c010b64e:	a1 28 90 11 c0       	mov    0xc0119028,%eax
c010b653:	89 04 24             	mov    %eax,(%esp)
c010b656:	e8 4f 76 ff ff       	call   c0102caa <list_is_empty>
c010b65b:	85 c0                	test   %eax,%eax
c010b65d:	75 13                	jne    c010b672 <send_killed_process+0x1ee>
c010b65f:	8d 45 e8             	lea    -0x18(%ebp),%eax
c010b662:	89 04 24             	mov    %eax,(%esp)
c010b665:	e8 96 77 ff ff       	call   c0102e00 <list_is_last>
c010b66a:	85 c0                	test   %eax,%eax
c010b66c:	0f 84 40 fe ff ff    	je     c010b4b2 <send_killed_process+0x2e>
            */
        }
        list_next(&it);
    }

}
c010b672:	c9                   	leave  
c010b673:	c3                   	ret    

c010b674 <unix_time>:
 * @param pointer ti time struct
 *
 * @return unix timestamp
 */
time_t unix_time(struct time *time)
{
c010b674:	55                   	push   %ebp
c010b675:	89 e5                	mov    %esp,%ebp
c010b677:	53                   	push   %ebx
c010b678:	83 ec 10             	sub    $0x10,%esp
    int year = (time->century*100)+time->year;
c010b67b:	8b 45 08             	mov    0x8(%ebp),%eax
c010b67e:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c010b682:	0f b6 c0             	movzbl %al,%eax
c010b685:	6b d0 64             	imul   $0x64,%eax,%edx
c010b688:	8b 45 08             	mov    0x8(%ebp),%eax
c010b68b:	0f b6 40 09          	movzbl 0x9(%eax),%eax
c010b68f:	0f b6 c0             	movzbl %al,%eax
c010b692:	01 d0                	add    %edx,%eax
c010b694:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int leap_years = ((year - 1) - 1968) / 4 - ((year - 1) - 1900) / 100 + ((year - 1) - 1600) / 400;
c010b697:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b69a:	2d b1 07 00 00       	sub    $0x7b1,%eax
c010b69f:	8d 50 03             	lea    0x3(%eax),%edx
c010b6a2:	85 c0                	test   %eax,%eax
c010b6a4:	0f 48 c2             	cmovs  %edx,%eax
c010b6a7:	c1 f8 02             	sar    $0x2,%eax
c010b6aa:	89 c3                	mov    %eax,%ebx
c010b6ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b6af:	8d 88 93 f8 ff ff    	lea    -0x76d(%eax),%ecx
c010b6b5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c010b6ba:	89 c8                	mov    %ecx,%eax
c010b6bc:	f7 ea                	imul   %edx
c010b6be:	c1 fa 05             	sar    $0x5,%edx
c010b6c1:	89 c8                	mov    %ecx,%eax
c010b6c3:	c1 f8 1f             	sar    $0x1f,%eax
c010b6c6:	89 d1                	mov    %edx,%ecx
c010b6c8:	29 c1                	sub    %eax,%ecx
c010b6ca:	89 c8                	mov    %ecx,%eax
c010b6cc:	29 c3                	sub    %eax,%ebx
c010b6ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b6d1:	8d 88 bf f9 ff ff    	lea    -0x641(%eax),%ecx
c010b6d7:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c010b6dc:	89 c8                	mov    %ecx,%eax
c010b6de:	f7 ea                	imul   %edx
c010b6e0:	c1 fa 07             	sar    $0x7,%edx
c010b6e3:	89 c8                	mov    %ecx,%eax
c010b6e5:	c1 f8 1f             	sar    $0x1f,%eax
c010b6e8:	89 d1                	mov    %edx,%ecx
c010b6ea:	29 c1                	sub    %eax,%ecx
c010b6ec:	89 c8                	mov    %ecx,%eax
c010b6ee:	01 d8                	add    %ebx,%eax
c010b6f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int unix_time = time->second + (time->minute *60) + (time->hour *60*60) + ((day_to_current_month[time->month - 1] + time->day_in_month - 1) *24*60*60) + (((year-1970)*365+leap_years)*24*60*60);
c010b6f3:	8b 45 08             	mov    0x8(%ebp),%eax
c010b6f6:	0f b6 00             	movzbl (%eax),%eax
c010b6f9:	0f b6 d0             	movzbl %al,%edx
c010b6fc:	8b 45 08             	mov    0x8(%ebp),%eax
c010b6ff:	0f b6 40 02          	movzbl 0x2(%eax),%eax
c010b703:	0f b6 c0             	movzbl %al,%eax
c010b706:	c1 e0 02             	shl    $0x2,%eax
c010b709:	89 c1                	mov    %eax,%ecx
c010b70b:	c1 e1 04             	shl    $0x4,%ecx
c010b70e:	89 cb                	mov    %ecx,%ebx
c010b710:	29 c3                	sub    %eax,%ebx
c010b712:	89 d8                	mov    %ebx,%eax
c010b714:	01 c2                	add    %eax,%edx
c010b716:	8b 45 08             	mov    0x8(%ebp),%eax
c010b719:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c010b71d:	0f b6 c0             	movzbl %al,%eax
c010b720:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
c010b726:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c010b729:	8b 45 08             	mov    0x8(%ebp),%eax
c010b72c:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c010b730:	0f b6 c0             	movzbl %al,%eax
c010b733:	83 e8 01             	sub    $0x1,%eax
c010b736:	8b 14 85 20 0e 11 c0 	mov    -0x3feef1e0(,%eax,4),%edx
c010b73d:	8b 45 08             	mov    0x8(%ebp),%eax
c010b740:	0f b6 40 07          	movzbl 0x7(%eax),%eax
c010b744:	0f b6 c0             	movzbl %al,%eax
c010b747:	01 d0                	add    %edx,%eax
c010b749:	83 e8 01             	sub    $0x1,%eax
c010b74c:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c010b752:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c010b755:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b758:	69 c0 6d 01 00 00    	imul   $0x16d,%eax,%eax
c010b75e:	8d 88 36 07 f5 ff    	lea    -0xaf8ca(%eax),%ecx
c010b764:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010b767:	01 c8                	add    %ecx,%eax
c010b769:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c010b76f:	01 d0                	add    %edx,%eax
c010b771:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if((time->month >2) && (year%4==0 && (year%100!=0 || year%400==0)))
c010b774:	8b 45 08             	mov    0x8(%ebp),%eax
c010b777:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c010b77b:	3c 02                	cmp    $0x2,%al
c010b77d:	76 62                	jbe    c010b7e1 <unix_time+0x16d>
c010b77f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b782:	83 e0 03             	and    $0x3,%eax
c010b785:	85 c0                	test   %eax,%eax
c010b787:	75 58                	jne    c010b7e1 <unix_time+0x16d>
c010b789:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010b78c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c010b791:	89 c8                	mov    %ecx,%eax
c010b793:	f7 ea                	imul   %edx
c010b795:	c1 fa 05             	sar    $0x5,%edx
c010b798:	89 c8                	mov    %ecx,%eax
c010b79a:	c1 f8 1f             	sar    $0x1f,%eax
c010b79d:	89 d3                	mov    %edx,%ebx
c010b79f:	29 c3                	sub    %eax,%ebx
c010b7a1:	89 d8                	mov    %ebx,%eax
c010b7a3:	6b c0 64             	imul   $0x64,%eax,%eax
c010b7a6:	89 ca                	mov    %ecx,%edx
c010b7a8:	29 c2                	sub    %eax,%edx
c010b7aa:	89 d0                	mov    %edx,%eax
c010b7ac:	85 c0                	test   %eax,%eax
c010b7ae:	75 2a                	jne    c010b7da <unix_time+0x166>
c010b7b0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010b7b3:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c010b7b8:	89 c8                	mov    %ecx,%eax
c010b7ba:	f7 ea                	imul   %edx
c010b7bc:	c1 fa 07             	sar    $0x7,%edx
c010b7bf:	89 c8                	mov    %ecx,%eax
c010b7c1:	c1 f8 1f             	sar    $0x1f,%eax
c010b7c4:	89 d3                	mov    %edx,%ebx
c010b7c6:	29 c3                	sub    %eax,%ebx
c010b7c8:	89 d8                	mov    %ebx,%eax
c010b7ca:	69 c0 90 01 00 00    	imul   $0x190,%eax,%eax
c010b7d0:	89 ca                	mov    %ecx,%edx
c010b7d2:	29 c2                	sub    %eax,%edx
c010b7d4:	89 d0                	mov    %edx,%eax
c010b7d6:	85 c0                	test   %eax,%eax
c010b7d8:	75 07                	jne    c010b7e1 <unix_time+0x16d>
        unix_time += 24*60*60;
c010b7da:	81 45 f8 80 51 01 00 	addl   $0x15180,-0x8(%ebp)
    return unix_time;
c010b7e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c010b7e4:	83 c4 10             	add    $0x10,%esp
c010b7e7:	5b                   	pop    %ebx
c010b7e8:	5d                   	pop    %ebp
c010b7e9:	c3                   	ret    

c010b7ea <sys_time>:
/**
 * @brief unix sys_time syscall. Returns the current unix-timestamp to the user
 * @param current user cpu state
 */
void sys_time(struct cpu_state **cpu)
{
c010b7ea:	55                   	push   %ebp
c010b7eb:	89 e5                	mov    %esp,%ebp
c010b7ed:	83 ec 28             	sub    $0x28,%esp
    struct time current_time;
    update_time(&current_time);
c010b7f0:	8d 45 e9             	lea    -0x17(%ebp),%eax
c010b7f3:	89 04 24             	mov    %eax,(%esp)
c010b7f6:	e8 8b 15 00 00       	call   c010cd86 <update_time>
    int stamp = unix_time(&current_time);
c010b7fb:	8d 45 e9             	lea    -0x17(%ebp),%eax
c010b7fe:	89 04 24             	mov    %eax,(%esp)
c010b801:	e8 6e fe ff ff       	call   c010b674 <unix_time>
c010b806:	89 45 f4             	mov    %eax,-0xc(%ebp)
    (*cpu)->CPU_ARG0 = stamp;
c010b809:	8b 45 08             	mov    0x8(%ebp),%eax
c010b80c:	8b 00                	mov    (%eax),%eax
c010b80e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010b811:	89 50 28             	mov    %edx,0x28(%eax)
    if((*cpu)->CPU_ARG1)
c010b814:	8b 45 08             	mov    0x8(%ebp),%eax
c010b817:	8b 00                	mov    (%eax),%eax
c010b819:	8b 40 1c             	mov    0x1c(%eax),%eax
c010b81c:	85 c0                	test   %eax,%eax
c010b81e:	74 0d                	je     c010b82d <sys_time+0x43>
        *((int*)(*cpu)->CPU_ARG1) = stamp;
c010b820:	8b 45 08             	mov    0x8(%ebp),%eax
c010b823:	8b 00                	mov    (%eax),%eax
c010b825:	8b 40 1c             	mov    0x1c(%eax),%eax
c010b828:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010b82b:	89 10                	mov    %edx,(%eax)
c010b82d:	c9                   	leave  
c010b82e:	c3                   	ret    

c010b82f <INIT_PAGING>:
 *
 * @param mb_info pointer to multiboot structure
 * @return void
 */
void INIT_PAGING(struct multiboot_struct *mb_info)
{
c010b82f:	55                   	push   %ebp
c010b830:	89 e5                	mov    %esp,%ebp
c010b832:	83 ec 18             	sub    $0x18,%esp
    ARCH_INIT_PAGING(mb_info);
c010b835:	8b 45 08             	mov    0x8(%ebp),%eax
c010b838:	89 04 24             	mov    %eax,(%esp)
c010b83b:	e8 2d 18 00 00       	call   c010d06d <ARCH_INIT_PAGING>
}
c010b840:	c9                   	leave  
c010b841:	c3                   	ret    

c010b842 <vmm_create_context>:
 *
 * @param context pointer to the memory structure
 * @return void
 */
void vmm_create_context(vmm_context_t *context)
{
c010b842:	55                   	push   %ebp
c010b843:	89 e5                	mov    %esp,%ebp
c010b845:	83 ec 18             	sub    $0x18,%esp
    arch_vmm_create_context(&context->arch_context);
c010b848:	8b 45 08             	mov    0x8(%ebp),%eax
c010b84b:	89 04 24             	mov    %eax,(%esp)
c010b84e:	e8 f1 19 00 00       	call   c010d244 <arch_vmm_create_context>
}
c010b853:	c9                   	leave  
c010b854:	c3                   	ret    

c010b855 <vmm_destroy_context>:
 *
 * @param context pointer to to destroying context
 * @return void
 */
void vmm_destroy_context(vmm_context_t *context)
{
c010b855:	55                   	push   %ebp
c010b856:	89 e5                	mov    %esp,%ebp
c010b858:	83 ec 18             	sub    $0x18,%esp
    arch_vmm_destroy_context(&context->arch_context);
c010b85b:	8b 45 08             	mov    0x8(%ebp),%eax
c010b85e:	89 04 24             	mov    %eax,(%esp)
c010b861:	e8 44 1a 00 00       	call   c010d2aa <arch_vmm_destroy_context>
}
c010b866:	c9                   	leave  
c010b867:	c3                   	ret    

c010b868 <vmm_switch_context>:
 *
 * @param context pointer to context
 * @return void
 */
void vmm_switch_context(vmm_context_t *context)
{
c010b868:	55                   	push   %ebp
c010b869:	89 e5                	mov    %esp,%ebp
c010b86b:	83 ec 18             	sub    $0x18,%esp
    if(context != current_context)
c010b86e:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010b873:	39 45 08             	cmp    %eax,0x8(%ebp)
c010b876:	74 1e                	je     c010b896 <vmm_switch_context+0x2e>
    {
        arch_update_context(&context->arch_context);
c010b878:	8b 45 08             	mov    0x8(%ebp),%eax
c010b87b:	89 04 24             	mov    %eax,(%esp)
c010b87e:	e8 d8 1b 00 00       	call   c010d45b <arch_update_context>
        arch_switch_context(&context->arch_context);
c010b883:	8b 45 08             	mov    0x8(%ebp),%eax
c010b886:	89 04 24             	mov    %eax,(%esp)
c010b889:	e8 4e 21 00 00       	call   c010d9dc <arch_switch_context>
        current_context = context;
c010b88e:	8b 45 08             	mov    0x8(%ebp),%eax
c010b891:	a3 30 90 11 c0       	mov    %eax,0xc0119030
    }
}
c010b896:	c9                   	leave  
c010b897:	c3                   	ret    

c010b898 <vmm_map>:
 * @param vframe virtual adress
 * @param flags additional paging flags (defined /include/arch/x86/arch_paging.h)
 * @return success
 */
int vmm_map(vmm_context_t *context, paddr_t pframe, vaddr_t vframe, uint8_t flags)
{
c010b898:	55                   	push   %ebp
c010b899:	89 e5                	mov    %esp,%ebp
c010b89b:	83 ec 28             	sub    $0x28,%esp
c010b89e:	8b 45 14             	mov    0x14(%ebp),%eax
c010b8a1:	88 45 f4             	mov    %al,-0xc(%ebp)
    return arch_map(&context->arch_context, pframe, vframe, flags);
c010b8a4:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c010b8a8:	8b 45 08             	mov    0x8(%ebp),%eax
c010b8ab:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010b8af:	8b 55 10             	mov    0x10(%ebp),%edx
c010b8b2:	89 54 24 08          	mov    %edx,0x8(%esp)
c010b8b6:	8b 55 0c             	mov    0xc(%ebp),%edx
c010b8b9:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b8bd:	89 04 24             	mov    %eax,(%esp)
c010b8c0:	e8 05 1d 00 00       	call   c010d5ca <arch_map>
}
c010b8c5:	c9                   	leave  
c010b8c6:	c3                   	ret    

c010b8c7 <vmm_unmap>:
 * @param context the vmm context
 * @param frame the adress to free
 * @return success
 */
int vmm_unmap(vmm_context_t *context, vaddr_t frame)
{
c010b8c7:	55                   	push   %ebp
c010b8c8:	89 e5                	mov    %esp,%ebp
c010b8ca:	83 ec 18             	sub    $0x18,%esp
    return arch_unmap(&context->arch_context, frame);
c010b8cd:	8b 45 08             	mov    0x8(%ebp),%eax
c010b8d0:	8b 55 0c             	mov    0xc(%ebp),%edx
c010b8d3:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b8d7:	89 04 24             	mov    %eax,(%esp)
c010b8da:	e8 07 1e 00 00       	call   c010d6e6 <arch_unmap>
}
c010b8df:	c9                   	leave  
c010b8e0:	c3                   	ret    

c010b8e1 <vmm_map_range>:
 * @param pages number of pages / size of the range to map
 * @param flags paging flags (same for vmm_map)
 * @return success
 */
int vmm_map_range(vmm_context_t *context, paddr_t pframe, vaddr_t vframe, int pages, uint8_t flags)
{
c010b8e1:	55                   	push   %ebp
c010b8e2:	89 e5                	mov    %esp,%ebp
c010b8e4:	53                   	push   %ebx
c010b8e5:	83 ec 34             	sub    $0x34,%esp
c010b8e8:	8b 45 18             	mov    0x18(%ebp),%eax
c010b8eb:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int p;
    for (p = 0; p < pages; ++p)
c010b8ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010b8f5:	eb 39                	jmp    c010b930 <vmm_map_range+0x4f>
    {
        vmm_map(context, pframe + PAGE_FRAME_ADDR(p), vframe + PAGE_FRAME_ADDR(p), flags);
c010b8f7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010b8fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010b8fe:	c1 e2 0c             	shl    $0xc,%edx
c010b901:	89 d1                	mov    %edx,%ecx
c010b903:	8b 55 10             	mov    0x10(%ebp),%edx
c010b906:	01 d1                	add    %edx,%ecx
c010b908:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010b90b:	c1 e2 0c             	shl    $0xc,%edx
c010b90e:	89 d3                	mov    %edx,%ebx
c010b910:	8b 55 0c             	mov    0xc(%ebp),%edx
c010b913:	01 da                	add    %ebx,%edx
c010b915:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010b919:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010b91d:	89 54 24 04          	mov    %edx,0x4(%esp)
c010b921:	8b 45 08             	mov    0x8(%ebp),%eax
c010b924:	89 04 24             	mov    %eax,(%esp)
c010b927:	e8 6c ff ff ff       	call   c010b898 <vmm_map>
 * @return success
 */
int vmm_map_range(vmm_context_t *context, paddr_t pframe, vaddr_t vframe, int pages, uint8_t flags)
{
    int p;
    for (p = 0; p < pages; ++p)
c010b92c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010b930:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b933:	3b 45 14             	cmp    0x14(%ebp),%eax
c010b936:	7c bf                	jl     c010b8f7 <vmm_map_range+0x16>
    {
        vmm_map(context, pframe + PAGE_FRAME_ADDR(p), vframe + PAGE_FRAME_ADDR(p), flags);
    }
    return 0;
c010b938:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010b93d:	83 c4 34             	add    $0x34,%esp
c010b940:	5b                   	pop    %ebx
c010b941:	5d                   	pop    %ebp
c010b942:	c3                   	ret    

c010b943 <vmm_unmap_range>:
 * @param frame the start adress in virtual space
 * @param pages number of pages / length of the range
 * @return success
 */
int vmm_unmap_range(vmm_context_t *context, vaddr_t frame, int pages)
{
c010b943:	55                   	push   %ebp
c010b944:	89 e5                	mov    %esp,%ebp
c010b946:	83 ec 28             	sub    $0x28,%esp
    int p;
    for(p = 0; p < pages; p++)
c010b949:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010b950:	eb 20                	jmp    c010b972 <vmm_unmap_range+0x2f>
    {
        vmm_unmap(context, frame + PAGE_FRAME_ADDR(p));
c010b952:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b955:	c1 e0 0c             	shl    $0xc,%eax
c010b958:	89 c2                	mov    %eax,%edx
c010b95a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010b95d:	01 d0                	add    %edx,%eax
c010b95f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010b963:	8b 45 08             	mov    0x8(%ebp),%eax
c010b966:	89 04 24             	mov    %eax,(%esp)
c010b969:	e8 59 ff ff ff       	call   c010b8c7 <vmm_unmap>
 * @return success
 */
int vmm_unmap_range(vmm_context_t *context, vaddr_t frame, int pages)
{
    int p;
    for(p = 0; p < pages; p++)
c010b96e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010b972:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b975:	3b 45 10             	cmp    0x10(%ebp),%eax
c010b978:	7c d8                	jl     c010b952 <vmm_unmap_range+0xf>
    {
        vmm_unmap(context, frame + PAGE_FRAME_ADDR(p));
    }
    return 0;
c010b97a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010b97f:	c9                   	leave  
c010b980:	c3                   	ret    

c010b981 <vmm_automap_kernel>:
 * @param pframe the physical adress of the page
 * @param flags paging flags (same for vmm_map)
 * @return the virtual adress
 */
vaddr_t vmm_automap_kernel(vmm_context_t *context, paddr_t pframe, uint8_t flags)
{
c010b981:	55                   	push   %ebp
c010b982:	89 e5                	mov    %esp,%ebp
c010b984:	83 ec 38             	sub    $0x38,%esp
c010b987:	8b 45 10             	mov    0x10(%ebp),%eax
c010b98a:	88 45 e4             	mov    %al,-0x1c(%ebp)
    vaddr_t vframe = arch_vaddr_find(&context->arch_context, 1,
c010b98d:	8b 45 08             	mov    0x8(%ebp),%eax
c010b990:	c7 44 24 0c 00 00 00 	movl   $0xe0000000,0xc(%esp)
c010b997:	e0 
c010b998:	c7 44 24 08 00 00 00 	movl   $0xc2000000,0x8(%esp)
c010b99f:	c2 
c010b9a0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c010b9a7:	00 
c010b9a8:	89 04 24             	mov    %eax,(%esp)
c010b9ab:	e8 ee 1d 00 00       	call   c010d79e <arch_vaddr_find>
c010b9b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                     MEMORY_LAYOUT_RESERVED_AREA_END,
                                     MEMORY_LAYOUT_KERNEL_HEAP_START);
    vmm_map(context, pframe, vframe, flags | VMM_PRESENT);
c010b9b3:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010b9b7:	83 c8 01             	or     $0x1,%eax
c010b9ba:	0f b6 c0             	movzbl %al,%eax
c010b9bd:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010b9c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010b9c4:	89 44 24 08          	mov    %eax,0x8(%esp)
c010b9c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c010b9cb:	89 44 24 04          	mov    %eax,0x4(%esp)
c010b9cf:	8b 45 08             	mov    0x8(%ebp),%eax
c010b9d2:	89 04 24             	mov    %eax,(%esp)
c010b9d5:	e8 be fe ff ff       	call   c010b898 <vmm_map>

    return vframe;
c010b9da:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010b9dd:	c9                   	leave  
c010b9de:	c3                   	ret    

c010b9df <vmm_automap_kernel_range>:
 * @param pages number of pages to map
 * @param flags paging flags (same as vmm_map)
 * @return the virtual start adress
 */
vaddr_t vmm_automap_kernel_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags)
{
c010b9df:	55                   	push   %ebp
c010b9e0:	89 e5                	mov    %esp,%ebp
c010b9e2:	83 ec 38             	sub    $0x38,%esp
c010b9e5:	8b 45 14             	mov    0x14(%ebp),%eax
c010b9e8:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int i;
    vaddr_t vaddr_start = arch_vaddr_find(&context->arch_context, pages, MEMORY_LAYOUT_RESERVED_AREA_END, MEMORY_LAYOUT_KERNEL_HEAP_START);
c010b9eb:	8b 45 08             	mov    0x8(%ebp),%eax
c010b9ee:	c7 44 24 0c 00 00 00 	movl   $0xe0000000,0xc(%esp)
c010b9f5:	e0 
c010b9f6:	c7 44 24 08 00 00 00 	movl   $0xc2000000,0x8(%esp)
c010b9fd:	c2 
c010b9fe:	8b 55 10             	mov    0x10(%ebp),%edx
c010ba01:	89 54 24 04          	mov    %edx,0x4(%esp)
c010ba05:	89 04 24             	mov    %eax,(%esp)
c010ba08:	e8 91 1d 00 00       	call   c010d79e <arch_vaddr_find>
c010ba0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(i = 0; i < pages; i++)
c010ba10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010ba17:	eb 45                	jmp    c010ba5e <vmm_automap_kernel_range+0x7f>
    {
        paddr_t paddr = pframe + i*PAGE_SIZE;
c010ba19:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ba1c:	c1 e0 0c             	shl    $0xc,%eax
c010ba1f:	89 c2                	mov    %eax,%edx
c010ba21:	8b 45 0c             	mov    0xc(%ebp),%eax
c010ba24:	01 d0                	add    %edx,%eax
c010ba26:	89 45 ec             	mov    %eax,-0x14(%ebp)
        vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
c010ba29:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ba2c:	c1 e0 0c             	shl    $0xc,%eax
c010ba2f:	89 c2                	mov    %eax,%edx
c010ba31:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ba34:	01 d0                	add    %edx,%eax
c010ba36:	89 45 e8             	mov    %eax,-0x18(%ebp)
        vmm_map(context, paddr, vaddr, flags);
c010ba39:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010ba3d:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010ba41:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ba44:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ba48:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ba4b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ba4f:	8b 45 08             	mov    0x8(%ebp),%eax
c010ba52:	89 04 24             	mov    %eax,(%esp)
c010ba55:	e8 3e fe ff ff       	call   c010b898 <vmm_map>
 */
vaddr_t vmm_automap_kernel_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags)
{
    int i;
    vaddr_t vaddr_start = arch_vaddr_find(&context->arch_context, pages, MEMORY_LAYOUT_RESERVED_AREA_END, MEMORY_LAYOUT_KERNEL_HEAP_START);
    for(i = 0; i < pages; i++)
c010ba5a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010ba5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ba61:	3b 45 10             	cmp    0x10(%ebp),%eax
c010ba64:	7c b3                	jl     c010ba19 <vmm_automap_kernel_range+0x3a>
        paddr_t paddr = pframe + i*PAGE_SIZE;
        vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
        vmm_map(context, paddr, vaddr, flags);
    }

    return vaddr_start;
c010ba66:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010ba69:	c9                   	leave  
c010ba6a:	c3                   	ret    

c010ba6b <vmm_automap_user>:
 * @param pframe the physical adress of the page
 * @param flags paging flags (same for vmm_map)
 * @return the virtual adress
 */
vaddr_t vmm_automap_user(vmm_context_t *context, paddr_t pframe, uint8_t flags)
{
c010ba6b:	55                   	push   %ebp
c010ba6c:	89 e5                	mov    %esp,%ebp
c010ba6e:	83 ec 38             	sub    $0x38,%esp
c010ba71:	8b 45 10             	mov    0x10(%ebp),%eax
c010ba74:	88 45 e4             	mov    %al,-0x1c(%ebp)
    vaddr_t vframe = arch_vaddr_find(&context->arch_context, 1,
c010ba77:	8b 45 08             	mov    0x8(%ebp),%eax
c010ba7a:	c7 44 24 0c 00 00 00 	movl   $0xc0000000,0xc(%esp)
c010ba81:	c0 
c010ba82:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010ba89:	00 
c010ba8a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c010ba91:	00 
c010ba92:	89 04 24             	mov    %eax,(%esp)
c010ba95:	e8 04 1d 00 00       	call   c010d79e <arch_vaddr_find>
c010ba9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                     0x0, MEMORY_LAYOUT_KERNEL_START);
    vmm_map(context, pframe, vframe, flags | VMM_PRESENT);
c010ba9d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010baa1:	83 c8 01             	or     $0x1,%eax
c010baa4:	0f b6 c0             	movzbl %al,%eax
c010baa7:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010baab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010baae:	89 44 24 08          	mov    %eax,0x8(%esp)
c010bab2:	8b 45 0c             	mov    0xc(%ebp),%eax
c010bab5:	89 44 24 04          	mov    %eax,0x4(%esp)
c010bab9:	8b 45 08             	mov    0x8(%ebp),%eax
c010babc:	89 04 24             	mov    %eax,(%esp)
c010babf:	e8 d4 fd ff ff       	call   c010b898 <vmm_map>

    return vframe;
c010bac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010bac7:	c9                   	leave  
c010bac8:	c3                   	ret    

c010bac9 <vmm_automap_user_range>:
 * @param pages number of pages to map
 * @param flags paging flags (same as vmm_map)
 * @return the virtual start adress
 */
vaddr_t vmm_automap_user_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags)
{
c010bac9:	55                   	push   %ebp
c010baca:	89 e5                	mov    %esp,%ebp
c010bacc:	83 ec 38             	sub    $0x38,%esp
c010bacf:	8b 45 14             	mov    0x14(%ebp),%eax
c010bad2:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int i;
    vaddr_t vaddr_start = arch_vaddr_find(&context->arch_context, pages, 0x1000, MEMORY_LAYOUT_KERNEL_START);
c010bad5:	8b 45 08             	mov    0x8(%ebp),%eax
c010bad8:	c7 44 24 0c 00 00 00 	movl   $0xc0000000,0xc(%esp)
c010badf:	c0 
c010bae0:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010bae7:	00 
c010bae8:	8b 55 10             	mov    0x10(%ebp),%edx
c010baeb:	89 54 24 04          	mov    %edx,0x4(%esp)
c010baef:	89 04 24             	mov    %eax,(%esp)
c010baf2:	e8 a7 1c 00 00       	call   c010d79e <arch_vaddr_find>
c010baf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(i = 0; i < pages; i++)
c010bafa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010bb01:	eb 45                	jmp    c010bb48 <vmm_automap_user_range+0x7f>
    {
        paddr_t paddr = pframe + i*PAGE_SIZE;
c010bb03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bb06:	c1 e0 0c             	shl    $0xc,%eax
c010bb09:	89 c2                	mov    %eax,%edx
c010bb0b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010bb0e:	01 d0                	add    %edx,%eax
c010bb10:	89 45 ec             	mov    %eax,-0x14(%ebp)
        vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
c010bb13:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bb16:	c1 e0 0c             	shl    $0xc,%eax
c010bb19:	89 c2                	mov    %eax,%edx
c010bb1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010bb1e:	01 d0                	add    %edx,%eax
c010bb20:	89 45 e8             	mov    %eax,-0x18(%ebp)
        vmm_map(context, paddr, vaddr, flags);
c010bb23:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010bb27:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010bb2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010bb2e:	89 44 24 08          	mov    %eax,0x8(%esp)
c010bb32:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010bb35:	89 44 24 04          	mov    %eax,0x4(%esp)
c010bb39:	8b 45 08             	mov    0x8(%ebp),%eax
c010bb3c:	89 04 24             	mov    %eax,(%esp)
c010bb3f:	e8 54 fd ff ff       	call   c010b898 <vmm_map>
 */
vaddr_t vmm_automap_user_range(vmm_context_t *context, paddr_t pframe, int pages, uint8_t flags)
{
    int i;
    vaddr_t vaddr_start = arch_vaddr_find(&context->arch_context, pages, 0x1000, MEMORY_LAYOUT_KERNEL_START);
    for(i = 0; i < pages; i++)
c010bb44:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010bb48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bb4b:	3b 45 10             	cmp    0x10(%ebp),%eax
c010bb4e:	7c b3                	jl     c010bb03 <vmm_automap_user_range+0x3a>
        paddr_t paddr = pframe + i*PAGE_SIZE;
        vaddr_t vaddr = vaddr_start + i*PAGE_SIZE;
        vmm_map(context, paddr, vaddr, flags);
    }

    return vaddr_start;
c010bb50:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010bb53:	c9                   	leave  
c010bb54:	c3                   	ret    

c010bb55 <alloc_memory>:

void alloc_memory(struct cpu_state **cpu)
{
c010bb55:	55                   	push   %ebp
c010bb56:	89 e5                	mov    %esp,%ebp
c010bb58:	83 ec 38             	sub    $0x38,%esp
    int pages = (*cpu)->CPU_ARG1;
c010bb5b:	8b 45 08             	mov    0x8(%ebp),%eax
c010bb5e:	8b 00                	mov    (%eax),%eax
c010bb60:	8b 40 1c             	mov    0x1c(%eax),%eax
c010bb63:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t *dest = (uint32_t *)arch_vaddr_find(&current_context->arch_context, pages, MEMORY_LAYOUT_USER_HEAP_START, MEMORY_LAYOUT_USER_HEAP_END);
c010bb66:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010bb6b:	c7 44 24 0c 00 00 00 	movl   $0xb0000000,0xc(%esp)
c010bb72:	b0 
c010bb73:	c7 44 24 08 00 00 00 	movl   $0xa0000000,0x8(%esp)
c010bb7a:	a0 
c010bb7b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bb7e:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bb82:	89 04 24             	mov    %eax,(%esp)
c010bb85:	e8 14 1c 00 00       	call   c010d79e <arch_vaddr_find>
c010bb8a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    int i;
    for(i = 0; i < pages; i++)
c010bb8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010bb94:	eb 3f                	jmp    c010bbd5 <alloc_memory+0x80>
    {
        uint32_t *paddr = (uint32_t *)pmm_alloc_page();
c010bb96:	e8 19 39 00 00       	call   c010f4b4 <pmm_alloc_page>
c010bb9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t *vaddr = dest + i*PAGE_SIZE;
c010bb9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bba1:	c1 e0 0e             	shl    $0xe,%eax
c010bba4:	89 c2                	mov    %eax,%edx
c010bba6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010bba9:	01 d0                	add    %edx,%eax
c010bbab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        vmm_map(current_context, (paddr_t)paddr, (vaddr_t)vaddr, VMM_PRESENT|VMM_WRITABLE|VMM_USER);
c010bbae:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c010bbb1:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010bbb4:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010bbb9:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c010bbc0:	00 
c010bbc1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010bbc5:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bbc9:	89 04 24             	mov    %eax,(%esp)
c010bbcc:	e8 c7 fc ff ff       	call   c010b898 <vmm_map>
    int pages = (*cpu)->CPU_ARG1;

    uint32_t *dest = (uint32_t *)arch_vaddr_find(&current_context->arch_context, pages, MEMORY_LAYOUT_USER_HEAP_START, MEMORY_LAYOUT_USER_HEAP_END);

    int i;
    for(i = 0; i < pages; i++)
c010bbd1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010bbd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bbd8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c010bbdb:	7c b9                	jl     c010bb96 <alloc_memory+0x41>
    {
        uint32_t *paddr = (uint32_t *)pmm_alloc_page();
        uint32_t *vaddr = dest + i*PAGE_SIZE;
        vmm_map(current_context, (paddr_t)paddr, (vaddr_t)vaddr, VMM_PRESENT|VMM_WRITABLE|VMM_USER);
    }
    (*cpu)->CPU_ARG0 = (uint32_t)dest;
c010bbdd:	8b 45 08             	mov    0x8(%ebp),%eax
c010bbe0:	8b 00                	mov    (%eax),%eax
c010bbe2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010bbe5:	89 50 28             	mov    %edx,0x28(%eax)
}
c010bbe8:	c9                   	leave  
c010bbe9:	c3                   	ret    

c010bbea <sys_brk>:


extern struct thread_state* current_thread; /// defined in /sched/scheduler.c

void sys_brk(struct cpu_state **cpu)
{
c010bbea:	55                   	push   %ebp
c010bbeb:	89 e5                	mov    %esp,%ebp
c010bbed:	83 ec 38             	sub    $0x38,%esp
    uint32_t new_bss_top = (*cpu)->CPU_ARG1;
c010bbf0:	8b 45 08             	mov    0x8(%ebp),%eax
c010bbf3:	8b 00                	mov    (%eax),%eax
c010bbf5:	8b 40 1c             	mov    0x1c(%eax),%eax
c010bbf8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t heap_top = current_thread->process->heap_top;
c010bbfb:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010bc00:	8b 00                	mov    (%eax),%eax
c010bc02:	8b 40 48             	mov    0x48(%eax),%eax
c010bc05:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(new_bss_top == 0)
c010bc08:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010bc0c:	75 10                	jne    c010bc1e <sys_brk+0x34>
    {
        (*cpu)->CPU_ARG0 = heap_top;
c010bc0e:	8b 45 08             	mov    0x8(%ebp),%eax
c010bc11:	8b 00                	mov    (%eax),%eax
c010bc13:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bc16:	89 50 28             	mov    %edx,0x28(%eax)
c010bc19:	e9 0c 01 00 00       	jmp    c010bd2a <sys_brk+0x140>
    }
    else if(new_bss_top > current_thread->process->heap_upper_limit || new_bss_top < current_thread->process->heap_lower_limit)
c010bc1e:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010bc23:	8b 00                	mov    (%eax),%eax
c010bc25:	8b 40 50             	mov    0x50(%eax),%eax
c010bc28:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c010bc2b:	72 0f                	jb     c010bc3c <sys_brk+0x52>
c010bc2d:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010bc32:	8b 00                	mov    (%eax),%eax
c010bc34:	8b 40 4c             	mov    0x4c(%eax),%eax
c010bc37:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c010bc3a:	76 11                	jbe    c010bc4d <sys_brk+0x63>
    {
        (*cpu)->CPU_ARG0 = 0;
c010bc3c:	8b 45 08             	mov    0x8(%ebp),%eax
c010bc3f:	8b 00                	mov    (%eax),%eax
c010bc41:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c010bc48:	e9 dd 00 00 00       	jmp    c010bd2a <sys_brk+0x140>
    }
    else if(new_bss_top > (heap_top|0x00000FFF))
c010bc4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bc50:	0d ff 0f 00 00       	or     $0xfff,%eax
c010bc55:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c010bc58:	0f 83 b9 00 00 00    	jae    c010bd17 <sys_brk+0x12d>
    {
        int req_memory = new_bss_top-((heap_top|0x00000FFF));
c010bc5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bc61:	89 c2                	mov    %eax,%edx
c010bc63:	81 ca ff 0f 00 00    	or     $0xfff,%edx
c010bc69:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010bc6c:	29 d0                	sub    %edx,%eax
c010bc6e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int pages = 1+(req_memory/PAGE_SIZE);
c010bc71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010bc74:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
c010bc7a:	85 c0                	test   %eax,%eax
c010bc7c:	0f 48 c2             	cmovs  %edx,%eax
c010bc7f:	c1 f8 0c             	sar    $0xc,%eax
c010bc82:	83 c0 01             	add    $0x1,%eax
c010bc85:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(req_memory%PAGE_SIZE)
c010bc88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010bc8b:	25 ff 0f 00 00       	and    $0xfff,%eax
c010bc90:	85 c0                	test   %eax,%eax
c010bc92:	74 04                	je     c010bc98 <sys_brk+0xae>
            pages++;
c010bc94:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

        heap_top = arch_vaddr_find(&current_context->arch_context, pages, MEMORY_LAYOUT_USER_HEAP_START, MEMORY_LAYOUT_USER_HEAP_END);
c010bc98:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010bc9d:	c7 44 24 0c 00 00 00 	movl   $0xb0000000,0xc(%esp)
c010bca4:	b0 
c010bca5:	c7 44 24 08 00 00 00 	movl   $0xa0000000,0x8(%esp)
c010bcac:	a0 
c010bcad:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bcb0:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bcb4:	89 04 24             	mov    %eax,(%esp)
c010bcb7:	e8 e2 1a 00 00       	call   c010d79e <arch_vaddr_find>
c010bcbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
        int i;
        for(i = 0; i < pages; i++)
c010bcbf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c010bcc6:	eb 3f                	jmp    c010bd07 <sys_brk+0x11d>
        {
            paddr_t paddr = pmm_alloc_page();
c010bcc8:	e8 e7 37 00 00       	call   c010f4b4 <pmm_alloc_page>
c010bccd:	89 45 e0             	mov    %eax,-0x20(%ebp)
            vaddr_t vaddr = heap_top + i*PAGE_SIZE;
c010bcd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010bcd3:	c1 e0 0c             	shl    $0xc,%eax
c010bcd6:	89 c2                	mov    %eax,%edx
c010bcd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bcdb:	01 d0                	add    %edx,%eax
c010bcdd:	89 45 dc             	mov    %eax,-0x24(%ebp)
            vmm_map(current_context, paddr, vaddr, VMM_PRESENT|VMM_WRITABLE|VMM_USER);
c010bce0:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010bce5:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c010bcec:	00 
c010bced:	8b 55 dc             	mov    -0x24(%ebp),%edx
c010bcf0:	89 54 24 08          	mov    %edx,0x8(%esp)
c010bcf4:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010bcf7:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bcfb:	89 04 24             	mov    %eax,(%esp)
c010bcfe:	e8 95 fb ff ff       	call   c010b898 <vmm_map>
        if(req_memory%PAGE_SIZE)
            pages++;

        heap_top = arch_vaddr_find(&current_context->arch_context, pages, MEMORY_LAYOUT_USER_HEAP_START, MEMORY_LAYOUT_USER_HEAP_END);
        int i;
        for(i = 0; i < pages; i++)
c010bd03:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c010bd07:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010bd0a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c010bd0d:	7c b9                	jl     c010bcc8 <sys_brk+0xde>
            paddr_t paddr = pmm_alloc_page();
            vaddr_t vaddr = heap_top + i*PAGE_SIZE;
            vmm_map(current_context, paddr, vaddr, VMM_PRESENT|VMM_WRITABLE|VMM_USER);
        }

        heap_top += req_memory;
c010bd0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010bd12:	01 45 f4             	add    %eax,-0xc(%ebp)
c010bd15:	eb 13                	jmp    c010bd2a <sys_brk+0x140>
    }
    else if(new_bss_top < (heap_top^0xFFFFF000))
c010bd17:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bd1a:	35 00 f0 ff ff       	xor    $0xfffff000,%eax
c010bd1f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c010bd22:	77 06                	ja     c010bd2a <sys_brk+0x140>
    {
        //todo Free
    }
    else
        heap_top = new_bss_top;
c010bd24:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010bd27:	89 45 f4             	mov    %eax,-0xc(%ebp)


    current_thread->process->heap_top = heap_top;
c010bd2a:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010bd2f:	8b 00                	mov    (%eax),%eax
c010bd31:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bd34:	89 50 48             	mov    %edx,0x48(%eax)
    (*cpu)->CPU_ARG0 = heap_top;
c010bd37:	8b 45 08             	mov    0x8(%ebp),%eax
c010bd3a:	8b 00                	mov    (%eax),%eax
c010bd3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bd3f:	89 50 28             	mov    %edx,0x28(%eax)
}
c010bd42:	c9                   	leave  
c010bd43:	c3                   	ret    

c010bd44 <INIT_HEAP>:

/**
 *  @brief Initiates the dynamic memory management module.
 */
void INIT_HEAP(void)
{
c010bd44:	55                   	push   %ebp
c010bd45:	89 e5                	mov    %esp,%ebp
c010bd47:	83 ec 08             	sub    $0x8,%esp
    used_blocks = create_block();
c010bd4a:	e8 28 00 00 00       	call   c010bd77 <create_block>
c010bd4f:	a3 34 90 11 c0       	mov    %eax,0xc0119034
    free_blocks = create_block();
c010bd54:	e8 1e 00 00 00       	call   c010bd77 <create_block>
c010bd59:	a3 38 90 11 c0       	mov    %eax,0xc0119038
    free_blocks->fragments[0].base = MEMORY_LAYOUT_KERNEL_HEAP_START;
c010bd5e:	a1 38 90 11 c0       	mov    0xc0119038,%eax
c010bd63:	c7 40 04 00 00 00 e0 	movl   $0xe0000000,0x4(%eax)
    free_blocks->fragments[0].size = MEMORY_LAYOUT_KERNEL_HEAP_END - MEMORY_LAYOUT_KERNEL_HEAP_START;
c010bd6a:	a1 38 90 11 c0       	mov    0xc0119038,%eax
c010bd6f:	c7 00 00 00 80 1f    	movl   $0x1f800000,(%eax)
}
c010bd75:	c9                   	leave  
c010bd76:	c3                   	ret    

c010bd77 <create_block>:
/**
 *  @brief Allocates header block for internal memory management structs.
 *  @return Pointer to the new header block
 */
struct header_block *create_block(void)
{
c010bd77:	55                   	push   %ebp
c010bd78:	89 e5                	mov    %esp,%ebp
c010bd7a:	83 ec 28             	sub    $0x28,%esp
    struct header_block *block = (struct header_block *) vmm_automap_kernel(current_context, pmm_alloc_page(), VMM_WRITABLE);
c010bd7d:	e8 32 37 00 00       	call   c010f4b4 <pmm_alloc_page>
c010bd82:	8b 15 30 90 11 c0    	mov    0xc0119030,%edx
c010bd88:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c010bd8f:	00 
c010bd90:	89 44 24 04          	mov    %eax,0x4(%esp)
c010bd94:	89 14 24             	mov    %edx,(%esp)
c010bd97:	e8 e5 fb ff ff       	call   c010b981 <vmm_automap_kernel>
c010bd9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memset((void*)block, 0, PAGE_SIZE);
c010bd9f:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010bda6:	00 
c010bda7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010bdae:	00 
c010bdaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bdb2:	89 04 24             	mov    %eax,(%esp)
c010bdb5:	e8 5f 76 ff ff       	call   c0103419 <memset>

    return block;
c010bdba:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010bdbd:	c9                   	leave  
c010bdbe:	c3                   	ret    

c010bdbf <heap_add_fragment>:
 *  @param header The Header block.
 *  @param base   The base adress of the new fragment.
 *  @param size   The size of the new Fragment.
 */
void heap_add_fragment(struct header_block *header, vaddr_t base, size_t size)
{
c010bdbf:	55                   	push   %ebp
c010bdc0:	89 e5                	mov    %esp,%ebp
c010bdc2:	83 ec 18             	sub    $0x18,%esp
    // go through all header blocks...
    while(header != NULL)
c010bdc5:	eb 66                	jmp    c010be2d <heap_add_fragment+0x6e>
    {
        int i;

        // go through all fragments...
        for(i = 0; i < 511; i++)
c010bdc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010bdce:	eb 2d                	jmp    c010bdfd <heap_add_fragment+0x3e>
        {
            if(header->fragments[i].base == 0)
c010bdd0:	8b 45 08             	mov    0x8(%ebp),%eax
c010bdd3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bdd6:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
c010bdda:	85 c0                	test   %eax,%eax
c010bddc:	75 1b                	jne    c010bdf9 <heap_add_fragment+0x3a>
            {
                header->fragments[i].base = base;
c010bdde:	8b 45 08             	mov    0x8(%ebp),%eax
c010bde1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bde4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010bde7:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
                header->fragments[i].size = size;
c010bdeb:	8b 45 08             	mov    0x8(%ebp),%eax
c010bdee:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bdf1:	8b 4d 10             	mov    0x10(%ebp),%ecx
c010bdf4:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
#if HEAP_DEBUG
                printf("[heap/add] %p, %d to %p\n", base, size, header);
#endif
                return;
c010bdf7:	eb 3a                	jmp    c010be33 <heap_add_fragment+0x74>
    while(header != NULL)
    {
        int i;

        // go through all fragments...
        for(i = 0; i < 511; i++)
c010bdf9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010bdfd:	81 7d f4 fe 01 00 00 	cmpl   $0x1fe,-0xc(%ebp)
c010be04:	7e ca                	jle    c010bdd0 <heap_add_fragment+0x11>
#endif
                return;
            }
        }

        if(header->next == NULL)
c010be06:	8b 45 08             	mov    0x8(%ebp),%eax
c010be09:	8b 80 f8 0f 00 00    	mov    0xff8(%eax),%eax
c010be0f:	85 c0                	test   %eax,%eax
c010be11:	75 0e                	jne    c010be21 <heap_add_fragment+0x62>
        {
            header->next = create_block();
c010be13:	e8 5f ff ff ff       	call   c010bd77 <create_block>
c010be18:	8b 55 08             	mov    0x8(%ebp),%edx
c010be1b:	89 82 f8 0f 00 00    	mov    %eax,0xff8(%edx)
        }

        header = header->next;
c010be21:	8b 45 08             	mov    0x8(%ebp),%eax
c010be24:	8b 80 f8 0f 00 00    	mov    0xff8(%eax),%eax
c010be2a:	89 45 08             	mov    %eax,0x8(%ebp)
 *  @param size   The size of the new Fragment.
 */
void heap_add_fragment(struct header_block *header, vaddr_t base, size_t size)
{
    // go through all header blocks...
    while(header != NULL)
c010be2d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010be31:	75 94                	jne    c010bdc7 <heap_add_fragment+0x8>
            header->next = create_block();
        }

        header = header->next;
    }
}
c010be33:	c9                   	leave  
c010be34:	c3                   	ret    

c010be35 <heap_remove_fragment>:
 *  @param header Header Block.
 *  @param base   Base address of the fragment to remove.
 *  @return size  0 = failure else the size fo the removed fragment
 */
size_t heap_remove_fragment(struct header_block *header, vaddr_t base)
{
c010be35:	55                   	push   %ebp
c010be36:	89 e5                	mov    %esp,%ebp
c010be38:	83 ec 10             	sub    $0x10,%esp
    // go through all header blocks...
    while(header != NULL)
c010be3b:	eb 4a                	jmp    c010be87 <heap_remove_fragment+0x52>
    {
        int i;

        // go through all fragments...
        for(i = 0; i < 511; i++)
c010be3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010be44:	eb 2c                	jmp    c010be72 <heap_remove_fragment+0x3d>
        {
            if(header->fragments[i].base == base)
c010be46:	8b 45 08             	mov    0x8(%ebp),%eax
c010be49:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010be4c:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
c010be50:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010be53:	75 19                	jne    c010be6e <heap_remove_fragment+0x39>
            {
                header->fragments[i].base = 0;
c010be55:	8b 45 08             	mov    0x8(%ebp),%eax
c010be58:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010be5b:	c7 44 d0 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,8)
c010be62:	00 
#if HEAP_DEBUG
                printf("[heap/remove] %p, %d from %p\n", base, header->fragments[i].size, header);
#endif
                return header->fragments[i].size;
c010be63:	8b 45 08             	mov    0x8(%ebp),%eax
c010be66:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010be69:	8b 04 d0             	mov    (%eax,%edx,8),%eax
c010be6c:	eb 24                	jmp    c010be92 <heap_remove_fragment+0x5d>
    while(header != NULL)
    {
        int i;

        // go through all fragments...
        for(i = 0; i < 511; i++)
c010be6e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010be72:	81 7d fc fe 01 00 00 	cmpl   $0x1fe,-0x4(%ebp)
c010be79:	7e cb                	jle    c010be46 <heap_remove_fragment+0x11>
#endif
                return header->fragments[i].size;
            }
        }

        header = header->next;
c010be7b:	8b 45 08             	mov    0x8(%ebp),%eax
c010be7e:	8b 80 f8 0f 00 00    	mov    0xff8(%eax),%eax
c010be84:	89 45 08             	mov    %eax,0x8(%ebp)
 *  @return size  0 = failure else the size fo the removed fragment
 */
size_t heap_remove_fragment(struct header_block *header, vaddr_t base)
{
    // go through all header blocks...
    while(header != NULL)
c010be87:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010be8b:	75 b0                	jne    c010be3d <heap_remove_fragment+0x8>
        }

        header = header->next;
    }

    return 0;
c010be8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010be92:	c9                   	leave  
c010be93:	c3                   	ret    

c010be94 <heap_provide_address>:
 *  @brief provide a specific data area
 *  @param start pointer to begin of data
 *  @param end pointer to end of data
 */
void heap_provide_address(vaddr_t start, vaddr_t end)
{
c010be94:	55                   	push   %ebp
c010be95:	89 e5                	mov    %esp,%ebp
c010be97:	83 ec 28             	sub    $0x28,%esp
    int pages = NUM_PAGES(end - (start & PAGE_MASK));
c010be9a:	8b 45 08             	mov    0x8(%ebp),%eax
c010be9d:	89 c2                	mov    %eax,%edx
c010be9f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010bea5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010bea8:	29 d0                	sub    %edx,%eax
c010beaa:	05 ff 0f 00 00       	add    $0xfff,%eax
c010beaf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010beb4:	c1 e8 0c             	shr    $0xc,%eax
c010beb7:	89 45 ec             	mov    %eax,-0x14(%ebp)

    paddr_t pframe = 0;
c010beba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    vaddr_t vframe = start & PAGE_MASK;
c010bec1:	8b 45 08             	mov    0x8(%ebp),%eax
c010bec4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010bec9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int i;
    for(i = 0; i < pages; i++)
c010becc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010bed3:	eb 66                	jmp    c010bf3b <heap_provide_address+0xa7>
    {
        if(! arch_vmm_is_present(&current_context->arch_context, vframe) &&
c010bed5:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010beda:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bedd:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bee1:	89 04 24             	mov    %eax,(%esp)
c010bee4:	e8 1f 1a 00 00       	call   c010d908 <arch_vmm_is_present>
c010bee9:	85 c0                	test   %eax,%eax
c010beeb:	75 43                	jne    c010bf30 <heap_provide_address+0x9c>
                arch_vaddr2paddr(&current_context->arch_context, vframe) == 0)
c010beed:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010bef2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bef5:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bef9:	89 04 24             	mov    %eax,(%esp)
c010befc:	e8 74 1a 00 00       	call   c010d975 <arch_vaddr2paddr>
    vaddr_t vframe = start & PAGE_MASK;

    int i;
    for(i = 0; i < pages; i++)
    {
        if(! arch_vmm_is_present(&current_context->arch_context, vframe) &&
c010bf01:	85 c0                	test   %eax,%eax
c010bf03:	75 2b                	jne    c010bf30 <heap_provide_address+0x9c>
                arch_vaddr2paddr(&current_context->arch_context, vframe) == 0)
        {
            pframe = pmm_alloc_page();
c010bf05:	e8 aa 35 00 00       	call   c010f4b4 <pmm_alloc_page>
c010bf0a:	89 45 e8             	mov    %eax,-0x18(%ebp)
            vmm_map(current_context, pframe, vframe, VMM_WRITABLE);
c010bf0d:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010bf12:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c010bf19:	00 
c010bf1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010bf1d:	89 54 24 08          	mov    %edx,0x8(%esp)
c010bf21:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010bf24:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bf28:	89 04 24             	mov    %eax,(%esp)
c010bf2b:	e8 68 f9 ff ff       	call   c010b898 <vmm_map>
        }
        vframe += PAGE_SIZE;
c010bf30:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)

    paddr_t pframe = 0;
    vaddr_t vframe = start & PAGE_MASK;

    int i;
    for(i = 0; i < pages; i++)
c010bf37:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010bf3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010bf3e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c010bf41:	7c 92                	jl     c010bed5 <heap_provide_address+0x41>
            pframe = pmm_alloc_page();
            vmm_map(current_context, pframe, vframe, VMM_WRITABLE);
        }
        vframe += PAGE_SIZE;
    }
}
c010bf43:	c9                   	leave  
c010bf44:	c3                   	ret    

c010bf45 <malloc>:
 * @brief Search for a free address and mark it as used.
 * @param size number of bytes
 * @return pointer to reserved bytes
 */
void *malloc(size_t bytes)
{
c010bf45:	55                   	push   %ebp
c010bf46:	89 e5                	mov    %esp,%ebp
c010bf48:	83 ec 28             	sub    $0x28,%esp
    struct header_block *header = free_blocks;
c010bf4b:	a1 38 90 11 c0       	mov    0xc0119038,%eax
c010bf50:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // go through all header blocks...
    while(header != NULL)
c010bf53:	e9 e1 00 00 00       	jmp    c010c039 <malloc+0xf4>
    {
        int i;

        // go through all fragments...
        for(i = 0; i < 511; i++)
c010bf58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010bf5f:	e9 bc 00 00 00       	jmp    c010c020 <malloc+0xdb>
        {
            if(header->fragments[i].base == 0)
c010bf64:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bf67:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bf6a:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
c010bf6e:	85 c0                	test   %eax,%eax
c010bf70:	0f 84 a5 00 00 00    	je     c010c01b <malloc+0xd6>
            {
                continue;
            }

            if(header->fragments[i].size >= bytes)
c010bf76:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bf79:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bf7c:	8b 04 d0             	mov    (%eax,%edx,8),%eax
c010bf7f:	3b 45 08             	cmp    0x8(%ebp),%eax
c010bf82:	0f 82 94 00 00 00    	jb     c010c01c <malloc+0xd7>
            {
                // found some space.
                vaddr_t base = header->fragments[i].base;
c010bf88:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bf8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bf8e:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
c010bf92:	89 45 ec             	mov    %eax,-0x14(%ebp)

#if HEAP_DEBUG
                printf("[heap/malloc] %p (%d >= %d) in %p\n", base, header->fragments[i].size,bytes, header);
#endif

                if(header->fragments[i].size > bytes)
c010bf95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bf98:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bf9b:	8b 04 d0             	mov    (%eax,%edx,8),%eax
c010bf9e:	3b 45 08             	cmp    0x8(%ebp),%eax
c010bfa1:	76 33                	jbe    c010bfd6 <malloc+0x91>
                {
                    // shrink fragment
                    header->fragments[i].base += bytes;
c010bfa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bfa6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bfa9:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
c010bfad:	8b 45 08             	mov    0x8(%ebp),%eax
c010bfb0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c010bfb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bfb6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bfb9:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
                    header->fragments[i].size -= bytes;
c010bfbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bfc0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bfc3:	8b 04 d0             	mov    (%eax,%edx,8),%eax
c010bfc6:	89 c1                	mov    %eax,%ecx
c010bfc8:	2b 4d 08             	sub    0x8(%ebp),%ecx
c010bfcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bfce:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bfd1:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
c010bfd4:	eb 0e                	jmp    c010bfe4 <malloc+0x9f>
                }
                else
                {
                    // remove fragment
                    header->fragments[i].base = 0;
c010bfd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010bfd9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010bfdc:	c7 44 d0 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,8)
c010bfe3:	00 
                }

                // add fragment to used list
                heap_add_fragment(used_blocks, base, bytes);
c010bfe4:	a1 34 90 11 c0       	mov    0xc0119034,%eax
c010bfe9:	8b 55 08             	mov    0x8(%ebp),%edx
c010bfec:	89 54 24 08          	mov    %edx,0x8(%esp)
c010bff0:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010bff3:	89 54 24 04          	mov    %edx,0x4(%esp)
c010bff7:	89 04 24             	mov    %eax,(%esp)
c010bffa:	e8 c0 fd ff ff       	call   c010bdbf <heap_add_fragment>

                // make sure that everything is mapped
                heap_provide_address(base, base + bytes);
c010bfff:	8b 45 08             	mov    0x8(%ebp),%eax
c010c002:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010c005:	01 d0                	add    %edx,%eax
c010c007:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c00b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010c00e:	89 04 24             	mov    %eax,(%esp)
c010c011:	e8 7e fe ff ff       	call   c010be94 <heap_provide_address>

                return (void *)base;
c010c016:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010c019:	eb 36                	jmp    c010c051 <malloc+0x10c>
        // go through all fragments...
        for(i = 0; i < 511; i++)
        {
            if(header->fragments[i].base == 0)
            {
                continue;
c010c01b:	90                   	nop
    while(header != NULL)
    {
        int i;

        // go through all fragments...
        for(i = 0; i < 511; i++)
c010c01c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010c020:	81 7d f0 fe 01 00 00 	cmpl   $0x1fe,-0x10(%ebp)
c010c027:	0f 8e 37 ff ff ff    	jle    c010bf64 <malloc+0x1f>

                return (void *)base;
            }
        }

        header = header->next;
c010c02d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c030:	8b 80 f8 0f 00 00    	mov    0xff8(%eax),%eax
c010c036:	89 45 f4             	mov    %eax,-0xc(%ebp)
void *malloc(size_t bytes)
{
    struct header_block *header = free_blocks;

    // go through all header blocks...
    while(header != NULL)
c010c039:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010c03d:	0f 85 15 ff ff ff    	jne    c010bf58 <malloc+0x13>

        header = header->next;
    }

    // no more memory :'(
    printf("!!! ERROR: no memory for malloc.. !!!\n");
c010c043:	c7 04 24 50 0e 11 c0 	movl   $0xc0110e50,(%esp)
c010c04a:	e8 50 02 00 00       	call   c010c29f <puts>
    while(1);
c010c04f:	eb fe                	jmp    c010c04f <malloc+0x10a>

    return NULL;
}
c010c051:	c9                   	leave  
c010c052:	c3                   	ret    

c010c053 <free>:
/**
 *  @brief Free a range of bytes in the heap
 *  @param ptr pointer
 */
void free(void *ptr)
{
c010c053:	55                   	push   %ebp
c010c054:	89 e5                	mov    %esp,%ebp
c010c056:	83 ec 28             	sub    $0x28,%esp
    size_t bytes = heap_remove_fragment(used_blocks, (vaddr_t) ptr);
c010c059:	8b 55 08             	mov    0x8(%ebp),%edx
c010c05c:	a1 34 90 11 c0       	mov    0xc0119034,%eax
c010c061:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c065:	89 04 24             	mov    %eax,(%esp)
c010c068:	e8 c8 fd ff ff       	call   c010be35 <heap_remove_fragment>
c010c06d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    heap_add_fragment(free_blocks, (vaddr_t)ptr, bytes);
c010c070:	8b 55 08             	mov    0x8(%ebp),%edx
c010c073:	a1 38 90 11 c0       	mov    0xc0119038,%eax
c010c078:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010c07b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010c07f:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c083:	89 04 24             	mov    %eax,(%esp)
c010c086:	e8 34 fd ff ff       	call   c010bdbf <heap_add_fragment>
}
c010c08b:	c9                   	leave  
c010c08c:	c3                   	ret    

c010c08d <calloc>:
 * @param num number of blocks
 * @param size size of one block
 * @return pointer to allocated memory
 */
void *calloc(size_t num, size_t size)
{
c010c08d:	55                   	push   %ebp
c010c08e:	89 e5                	mov    %esp,%ebp
c010c090:	83 ec 28             	sub    $0x28,%esp
    size_t bytes = num * size;
c010c093:	8b 45 08             	mov    0x8(%ebp),%eax
c010c096:	0f af 45 0c          	imul   0xc(%ebp),%eax
c010c09a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    void *data = malloc(bytes);
c010c09d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c0a0:	89 04 24             	mov    %eax,(%esp)
c010c0a3:	e8 9d fe ff ff       	call   c010bf45 <malloc>
c010c0a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(data, 0, bytes);
c010c0ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c0ae:	89 44 24 08          	mov    %eax,0x8(%esp)
c010c0b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010c0b9:	00 
c010c0ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010c0bd:	89 04 24             	mov    %eax,(%esp)
c010c0c0:	e8 54 73 ff ff       	call   c0103419 <memset>

    return data;
c010c0c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010c0c8:	c9                   	leave  
c010c0c9:	c3                   	ret    

c010c0ca <realloc>:
 *  @param ptr pointer to old location
 *  @param size new size
 *  @return new pointer
 */
void *realloc(void *ptr, size_t size)
{
c010c0ca:	55                   	push   %ebp
c010c0cb:	89 e5                	mov    %esp,%ebp
c010c0cd:	83 ec 28             	sub    $0x28,%esp
    // get fragment size and remove
    size_t old_size = heap_remove_fragment(used_blocks, (vaddr_t) ptr);
c010c0d0:	8b 55 08             	mov    0x8(%ebp),%edx
c010c0d3:	a1 34 90 11 c0       	mov    0xc0119034,%eax
c010c0d8:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c0dc:	89 04 24             	mov    %eax,(%esp)
c010c0df:	e8 51 fd ff ff       	call   c010be35 <heap_remove_fragment>
c010c0e4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // malloc new
    void *dest = malloc(size);
c010c0e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c010c0ea:	89 04 24             	mov    %eax,(%esp)
c010c0ed:	e8 53 fe ff ff       	call   c010bf45 <malloc>
c010c0f2:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // copy data from old to new
    size_t copy_size = (size > old_size) ? old_size : size;
c010c0f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c0f8:	39 45 0c             	cmp    %eax,0xc(%ebp)
c010c0fb:	0f 46 45 0c          	cmovbe 0xc(%ebp),%eax
c010c0ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
    memcpy(dest, ptr, copy_size);
c010c102:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010c105:	89 44 24 08          	mov    %eax,0x8(%esp)
c010c109:	8b 45 08             	mov    0x8(%ebp),%eax
c010c10c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c110:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010c113:	89 04 24             	mov    %eax,(%esp)
c010c116:	e8 88 71 ff ff       	call   c01032a3 <memcpy>

    return dest;
c010c11b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010c11e:	c9                   	leave  
c010c11f:	c3                   	ret    

c010c120 <outb>:
    asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
    return result;
}

static inline void outb(uint16_t port, uint8_t value)
{
c010c120:	55                   	push   %ebp
c010c121:	89 e5                	mov    %esp,%ebp
c010c123:	83 ec 08             	sub    $0x8,%esp
c010c126:	8b 55 08             	mov    0x8(%ebp),%edx
c010c129:	8b 45 0c             	mov    0xc(%ebp),%eax
c010c12c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010c130:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c010c133:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c010c137:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c010c13b:	ee                   	out    %al,(%dx)
}
c010c13c:	c9                   	leave  
c010c13d:	c3                   	ret    

c010c13e <putchar>:

color_t cga_color = WHITE | (BLACK << 4);
static char *video_mem = (char *)0xc00b8000;

int putchar(int c)
{
c010c13e:	55                   	push   %ebp
c010c13f:	89 e5                	mov    %esp,%ebp
c010c141:	83 ec 18             	sub    $0x18,%esp
    if (c == '\b')
c010c144:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
c010c148:	0f 85 87 00 00 00    	jne    c010c1d5 <putchar+0x97>
    {
        if (x > 0)
c010c14e:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c153:	85 c0                	test   %eax,%eax
c010c155:	7e 2b                	jle    c010c182 <putchar+0x44>
        {
            gotoxy(--x, y);
c010c157:	a1 40 90 11 c0       	mov    0xc0119040,%eax
c010c15c:	0f b6 d0             	movzbl %al,%edx
c010c15f:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c164:	83 e8 01             	sub    $0x1,%eax
c010c167:	a3 3c 90 11 c0       	mov    %eax,0xc011903c
c010c16c:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c171:	0f b6 c0             	movzbl %al,%eax
c010c174:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c178:	89 04 24             	mov    %eax,(%esp)
c010c17b:	e8 0d 02 00 00       	call   c010c38d <gotoxy>
c010c180:	eb 25                	jmp    c010c1a7 <putchar+0x69>
        }
        else
        {
            gotoxy(columns - 1, --y);
c010c182:	a1 40 90 11 c0       	mov    0xc0119040,%eax
c010c187:	83 e8 01             	sub    $0x1,%eax
c010c18a:	a3 40 90 11 c0       	mov    %eax,0xc0119040
c010c18f:	a1 40 90 11 c0       	mov    0xc0119040,%eax
c010c194:	0f b6 c0             	movzbl %al,%eax
c010c197:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c19b:	c7 04 24 4f 00 00 00 	movl   $0x4f,(%esp)
c010c1a2:	e8 e6 01 00 00       	call   c010c38d <gotoxy>
        }

        video_mem[2 * (y * columns + x)] = 0;
c010c1a7:	8b 0d 28 21 11 c0    	mov    0xc0112128,%ecx
c010c1ad:	8b 15 40 90 11 c0    	mov    0xc0119040,%edx
c010c1b3:	89 d0                	mov    %edx,%eax
c010c1b5:	c1 e0 02             	shl    $0x2,%eax
c010c1b8:	01 d0                	add    %edx,%eax
c010c1ba:	c1 e0 04             	shl    $0x4,%eax
c010c1bd:	89 c2                	mov    %eax,%edx
c010c1bf:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c1c4:	01 d0                	add    %edx,%eax
c010c1c6:	01 c0                	add    %eax,%eax
c010c1c8:	01 c8                	add    %ecx,%eax
c010c1ca:	c6 00 00             	movb   $0x0,(%eax)

        return c;
c010c1cd:	8b 45 08             	mov    0x8(%ebp),%eax
c010c1d0:	e9 c8 00 00 00       	jmp    c010c29d <putchar+0x15f>
    }

    if ((x > columns - 1) || (c == '\n'))
c010c1d5:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c1da:	83 f8 4f             	cmp    $0x4f,%eax
c010c1dd:	7f 06                	jg     c010c1e5 <putchar+0xa7>
c010c1df:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c010c1e3:	75 33                	jne    c010c218 <putchar+0xda>
    {
        gotoxy(0, ++y);
c010c1e5:	a1 40 90 11 c0       	mov    0xc0119040,%eax
c010c1ea:	83 c0 01             	add    $0x1,%eax
c010c1ed:	a3 40 90 11 c0       	mov    %eax,0xc0119040
c010c1f2:	a1 40 90 11 c0       	mov    0xc0119040,%eax
c010c1f7:	0f b6 c0             	movzbl %al,%eax
c010c1fa:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c1fe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010c205:	e8 83 01 00 00       	call   c010c38d <gotoxy>

        if (c == '\n')
c010c20a:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c010c20e:	75 08                	jne    c010c218 <putchar+0xda>
        {
            return c;
c010c210:	8b 45 08             	mov    0x8(%ebp),%eax
c010c213:	e9 85 00 00 00       	jmp    c010c29d <putchar+0x15f>
        }
    }

    video_mem[2 * (y * columns + x)] = c;
c010c218:	8b 0d 28 21 11 c0    	mov    0xc0112128,%ecx
c010c21e:	8b 15 40 90 11 c0    	mov    0xc0119040,%edx
c010c224:	89 d0                	mov    %edx,%eax
c010c226:	c1 e0 02             	shl    $0x2,%eax
c010c229:	01 d0                	add    %edx,%eax
c010c22b:	c1 e0 04             	shl    $0x4,%eax
c010c22e:	89 c2                	mov    %eax,%edx
c010c230:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c235:	01 d0                	add    %edx,%eax
c010c237:	01 c0                	add    %eax,%eax
c010c239:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c010c23c:	8b 45 08             	mov    0x8(%ebp),%eax
c010c23f:	88 02                	mov    %al,(%edx)
    video_mem[2 * (y * columns + x) + 1] = cga_color;
c010c241:	8b 0d 28 21 11 c0    	mov    0xc0112128,%ecx
c010c247:	8b 15 40 90 11 c0    	mov    0xc0119040,%edx
c010c24d:	89 d0                	mov    %edx,%eax
c010c24f:	c1 e0 02             	shl    $0x2,%eax
c010c252:	01 d0                	add    %edx,%eax
c010c254:	c1 e0 04             	shl    $0x4,%eax
c010c257:	89 c2                	mov    %eax,%edx
c010c259:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c25e:	01 d0                	add    %edx,%eax
c010c260:	01 c0                	add    %eax,%eax
c010c262:	83 c0 01             	add    $0x1,%eax
c010c265:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c010c268:	0f b6 05 24 21 11 c0 	movzbl 0xc0112124,%eax
c010c26f:	88 02                	mov    %al,(%edx)

    gotoxy(++x, y);
c010c271:	a1 40 90 11 c0       	mov    0xc0119040,%eax
c010c276:	0f b6 d0             	movzbl %al,%edx
c010c279:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c27e:	83 c0 01             	add    $0x1,%eax
c010c281:	a3 3c 90 11 c0       	mov    %eax,0xc011903c
c010c286:	a1 3c 90 11 c0       	mov    0xc011903c,%eax
c010c28b:	0f b6 c0             	movzbl %al,%eax
c010c28e:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c292:	89 04 24             	mov    %eax,(%esp)
c010c295:	e8 f3 00 00 00       	call   c010c38d <gotoxy>

    return c;
c010c29a:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010c29d:	c9                   	leave  
c010c29e:	c3                   	ret    

c010c29f <puts>:

int puts(const char* s)
{
c010c29f:	55                   	push   %ebp
c010c2a0:	89 e5                	mov    %esp,%ebp
c010c2a2:	83 ec 28             	sub    $0x28,%esp
    int printed = 1;
c010c2a5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

    while (*s)
c010c2ac:	eb 19                	jmp    c010c2c7 <puts+0x28>
    {
        putchar(*s++);
c010c2ae:	8b 45 08             	mov    0x8(%ebp),%eax
c010c2b1:	0f b6 00             	movzbl (%eax),%eax
c010c2b4:	0f be c0             	movsbl %al,%eax
c010c2b7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c010c2bb:	89 04 24             	mov    %eax,(%esp)
c010c2be:	e8 7b fe ff ff       	call   c010c13e <putchar>
        ++printed;
c010c2c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)

int puts(const char* s)
{
    int printed = 1;

    while (*s)
c010c2c7:	8b 45 08             	mov    0x8(%ebp),%eax
c010c2ca:	0f b6 00             	movzbl (%eax),%eax
c010c2cd:	84 c0                	test   %al,%al
c010c2cf:	75 dd                	jne    c010c2ae <puts+0xf>
    {
        putchar(*s++);
        ++printed;
    }
    putchar('\n');
c010c2d1:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c010c2d8:	e8 61 fe ff ff       	call   c010c13e <putchar>

    return printed;
c010c2dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010c2e0:	c9                   	leave  
c010c2e1:	c3                   	ret    

c010c2e2 <fputs>:

int fputs(const char* s, int fd)
{
c010c2e2:	55                   	push   %ebp
c010c2e3:	89 e5                	mov    %esp,%ebp
c010c2e5:	83 ec 18             	sub    $0x18,%esp
    if (fd == STDOUT)
c010c2e8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c010c2ec:	75 21                	jne    c010c30f <fputs+0x2d>
    {
        while (*s)
c010c2ee:	eb 15                	jmp    c010c305 <fputs+0x23>
        {
            putchar(*s++);
c010c2f0:	8b 45 08             	mov    0x8(%ebp),%eax
c010c2f3:	0f b6 00             	movzbl (%eax),%eax
c010c2f6:	0f be c0             	movsbl %al,%eax
c010c2f9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c010c2fd:	89 04 24             	mov    %eax,(%esp)
c010c300:	e8 39 fe ff ff       	call   c010c13e <putchar>

int fputs(const char* s, int fd)
{
    if (fd == STDOUT)
    {
        while (*s)
c010c305:	8b 45 08             	mov    0x8(%ebp),%eax
c010c308:	0f b6 00             	movzbl (%eax),%eax
c010c30b:	84 c0                	test   %al,%al
c010c30d:	75 e1                	jne    c010c2f0 <fputs+0xe>
        {
            putchar(*s++);
        }
    }

    return 0;
c010c30f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010c314:	c9                   	leave  
c010c315:	c3                   	ret    

c010c316 <clear_screen>:

void clear_screen(void)
{
c010c316:	55                   	push   %ebp
c010c317:	89 e5                	mov    %esp,%ebp
c010c319:	83 ec 28             	sub    $0x28,%esp
    int i;
    for (i = 0; i < lines * columns; i++)
c010c31c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010c323:	eb 26                	jmp    c010c34b <clear_screen+0x35>
    {
        video_mem[2 * i] = 0;
c010c325:	8b 15 28 21 11 c0    	mov    0xc0112128,%edx
c010c32b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c32e:	01 c0                	add    %eax,%eax
c010c330:	01 d0                	add    %edx,%eax
c010c332:	c6 00 00             	movb   $0x0,(%eax)
        video_mem[2 * i + 1] = 0;
c010c335:	a1 28 21 11 c0       	mov    0xc0112128,%eax
c010c33a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010c33d:	01 d2                	add    %edx,%edx
c010c33f:	83 c2 01             	add    $0x1,%edx
c010c342:	01 d0                	add    %edx,%eax
c010c344:	c6 00 00             	movb   $0x0,(%eax)
}

void clear_screen(void)
{
    int i;
    for (i = 0; i < lines * columns; i++)
c010c347:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010c34b:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
c010c352:	7e d1                	jle    c010c325 <clear_screen+0xf>
    {
        video_mem[2 * i] = 0;
        video_mem[2 * i + 1] = 0;
    }

    gotoxy(0, 0);
c010c354:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010c35b:	00 
c010c35c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010c363:	e8 25 00 00 00       	call   c010c38d <gotoxy>
}
c010c368:	c9                   	leave  
c010c369:	c3                   	ret    

c010c36a <set_color>:

void set_color(color_t _color)
{
c010c36a:	55                   	push   %ebp
c010c36b:	89 e5                	mov    %esp,%ebp
c010c36d:	83 ec 04             	sub    $0x4,%esp
c010c370:	8b 45 08             	mov    0x8(%ebp),%eax
c010c373:	88 45 fc             	mov    %al,-0x4(%ebp)
    cga_color = _color;
c010c376:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c010c37a:	a2 24 21 11 c0       	mov    %al,0xc0112124
}
c010c37f:	c9                   	leave  
c010c380:	c3                   	ret    

c010c381 <get_color>:

color_t get_color(void)
{
c010c381:	55                   	push   %ebp
c010c382:	89 e5                	mov    %esp,%ebp
    return cga_color;
c010c384:	0f b6 05 24 21 11 c0 	movzbl 0xc0112124,%eax
}
c010c38b:	5d                   	pop    %ebp
c010c38c:	c3                   	ret    

c010c38d <gotoxy>:

void gotoxy(uint8_t _x, uint8_t _y)
{
c010c38d:	55                   	push   %ebp
c010c38e:	89 e5                	mov    %esp,%ebp
c010c390:	83 ec 38             	sub    $0x38,%esp
c010c393:	8b 55 08             	mov    0x8(%ebp),%edx
c010c396:	8b 45 0c             	mov    0xc(%ebp),%eax
c010c399:	88 55 e4             	mov    %dl,-0x1c(%ebp)
c010c39c:	88 45 e0             	mov    %al,-0x20(%ebp)
    uint16_t offset;

    if ((_y * columns + _x) >= (columns * lines))   /* scroll if neccessary */
c010c39f:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
c010c3a3:	89 d0                	mov    %edx,%eax
c010c3a5:	c1 e0 02             	shl    $0x2,%eax
c010c3a8:	01 d0                	add    %edx,%eax
c010c3aa:	c1 e0 04             	shl    $0x4,%eax
c010c3ad:	89 c2                	mov    %eax,%edx
c010c3af:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010c3b3:	01 d0                	add    %edx,%eax
c010c3b5:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c010c3ba:	7e 76                	jle    c010c432 <gotoxy+0xa5>
    {
        memmove(video_mem, video_mem + 2 * columns, 2 * lines * columns);
c010c3bc:	a1 28 21 11 c0       	mov    0xc0112128,%eax
c010c3c1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c010c3c7:	a1 28 21 11 c0       	mov    0xc0112128,%eax
c010c3cc:	c7 44 24 08 a0 0f 00 	movl   $0xfa0,0x8(%esp)
c010c3d3:	00 
c010c3d4:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c3d8:	89 04 24             	mov    %eax,(%esp)
c010c3db:	e8 04 6f ff ff       	call   c01032e4 <memmove>

        int i;
        for(i = 0; i < 2*columns; i++)
c010c3e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010c3e7:	eb 3c                	jmp    c010c425 <gotoxy+0x98>
        {
            if(i%2==0)
c010c3e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c3ec:	83 e0 01             	and    $0x1,%eax
c010c3ef:	85 c0                	test   %eax,%eax
c010c3f1:	75 15                	jne    c010c408 <gotoxy+0x7b>
                video_mem[2 * lines * columns + i] = 0;
c010c3f3:	8b 15 28 21 11 c0    	mov    0xc0112128,%edx
c010c3f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c3fc:	05 a0 0f 00 00       	add    $0xfa0,%eax
c010c401:	01 d0                	add    %edx,%eax
c010c403:	c6 00 00             	movb   $0x0,(%eax)
c010c406:	eb 19                	jmp    c010c421 <gotoxy+0x94>
            else
                video_mem[2 * lines * columns + i] = cga_color;
c010c408:	8b 15 28 21 11 c0    	mov    0xc0112128,%edx
c010c40e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c411:	05 a0 0f 00 00       	add    $0xfa0,%eax
c010c416:	01 c2                	add    %eax,%edx
c010c418:	0f b6 05 24 21 11 c0 	movzbl 0xc0112124,%eax
c010c41f:	88 02                	mov    %al,(%edx)
    if ((_y * columns + _x) >= (columns * lines))   /* scroll if neccessary */
    {
        memmove(video_mem, video_mem + 2 * columns, 2 * lines * columns);

        int i;
        for(i = 0; i < 2*columns; i++)
c010c421:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010c425:	81 7d f4 9f 00 00 00 	cmpl   $0x9f,-0xc(%ebp)
c010c42c:	7e bb                	jle    c010c3e9 <gotoxy+0x5c>
                video_mem[2 * lines * columns + i] = 0;
            else
                video_mem[2 * lines * columns + i] = cga_color;
        }

        --_y;
c010c42e:	80 6d e0 01          	subb   $0x1,-0x20(%ebp)
    }

    x = _x;
c010c432:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010c436:	a3 3c 90 11 c0       	mov    %eax,0xc011903c
    y = _y;
c010c43b:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c010c43f:	a3 40 90 11 c0       	mov    %eax,0xc0119040
    offset = _y * columns + _x;
c010c444:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
c010c448:	89 d0                	mov    %edx,%eax
c010c44a:	c1 e0 02             	shl    $0x2,%eax
c010c44d:	01 d0                	add    %edx,%eax
c010c44f:	c1 e0 04             	shl    $0x4,%eax
c010c452:	89 c2                	mov    %eax,%edx
c010c454:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010c458:	01 d0                	add    %edx,%eax
c010c45a:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

    if (video_mem[2 * offset] == 0)
c010c45e:	8b 15 28 21 11 c0    	mov    0xc0112128,%edx
c010c464:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c010c468:	01 c0                	add    %eax,%eax
c010c46a:	01 d0                	add    %edx,%eax
c010c46c:	0f b6 00             	movzbl (%eax),%eax
c010c46f:	84 c0                	test   %al,%al
c010c471:	75 19                	jne    c010c48c <gotoxy+0xff>
    {
        video_mem[2 * offset + 1] = cga_color;
c010c473:	a1 28 21 11 c0       	mov    0xc0112128,%eax
c010c478:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
c010c47c:	01 d2                	add    %edx,%edx
c010c47e:	83 c2 01             	add    $0x1,%edx
c010c481:	01 c2                	add    %eax,%edx
c010c483:	0f b6 05 24 21 11 c0 	movzbl 0xc0112124,%eax
c010c48a:	88 02                	mov    %al,(%edx)
    }


    outb(CRTC_INDEX_PORT, CRTC_CURSOR_LOCATION_HIGH);
c010c48c:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
c010c493:	00 
c010c494:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
c010c49b:	e8 80 fc ff ff       	call   c010c120 <outb>
    outb(CRTC_DATA_PORT, (uint8_t)(offset >> 8));
c010c4a0:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c010c4a4:	66 c1 e8 08          	shr    $0x8,%ax
c010c4a8:	0f b6 c0             	movzbl %al,%eax
c010c4ab:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c4af:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
c010c4b6:	e8 65 fc ff ff       	call   c010c120 <outb>

    outb(CRTC_INDEX_PORT, CRTC_CURSOR_LOCATION_LOW);
c010c4bb:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
c010c4c2:	00 
c010c4c3:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
c010c4ca:	e8 51 fc ff ff       	call   c010c120 <outb>
    outb(CRTC_DATA_PORT, (uint8_t)offset);
c010c4cf:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c010c4d3:	0f b6 c0             	movzbl %al,%eax
c010c4d6:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c4da:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
c010c4e1:	e8 3a fc ff ff       	call   c010c120 <outb>
c010c4e6:	c9                   	leave  
c010c4e7:	c3                   	ret    

c010c4e8 <arch_create_thread_context>:
 *  @param argv Argument sting array
 *  @param environ String array of enviroent varrables. (Terminated by a NULL pointer)
 *  @return NULL if an error occured or the same addres as context
 */
struct cpu_state *arch_create_thread_context(struct arch_thread_context *context, privilege_t prev, vaddr_t entry,vaddr_t return_adress, char **argv, char **environ)
{
c010c4e8:	55                   	push   %ebp
c010c4e9:	89 e5                	mov    %esp,%ebp
c010c4eb:	83 ec 78             	sub    $0x78,%esp
    void *kernel_stack = malloc(0x1000);
c010c4ee:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
c010c4f5:	e8 4b fa ff ff       	call   c010bf45 <malloc>
c010c4fa:	89 45 c0             	mov    %eax,-0x40(%ebp)
    struct cpu_state *new_state = kernel_stack + 0x1000 - sizeof(struct cpu_state) - 3*sizeof(uint32_t);
c010c4fd:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010c500:	05 ac 0f 00 00       	add    $0xfac,%eax
c010c505:	89 45 bc             	mov    %eax,-0x44(%ebp)

    context->kernel_mode_stack = (uint32_t)kernel_stack;
c010c508:	8b 55 c0             	mov    -0x40(%ebp),%edx
c010c50b:	8b 45 08             	mov    0x8(%ebp),%eax
c010c50e:	89 50 04             	mov    %edx,0x4(%eax)
    context->state = new_state;
c010c511:	8b 45 08             	mov    0x8(%ebp),%eax
c010c514:	8b 55 bc             	mov    -0x44(%ebp),%edx
c010c517:	89 10                	mov    %edx,(%eax)

    memset(new_state, 0, sizeof(struct cpu_state));
c010c519:	c7 44 24 08 48 00 00 	movl   $0x48,0x8(%esp)
c010c520:	00 
c010c521:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010c528:	00 
c010c529:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c52c:	89 04 24             	mov    %eax,(%esp)
c010c52f:	e8 e5 6e ff ff       	call   c0103419 <memset>
    new_state->eip = entry;
c010c534:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c537:	8b 55 10             	mov    0x10(%ebp),%edx
c010c53a:	89 50 34             	mov    %edx,0x34(%eax)
    new_state->eflags = 0x00000202;
c010c53d:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c540:	c7 40 3c 02 02 00 00 	movl   $0x202,0x3c(%eax)

    size_t argc = 0;
c010c547:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if(argv != NULL)
c010c54e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c010c552:	74 1b                	je     c010c56f <arch_create_thread_context+0x87>
    {
        while(argv[argc] != NULL)
c010c554:	eb 04                	jmp    c010c55a <arch_create_thread_context+0x72>
            argc++;
c010c556:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    new_state->eflags = 0x00000202;

    size_t argc = 0;
    if(argv != NULL)
    {
        while(argv[argc] != NULL)
c010c55a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c55d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c564:	8b 45 18             	mov    0x18(%ebp),%eax
c010c567:	01 d0                	add    %edx,%eax
c010c569:	8b 00                	mov    (%eax),%eax
c010c56b:	85 c0                	test   %eax,%eax
c010c56d:	75 e7                	jne    c010c556 <arch_create_thread_context+0x6e>
            argc++;
    }

    uint32_t *stack;
    if(prev == KERNELMODE)
c010c56f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010c573:	75 71                	jne    c010c5e6 <arch_create_thread_context+0xfe>
    {
        new_state->cs = 0x08;
c010c575:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c578:	c7 40 38 08 00 00 00 	movl   $0x8,0x38(%eax)
        new_state->ds = 0x10;
c010c57f:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c582:	c7 40 0c 10 00 00 00 	movl   $0x10,0xc(%eax)
        new_state->es = 0x10;
c010c589:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c58c:	c7 40 08 10 00 00 00 	movl   $0x10,0x8(%eax)
        new_state->fs = 0x10;
c010c593:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c596:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
        new_state->gs = 0x10;
c010c59d:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c5a0:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
        stack = kernel_stack + 0x1000;
c010c5a6:	8b 45 c0             	mov    -0x40(%ebp),%eax
c010c5a9:	05 00 10 00 00       	add    $0x1000,%eax
c010c5ae:	89 45 b8             	mov    %eax,-0x48(%ebp)
        *--stack = (uint32_t) return_adress;
c010c5b1:	83 6d b8 04          	subl   $0x4,-0x48(%ebp)
c010c5b5:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c5b8:	8b 55 14             	mov    0x14(%ebp),%edx
c010c5bb:	89 10                	mov    %edx,(%eax)
        *--stack = (uint32_t) environ;
c010c5bd:	83 6d b8 04          	subl   $0x4,-0x48(%ebp)
c010c5c1:	8b 55 1c             	mov    0x1c(%ebp),%edx
c010c5c4:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c5c7:	89 10                	mov    %edx,(%eax)
        *--stack = (uint32_t) argv;
c010c5c9:	83 6d b8 04          	subl   $0x4,-0x48(%ebp)
c010c5cd:	8b 55 18             	mov    0x18(%ebp),%edx
c010c5d0:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c5d3:	89 10                	mov    %edx,(%eax)
        *--stack = (uint32_t) argc;
c010c5d5:	83 6d b8 04          	subl   $0x4,-0x48(%ebp)
c010c5d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c5dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010c5df:	89 10                	mov    %edx,(%eax)
c010c5e1:	e9 50 04 00 00       	jmp    c010ca36 <arch_create_thread_context+0x54e>
    }
    else
    {
        vaddr_t *user_argv = NULL;
c010c5e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        if(argv != NULL)
c010c5ed:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c010c5f1:	0f 84 a4 01 00 00    	je     c010c79b <arch_create_thread_context+0x2b3>
        {
            size_t size = sizeof(char*);
c010c5f7:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)
            int i = 0;
c010c5fe:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            while(argv[i] != NULL)
c010c605:	eb 28                	jmp    c010c62f <arch_create_thread_context+0x147>
            {
                size += sizeof(char*) + strlen(argv[i]) + 1;
c010c607:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c60a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c611:	8b 45 18             	mov    0x18(%ebp),%eax
c010c614:	01 d0                	add    %edx,%eax
c010c616:	8b 00                	mov    (%eax),%eax
c010c618:	89 04 24             	mov    %eax,(%esp)
c010c61b:	e8 ad 68 ff ff       	call   c0102ecd <strlen>
c010c620:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010c623:	01 d0                	add    %edx,%eax
c010c625:	83 c0 05             	add    $0x5,%eax
c010c628:	89 45 ec             	mov    %eax,-0x14(%ebp)
                i++;
c010c62b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        vaddr_t *user_argv = NULL;
        if(argv != NULL)
        {
            size_t size = sizeof(char*);
            int i = 0;
            while(argv[i] != NULL)
c010c62f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c632:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c639:	8b 45 18             	mov    0x18(%ebp),%eax
c010c63c:	01 d0                	add    %edx,%eax
c010c63e:	8b 00                	mov    (%eax),%eax
c010c640:	85 c0                	test   %eax,%eax
c010c642:	75 c3                	jne    c010c607 <arch_create_thread_context+0x11f>
            {
                size += sizeof(char*) + strlen(argv[i]) + 1;
                i++;
            }

            if(size > 0)
c010c644:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010c648:	0f 84 4d 01 00 00    	je     c010c79b <arch_create_thread_context+0x2b3>
            {
                size_t pages = NUM_PAGES(size);
c010c64e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010c651:	05 ff 0f 00 00       	add    $0xfff,%eax
c010c656:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010c65b:	c1 e8 0c             	shr    $0xc,%eax
c010c65e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

                paddr_t vars = pmm_alloc_page_range(pages);
c010c661:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c010c664:	89 04 24             	mov    %eax,(%esp)
c010c667:	e8 27 2f 00 00       	call   c010f593 <pmm_alloc_page_range>
c010c66c:	89 45 b0             	mov    %eax,-0x50(%ebp)
                user_argv = (vaddr_t *)vmm_automap_user_range(&context->memory, vars, pages, VMM_PRESENT | VMM_WRITABLE | VMM_USER);
c010c66f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c010c672:	8b 55 08             	mov    0x8(%ebp),%edx
c010c675:	83 c2 0c             	add    $0xc,%edx
c010c678:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c010c67f:	00 
c010c680:	89 44 24 08          	mov    %eax,0x8(%esp)
c010c684:	8b 45 b0             	mov    -0x50(%ebp),%eax
c010c687:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c68b:	89 14 24             	mov    %edx,(%esp)
c010c68e:	e8 36 f4 ff ff       	call   c010bac9 <vmm_automap_user_range>
c010c693:	89 45 f0             	mov    %eax,-0x10(%ebp)
                vaddr_t *kernel_argv = (vaddr_t *) vmm_automap_kernel_range(current_context, vars, pages, VMM_PRESENT | VMM_WRITABLE);
c010c696:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c010c699:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010c69e:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c010c6a5:	00 
c010c6a6:	89 54 24 08          	mov    %edx,0x8(%esp)
c010c6aa:	8b 55 b0             	mov    -0x50(%ebp),%edx
c010c6ad:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c6b1:	89 04 24             	mov    %eax,(%esp)
c010c6b4:	e8 26 f3 ff ff       	call   c010b9df <vmm_automap_kernel_range>
c010c6b9:	89 45 ac             	mov    %eax,-0x54(%ebp)
                vaddr_t vbase =(vaddr_t)( user_argv+((argc+1)*sizeof(char *)));
c010c6bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c6bf:	83 c0 01             	add    $0x1,%eax
c010c6c2:	89 c2                	mov    %eax,%edx
c010c6c4:	c1 e2 04             	shl    $0x4,%edx
c010c6c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010c6ca:	01 d0                	add    %edx,%eax
c010c6cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                char *user_strs = (char*) (kernel_argv+(argc+1)*sizeof(char *));
c010c6cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c6d2:	83 c0 01             	add    $0x1,%eax
c010c6d5:	89 c2                	mov    %eax,%edx
c010c6d7:	c1 e2 04             	shl    $0x4,%edx
c010c6da:	8b 45 ac             	mov    -0x54(%ebp),%eax
c010c6dd:	01 d0                	add    %edx,%eax
c010c6df:	89 45 e0             	mov    %eax,-0x20(%ebp)
                for(i = 0; i < argc; i++)
c010c6e2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c010c6e9:	eb 7b                	jmp    c010c766 <arch_create_thread_context+0x27e>
                {
                    kernel_argv[i] = vbase;
c010c6eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c6ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c6f5:	8b 45 ac             	mov    -0x54(%ebp),%eax
c010c6f8:	01 c2                	add    %eax,%edx
c010c6fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010c6fd:	89 02                	mov    %eax,(%edx)
                    strcpy(user_strs, argv[i]);
c010c6ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c702:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c709:	8b 45 18             	mov    0x18(%ebp),%eax
c010c70c:	01 d0                	add    %edx,%eax
c010c70e:	8b 00                	mov    (%eax),%eax
c010c710:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c714:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010c717:	89 04 24             	mov    %eax,(%esp)
c010c71a:	e8 d5 67 ff ff       	call   c0102ef4 <strcpy>

                    user_strs += strlen(argv[i])+sizeof(char);
c010c71f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c722:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c729:	8b 45 18             	mov    0x18(%ebp),%eax
c010c72c:	01 d0                	add    %edx,%eax
c010c72e:	8b 00                	mov    (%eax),%eax
c010c730:	89 04 24             	mov    %eax,(%esp)
c010c733:	e8 95 67 ff ff       	call   c0102ecd <strlen>
c010c738:	83 c0 01             	add    $0x1,%eax
c010c73b:	01 45 e0             	add    %eax,-0x20(%ebp)
                    vbase += strlen(argv[i])+sizeof(char);
c010c73e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c741:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c748:	8b 45 18             	mov    0x18(%ebp),%eax
c010c74b:	01 d0                	add    %edx,%eax
c010c74d:	8b 00                	mov    (%eax),%eax
c010c74f:	89 04 24             	mov    %eax,(%esp)
c010c752:	e8 76 67 ff ff       	call   c0102ecd <strlen>
c010c757:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010c75a:	01 d0                	add    %edx,%eax
c010c75c:	83 c0 01             	add    $0x1,%eax
c010c75f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                user_argv = (vaddr_t *)vmm_automap_user_range(&context->memory, vars, pages, VMM_PRESENT | VMM_WRITABLE | VMM_USER);
                vaddr_t *kernel_argv = (vaddr_t *) vmm_automap_kernel_range(current_context, vars, pages, VMM_PRESENT | VMM_WRITABLE);
                vaddr_t vbase =(vaddr_t)( user_argv+((argc+1)*sizeof(char *)));

                char *user_strs = (char*) (kernel_argv+(argc+1)*sizeof(char *));
                for(i = 0; i < argc; i++)
c010c762:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010c766:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c769:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010c76c:	0f 82 79 ff ff ff    	jb     c010c6eb <arch_create_thread_context+0x203>
                    strcpy(user_strs, argv[i]);

                    user_strs += strlen(argv[i])+sizeof(char);
                    vbase += strlen(argv[i])+sizeof(char);
                }
                kernel_argv[i] = 0;
c010c772:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010c775:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c77c:	8b 45 ac             	mov    -0x54(%ebp),%eax
c010c77f:	01 d0                	add    %edx,%eax
c010c781:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

                vmm_unmap(current_context, (vaddr_t) kernel_argv);
c010c787:	8b 55 ac             	mov    -0x54(%ebp),%edx
c010c78a:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010c78f:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c793:	89 04 24             	mov    %eax,(%esp)
c010c796:	e8 2c f1 ff ff       	call   c010b8c7 <vmm_unmap>
            }
        }

        vaddr_t *user_environ = NULL;
c010c79b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
        if(environ != NULL)
c010c7a2:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c010c7a6:	0f 84 a4 01 00 00    	je     c010c950 <arch_create_thread_context+0x468>
        {
            size_t envc = 0;
c010c7ac:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
            size_t size = sizeof(char*);
c010c7b3:	c7 45 d4 04 00 00 00 	movl   $0x4,-0x2c(%ebp)
            while(environ[envc] != NULL)
c010c7ba:	eb 28                	jmp    c010c7e4 <arch_create_thread_context+0x2fc>
            {
                size += sizeof(char*) + strlen(environ[envc]) + 1;
c010c7bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010c7bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c7c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
c010c7c9:	01 d0                	add    %edx,%eax
c010c7cb:	8b 00                	mov    (%eax),%eax
c010c7cd:	89 04 24             	mov    %eax,(%esp)
c010c7d0:	e8 f8 66 ff ff       	call   c0102ecd <strlen>
c010c7d5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c010c7d8:	01 d0                	add    %edx,%eax
c010c7da:	83 c0 05             	add    $0x5,%eax
c010c7dd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                envc++;
c010c7e0:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
        vaddr_t *user_environ = NULL;
        if(environ != NULL)
        {
            size_t envc = 0;
            size_t size = sizeof(char*);
            while(environ[envc] != NULL)
c010c7e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010c7e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c7ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
c010c7f1:	01 d0                	add    %edx,%eax
c010c7f3:	8b 00                	mov    (%eax),%eax
c010c7f5:	85 c0                	test   %eax,%eax
c010c7f7:	75 c3                	jne    c010c7bc <arch_create_thread_context+0x2d4>
            {
                size += sizeof(char*) + strlen(environ[envc]) + 1;
                envc++;
            }

            if(size > 0)
c010c7f9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c010c7fd:	0f 84 4d 01 00 00    	je     c010c950 <arch_create_thread_context+0x468>
            {
                size_t pages = NUM_PAGES(size);
c010c803:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010c806:	05 ff 0f 00 00       	add    $0xfff,%eax
c010c80b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010c810:	c1 e8 0c             	shr    $0xc,%eax
c010c813:	89 45 a8             	mov    %eax,-0x58(%ebp)

                paddr_t vars = pmm_alloc_page_range(pages);
c010c816:	8b 45 a8             	mov    -0x58(%ebp),%eax
c010c819:	89 04 24             	mov    %eax,(%esp)
c010c81c:	e8 72 2d 00 00       	call   c010f593 <pmm_alloc_page_range>
c010c821:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                user_environ = (vaddr_t *)vmm_automap_user_range(&context->memory, vars, pages, VMM_PRESENT | VMM_WRITABLE | VMM_USER);
c010c824:	8b 45 a8             	mov    -0x58(%ebp),%eax
c010c827:	8b 55 08             	mov    0x8(%ebp),%edx
c010c82a:	83 c2 0c             	add    $0xc,%edx
c010c82d:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c010c834:	00 
c010c835:	89 44 24 08          	mov    %eax,0x8(%esp)
c010c839:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c010c83c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c840:	89 14 24             	mov    %edx,(%esp)
c010c843:	e8 81 f2 ff ff       	call   c010bac9 <vmm_automap_user_range>
c010c848:	89 45 dc             	mov    %eax,-0x24(%ebp)
                vaddr_t *kenrel_envp = (vaddr_t *) vmm_automap_kernel_range(current_context, vars, pages, VMM_PRESENT | VMM_WRITABLE);
c010c84b:	8b 55 a8             	mov    -0x58(%ebp),%edx
c010c84e:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010c853:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c010c85a:	00 
c010c85b:	89 54 24 08          	mov    %edx,0x8(%esp)
c010c85f:	8b 55 a4             	mov    -0x5c(%ebp),%edx
c010c862:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c866:	89 04 24             	mov    %eax,(%esp)
c010c869:	e8 71 f1 ff ff       	call   c010b9df <vmm_automap_kernel_range>
c010c86e:	89 45 a0             	mov    %eax,-0x60(%ebp)
                vaddr_t vbase =(vaddr_t)( user_environ+((envc+1)*sizeof(char *)));
c010c871:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010c874:	83 c0 01             	add    $0x1,%eax
c010c877:	89 c2                	mov    %eax,%edx
c010c879:	c1 e2 04             	shl    $0x4,%edx
c010c87c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010c87f:	01 d0                	add    %edx,%eax
c010c881:	89 45 d0             	mov    %eax,-0x30(%ebp)

                char *user_strs = (char*) (kenrel_envp+(envc+1)*sizeof(char *));
c010c884:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010c887:	83 c0 01             	add    $0x1,%eax
c010c88a:	89 c2                	mov    %eax,%edx
c010c88c:	c1 e2 04             	shl    $0x4,%edx
c010c88f:	8b 45 a0             	mov    -0x60(%ebp),%eax
c010c892:	01 d0                	add    %edx,%eax
c010c894:	89 45 cc             	mov    %eax,-0x34(%ebp)
                int i;
                for(i = 0; i < envc; i++)
c010c897:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
c010c89e:	eb 7b                	jmp    c010c91b <arch_create_thread_context+0x433>
                {
                    kenrel_envp[i] = vbase;
c010c8a0:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010c8a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c8aa:	8b 45 a0             	mov    -0x60(%ebp),%eax
c010c8ad:	01 c2                	add    %eax,%edx
c010c8af:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010c8b2:	89 02                	mov    %eax,(%edx)
                    strcpy(user_strs, environ[i]);
c010c8b4:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010c8b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c8be:	8b 45 1c             	mov    0x1c(%ebp),%eax
c010c8c1:	01 d0                	add    %edx,%eax
c010c8c3:	8b 00                	mov    (%eax),%eax
c010c8c5:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c8c9:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010c8cc:	89 04 24             	mov    %eax,(%esp)
c010c8cf:	e8 20 66 ff ff       	call   c0102ef4 <strcpy>

                    user_strs += strlen(environ[i])+sizeof(char);
c010c8d4:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010c8d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c8de:	8b 45 1c             	mov    0x1c(%ebp),%eax
c010c8e1:	01 d0                	add    %edx,%eax
c010c8e3:	8b 00                	mov    (%eax),%eax
c010c8e5:	89 04 24             	mov    %eax,(%esp)
c010c8e8:	e8 e0 65 ff ff       	call   c0102ecd <strlen>
c010c8ed:	83 c0 01             	add    $0x1,%eax
c010c8f0:	01 45 cc             	add    %eax,-0x34(%ebp)
                    vbase += strlen(environ[i])+sizeof(char);
c010c8f3:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010c8f6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c8fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
c010c900:	01 d0                	add    %edx,%eax
c010c902:	8b 00                	mov    (%eax),%eax
c010c904:	89 04 24             	mov    %eax,(%esp)
c010c907:	e8 c1 65 ff ff       	call   c0102ecd <strlen>
c010c90c:	8b 55 d0             	mov    -0x30(%ebp),%edx
c010c90f:	01 d0                	add    %edx,%eax
c010c911:	83 c0 01             	add    $0x1,%eax
c010c914:	89 45 d0             	mov    %eax,-0x30(%ebp)
                vaddr_t *kenrel_envp = (vaddr_t *) vmm_automap_kernel_range(current_context, vars, pages, VMM_PRESENT | VMM_WRITABLE);
                vaddr_t vbase =(vaddr_t)( user_environ+((envc+1)*sizeof(char *)));

                char *user_strs = (char*) (kenrel_envp+(envc+1)*sizeof(char *));
                int i;
                for(i = 0; i < envc; i++)
c010c917:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
c010c91b:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010c91e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c010c921:	0f 82 79 ff ff ff    	jb     c010c8a0 <arch_create_thread_context+0x3b8>
                    strcpy(user_strs, environ[i]);

                    user_strs += strlen(environ[i])+sizeof(char);
                    vbase += strlen(environ[i])+sizeof(char);
                }
                kenrel_envp[i] = 0;
c010c927:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010c92a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010c931:	8b 45 a0             	mov    -0x60(%ebp),%eax
c010c934:	01 d0                	add    %edx,%eax
c010c936:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

                vmm_unmap(current_context, (vaddr_t) kenrel_envp);
c010c93c:	8b 55 a0             	mov    -0x60(%ebp),%edx
c010c93f:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010c944:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c948:	89 04 24             	mov    %eax,(%esp)
c010c94b:	e8 77 ef ff ff       	call   c010b8c7 <vmm_unmap>
        }




        paddr_t pframe = pmm_alloc_page();
c010c950:	e8 5f 2b 00 00       	call   c010f4b4 <pmm_alloc_page>
c010c955:	89 45 9c             	mov    %eax,-0x64(%ebp)
        context->program_stack = pframe;
c010c958:	8b 45 08             	mov    0x8(%ebp),%eax
c010c95b:	8b 55 9c             	mov    -0x64(%ebp),%edx
c010c95e:	89 50 08             	mov    %edx,0x8(%eax)
        vmm_map(&context->memory, pframe, MEMORY_LAYOUT_STACK_TOP-0x1000, VMM_PRESENT | VMM_WRITABLE | VMM_USER);
c010c961:	8b 45 08             	mov    0x8(%ebp),%eax
c010c964:	8d 50 0c             	lea    0xc(%eax),%edx
c010c967:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
c010c96e:	00 
c010c96f:	c7 44 24 08 00 f0 ff 	movl   $0xbffff000,0x8(%esp)
c010c976:	bf 
c010c977:	8b 45 9c             	mov    -0x64(%ebp),%eax
c010c97a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010c97e:	89 14 24             	mov    %edx,(%esp)
c010c981:	e8 12 ef ff ff       	call   c010b898 <vmm_map>
        new_state->esp = (uint32_t) MEMORY_LAYOUT_STACK_TOP - 3*sizeof(uint32_t);
c010c986:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c989:	c7 40 40 f4 ff ff bf 	movl   $0xbffffff4,0x40(%eax)

        stack = (uint32_t *) vmm_automap_kernel(current_context, pframe, VMM_PRESENT | VMM_WRITABLE);
c010c990:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010c995:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c010c99c:	00 
c010c99d:	8b 55 9c             	mov    -0x64(%ebp),%edx
c010c9a0:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c9a4:	89 04 24             	mov    %eax,(%esp)
c010c9a7:	e8 d5 ef ff ff       	call   c010b981 <vmm_automap_kernel>
c010c9ac:	89 45 b8             	mov    %eax,-0x48(%ebp)

        stack[1023] = (uint32_t) user_environ;
c010c9af:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c9b2:	8d 90 fc 0f 00 00    	lea    0xffc(%eax),%edx
c010c9b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010c9bb:	89 02                	mov    %eax,(%edx)
        stack[1022] = (uint32_t) user_argv;
c010c9bd:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c9c0:	8d 90 f8 0f 00 00    	lea    0xff8(%eax),%edx
c010c9c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010c9c9:	89 02                	mov    %eax,(%edx)
        stack[1021] = (uint32_t) argc;
c010c9cb:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c9ce:	8d 90 f4 0f 00 00    	lea    0xff4(%eax),%edx
c010c9d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010c9d7:	89 02                	mov    %eax,(%edx)
        stack[1020] = (uint32_t) return_adress;
c010c9d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010c9dc:	8d 90 f0 0f 00 00    	lea    0xff0(%eax),%edx
c010c9e2:	8b 45 14             	mov    0x14(%ebp),%eax
c010c9e5:	89 02                	mov    %eax,(%edx)

        vmm_unmap(current_context, (vaddr_t)stack);
c010c9e7:	8b 55 b8             	mov    -0x48(%ebp),%edx
c010c9ea:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010c9ef:	89 54 24 04          	mov    %edx,0x4(%esp)
c010c9f3:	89 04 24             	mov    %eax,(%esp)
c010c9f6:	e8 cc ee ff ff       	call   c010b8c7 <vmm_unmap>

        new_state->cs = 0x1b;
c010c9fb:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010c9fe:	c7 40 38 1b 00 00 00 	movl   $0x1b,0x38(%eax)
        new_state->ss = 0x23;
c010ca05:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010ca08:	c7 40 44 23 00 00 00 	movl   $0x23,0x44(%eax)

        int i;
        for(i = 0; i < IO_BITMAP_LENGTH / 32; i++)
c010ca0f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
c010ca16:	eb 15                	jmp    c010ca2d <arch_create_thread_context+0x545>
            context->ports.iobmp[i] = 0xFFFFFFFF;
c010ca18:	8b 45 08             	mov    0x8(%ebp),%eax
c010ca1b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c010ca1e:	83 c2 04             	add    $0x4,%edx
c010ca21:	c7 44 90 04 ff ff ff 	movl   $0xffffffff,0x4(%eax,%edx,4)
c010ca28:	ff 

        new_state->cs = 0x1b;
        new_state->ss = 0x23;

        int i;
        for(i = 0; i < IO_BITMAP_LENGTH / 32; i++)
c010ca29:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
c010ca2d:	81 7d c4 fe 07 00 00 	cmpl   $0x7fe,-0x3c(%ebp)
c010ca34:	7e e2                	jle    c010ca18 <arch_create_thread_context+0x530>
            context->ports.iobmp[i] = 0xFFFFFFFF;
    }

    return new_state;
c010ca36:	8b 45 bc             	mov    -0x44(%ebp),%eax

}
c010ca39:	c9                   	leave  
c010ca3a:	c3                   	ret    

c010ca3b <arch_destroy_thread_context>:
/**
 *  @brief Destroys a thread context and frees its associated memory.
 *  @param context The context to destroy.
 */
void arch_destroy_thread_context(struct arch_thread_context *context)
{
c010ca3b:	55                   	push   %ebp
c010ca3c:	89 e5                	mov    %esp,%ebp
c010ca3e:	83 ec 18             	sub    $0x18,%esp
    free(context->state);
c010ca41:	8b 45 08             	mov    0x8(%ebp),%eax
c010ca44:	8b 00                	mov    (%eax),%eax
c010ca46:	89 04 24             	mov    %eax,(%esp)
c010ca49:	e8 05 f6 ff ff       	call   c010c053 <free>
    arch_vmm_destroy_context(&context->memory.arch_context);
c010ca4e:	8b 45 08             	mov    0x8(%ebp),%eax
c010ca51:	83 c0 0c             	add    $0xc,%eax
c010ca54:	89 04 24             	mov    %eax,(%esp)
c010ca57:	e8 4e 08 00 00       	call   c010d2aa <arch_vmm_destroy_context>
    free(context);
c010ca5c:	8b 45 08             	mov    0x8(%ebp),%eax
c010ca5f:	89 04 24             	mov    %eax,(%esp)
c010ca62:	e8 ec f5 ff ff       	call   c010c053 <free>
}
c010ca67:	c9                   	leave  
c010ca68:	c3                   	ret    

c010ca69 <check_port>:
 * @brief Checks if the port is already taken
 * @param port	The port id
 * @return 1 if the port is available; 0 if the port is already taken
 */
int check_port(portid_t port)
{
c010ca69:	55                   	push   %ebp
c010ca6a:	89 e5                	mov    %esp,%ebp
c010ca6c:	56                   	push   %esi
c010ca6d:	53                   	push   %ebx
c010ca6e:	83 ec 04             	sub    $0x4,%esp
c010ca71:	8b 45 08             	mov    0x8(%ebp),%eax
c010ca74:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    return !(global_iobmp[port/32] & (1<< (port & 31)));
c010ca78:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c010ca7c:	66 c1 e8 05          	shr    $0x5,%ax
c010ca80:	0f b7 c0             	movzwl %ax,%eax
c010ca83:	8b 14 85 60 90 11 c0 	mov    -0x3fee6fa0(,%eax,4),%edx
c010ca8a:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c010ca8e:	83 e0 1f             	and    $0x1f,%eax
c010ca91:	bb 01 00 00 00       	mov    $0x1,%ebx
c010ca96:	89 de                	mov    %ebx,%esi
c010ca98:	89 c1                	mov    %eax,%ecx
c010ca9a:	d3 e6                	shl    %cl,%esi
c010ca9c:	89 f0                	mov    %esi,%eax
c010ca9e:	21 d0                	and    %edx,%eax
c010caa0:	85 c0                	test   %eax,%eax
c010caa2:	0f 94 c0             	sete   %al
c010caa5:	0f b6 c0             	movzbl %al,%eax
}
c010caa8:	83 c4 04             	add    $0x4,%esp
c010caab:	5b                   	pop    %ebx
c010caac:	5e                   	pop    %esi
c010caad:	5d                   	pop    %ebp
c010caae:	c3                   	ret    

c010caaf <check_port_access>:
 * @param context 	Thread context which should be checked
 * @param port 		The port id
 * @return 1 if access is granted; 0 if access is denied
 */
int check_port_access(struct arch_thread_context *context, portid_t port)
{
c010caaf:	55                   	push   %ebp
c010cab0:	89 e5                	mov    %esp,%ebp
c010cab2:	56                   	push   %esi
c010cab3:	53                   	push   %ebx
c010cab4:	83 ec 04             	sub    $0x4,%esp
c010cab7:	8b 45 0c             	mov    0xc(%ebp),%eax
c010caba:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    return !(context->ports.iobmp[port/32] & (1<< (port & 31)));
c010cabe:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c010cac2:	66 c1 e8 05          	shr    $0x5,%ax
c010cac6:	0f b7 d0             	movzwl %ax,%edx
c010cac9:	8b 45 08             	mov    0x8(%ebp),%eax
c010cacc:	83 c2 04             	add    $0x4,%edx
c010cacf:	8b 54 90 04          	mov    0x4(%eax,%edx,4),%edx
c010cad3:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c010cad7:	83 e0 1f             	and    $0x1f,%eax
c010cada:	bb 01 00 00 00       	mov    $0x1,%ebx
c010cadf:	89 de                	mov    %ebx,%esi
c010cae1:	89 c1                	mov    %eax,%ecx
c010cae3:	d3 e6                	shl    %cl,%esi
c010cae5:	89 f0                	mov    %esi,%eax
c010cae7:	21 d0                	and    %edx,%eax
c010cae9:	85 c0                	test   %eax,%eax
c010caeb:	0f 94 c0             	sete   %al
c010caee:	0f b6 c0             	movzbl %al,%eax
}
c010caf1:	83 c4 04             	add    $0x4,%esp
c010caf4:	5b                   	pop    %ebx
c010caf5:	5e                   	pop    %esi
c010caf6:	5d                   	pop    %ebp
c010caf7:	c3                   	ret    

c010caf8 <alloc_port>:
 * @param context 	Thread context which should get access
 * @param port 		The port id
 * @return 1 if access is granted; 0 if access is denied/already taken
 */
int alloc_port(struct arch_thread_context *context, portid_t port)
{
c010caf8:	55                   	push   %ebp
c010caf9:	89 e5                	mov    %esp,%ebp
c010cafb:	57                   	push   %edi
c010cafc:	56                   	push   %esi
c010cafd:	53                   	push   %ebx
c010cafe:	83 ec 0c             	sub    $0xc,%esp
c010cb01:	8b 45 0c             	mov    0xc(%ebp),%eax
c010cb04:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
    if(check_port(port))
c010cb08:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cb0c:	89 04 24             	mov    %eax,(%esp)
c010cb0f:	e8 55 ff ff ff       	call   c010ca69 <check_port>
c010cb14:	85 c0                	test   %eax,%eax
c010cb16:	74 6e                	je     c010cb86 <alloc_port+0x8e>
    {
        global_iobmp[port/32] |=  1<< (port & 31);
c010cb18:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cb1c:	66 c1 e8 05          	shr    $0x5,%ax
c010cb20:	0f b7 d0             	movzwl %ax,%edx
c010cb23:	0f b7 c0             	movzwl %ax,%eax
c010cb26:	8b 1c 85 60 90 11 c0 	mov    -0x3fee6fa0(,%eax,4),%ebx
c010cb2d:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cb31:	83 e0 1f             	and    $0x1f,%eax
c010cb34:	be 01 00 00 00       	mov    $0x1,%esi
c010cb39:	89 f7                	mov    %esi,%edi
c010cb3b:	89 c1                	mov    %eax,%ecx
c010cb3d:	d3 e7                	shl    %cl,%edi
c010cb3f:	89 f8                	mov    %edi,%eax
c010cb41:	09 d8                	or     %ebx,%eax
c010cb43:	89 04 95 60 90 11 c0 	mov    %eax,-0x3fee6fa0(,%edx,4)
        context->ports.iobmp[port/32] &= ~(1<< (port & 31));
c010cb4a:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cb4e:	66 c1 e8 05          	shr    $0x5,%ax
c010cb52:	0f b7 d0             	movzwl %ax,%edx
c010cb55:	0f b7 c8             	movzwl %ax,%ecx
c010cb58:	8b 45 08             	mov    0x8(%ebp),%eax
c010cb5b:	83 c1 04             	add    $0x4,%ecx
c010cb5e:	8b 5c 88 04          	mov    0x4(%eax,%ecx,4),%ebx
c010cb62:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cb66:	83 e0 1f             	and    $0x1f,%eax
c010cb69:	be 01 00 00 00       	mov    $0x1,%esi
c010cb6e:	89 f7                	mov    %esi,%edi
c010cb70:	89 c1                	mov    %eax,%ecx
c010cb72:	d3 e7                	shl    %cl,%edi
c010cb74:	89 f8                	mov    %edi,%eax
c010cb76:	f7 d0                	not    %eax
c010cb78:	89 d9                	mov    %ebx,%ecx
c010cb7a:	21 c1                	and    %eax,%ecx
c010cb7c:	8b 45 08             	mov    0x8(%ebp),%eax
c010cb7f:	83 c2 04             	add    $0x4,%edx
c010cb82:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
    }
    return check_port_access(context, port); // if the port has already been allocated, it will return 1 again
c010cb86:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cb8a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cb8e:	8b 45 08             	mov    0x8(%ebp),%eax
c010cb91:	89 04 24             	mov    %eax,(%esp)
c010cb94:	e8 16 ff ff ff       	call   c010caaf <check_port_access>
}
c010cb99:	83 c4 0c             	add    $0xc,%esp
c010cb9c:	5b                   	pop    %ebx
c010cb9d:	5e                   	pop    %esi
c010cb9e:	5f                   	pop    %edi
c010cb9f:	5d                   	pop    %ebp
c010cba0:	c3                   	ret    

c010cba1 <free_port>:
 * @brief Removes the access rights for a port from context
 * @param context 	Thread context which should loose access
 * @param port 		The port id
 */
void free_port(struct arch_thread_context *context, portid_t port)
{
c010cba1:	55                   	push   %ebp
c010cba2:	89 e5                	mov    %esp,%ebp
c010cba4:	57                   	push   %edi
c010cba5:	56                   	push   %esi
c010cba6:	53                   	push   %ebx
c010cba7:	83 ec 0c             	sub    $0xc,%esp
c010cbaa:	8b 45 0c             	mov    0xc(%ebp),%eax
c010cbad:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
    if(check_port_access(context,port))
c010cbb1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cbb5:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cbb9:	8b 45 08             	mov    0x8(%ebp),%eax
c010cbbc:	89 04 24             	mov    %eax,(%esp)
c010cbbf:	e8 eb fe ff ff       	call   c010caaf <check_port_access>
c010cbc4:	85 c0                	test   %eax,%eax
c010cbc6:	74 6e                	je     c010cc36 <free_port+0x95>
    {
        context->ports.iobmp[port/32] |= 1<<(port & 31);
c010cbc8:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cbcc:	66 c1 e8 05          	shr    $0x5,%ax
c010cbd0:	0f b7 d0             	movzwl %ax,%edx
c010cbd3:	0f b7 c8             	movzwl %ax,%ecx
c010cbd6:	8b 45 08             	mov    0x8(%ebp),%eax
c010cbd9:	83 c1 04             	add    $0x4,%ecx
c010cbdc:	8b 5c 88 04          	mov    0x4(%eax,%ecx,4),%ebx
c010cbe0:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cbe4:	83 e0 1f             	and    $0x1f,%eax
c010cbe7:	be 01 00 00 00       	mov    $0x1,%esi
c010cbec:	89 f7                	mov    %esi,%edi
c010cbee:	89 c1                	mov    %eax,%ecx
c010cbf0:	d3 e7                	shl    %cl,%edi
c010cbf2:	89 f8                	mov    %edi,%eax
c010cbf4:	89 d9                	mov    %ebx,%ecx
c010cbf6:	09 c1                	or     %eax,%ecx
c010cbf8:	8b 45 08             	mov    0x8(%ebp),%eax
c010cbfb:	83 c2 04             	add    $0x4,%edx
c010cbfe:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
        global_iobmp[port/32] &= ~(1<< (port & 31));
c010cc02:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cc06:	66 c1 e8 05          	shr    $0x5,%ax
c010cc0a:	0f b7 d0             	movzwl %ax,%edx
c010cc0d:	0f b7 c0             	movzwl %ax,%eax
c010cc10:	8b 1c 85 60 90 11 c0 	mov    -0x3fee6fa0(,%eax,4),%ebx
c010cc17:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
c010cc1b:	83 e0 1f             	and    $0x1f,%eax
c010cc1e:	be 01 00 00 00       	mov    $0x1,%esi
c010cc23:	89 f7                	mov    %esi,%edi
c010cc25:	89 c1                	mov    %eax,%ecx
c010cc27:	d3 e7                	shl    %cl,%edi
c010cc29:	89 f8                	mov    %edi,%eax
c010cc2b:	f7 d0                	not    %eax
c010cc2d:	21 d8                	and    %ebx,%eax
c010cc2f:	89 04 95 60 90 11 c0 	mov    %eax,-0x3fee6fa0(,%edx,4)
    }
}
c010cc36:	83 c4 0c             	add    $0xc,%esp
c010cc39:	5b                   	pop    %ebx
c010cc3a:	5e                   	pop    %esi
c010cc3b:	5f                   	pop    %edi
c010cc3c:	5d                   	pop    %ebp
c010cc3d:	c3                   	ret    

c010cc3e <outb>:
    asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
    return result;
}

static inline void outb(uint16_t port, uint8_t value)
{
c010cc3e:	55                   	push   %ebp
c010cc3f:	89 e5                	mov    %esp,%ebp
c010cc41:	83 ec 08             	sub    $0x8,%esp
c010cc44:	8b 55 08             	mov    0x8(%ebp),%edx
c010cc47:	8b 45 0c             	mov    0xc(%ebp),%eax
c010cc4a:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010cc4e:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c010cc51:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c010cc55:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c010cc59:	ee                   	out    %al,(%dx)
}
c010cc5a:	c9                   	leave  
c010cc5b:	c3                   	ret    

c010cc5c <INIT_CLOCK>:

/**
 * @brief Initiates PIT and RTC.
 */
void INIT_CLOCK(int freq)
{
c010cc5c:	55                   	push   %ebp
c010cc5d:	89 e5                	mov    %esp,%ebp
c010cc5f:	83 ec 18             	sub    $0x18,%esp
    startup = malloc(sizeof(struct time));
c010cc62:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
c010cc69:	e8 d7 f2 ff ff       	call   c010bf45 <malloc>
c010cc6e:	a3 34 f0 11 c0       	mov    %eax,0xc011f034
    up_time = 0;
c010cc73:	c7 05 38 f0 11 c0 00 	movl   $0x0,0xc011f038
c010cc7a:	00 00 00 
c010cc7d:	c7 05 3c f0 11 c0 00 	movl   $0x0,0xc011f03c
c010cc84:	00 00 00 
    INIT_RTC();
c010cc87:	e8 83 00 00 00       	call   c010cd0f <INIT_RTC>
    INIT_PIT(freq);
c010cc8c:	8b 45 08             	mov    0x8(%ebp),%eax
c010cc8f:	89 04 24             	mov    %eax,(%esp)
c010cc92:	e8 51 00 00 00       	call   c010cce8 <INIT_PIT>
}
c010cc97:	c9                   	leave  
c010cc98:	c3                   	ret    

c010cc99 <set_pit_freq>:
 * @brief set PIT Fequency.
 * @param freqency
 * @return void
 */
void set_pit_freq(int freq)
{
c010cc99:	55                   	push   %ebp
c010cc9a:	89 e5                	mov    %esp,%ebp
c010cc9c:	83 ec 18             	sub    $0x18,%esp
    timer_freq = freq;
c010cc9f:	8b 45 08             	mov    0x8(%ebp),%eax
c010cca2:	a3 5c b0 11 c0       	mov    %eax,0xc011b05c
    int counter = 1193182 / freq;
c010cca7:	b8 de 34 12 00       	mov    $0x1234de,%eax
c010ccac:	89 c2                	mov    %eax,%edx
c010ccae:	c1 fa 1f             	sar    $0x1f,%edx
c010ccb1:	f7 7d 08             	idivl  0x8(%ebp)
c010ccb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    outb(0x40,counter & 0xFF);
c010ccb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010ccba:	0f b6 c0             	movzbl %al,%eax
c010ccbd:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ccc1:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
c010ccc8:	e8 71 ff ff ff       	call   c010cc3e <outb>
    outb(0x40,counter >> 8);
c010cccd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010ccd0:	c1 f8 08             	sar    $0x8,%eax
c010ccd3:	0f b6 c0             	movzbl %al,%eax
c010ccd6:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ccda:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
c010cce1:	e8 58 ff ff ff       	call   c010cc3e <outb>
}
c010cce6:	c9                   	leave  
c010cce7:	c3                   	ret    

c010cce8 <INIT_PIT>:
 * @brief Initalize the Programmable Intervall Timer.
 * @param frequency
 * @return void
 */
void INIT_PIT(int freq)
{
c010cce8:	55                   	push   %ebp
c010cce9:	89 e5                	mov    %esp,%ebp
c010cceb:	83 ec 08             	sub    $0x8,%esp
    outb(0x43, 0x34);
c010ccee:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
c010ccf5:	00 
c010ccf6:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
c010ccfd:	e8 3c ff ff ff       	call   c010cc3e <outb>
    set_pit_freq(freq);
c010cd02:	8b 45 08             	mov    0x8(%ebp),%eax
c010cd05:	89 04 24             	mov    %eax,(%esp)
c010cd08:	e8 8c ff ff ff       	call   c010cc99 <set_pit_freq>
}
c010cd0d:	c9                   	leave  
c010cd0e:	c3                   	ret    

c010cd0f <INIT_RTC>:
 * @brief Initalize the Real Time Clock.
 * @param void
 * @return void
 */
void INIT_RTC(void)
{
c010cd0f:	55                   	push   %ebp
c010cd10:	89 e5                	mov    %esp,%ebp
c010cd12:	83 ec 18             	sub    $0x18,%esp
    cmos = malloc(sizeof(struct cmos_data));
c010cd15:	c7 04 24 13 00 00 00 	movl   $0x13,(%esp)
c010cd1c:	e8 24 f2 ff ff       	call   c010bf45 <malloc>
c010cd21:	a3 30 f0 11 c0       	mov    %eax,0xc011f030
    get_cmos_data(cmos);
c010cd26:	a1 30 f0 11 c0       	mov    0xc011f030,%eax
c010cd2b:	89 04 24             	mov    %eax,(%esp)
c010cd2e:	e8 c7 0d 00 00       	call   c010dafa <get_cmos_data>
    update_time(startup);
c010cd33:	a1 34 f0 11 c0       	mov    0xc011f034,%eax
c010cd38:	89 04 24             	mov    %eax,(%esp)
c010cd3b:	e8 46 00 00 00       	call   c010cd86 <update_time>
}
c010cd40:	c9                   	leave  
c010cd41:	c3                   	ret    

c010cd42 <sync_sys_clock>:

void sync_sys_clock()
{
c010cd42:	55                   	push   %ebp
c010cd43:	89 e5                	mov    %esp,%ebp
c010cd45:	53                   	push   %ebx
c010cd46:	83 ec 0c             	sub    $0xc,%esp
    up_time += 1000/timer_freq;
c010cd49:	8b 15 5c b0 11 c0    	mov    0xc011b05c,%edx
c010cd4f:	89 55 f4             	mov    %edx,-0xc(%ebp)
c010cd52:	b8 e8 03 00 00       	mov    $0x3e8,%eax
c010cd57:	89 c2                	mov    %eax,%edx
c010cd59:	c1 fa 1f             	sar    $0x1f,%edx
c010cd5c:	f7 7d f4             	idivl  -0xc(%ebp)
c010cd5f:	89 c1                	mov    %eax,%ecx
c010cd61:	89 c3                	mov    %eax,%ebx
c010cd63:	c1 fb 1f             	sar    $0x1f,%ebx
c010cd66:	a1 38 f0 11 c0       	mov    0xc011f038,%eax
c010cd6b:	8b 15 3c f0 11 c0    	mov    0xc011f03c,%edx
c010cd71:	01 c8                	add    %ecx,%eax
c010cd73:	11 da                	adc    %ebx,%edx
c010cd75:	a3 38 f0 11 c0       	mov    %eax,0xc011f038
c010cd7a:	89 15 3c f0 11 c0    	mov    %edx,0xc011f03c
}
c010cd80:	83 c4 0c             	add    $0xc,%esp
c010cd83:	5b                   	pop    %ebx
c010cd84:	5d                   	pop    %ebp
c010cd85:	c3                   	ret    

c010cd86 <update_time>:
/**
 * @brief Updates the time from CMOS-RTC.
 * @param void
 */
void update_time(struct time *time)
{
c010cd86:	55                   	push   %ebp
c010cd87:	89 e5                	mov    %esp,%ebp
c010cd89:	83 ec 18             	sub    $0x18,%esp
    time->second =       bcd_decode(cmos_read_byte(0x00));
c010cd8c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010cd93:	e8 bf 0e 00 00       	call   c010dc57 <cmos_read_byte>
c010cd98:	0f b6 c0             	movzbl %al,%eax
c010cd9b:	89 04 24             	mov    %eax,(%esp)
c010cd9e:	e8 f5 52 ff ff       	call   c0102098 <bcd_decode>
c010cda3:	8b 55 08             	mov    0x8(%ebp),%edx
c010cda6:	88 02                	mov    %al,(%edx)
    time->alarm_sec =    bcd_decode(cmos_read_byte(0x01));
c010cda8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c010cdaf:	e8 a3 0e 00 00       	call   c010dc57 <cmos_read_byte>
c010cdb4:	0f b6 c0             	movzbl %al,%eax
c010cdb7:	89 04 24             	mov    %eax,(%esp)
c010cdba:	e8 d9 52 ff ff       	call   c0102098 <bcd_decode>
c010cdbf:	8b 55 08             	mov    0x8(%ebp),%edx
c010cdc2:	88 42 01             	mov    %al,0x1(%edx)
    time->minute =       bcd_decode(cmos_read_byte(0x02));
c010cdc5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c010cdcc:	e8 86 0e 00 00       	call   c010dc57 <cmos_read_byte>
c010cdd1:	0f b6 c0             	movzbl %al,%eax
c010cdd4:	89 04 24             	mov    %eax,(%esp)
c010cdd7:	e8 bc 52 ff ff       	call   c0102098 <bcd_decode>
c010cddc:	8b 55 08             	mov    0x8(%ebp),%edx
c010cddf:	88 42 02             	mov    %al,0x2(%edx)
    time->alarm_min =    bcd_decode(cmos_read_byte(0x03));
c010cde2:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c010cde9:	e8 69 0e 00 00       	call   c010dc57 <cmos_read_byte>
c010cdee:	0f b6 c0             	movzbl %al,%eax
c010cdf1:	89 04 24             	mov    %eax,(%esp)
c010cdf4:	e8 9f 52 ff ff       	call   c0102098 <bcd_decode>
c010cdf9:	8b 55 08             	mov    0x8(%ebp),%edx
c010cdfc:	88 42 03             	mov    %al,0x3(%edx)
    time->hour =         bcd_decode(cmos_read_byte(0x04));
c010cdff:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c010ce06:	e8 4c 0e 00 00       	call   c010dc57 <cmos_read_byte>
c010ce0b:	0f b6 c0             	movzbl %al,%eax
c010ce0e:	89 04 24             	mov    %eax,(%esp)
c010ce11:	e8 82 52 ff ff       	call   c0102098 <bcd_decode>
c010ce16:	8b 55 08             	mov    0x8(%ebp),%edx
c010ce19:	88 42 04             	mov    %al,0x4(%edx)
    time->alarm_hour =   bcd_decode(cmos_read_byte(0x05));
c010ce1c:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c010ce23:	e8 2f 0e 00 00       	call   c010dc57 <cmos_read_byte>
c010ce28:	0f b6 c0             	movzbl %al,%eax
c010ce2b:	89 04 24             	mov    %eax,(%esp)
c010ce2e:	e8 65 52 ff ff       	call   c0102098 <bcd_decode>
c010ce33:	8b 55 08             	mov    0x8(%ebp),%edx
c010ce36:	88 42 05             	mov    %al,0x5(%edx)
    time->week_day =     bcd_decode(cmos_read_byte(0x06)) - 1;
c010ce39:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c010ce40:	e8 12 0e 00 00       	call   c010dc57 <cmos_read_byte>
c010ce45:	0f b6 c0             	movzbl %al,%eax
c010ce48:	89 04 24             	mov    %eax,(%esp)
c010ce4b:	e8 48 52 ff ff       	call   c0102098 <bcd_decode>
c010ce50:	8d 50 ff             	lea    -0x1(%eax),%edx
c010ce53:	8b 45 08             	mov    0x8(%ebp),%eax
c010ce56:	88 50 06             	mov    %dl,0x6(%eax)
    time->day_in_month = bcd_decode(cmos_read_byte(0x07));
c010ce59:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c010ce60:	e8 f2 0d 00 00       	call   c010dc57 <cmos_read_byte>
c010ce65:	0f b6 c0             	movzbl %al,%eax
c010ce68:	89 04 24             	mov    %eax,(%esp)
c010ce6b:	e8 28 52 ff ff       	call   c0102098 <bcd_decode>
c010ce70:	8b 55 08             	mov    0x8(%ebp),%edx
c010ce73:	88 42 07             	mov    %al,0x7(%edx)
    time->month =        bcd_decode(cmos_read_byte(0x08));
c010ce76:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c010ce7d:	e8 d5 0d 00 00       	call   c010dc57 <cmos_read_byte>
c010ce82:	0f b6 c0             	movzbl %al,%eax
c010ce85:	89 04 24             	mov    %eax,(%esp)
c010ce88:	e8 0b 52 ff ff       	call   c0102098 <bcd_decode>
c010ce8d:	8b 55 08             	mov    0x8(%ebp),%edx
c010ce90:	88 42 08             	mov    %al,0x8(%edx)
    time->year =         bcd_decode(cmos_read_byte(0x09));
c010ce93:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c010ce9a:	e8 b8 0d 00 00       	call   c010dc57 <cmos_read_byte>
c010ce9f:	0f b6 c0             	movzbl %al,%eax
c010cea2:	89 04 24             	mov    %eax,(%esp)
c010cea5:	e8 ee 51 ff ff       	call   c0102098 <bcd_decode>
c010ceaa:	8b 55 08             	mov    0x8(%ebp),%edx
c010cead:	88 42 09             	mov    %al,0x9(%edx)
    time->century =      bcd_decode(cmos_read_byte(0x32));
c010ceb0:	c7 04 24 32 00 00 00 	movl   $0x32,(%esp)
c010ceb7:	e8 9b 0d 00 00       	call   c010dc57 <cmos_read_byte>
c010cebc:	0f b6 c0             	movzbl %al,%eax
c010cebf:	89 04 24             	mov    %eax,(%esp)
c010cec2:	e8 d1 51 ff ff       	call   c0102098 <bcd_decode>
c010cec7:	8b 55 08             	mov    0x8(%ebp),%edx
c010ceca:	88 42 0a             	mov    %al,0xa(%edx)
}
c010cecd:	c9                   	leave  
c010cece:	c3                   	ret    

c010cecf <change_time>:
/**
 * @brief Changes the Time from CMOS.
 * @param time New time
 */
void change_time(struct time *time)
{
c010cecf:	55                   	push   %ebp
c010ced0:	89 e5                	mov    %esp,%ebp
c010ced2:	83 ec 18             	sub    $0x18,%esp
    cmos_write_byte(0x00, (uint8_t)bcd_encode(time->second));
c010ced5:	8b 45 08             	mov    0x8(%ebp),%eax
c010ced8:	0f b6 00             	movzbl (%eax),%eax
c010cedb:	0f b6 c0             	movzbl %al,%eax
c010cede:	89 04 24             	mov    %eax,(%esp)
c010cee1:	e8 dd 51 ff ff       	call   c01020c3 <bcd_encode>
c010cee6:	0f b6 c0             	movzbl %al,%eax
c010cee9:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ceed:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010cef4:	e8 ac 0d 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x01, (uint8_t)bcd_encode(time->alarm_sec));
c010cef9:	8b 45 08             	mov    0x8(%ebp),%eax
c010cefc:	0f b6 40 01          	movzbl 0x1(%eax),%eax
c010cf00:	0f b6 c0             	movzbl %al,%eax
c010cf03:	89 04 24             	mov    %eax,(%esp)
c010cf06:	e8 b8 51 ff ff       	call   c01020c3 <bcd_encode>
c010cf0b:	0f b6 c0             	movzbl %al,%eax
c010cf0e:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cf12:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c010cf19:	e8 87 0d 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x02, (uint8_t)bcd_encode(time->minute));
c010cf1e:	8b 45 08             	mov    0x8(%ebp),%eax
c010cf21:	0f b6 40 02          	movzbl 0x2(%eax),%eax
c010cf25:	0f b6 c0             	movzbl %al,%eax
c010cf28:	89 04 24             	mov    %eax,(%esp)
c010cf2b:	e8 93 51 ff ff       	call   c01020c3 <bcd_encode>
c010cf30:	0f b6 c0             	movzbl %al,%eax
c010cf33:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cf37:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c010cf3e:	e8 62 0d 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x03, (uint8_t)bcd_encode(time->alarm_min));
c010cf43:	8b 45 08             	mov    0x8(%ebp),%eax
c010cf46:	0f b6 40 03          	movzbl 0x3(%eax),%eax
c010cf4a:	0f b6 c0             	movzbl %al,%eax
c010cf4d:	89 04 24             	mov    %eax,(%esp)
c010cf50:	e8 6e 51 ff ff       	call   c01020c3 <bcd_encode>
c010cf55:	0f b6 c0             	movzbl %al,%eax
c010cf58:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cf5c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c010cf63:	e8 3d 0d 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x04, (uint8_t)bcd_encode(time->hour));
c010cf68:	8b 45 08             	mov    0x8(%ebp),%eax
c010cf6b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c010cf6f:	0f b6 c0             	movzbl %al,%eax
c010cf72:	89 04 24             	mov    %eax,(%esp)
c010cf75:	e8 49 51 ff ff       	call   c01020c3 <bcd_encode>
c010cf7a:	0f b6 c0             	movzbl %al,%eax
c010cf7d:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cf81:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c010cf88:	e8 18 0d 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x05, (uint8_t)bcd_encode(time->alarm_hour));
c010cf8d:	8b 45 08             	mov    0x8(%ebp),%eax
c010cf90:	0f b6 40 05          	movzbl 0x5(%eax),%eax
c010cf94:	0f b6 c0             	movzbl %al,%eax
c010cf97:	89 04 24             	mov    %eax,(%esp)
c010cf9a:	e8 24 51 ff ff       	call   c01020c3 <bcd_encode>
c010cf9f:	0f b6 c0             	movzbl %al,%eax
c010cfa2:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cfa6:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c010cfad:	e8 f3 0c 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x06, (uint8_t)bcd_encode(time->week_day));
c010cfb2:	8b 45 08             	mov    0x8(%ebp),%eax
c010cfb5:	0f b6 40 06          	movzbl 0x6(%eax),%eax
c010cfb9:	0f b6 c0             	movzbl %al,%eax
c010cfbc:	89 04 24             	mov    %eax,(%esp)
c010cfbf:	e8 ff 50 ff ff       	call   c01020c3 <bcd_encode>
c010cfc4:	0f b6 c0             	movzbl %al,%eax
c010cfc7:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cfcb:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c010cfd2:	e8 ce 0c 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x07, (uint8_t)bcd_encode(time->day_in_month));
c010cfd7:	8b 45 08             	mov    0x8(%ebp),%eax
c010cfda:	0f b6 40 07          	movzbl 0x7(%eax),%eax
c010cfde:	0f b6 c0             	movzbl %al,%eax
c010cfe1:	89 04 24             	mov    %eax,(%esp)
c010cfe4:	e8 da 50 ff ff       	call   c01020c3 <bcd_encode>
c010cfe9:	0f b6 c0             	movzbl %al,%eax
c010cfec:	89 44 24 04          	mov    %eax,0x4(%esp)
c010cff0:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c010cff7:	e8 a9 0c 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x08, (uint8_t)bcd_encode(time->month));
c010cffc:	8b 45 08             	mov    0x8(%ebp),%eax
c010cfff:	0f b6 40 08          	movzbl 0x8(%eax),%eax
c010d003:	0f b6 c0             	movzbl %al,%eax
c010d006:	89 04 24             	mov    %eax,(%esp)
c010d009:	e8 b5 50 ff ff       	call   c01020c3 <bcd_encode>
c010d00e:	0f b6 c0             	movzbl %al,%eax
c010d011:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d015:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c010d01c:	e8 84 0c 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x09, (uint8_t)bcd_encode(time->year));
c010d021:	8b 45 08             	mov    0x8(%ebp),%eax
c010d024:	0f b6 40 09          	movzbl 0x9(%eax),%eax
c010d028:	0f b6 c0             	movzbl %al,%eax
c010d02b:	89 04 24             	mov    %eax,(%esp)
c010d02e:	e8 90 50 ff ff       	call   c01020c3 <bcd_encode>
c010d033:	0f b6 c0             	movzbl %al,%eax
c010d036:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d03a:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c010d041:	e8 5f 0c 00 00       	call   c010dca5 <cmos_write_byte>
    cmos_write_byte(0x32, (uint8_t)bcd_encode(time->century));
c010d046:	8b 45 08             	mov    0x8(%ebp),%eax
c010d049:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c010d04d:	0f b6 c0             	movzbl %al,%eax
c010d050:	89 04 24             	mov    %eax,(%esp)
c010d053:	e8 6b 50 ff ff       	call   c01020c3 <bcd_encode>
c010d058:	0f b6 c0             	movzbl %al,%eax
c010d05b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d05f:	c7 04 24 32 00 00 00 	movl   $0x32,(%esp)
c010d066:	e8 3a 0c 00 00       	call   c010dca5 <cmos_write_byte>
c010d06b:	c9                   	leave  
c010d06c:	c3                   	ret    

c010d06d <ARCH_INIT_PAGING>:
 *
 * @param mb_info multiboot structure
 * @return void
 */
void ARCH_INIT_PAGING(struct multiboot_struct *mb_info)
{
c010d06d:	55                   	push   %ebp
c010d06e:	89 e5                	mov    %esp,%ebp
c010d070:	83 ec 48             	sub    $0x48,%esp
    paddr_t pframe = pmm_alloc_page_limit(0);
c010d073:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010d07a:	e8 72 24 00 00       	call   c010f4f1 <pmm_alloc_page_limit>
c010d07f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    vaddr_t vframe = MEMORY_LAYOUT_PAGING_STRUCTURES_START;
c010d082:	c7 45 e8 00 00 80 ff 	movl   $0xff800000,-0x18(%ebp)

    kernel_context.arch_context.phys_addr = pframe;
c010d089:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d08c:	a3 44 f0 11 c0       	mov    %eax,0xc011f044
    kernel_context.arch_context.entries = (pde_t *) pframe + MEMORY_LAYOUT_KERNEL_START;
c010d091:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d094:	a3 40 f0 11 c0       	mov    %eax,0xc011f040
    memset(kernel_context.arch_context.entries, 0, PAGE_SIZE);
c010d099:	a1 40 f0 11 c0       	mov    0xc011f040,%eax
c010d09e:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010d0a5:	00 
c010d0a6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010d0ad:	00 
c010d0ae:	89 04 24             	mov    %eax,(%esp)
c010d0b1:	e8 63 63 ff ff       	call   c0103419 <memset>

    kernel_context.arch_context.entries[PDE_INDEX(vframe)] = pframe | VMM_WRITABLE | VMM_PRESENT;
c010d0b6:	a1 40 f0 11 c0       	mov    0xc011f040,%eax
c010d0bb:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010d0be:	c1 ea 16             	shr    $0x16,%edx
c010d0c1:	c1 e2 02             	shl    $0x2,%edx
c010d0c4:	01 d0                	add    %edx,%eax
c010d0c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010d0c9:	83 ca 03             	or     $0x3,%edx
c010d0cc:	89 10                	mov    %edx,(%eax)
    vmm_map_range(&kernel_context, 0, MEMORY_LAYOUT_KERNEL_START, NUM_PAGES(MEMORY_LAYOUT_DIRECT_MAPPED), VMM_WRITABLE);// kernel
c010d0ce:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
c010d0d5:	00 
c010d0d6:	c7 44 24 0c 00 20 00 	movl   $0x2000,0xc(%esp)
c010d0dd:	00 
c010d0de:	c7 44 24 08 00 00 00 	movl   $0xc0000000,0x8(%esp)
c010d0e5:	c0 
c010d0e6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010d0ed:	00 
c010d0ee:	c7 04 24 40 f0 11 c0 	movl   $0xc011f040,(%esp)
c010d0f5:	e8 e7 e7 ff ff       	call   c010b8e1 <vmm_map_range>
    vmm_map(&kernel_context, 0xB8000, 0xC00B8000, VMM_WRITABLE);// videomemory (0xB8000 - 0xBFFFF)
c010d0fa:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c010d101:	00 
c010d102:	c7 44 24 08 00 80 0b 	movl   $0xc00b8000,0x8(%esp)
c010d109:	c0 
c010d10a:	c7 44 24 04 00 80 0b 	movl   $0xb8000,0x4(%esp)
c010d111:	00 
c010d112:	c7 04 24 40 f0 11 c0 	movl   $0xc011f040,(%esp)
c010d119:	e8 7a e7 ff ff       	call   c010b898 <vmm_map>
    // multiboot
    vmm_map(&kernel_context, ((vaddr_t)mb_info & (~0xfff)) - MEMORY_LAYOUT_KERNEL_START, ((paddr_t)mb_info&(~0xfff)), VMM_WRITABLE);
c010d11e:	8b 45 08             	mov    0x8(%ebp),%eax
c010d121:	89 c2                	mov    %eax,%edx
c010d123:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010d129:	8b 45 08             	mov    0x8(%ebp),%eax
c010d12c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d131:	05 00 00 00 40       	add    $0x40000000,%eax
c010d136:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c010d13d:	00 
c010d13e:	89 54 24 08          	mov    %edx,0x8(%esp)
c010d142:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d146:	c7 04 24 40 f0 11 c0 	movl   $0xc011f040,(%esp)
c010d14d:	e8 46 e7 ff ff       	call   c010b898 <vmm_map>
    vmm_map(&kernel_context, (mb_info->mods_addr & (~0xfff)) - MEMORY_LAYOUT_KERNEL_START, mb_info->mods_addr & (~0xfff), VMM_WRITABLE);
c010d152:	8b 45 08             	mov    0x8(%ebp),%eax
c010d155:	8b 40 18             	mov    0x18(%eax),%eax
c010d158:	89 c2                	mov    %eax,%edx
c010d15a:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010d160:	8b 45 08             	mov    0x8(%ebp),%eax
c010d163:	8b 40 18             	mov    0x18(%eax),%eax
c010d166:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d16b:	05 00 00 00 40       	add    $0x40000000,%eax
c010d170:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
c010d177:	00 
c010d178:	89 54 24 08          	mov    %edx,0x8(%esp)
c010d17c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d180:	c7 04 24 40 f0 11 c0 	movl   $0xc011f040,(%esp)
c010d187:	e8 0c e7 ff ff       	call   c010b898 <vmm_map>

    int i;
    uintptr_t addr;
    struct mods_add *modules = (void*) mb_info->mods_addr;
c010d18c:	8b 45 08             	mov    0x8(%ebp),%eax
c010d18f:	8b 40 18             	mov    0x18(%eax),%eax
c010d192:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(i = 0; i < mb_info->mods_count; i++)
c010d195:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010d19c:	eb 5b                	jmp    c010d1f9 <ARCH_INIT_PAGING+0x18c>
    {
        addr = modules[i].mod_start & (~0xfff);
c010d19e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d1a1:	89 c2                	mov    %eax,%edx
c010d1a3:	c1 e2 04             	shl    $0x4,%edx
c010d1a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010d1a9:	01 d0                	add    %edx,%eax
c010d1ab:	8b 00                	mov    (%eax),%eax
c010d1ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d1b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        while(addr < modules[i].mod_end)
c010d1b5:	eb 29                	jmp    c010d1e0 <ARCH_INIT_PAGING+0x173>
        {
            vmm_map(&kernel_context, addr, addr, VMM_PRESENT | VMM_WRITABLE);
c010d1b7:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
c010d1be:	00 
c010d1bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d1c2:	89 44 24 08          	mov    %eax,0x8(%esp)
c010d1c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d1c9:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d1cd:	c7 04 24 40 f0 11 c0 	movl   $0xc011f040,(%esp)
c010d1d4:	e8 bf e6 ff ff       	call   c010b898 <vmm_map>
            addr += PAGE_SIZE;
c010d1d9:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
    uintptr_t addr;
    struct mods_add *modules = (void*) mb_info->mods_addr;
    for(i = 0; i < mb_info->mods_count; i++)
    {
        addr = modules[i].mod_start & (~0xfff);
        while(addr < modules[i].mod_end)
c010d1e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d1e3:	89 c2                	mov    %eax,%edx
c010d1e5:	c1 e2 04             	shl    $0x4,%edx
c010d1e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010d1eb:	01 d0                	add    %edx,%eax
c010d1ed:	8b 40 04             	mov    0x4(%eax),%eax
c010d1f0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c010d1f3:	77 c2                	ja     c010d1b7 <ARCH_INIT_PAGING+0x14a>
    vmm_map(&kernel_context, (mb_info->mods_addr & (~0xfff)) - MEMORY_LAYOUT_KERNEL_START, mb_info->mods_addr & (~0xfff), VMM_WRITABLE);

    int i;
    uintptr_t addr;
    struct mods_add *modules = (void*) mb_info->mods_addr;
    for(i = 0; i < mb_info->mods_count; i++)
c010d1f5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010d1f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d1fc:	8b 45 08             	mov    0x8(%ebp),%eax
c010d1ff:	8b 40 14             	mov    0x14(%eax),%eax
c010d202:	39 c2                	cmp    %eax,%edx
c010d204:	72 98                	jb     c010d19e <ARCH_INIT_PAGING+0x131>
            vmm_map(&kernel_context, addr, addr, VMM_PRESENT | VMM_WRITABLE);
            addr += PAGE_SIZE;
        }
    }

    void *pd_vaddr = (void *) vmm_automap_kernel(&kernel_context, pframe, VMM_WRITABLE);
c010d206:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
c010d20d:	00 
c010d20e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d211:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d215:	c7 04 24 40 f0 11 c0 	movl   $0xc011f040,(%esp)
c010d21c:	e8 60 e7 ff ff       	call   c010b981 <vmm_automap_kernel>
c010d221:	89 45 e0             	mov    %eax,-0x20(%ebp)
    kernel_context.arch_context.entries = pd_vaddr;
c010d224:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010d227:	a3 40 f0 11 c0       	mov    %eax,0xc011f040

    arch_switch_context(&kernel_context.arch_context);
c010d22c:	c7 04 24 40 f0 11 c0 	movl   $0xc011f040,(%esp)
c010d233:	e8 a4 07 00 00       	call   c010d9dc <arch_switch_context>
    current_context = &kernel_context;
c010d238:	c7 05 30 90 11 c0 40 	movl   $0xc011f040,0xc0119030
c010d23f:	f0 11 c0 
}
c010d242:	c9                   	leave  
c010d243:	c3                   	ret    

c010d244 <arch_vmm_create_context>:
 *
 * @param context pointer to the memory structure
 * @return void
 */
void arch_vmm_create_context(arch_vmm_context_t *context)
{
c010d244:	55                   	push   %ebp
c010d245:	89 e5                	mov    %esp,%ebp
c010d247:	83 ec 28             	sub    $0x28,%esp
    uintptr_t paddr = (uintptr_t) pmm_alloc_page();
c010d24a:	e8 65 22 00 00       	call   c010f4b4 <pmm_alloc_page>
c010d24f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t vaddr = vmm_automap_kernel(current_context, paddr, VMM_PRESENT | VMM_WRITABLE);
c010d252:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d257:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c010d25e:	00 
c010d25f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d262:	89 54 24 04          	mov    %edx,0x4(%esp)
c010d266:	89 04 24             	mov    %eax,(%esp)
c010d269:	e8 13 e7 ff ff       	call   c010b981 <vmm_automap_kernel>
c010d26e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset((void*)vaddr, 0, PAGE_SIZE);
c010d271:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d274:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010d27b:	00 
c010d27c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010d283:	00 
c010d284:	89 04 24             	mov    %eax,(%esp)
c010d287:	e8 8d 61 ff ff       	call   c0103419 <memset>

    context->entries = (pde_t *) vaddr;
c010d28c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010d28f:	8b 45 08             	mov    0x8(%ebp),%eax
c010d292:	89 10                	mov    %edx,(%eax)
    context->phys_addr = paddr;
c010d294:	8b 45 08             	mov    0x8(%ebp),%eax
c010d297:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d29a:	89 50 04             	mov    %edx,0x4(%eax)

    arch_update_context(context);
c010d29d:	8b 45 08             	mov    0x8(%ebp),%eax
c010d2a0:	89 04 24             	mov    %eax,(%esp)
c010d2a3:	e8 b3 01 00 00       	call   c010d45b <arch_update_context>
}
c010d2a8:	c9                   	leave  
c010d2a9:	c3                   	ret    

c010d2aa <arch_vmm_destroy_context>:
 *
 * @param context pointer to to destroying context
 * @return void
 */
void arch_vmm_destroy_context(arch_vmm_context_t *context)
{
c010d2aa:	55                   	push   %ebp
c010d2ab:	89 e5                	mov    %esp,%ebp
c010d2ad:	83 ec 28             	sub    $0x28,%esp
    int pt;
    for (pt = 0; pt < PD_LENGTH; ++pt)
c010d2b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010d2b7:	eb 31                	jmp    c010d2ea <arch_vmm_destroy_context+0x40>
    {
        if (context->entries[pt] & VMM_PRESENT)
c010d2b9:	8b 45 08             	mov    0x8(%ebp),%eax
c010d2bc:	8b 00                	mov    (%eax),%eax
c010d2be:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d2c1:	c1 e2 02             	shl    $0x2,%edx
c010d2c4:	01 d0                	add    %edx,%eax
c010d2c6:	8b 00                	mov    (%eax),%eax
c010d2c8:	83 e0 01             	and    $0x1,%eax
c010d2cb:	85 c0                	test   %eax,%eax
c010d2cd:	74 17                	je     c010d2e6 <arch_vmm_destroy_context+0x3c>
        {
            pmm_mark_page_as_free((paddr_t)context->entries[pt]);
c010d2cf:	8b 45 08             	mov    0x8(%ebp),%eax
c010d2d2:	8b 00                	mov    (%eax),%eax
c010d2d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d2d7:	c1 e2 02             	shl    $0x2,%edx
c010d2da:	01 d0                	add    %edx,%eax
c010d2dc:	8b 00                	mov    (%eax),%eax
c010d2de:	89 04 24             	mov    %eax,(%esp)
c010d2e1:	e8 b7 1e 00 00       	call   c010f19d <pmm_mark_page_as_free>
 * @return void
 */
void arch_vmm_destroy_context(arch_vmm_context_t *context)
{
    int pt;
    for (pt = 0; pt < PD_LENGTH; ++pt)
c010d2e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010d2ea:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010d2f1:	7e c6                	jle    c010d2b9 <arch_vmm_destroy_context+0xf>
        if (context->entries[pt] & VMM_PRESENT)
        {
            pmm_mark_page_as_free((paddr_t)context->entries[pt]);
        }
    }
    pmm_mark_page_as_free((paddr_t)context->phys_addr);
c010d2f3:	8b 45 08             	mov    0x8(%ebp),%eax
c010d2f6:	8b 40 04             	mov    0x4(%eax),%eax
c010d2f9:	89 04 24             	mov    %eax,(%esp)
c010d2fc:	e8 9c 1e 00 00       	call   c010f19d <pmm_mark_page_as_free>
}
c010d301:	c9                   	leave  
c010d302:	c3                   	ret    

c010d303 <arch_sync_pts>:
 * @param index_low start pde-index
 * @param index_high end pde-index
 * @return void
 */
void arch_sync_pts(arch_vmm_context_t *dest, arch_vmm_context_t *src, int index_low, int index_high)
{
c010d303:	55                   	push   %ebp
c010d304:	89 e5                	mov    %esp,%ebp
c010d306:	83 ec 10             	sub    $0x10,%esp
    int i;
    for(i = index_low; i < index_high; i++)
c010d309:	8b 45 10             	mov    0x10(%ebp),%eax
c010d30c:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010d30f:	eb 22                	jmp    c010d333 <arch_sync_pts+0x30>
    {
        dest->entries[i] = src->entries[i];
c010d311:	8b 45 08             	mov    0x8(%ebp),%eax
c010d314:	8b 00                	mov    (%eax),%eax
c010d316:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010d319:	c1 e2 02             	shl    $0x2,%edx
c010d31c:	01 c2                	add    %eax,%edx
c010d31e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d321:	8b 00                	mov    (%eax),%eax
c010d323:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c010d326:	c1 e1 02             	shl    $0x2,%ecx
c010d329:	01 c8                	add    %ecx,%eax
c010d32b:	8b 00                	mov    (%eax),%eax
c010d32d:	89 02                	mov    %eax,(%edx)
 * @return void
 */
void arch_sync_pts(arch_vmm_context_t *dest, arch_vmm_context_t *src, int index_low, int index_high)
{
    int i;
    for(i = index_low; i < index_high; i++)
c010d32f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010d333:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010d336:	3b 45 14             	cmp    0x14(%ebp),%eax
c010d339:	7c d6                	jl     c010d311 <arch_sync_pts+0xe>
    {
        dest->entries[i] = src->entries[i];
    }
}
c010d33b:	c9                   	leave  
c010d33c:	c3                   	ret    

c010d33d <arch_fork_context>:
 * @param src the original context
 * @param dest the new context
 * @return void
 */
void arch_fork_context(arch_vmm_context_t *src, arch_vmm_context_t *dest)
{
c010d33d:	55                   	push   %ebp
c010d33e:	89 e5                	mov    %esp,%ebp
c010d340:	83 ec 28             	sub    $0x28,%esp
    if(src != NULL && dest != NULL)
c010d343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010d347:	0f 84 0c 01 00 00    	je     c010d459 <arch_fork_context+0x11c>
c010d34d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010d351:	0f 84 02 01 00 00    	je     c010d459 <arch_fork_context+0x11c>
    {
        if(src->entries != NULL && dest->entries != NULL)
c010d357:	8b 45 08             	mov    0x8(%ebp),%eax
c010d35a:	8b 00                	mov    (%eax),%eax
c010d35c:	85 c0                	test   %eax,%eax
c010d35e:	0f 84 f5 00 00 00    	je     c010d459 <arch_fork_context+0x11c>
c010d364:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d367:	8b 00                	mov    (%eax),%eax
c010d369:	85 c0                	test   %eax,%eax
c010d36b:	0f 84 e8 00 00 00    	je     c010d459 <arch_fork_context+0x11c>
        {
            int i;
            for(i = 0; i < 1024; i++)
c010d371:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010d378:	e9 cf 00 00 00       	jmp    c010d44c <arch_fork_context+0x10f>
            {
                if(src->entries[i] & VMM_PRESENT)
c010d37d:	8b 45 08             	mov    0x8(%ebp),%eax
c010d380:	8b 00                	mov    (%eax),%eax
c010d382:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d385:	c1 e2 02             	shl    $0x2,%edx
c010d388:	01 d0                	add    %edx,%eax
c010d38a:	8b 00                	mov    (%eax),%eax
c010d38c:	83 e0 01             	and    $0x1,%eax
c010d38f:	85 c0                	test   %eax,%eax
c010d391:	0f 84 b1 00 00 00    	je     c010d448 <arch_fork_context+0x10b>
                {
                    int flags = src->entries[i] & 0xfff;
c010d397:	8b 45 08             	mov    0x8(%ebp),%eax
c010d39a:	8b 00                	mov    (%eax),%eax
c010d39c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d39f:	c1 e2 02             	shl    $0x2,%edx
c010d3a2:	01 d0                	add    %edx,%eax
c010d3a4:	8b 00                	mov    (%eax),%eax
c010d3a6:	25 ff 0f 00 00       	and    $0xfff,%eax
c010d3ab:	89 45 f0             	mov    %eax,-0x10(%ebp)

                    pt_t *pt_src = (pt_t *) pt_get(src, i);
c010d3ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d3b1:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d3b5:	8b 45 08             	mov    0x8(%ebp),%eax
c010d3b8:	89 04 24             	mov    %eax,(%esp)
c010d3bb:	e8 dd 00 00 00       	call   c010d49d <pt_get>
c010d3c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
                    pt_t *pt_dest = (pt_t *) pt_create(dest, i, flags);
c010d3c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d3c6:	0f b6 c0             	movzbl %al,%eax
c010d3c9:	89 44 24 08          	mov    %eax,0x8(%esp)
c010d3cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d3d0:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d3d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d3d7:	89 04 24             	mov    %eax,(%esp)
c010d3da:	e8 3b 01 00 00       	call   c010d51a <pt_create>
c010d3df:	89 45 e8             	mov    %eax,-0x18(%ebp)

                    if(pt_src == NULL || pt_dest == NULL)
c010d3e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010d3e6:	74 06                	je     c010d3ee <arch_fork_context+0xb1>
c010d3e8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010d3ec:	75 0e                	jne    c010d3fc <arch_fork_context+0xbf>
                    {
                        printf("aaaah");
c010d3ee:	c7 04 24 78 0e 11 c0 	movl   $0xc0110e78,(%esp)
c010d3f5:	e8 27 62 ff ff       	call   c0103621 <printf>
                        while(1);
c010d3fa:	eb fe                	jmp    c010d3fa <arch_fork_context+0xbd>
                    }

                    memcpy(pt_dest, pt_src, 0x1000);
c010d3fc:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010d403:	00 
c010d404:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d407:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d40b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010d40e:	89 04 24             	mov    %eax,(%esp)
c010d411:	e8 8d 5e ff ff       	call   c01032a3 <memcpy>

                    if(src != &current_context->arch_context)
c010d416:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d41b:	3b 45 08             	cmp    0x8(%ebp),%eax
c010d41e:	74 14                	je     c010d434 <arch_fork_context+0xf7>
                        vmm_unmap(current_context, (vaddr_t) pt_src);
c010d420:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010d423:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d428:	89 54 24 04          	mov    %edx,0x4(%esp)
c010d42c:	89 04 24             	mov    %eax,(%esp)
c010d42f:	e8 93 e4 ff ff       	call   c010b8c7 <vmm_unmap>
                    vmm_unmap(current_context, (vaddr_t) pt_dest);
c010d434:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010d437:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d43c:	89 54 24 04          	mov    %edx,0x4(%esp)
c010d440:	89 04 24             	mov    %eax,(%esp)
c010d443:	e8 7f e4 ff ff       	call   c010b8c7 <vmm_unmap>
    if(src != NULL && dest != NULL)
    {
        if(src->entries != NULL && dest->entries != NULL)
        {
            int i;
            for(i = 0; i < 1024; i++)
c010d448:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010d44c:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010d453:	0f 8e 24 ff ff ff    	jle    c010d37d <arch_fork_context+0x40>
                    vmm_unmap(current_context, (vaddr_t) pt_dest);
                }
            }
        }
    }
}
c010d459:	c9                   	leave  
c010d45a:	c3                   	ret    

c010d45b <arch_update_context>:
 *
 * @param context context
 * @return void
 */
void arch_update_context(arch_vmm_context_t *context)
{
c010d45b:	55                   	push   %ebp
c010d45c:	89 e5                	mov    %esp,%ebp
c010d45e:	83 ec 10             	sub    $0x10,%esp
#define START PDE_INDEX(MEMORY_LAYOUT_KERNEL_START)
    arch_sync_pts(context, &current_context->arch_context, START, 1024);
c010d461:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d466:	c7 44 24 0c 00 04 00 	movl   $0x400,0xc(%esp)
c010d46d:	00 
c010d46e:	c7 44 24 08 00 03 00 	movl   $0x300,0x8(%esp)
c010d475:	00 
c010d476:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d47a:	8b 45 08             	mov    0x8(%ebp),%eax
c010d47d:	89 04 24             	mov    %eax,(%esp)
c010d480:	e8 7e fe ff ff       	call   c010d303 <arch_sync_pts>
    context->entries[PDE_INDEX(MEMORY_LAYOUT_PAGING_STRUCTURES_START)] = (uint32_t) context->phys_addr | VMM_PRESENT | VMM_WRITABLE;
c010d485:	8b 45 08             	mov    0x8(%ebp),%eax
c010d488:	8b 00                	mov    (%eax),%eax
c010d48a:	8d 90 f8 0f 00 00    	lea    0xff8(%eax),%edx
c010d490:	8b 45 08             	mov    0x8(%ebp),%eax
c010d493:	8b 40 04             	mov    0x4(%eax),%eax
c010d496:	83 c8 03             	or     $0x3,%eax
c010d499:	89 02                	mov    %eax,(%edx)
}
c010d49b:	c9                   	leave  
c010d49c:	c3                   	ret    

c010d49d <pt_get>:
 * @param index index
 * @param flags flags
 * @return pagetable
 */
pt_t pt_get(arch_vmm_context_t *context, int index)
{
c010d49d:	55                   	push   %ebp
c010d49e:	89 e5                	mov    %esp,%ebp
c010d4a0:	83 ec 28             	sub    $0x28,%esp
    pt_t pt;

    if(current_context != NULL)
c010d4a3:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d4a8:	85 c0                	test   %eax,%eax
c010d4aa:	74 52                	je     c010d4fe <pt_get+0x61>
    {
        if(context == &current_context->arch_context)
c010d4ac:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d4b1:	3b 45 08             	cmp    0x8(%ebp),%eax
c010d4b4:	75 10                	jne    c010d4c6 <pt_get+0x29>
        {
            pt = (pt_t) PT_VADDR(index);
c010d4b6:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d4b9:	05 00 f8 0f 00       	add    $0xff800,%eax
c010d4be:	c1 e0 0c             	shl    $0xc,%eax
c010d4c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010d4c4:	eb 4f                	jmp    c010d515 <pt_get+0x78>
        }
        else
        {
            pt = (pt_t) PT_PADDR(index);
c010d4c6:	8b 45 08             	mov    0x8(%ebp),%eax
c010d4c9:	8b 00                	mov    (%eax),%eax
c010d4cb:	8b 55 0c             	mov    0xc(%ebp),%edx
c010d4ce:	c1 e2 02             	shl    $0x2,%edx
c010d4d1:	01 d0                	add    %edx,%eax
c010d4d3:	8b 00                	mov    (%eax),%eax
c010d4d5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d4da:	89 45 f4             	mov    %eax,-0xc(%ebp)
            pt = (pt_t) vmm_automap_kernel(current_context, (paddr_t) pt, VMM_PRESENT | VMM_WRITABLE);
c010d4dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d4e0:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d4e5:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
c010d4ec:	00 
c010d4ed:	89 54 24 04          	mov    %edx,0x4(%esp)
c010d4f1:	89 04 24             	mov    %eax,(%esp)
c010d4f4:	e8 88 e4 ff ff       	call   c010b981 <vmm_automap_kernel>
c010d4f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010d4fc:	eb 17                	jmp    c010d515 <pt_get+0x78>
        }
    }
    else
    {
        pt = (pt_t) PT_PADDR(index) + MEMORY_LAYOUT_KERNEL_START;
c010d4fe:	8b 45 08             	mov    0x8(%ebp),%eax
c010d501:	8b 00                	mov    (%eax),%eax
c010d503:	8b 55 0c             	mov    0xc(%ebp),%edx
c010d506:	c1 e2 02             	shl    $0x2,%edx
c010d509:	01 d0                	add    %edx,%eax
c010d50b:	8b 00                	mov    (%eax),%eax
c010d50d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d512:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    return pt;
c010d515:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010d518:	c9                   	leave  
c010d519:	c3                   	ret    

c010d51a <pt_create>:
 * @param index index
 * @param flags flags
 * @return pagetable
 */
pt_t pt_create(arch_vmm_context_t *context, int index, uint8_t flags)
{
c010d51a:	55                   	push   %ebp
c010d51b:	89 e5                	mov    %esp,%ebp
c010d51d:	83 ec 38             	sub    $0x38,%esp
c010d520:	8b 45 10             	mov    0x10(%ebp),%eax
c010d523:	88 45 e4             	mov    %al,-0x1c(%ebp)
    pt_t pt;
    if(current_context == NULL)
c010d526:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d52b:	85 c0                	test   %eax,%eax
c010d52d:	75 11                	jne    c010d540 <pt_create+0x26>
        pt = (pt_t) pmm_alloc_page_limit(0);
c010d52f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010d536:	e8 b6 1f 00 00       	call   c010f4f1 <pmm_alloc_page_limit>
c010d53b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010d53e:	eb 08                	jmp    c010d548 <pt_create+0x2e>
    else
        pt = (pt_t)pmm_alloc_page();
c010d540:	e8 6f 1f 00 00       	call   c010f4b4 <pmm_alloc_page>
c010d545:	89 45 f4             	mov    %eax,-0xc(%ebp)

    context->entries[index] = (pde_t) pt | flags | VMM_PRESENT;
c010d548:	8b 45 08             	mov    0x8(%ebp),%eax
c010d54b:	8b 00                	mov    (%eax),%eax
c010d54d:	8b 55 0c             	mov    0xc(%ebp),%edx
c010d550:	c1 e2 02             	shl    $0x2,%edx
c010d553:	01 d0                	add    %edx,%eax
c010d555:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c010d559:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d55c:	09 ca                	or     %ecx,%edx
c010d55e:	83 ca 01             	or     $0x1,%edx
c010d561:	89 10                	mov    %edx,(%eax)

    pt = pt_get(context, index);
c010d563:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d566:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d56a:	8b 45 08             	mov    0x8(%ebp),%eax
c010d56d:	89 04 24             	mov    %eax,(%esp)
c010d570:	e8 28 ff ff ff       	call   c010d49d <pt_get>
c010d575:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memset(pt, 0, 4096);
c010d578:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
c010d57f:	00 
c010d580:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010d587:	00 
c010d588:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d58b:	89 04 24             	mov    %eax,(%esp)
c010d58e:	e8 86 5e ff ff       	call   c0103419 <memset>

    return pt;
c010d593:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010d596:	c9                   	leave  
c010d597:	c3                   	ret    

c010d598 <pt_destroy>:
 * @param context pagedirectory
 * @param index index
 * @return void
 */
void pt_destroy(arch_vmm_context_t *context, int index)
{
c010d598:	55                   	push   %ebp
c010d599:	89 e5                	mov    %esp,%ebp
c010d59b:	83 ec 18             	sub    $0x18,%esp
    pmm_mark_page_as_free((paddr_t)context->entries[index]);
c010d59e:	8b 45 08             	mov    0x8(%ebp),%eax
c010d5a1:	8b 00                	mov    (%eax),%eax
c010d5a3:	8b 55 0c             	mov    0xc(%ebp),%edx
c010d5a6:	c1 e2 02             	shl    $0x2,%edx
c010d5a9:	01 d0                	add    %edx,%eax
c010d5ab:	8b 00                	mov    (%eax),%eax
c010d5ad:	89 04 24             	mov    %eax,(%esp)
c010d5b0:	e8 e8 1b 00 00       	call   c010f19d <pmm_mark_page_as_free>
    context->entries[index] = 0;
c010d5b5:	8b 45 08             	mov    0x8(%ebp),%eax
c010d5b8:	8b 00                	mov    (%eax),%eax
c010d5ba:	8b 55 0c             	mov    0xc(%ebp),%edx
c010d5bd:	c1 e2 02             	shl    $0x2,%edx
c010d5c0:	01 d0                	add    %edx,%eax
c010d5c2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c010d5c8:	c9                   	leave  
c010d5c9:	c3                   	ret    

c010d5ca <arch_map>:
 * @param vframe vitual adress
 * @param flags flags
 * @return success
 */
int arch_map(arch_vmm_context_t *context, paddr_t pframe, vaddr_t vframe, uint8_t flags)
{
c010d5ca:	55                   	push   %ebp
c010d5cb:	89 e5                	mov    %esp,%ebp
c010d5cd:	83 ec 38             	sub    $0x38,%esp
c010d5d0:	8b 45 14             	mov    0x14(%ebp),%eax
c010d5d3:	88 45 e4             	mov    %al,-0x1c(%ebp)
    if( (pframe & 0xFFF) || (vframe & 0xFFF) )
c010d5d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d5d9:	25 ff 0f 00 00       	and    $0xfff,%eax
c010d5de:	85 c0                	test   %eax,%eax
c010d5e0:	75 0c                	jne    c010d5ee <arch_map+0x24>
c010d5e2:	8b 45 10             	mov    0x10(%ebp),%eax
c010d5e5:	25 ff 0f 00 00       	and    $0xfff,%eax
c010d5ea:	85 c0                	test   %eax,%eax
c010d5ec:	74 24                	je     c010d612 <arch_map+0x48>
    {
        printf("pd_map(): can't map 0x%x to 0x%x.", pframe, vframe);
c010d5ee:	8b 45 10             	mov    0x10(%ebp),%eax
c010d5f1:	89 44 24 08          	mov    %eax,0x8(%esp)
c010d5f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d5f8:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d5fc:	c7 04 24 80 0e 11 c0 	movl   $0xc0110e80,(%esp)
c010d603:	e8 19 60 ff ff       	call   c0103621 <printf>
        return -1;
c010d608:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010d60d:	e9 d2 00 00 00       	jmp    c010d6e4 <arch_map+0x11a>
    }

    uint32_t pd_index = PDE_INDEX(vframe);
c010d612:	8b 45 10             	mov    0x10(%ebp),%eax
c010d615:	c1 e8 16             	shr    $0x16,%eax
c010d618:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t pt_index = PTE_INDEX(vframe);
c010d61b:	8b 45 10             	mov    0x10(%ebp),%eax
c010d61e:	c1 e8 0c             	shr    $0xc,%eax
c010d621:	25 ff 03 00 00       	and    $0x3ff,%eax
c010d626:	89 45 ec             	mov    %eax,-0x14(%ebp)

    pt_t pt = NULL;
c010d629:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    pde_t pde = context->entries[pd_index];
c010d630:	8b 45 08             	mov    0x8(%ebp),%eax
c010d633:	8b 00                	mov    (%eax),%eax
c010d635:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010d638:	c1 e2 02             	shl    $0x2,%edx
c010d63b:	01 d0                	add    %edx,%eax
c010d63d:	8b 00                	mov    (%eax),%eax
c010d63f:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if (pde & VMM_PRESENT)
c010d642:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010d645:	83 e0 01             	and    $0x1,%eax
c010d648:	85 c0                	test   %eax,%eax
c010d64a:	74 17                	je     c010d663 <arch_map+0x99>
    {
        pt = pt_get(context, pd_index);
c010d64c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d64f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d653:	8b 45 08             	mov    0x8(%ebp),%eax
c010d656:	89 04 24             	mov    %eax,(%esp)
c010d659:	e8 3f fe ff ff       	call   c010d49d <pt_get>
c010d65e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010d661:	eb 23                	jmp    c010d686 <arch_map+0xbc>
    }
    else
    {
        pt = pt_create(context, pd_index, VMM_PRESENT | flags);
c010d663:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c010d667:	83 c8 01             	or     $0x1,%eax
c010d66a:	0f b6 d0             	movzbl %al,%edx
c010d66d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d670:	89 54 24 08          	mov    %edx,0x8(%esp)
c010d674:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d678:	8b 45 08             	mov    0x8(%ebp),%eax
c010d67b:	89 04 24             	mov    %eax,(%esp)
c010d67e:	e8 97 fe ff ff       	call   c010d51a <pt_create>
c010d683:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    pt[pt_index] = (pte_t)(pframe & ~0xFFF) | VMM_PRESENT | (flags & 0xFFF);
c010d686:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d689:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010d690:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d693:	01 d0                	add    %edx,%eax
c010d695:	8b 55 0c             	mov    0xc(%ebp),%edx
c010d698:	89 d1                	mov    %edx,%ecx
c010d69a:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c010d6a0:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c010d6a4:	09 ca                	or     %ecx,%edx
c010d6a6:	83 ca 01             	or     $0x1,%edx
c010d6a9:	89 10                	mov    %edx,(%eax)

    if(current_context != NULL)
c010d6ab:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d6b0:	85 c0                	test   %eax,%eax
c010d6b2:	74 2b                	je     c010d6df <arch_map+0x115>
    {
        if(context == &current_context->arch_context)
c010d6b4:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d6b9:	3b 45 08             	cmp    0x8(%ebp),%eax
c010d6bc:	75 0d                	jne    c010d6cb <arch_map+0x101>
        {
            paging_flush_tlb(vframe);
c010d6be:	8b 45 10             	mov    0x10(%ebp),%eax
c010d6c1:	89 04 24             	mov    %eax,(%esp)
c010d6c4:	e8 de 03 00 00       	call   c010daa7 <paging_flush_tlb>
c010d6c9:	eb 14                	jmp    c010d6df <arch_map+0x115>
        }
        else
        {
            vmm_unmap(current_context, (vaddr_t) pt);
c010d6cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d6ce:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d6d3:	89 54 24 04          	mov    %edx,0x4(%esp)
c010d6d7:	89 04 24             	mov    %eax,(%esp)
c010d6da:	e8 e8 e1 ff ff       	call   c010b8c7 <vmm_unmap>
        }
    }

    return 0;
c010d6df:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010d6e4:	c9                   	leave  
c010d6e5:	c3                   	ret    

c010d6e6 <arch_unmap>:
 * @param frame adress to unmap
 *
 * @return void
 */
int arch_unmap(arch_vmm_context_t *context, vaddr_t frame)
{
c010d6e6:	55                   	push   %ebp
c010d6e7:	89 e5                	mov    %esp,%ebp
c010d6e9:	83 ec 28             	sub    $0x28,%esp
    pt_t pt = pt_get(context, PDE_INDEX(frame));
c010d6ec:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d6ef:	c1 e8 16             	shr    $0x16,%eax
c010d6f2:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d6f6:	8b 45 08             	mov    0x8(%ebp),%eax
c010d6f9:	89 04 24             	mov    %eax,(%esp)
c010d6fc:	e8 9c fd ff ff       	call   c010d49d <pt_get>
c010d701:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pt[PTE_INDEX(frame)] = 0;
c010d704:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d707:	c1 e8 0c             	shr    $0xc,%eax
c010d70a:	25 ff 03 00 00       	and    $0x3ff,%eax
c010d70f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010d716:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d719:	01 d0                	add    %edx,%eax
c010d71b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    int pt_emty = 1, i;
c010d721:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    for(i = 0; i < PT_LENGTH; i++)
c010d728:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010d72f:	eb 22                	jmp    c010d753 <arch_unmap+0x6d>
    {
        if(pt[i])
c010d731:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d734:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010d73b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d73e:	01 d0                	add    %edx,%eax
c010d740:	8b 00                	mov    (%eax),%eax
c010d742:	85 c0                	test   %eax,%eax
c010d744:	74 09                	je     c010d74f <arch_unmap+0x69>
        {
            pt_emty = 0;
c010d746:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            break;
c010d74d:	eb 0d                	jmp    c010d75c <arch_unmap+0x76>
{
    pt_t pt = pt_get(context, PDE_INDEX(frame));
    pt[PTE_INDEX(frame)] = 0;

    int pt_emty = 1, i;
    for(i = 0; i < PT_LENGTH; i++)
c010d74f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010d753:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010d75a:	7e d5                	jle    c010d731 <arch_unmap+0x4b>
            pt_emty = 0;
            break;
        }
    }

    if(pt_emty)
c010d75c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010d760:	74 17                	je     c010d779 <arch_unmap+0x93>
    {
        pt_destroy(context, PDE_INDEX(frame));
c010d762:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d765:	c1 e8 16             	shr    $0x16,%eax
c010d768:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d76c:	8b 45 08             	mov    0x8(%ebp),%eax
c010d76f:	89 04 24             	mov    %eax,(%esp)
c010d772:	e8 21 fe ff ff       	call   c010d598 <pt_destroy>
c010d777:	eb 1e                	jmp    c010d797 <arch_unmap+0xb1>
    }
    else
    {
        if(context != &current_context->arch_context)
c010d779:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d77e:	3b 45 08             	cmp    0x8(%ebp),%eax
c010d781:	74 14                	je     c010d797 <arch_unmap+0xb1>
            vmm_unmap(current_context, (vaddr_t) pt);
c010d783:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010d786:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d78b:	89 54 24 04          	mov    %edx,0x4(%esp)
c010d78f:	89 04 24             	mov    %eax,(%esp)
c010d792:	e8 30 e1 ff ff       	call   c010b8c7 <vmm_unmap>
    }

    return 0;
c010d797:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010d79c:	c9                   	leave  
c010d79d:	c3                   	ret    

c010d79e <arch_vaddr_find>:
 * @param limit_high the highest limit of the adress
 * @param flags paging flags for temporary mappings
 * @return virtual start adress
 */
vaddr_t arch_vaddr_find(arch_vmm_context_t *context, int num, vaddr_t limit_low, vaddr_t limit_high)
{
c010d79e:	55                   	push   %ebp
c010d79f:	89 e5                	mov    %esp,%ebp
c010d7a1:	83 ec 48             	sub    $0x48,%esp
	  pages_found += l; \
	  if(pages_found >= num) { \
	    return vaddr; \
	  }

    vaddr_t vaddr = 0;
c010d7a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int page = 0;
c010d7ab:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    int pages_found = 0;
c010d7b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    uint32_t pd_index = PDE_INDEX(limit_low);
c010d7b9:	8b 45 10             	mov    0x10(%ebp),%eax
c010d7bc:	c1 e8 16             	shr    $0x16,%eax
c010d7bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t pt_index = PTE_INDEX(limit_low);
c010d7c2:	8b 45 10             	mov    0x10(%ebp),%eax
c010d7c5:	c1 e8 0c             	shr    $0xc,%eax
c010d7c8:	25 ff 03 00 00       	and    $0x3ff,%eax
c010d7cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t pd_index_end = PDE_INDEX(limit_high);
c010d7d0:	8b 45 14             	mov    0x14(%ebp),%eax
c010d7d3:	c1 e8 16             	shr    $0x16,%eax
c010d7d6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint32_t pt_index_end = PTE_INDEX(limit_high);
c010d7d9:	8b 45 14             	mov    0x14(%ebp),%eax
c010d7dc:	c1 e8 0c             	shr    $0xc,%eax
c010d7df:	25 ff 03 00 00       	and    $0x3ff,%eax
c010d7e4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    pt_t pt;
    while(pd_index <= pd_index_end)
c010d7e7:	e9 09 01 00 00       	jmp    c010d8f5 <arch_vaddr_find+0x157>
    {
        if(context->entries[pd_index] & VMM_PRESENT)
c010d7ec:	8b 45 08             	mov    0x8(%ebp),%eax
c010d7ef:	8b 00                	mov    (%eax),%eax
c010d7f1:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010d7f4:	c1 e2 02             	shl    $0x2,%edx
c010d7f7:	01 d0                	add    %edx,%eax
c010d7f9:	8b 00                	mov    (%eax),%eax
c010d7fb:	83 e0 01             	and    $0x1,%eax
c010d7fe:	85 c0                	test   %eax,%eax
c010d800:	0f 84 b8 00 00 00    	je     c010d8be <arch_vaddr_find+0x120>
        {
            pt = pt_get(context, pd_index);
c010d806:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d809:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d80d:	8b 45 08             	mov    0x8(%ebp),%eax
c010d810:	89 04 24             	mov    %eax,(%esp)
c010d813:	e8 85 fc ff ff       	call   c010d49d <pt_get>
c010d818:	89 45 d8             	mov    %eax,-0x28(%ebp)

            uint32_t pt_end = (pd_index == pd_index_end) ? pt_index_end : PT_LENGTH; // last pd entry
c010d81b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d81e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c010d821:	75 05                	jne    c010d828 <arch_vaddr_find+0x8a>
c010d823:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010d826:	eb 05                	jmp    c010d82d <arch_vaddr_find+0x8f>
c010d828:	b8 00 04 00 00       	mov    $0x400,%eax
c010d82d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            for(; pt_index < pt_end; pt_index++)
c010d830:	eb 5d                	jmp    c010d88f <arch_vaddr_find+0xf1>
            {
                if(! ((uint32_t)pt[pt_index] & VMM_PRESENT) )
c010d832:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010d835:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010d83c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010d83f:	01 d0                	add    %edx,%eax
c010d841:	8b 00                	mov    (%eax),%eax
c010d843:	83 e0 01             	and    $0x1,%eax
c010d846:	85 c0                	test   %eax,%eax
c010d848:	75 33                	jne    c010d87d <arch_vaddr_find+0xdf>
                {
                    PAGES_FOUND(1);
c010d84a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010d84e:	75 19                	jne    c010d869 <arch_vaddr_find+0xcb>
c010d850:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d853:	89 c2                	mov    %eax,%edx
c010d855:	c1 e2 0a             	shl    $0xa,%edx
c010d858:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010d85b:	01 d0                	add    %edx,%eax
c010d85d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c010d860:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010d863:	c1 e0 0c             	shl    $0xc,%eax
c010d866:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010d869:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010d86d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d870:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010d873:	7c 16                	jl     c010d88b <arch_vaddr_find+0xed>
c010d875:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d878:	e9 89 00 00 00       	jmp    c010d906 <arch_vaddr_find+0x168>
                }
                else
                {
                    pages_found = 0;
c010d87d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
                    vaddr = (uintptr_t)NULL;
c010d884:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        if(context->entries[pd_index] & VMM_PRESENT)
        {
            pt = pt_get(context, pd_index);

            uint32_t pt_end = (pd_index == pd_index_end) ? pt_index_end : PT_LENGTH; // last pd entry
            for(; pt_index < pt_end; pt_index++)
c010d88b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010d88f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010d892:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
c010d895:	72 9b                	jb     c010d832 <arch_vaddr_find+0x94>
                    pages_found = 0;
                    vaddr = (uintptr_t)NULL;
                }
            }

            pt_index = 0;
c010d897:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            if(context != &current_context->arch_context)
c010d89e:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d8a3:	3b 45 08             	cmp    0x8(%ebp),%eax
c010d8a6:	74 49                	je     c010d8f1 <arch_vaddr_find+0x153>
                vmm_unmap(current_context, (vaddr_t)pt);
c010d8a8:	8b 55 d8             	mov    -0x28(%ebp),%edx
c010d8ab:	a1 30 90 11 c0       	mov    0xc0119030,%eax
c010d8b0:	89 54 24 04          	mov    %edx,0x4(%esp)
c010d8b4:	89 04 24             	mov    %eax,(%esp)
c010d8b7:	e8 0b e0 ff ff       	call   c010b8c7 <vmm_unmap>
c010d8bc:	eb 33                	jmp    c010d8f1 <arch_vaddr_find+0x153>
        }
        else
        {
            PAGES_FOUND(PT_LENGTH);
c010d8be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010d8c2:	75 19                	jne    c010d8dd <arch_vaddr_find+0x13f>
c010d8c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d8c7:	89 c2                	mov    %eax,%edx
c010d8c9:	c1 e2 0a             	shl    $0xa,%edx
c010d8cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010d8cf:	01 d0                	add    %edx,%eax
c010d8d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c010d8d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010d8d7:	c1 e0 0c             	shl    $0xc,%eax
c010d8da:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010d8dd:	81 45 f0 00 04 00 00 	addl   $0x400,-0x10(%ebp)
c010d8e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d8e7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010d8ea:	7c 05                	jl     c010d8f1 <arch_vaddr_find+0x153>
c010d8ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d8ef:	eb 15                	jmp    c010d906 <arch_vaddr_find+0x168>
        }
        pd_index++;
c010d8f1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    uint32_t pd_index = PDE_INDEX(limit_low);
    uint32_t pt_index = PTE_INDEX(limit_low);
    uint32_t pd_index_end = PDE_INDEX(limit_high);
    uint32_t pt_index_end = PTE_INDEX(limit_high);
    pt_t pt;
    while(pd_index <= pd_index_end)
c010d8f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d8f8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c010d8fb:	0f 86 eb fe ff ff    	jbe    c010d7ec <arch_vaddr_find+0x4e>
            PAGES_FOUND(PT_LENGTH);
        }
        pd_index++;
    }

    return 0;
c010d901:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010d906:	c9                   	leave  
c010d907:	c3                   	ret    

c010d908 <arch_vmm_is_present>:
 * @param context context
 * @param vaddr adress to check
 * @return true, if is present; false, if not
 */
int arch_vmm_is_present(arch_vmm_context_t *context, vaddr_t vaddr)
{
c010d908:	55                   	push   %ebp
c010d909:	89 e5                	mov    %esp,%ebp
c010d90b:	83 ec 28             	sub    $0x28,%esp
    unsigned int pd_index = PDE_INDEX(vaddr);
c010d90e:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d911:	c1 e8 16             	shr    $0x16,%eax
c010d914:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned int pt_index = PTE_INDEX(vaddr);
c010d917:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d91a:	c1 e8 0c             	shr    $0xc,%eax
c010d91d:	25 ff 03 00 00       	and    $0x3ff,%eax
c010d922:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(context->entries[pd_index] & VMM_PRESENT)
c010d925:	8b 45 08             	mov    0x8(%ebp),%eax
c010d928:	8b 00                	mov    (%eax),%eax
c010d92a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d92d:	c1 e2 02             	shl    $0x2,%edx
c010d930:	01 d0                	add    %edx,%eax
c010d932:	8b 00                	mov    (%eax),%eax
c010d934:	83 e0 01             	and    $0x1,%eax
c010d937:	85 c0                	test   %eax,%eax
c010d939:	74 33                	je     c010d96e <arch_vmm_is_present+0x66>
    {
        pt_t *pt = (pt_t *)pt_get(context, pd_index);
c010d93b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d93e:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d942:	8b 45 08             	mov    0x8(%ebp),%eax
c010d945:	89 04 24             	mov    %eax,(%esp)
c010d948:	e8 50 fb ff ff       	call   c010d49d <pt_get>
c010d94d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return ((uint32_t)pt[pt_index] & VMM_PRESENT) ? 1 : 0;
c010d950:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d953:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010d95a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d95d:	01 d0                	add    %edx,%eax
c010d95f:	8b 00                	mov    (%eax),%eax
c010d961:	83 e0 01             	and    $0x1,%eax
c010d964:	85 c0                	test   %eax,%eax
c010d966:	0f 95 c0             	setne  %al
c010d969:	0f b6 c0             	movzbl %al,%eax
c010d96c:	eb 05                	jmp    c010d973 <arch_vmm_is_present+0x6b>
    }

    return 0;
c010d96e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010d973:	c9                   	leave  
c010d974:	c3                   	ret    

c010d975 <arch_vaddr2paddr>:
 * @param context context
 * @param vaddr the virtual adress
 * @return the physical adress
 */
paddr_t arch_vaddr2paddr(arch_vmm_context_t *context, vaddr_t vaddr)
{
c010d975:	55                   	push   %ebp
c010d976:	89 e5                	mov    %esp,%ebp
c010d978:	83 ec 28             	sub    $0x28,%esp
    unsigned int pd_index = PDE_INDEX(vaddr);
c010d97b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d97e:	c1 e8 16             	shr    $0x16,%eax
c010d981:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned int pt_index = PTE_INDEX(vaddr);
c010d984:	8b 45 0c             	mov    0xc(%ebp),%eax
c010d987:	c1 e8 0c             	shr    $0xc,%eax
c010d98a:	25 ff 03 00 00       	and    $0x3ff,%eax
c010d98f:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(context->entries[pd_index] & VMM_PRESENT)
c010d992:	8b 45 08             	mov    0x8(%ebp),%eax
c010d995:	8b 00                	mov    (%eax),%eax
c010d997:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010d99a:	c1 e2 02             	shl    $0x2,%edx
c010d99d:	01 d0                	add    %edx,%eax
c010d99f:	8b 00                	mov    (%eax),%eax
c010d9a1:	83 e0 01             	and    $0x1,%eax
c010d9a4:	85 c0                	test   %eax,%eax
c010d9a6:	74 2d                	je     c010d9d5 <arch_vaddr2paddr+0x60>
    {
        pt_t *pt = (pt_t *) pt_get(context, pd_index);
c010d9a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010d9ab:	89 44 24 04          	mov    %eax,0x4(%esp)
c010d9af:	8b 45 08             	mov    0x8(%ebp),%eax
c010d9b2:	89 04 24             	mov    %eax,(%esp)
c010d9b5:	e8 e3 fa ff ff       	call   c010d49d <pt_get>
c010d9ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return (paddr_t) pt[pt_index] & ~0xfff;
c010d9bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010d9c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010d9c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010d9ca:	01 d0                	add    %edx,%eax
c010d9cc:	8b 00                	mov    (%eax),%eax
c010d9ce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010d9d3:	eb 05                	jmp    c010d9da <arch_vaddr2paddr+0x65>
    }
    return 0;
c010d9d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010d9da:	c9                   	leave  
c010d9db:	c3                   	ret    

c010d9dc <arch_switch_context>:
 * @param context pagedirectory
 * @param flags flags
 * @return void
 */
void arch_switch_context(arch_vmm_context_t *context)
{
c010d9dc:	55                   	push   %ebp
c010d9dd:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %0, %%cr3" : : "r" (context->phys_addr));
c010d9df:	8b 45 08             	mov    0x8(%ebp),%eax
c010d9e2:	8b 40 04             	mov    0x4(%eax),%eax
c010d9e5:	0f 22 d8             	mov    %eax,%cr3
}
c010d9e8:	5d                   	pop    %ebp
c010d9e9:	c3                   	ret    

c010d9ea <page_fault_handler>:
 *
 * @param cpu current cpu state
 * @return void
 */
void page_fault_handler(struct cpu_state **cpu_p)
{
c010d9ea:	55                   	push   %ebp
c010d9eb:	89 e5                	mov    %esp,%ebp
c010d9ed:	56                   	push   %esi
c010d9ee:	53                   	push   %ebx
c010d9ef:	81 ec 30 02 00 00    	sub    $0x230,%esp
    struct cpu_state *cpu = cpu_p[0];
c010d9f5:	8b 45 08             	mov    0x8(%ebp),%eax
c010d9f8:	8b 00                	mov    (%eax),%eax
c010d9fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char message[512];

    uint32_t addr;
    asm volatile("mov %%cr2, %0" : "=r" (addr));
c010d9fd:	0f 20 d3             	mov    %cr2,%ebx
c010da00:	89 5d f0             	mov    %ebx,-0x10(%ebp)

    sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X\n Process: %s\n", ((cpu->error & 4) ? "user" : "kernel"),
            ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip,current_thread->process->name);
c010da03:	a1 0c 90 11 c0       	mov    0xc011900c,%eax
c010da08:	8b 00                	mov    (%eax),%eax
    char message[512];

    uint32_t addr;
    asm volatile("mov %%cr2, %0" : "=r" (addr));

    sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X\n Process: %s\n", ((cpu->error & 4) ? "user" : "kernel"),
c010da0a:	8b 70 0c             	mov    0xc(%eax),%esi
            ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip,current_thread->process->name);
c010da0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    char message[512];

    uint32_t addr;
    asm volatile("mov %%cr2, %0" : "=r" (addr));

    sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X\n Process: %s\n", ((cpu->error & 4) ? "user" : "kernel"),
c010da10:	8b 58 34             	mov    0x34(%eax),%ebx
            ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip,current_thread->process->name);
c010da13:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010da16:	8b 40 30             	mov    0x30(%eax),%eax
c010da19:	83 e0 01             	and    $0x1,%eax
    char message[512];

    uint32_t addr;
    asm volatile("mov %%cr2, %0" : "=r" (addr));

    sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X\n Process: %s\n", ((cpu->error & 4) ? "user" : "kernel"),
c010da1c:	85 c0                	test   %eax,%eax
c010da1e:	74 07                	je     c010da27 <page_fault_handler+0x3d>
c010da20:	b9 a2 0e 11 c0       	mov    $0xc0110ea2,%ecx
c010da25:	eb 05                	jmp    c010da2c <page_fault_handler+0x42>
c010da27:	b9 b0 0e 11 c0       	mov    $0xc0110eb0,%ecx
            ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip,current_thread->process->name);
c010da2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010da2f:	8b 40 30             	mov    0x30(%eax),%eax
c010da32:	83 e0 02             	and    $0x2,%eax
    char message[512];

    uint32_t addr;
    asm volatile("mov %%cr2, %0" : "=r" (addr));

    sprintf(message, "Page fault in %s space:\nError %s address %#010X: %s.\nEIP: %#010X\n Process: %s\n", ((cpu->error & 4) ? "user" : "kernel"),
c010da35:	85 c0                	test   %eax,%eax
c010da37:	74 07                	je     c010da40 <page_fault_handler+0x56>
c010da39:	ba be 0e 11 c0       	mov    $0xc0110ebe,%edx
c010da3e:	eb 05                	jmp    c010da45 <page_fault_handler+0x5b>
c010da40:	ba c9 0e 11 c0       	mov    $0xc0110ec9,%edx
c010da45:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010da48:	8b 40 30             	mov    0x30(%eax),%eax
c010da4b:	83 e0 04             	and    $0x4,%eax
c010da4e:	85 c0                	test   %eax,%eax
c010da50:	74 07                	je     c010da59 <page_fault_handler+0x6f>
c010da52:	b8 d4 0e 11 c0       	mov    $0xc0110ed4,%eax
c010da57:	eb 05                	jmp    c010da5e <page_fault_handler+0x74>
c010da59:	b8 d9 0e 11 c0       	mov    $0xc0110ed9,%eax
c010da5e:	89 74 24 1c          	mov    %esi,0x1c(%esp)
c010da62:	89 5c 24 18          	mov    %ebx,0x18(%esp)
c010da66:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c010da6a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c010da6d:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c010da71:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010da75:	89 44 24 08          	mov    %eax,0x8(%esp)
c010da79:	c7 44 24 04 e0 0e 11 	movl   $0xc0110ee0,0x4(%esp)
c010da80:	c0 
c010da81:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c010da87:	89 04 24             	mov    %eax,(%esp)
c010da8a:	e8 ff 5b ff ff       	call   c010368e <sprintf>
            ((cpu->error & 2) ? "writing to" : "reading at"), addr, ((cpu->error & 1) ? "Access denied" : "Nonpaged area"), cpu->eip,current_thread->process->name);

    panic(message);
c010da8f:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c010da95:	89 04 24             	mov    %eax,(%esp)
c010da98:	e8 b3 46 ff ff       	call   c0102150 <panic>
}
c010da9d:	81 c4 30 02 00 00    	add    $0x230,%esp
c010daa3:	5b                   	pop    %ebx
c010daa4:	5e                   	pop    %esi
c010daa5:	5d                   	pop    %ebp
c010daa6:	c3                   	ret    

c010daa7 <paging_flush_tlb>:

/**
 * @fn paging_flush_tlb
 */
static inline void paging_flush_tlb(vaddr_t addr)
{
c010daa7:	55                   	push   %ebp
c010daa8:	89 e5                	mov    %esp,%ebp
    asm volatile ("invlpg %0" : : "m" (*(char*) addr));
c010daaa:	8b 45 08             	mov    0x8(%ebp),%eax
c010daad:	0f 01 38             	invlpg (%eax)
}
c010dab0:	5d                   	pop    %ebp
c010dab1:	c3                   	ret    

c010dab2 <inb>:
#include <arch_context.h>

typedef uint16_t portid_t;

static inline uint8_t inb(uint16_t port)
{
c010dab2:	55                   	push   %ebp
c010dab3:	89 e5                	mov    %esp,%ebp
c010dab5:	53                   	push   %ebx
c010dab6:	83 ec 14             	sub    $0x14,%esp
c010dab9:	8b 45 08             	mov    0x8(%ebp),%eax
c010dabc:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    uint8_t result;
    asm volatile("inb %1, %0" : "=a" (result) : "Nd" (port));
c010dac0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c010dac4:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c010dac8:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c010dacc:	ec                   	in     (%dx),%al
c010dacd:	89 c3                	mov    %eax,%ebx
c010dacf:	88 5d fb             	mov    %bl,-0x5(%ebp)
    return result;
c010dad2:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
}
c010dad6:	83 c4 14             	add    $0x14,%esp
c010dad9:	5b                   	pop    %ebx
c010dada:	5d                   	pop    %ebp
c010dadb:	c3                   	ret    

c010dadc <outb>:
    asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
    return result;
}

static inline void outb(uint16_t port, uint8_t value)
{
c010dadc:	55                   	push   %ebp
c010dadd:	89 e5                	mov    %esp,%ebp
c010dadf:	83 ec 08             	sub    $0x8,%esp
c010dae2:	8b 55 08             	mov    0x8(%ebp),%edx
c010dae5:	8b 45 0c             	mov    0xc(%ebp),%eax
c010dae8:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010daec:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c010daef:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c010daf3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c010daf7:	ee                   	out    %al,(%dx)
}
c010daf8:	c9                   	leave  
c010daf9:	c3                   	ret    

c010dafa <get_cmos_data>:
 * @brief Reads the Values from Complementary Metal Oxide Semiconductor.
 * @param buffer
 * @return void
 */
void get_cmos_data(struct cmos_data *cmos)
{
c010dafa:	55                   	push   %ebp
c010dafb:	89 e5                	mov    %esp,%ebp
c010dafd:	83 ec 18             	sub    $0x18,%esp
    cmos->registers.register_a = cmos_read_byte(CMOS_TIMER_FREQ_REG);
c010db00:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c010db07:	e8 4b 01 00 00       	call   c010dc57 <cmos_read_byte>
c010db0c:	8b 55 08             	mov    0x8(%ebp),%edx
c010db0f:	88 02                	mov    %al,(%edx)
    cmos->registers.register_b = cmos_read_byte(CMOS_TIMER_SETTING);
c010db11:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
c010db18:	e8 3a 01 00 00       	call   c010dc57 <cmos_read_byte>
c010db1d:	8b 55 08             	mov    0x8(%ebp),%edx
c010db20:	88 42 01             	mov    %al,0x1(%edx)
    cmos->registers.register_c = cmos_read_byte(CMOS_SRC_REG);
c010db23:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c010db2a:	e8 28 01 00 00       	call   c010dc57 <cmos_read_byte>
c010db2f:	8b 55 08             	mov    0x8(%ebp),%edx
c010db32:	88 42 02             	mov    %al,0x2(%edx)
    cmos->registers.register_d = cmos_read_byte(CMOS_VALIDITY_REG);
c010db35:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
c010db3c:	e8 16 01 00 00       	call   c010dc57 <cmos_read_byte>
c010db41:	8b 55 08             	mov    0x8(%ebp),%edx
c010db44:	88 42 03             	mov    %al,0x3(%edx)

    cmos->hardware.post_diagnostig_status_byte = cmos_read_byte(0x0E);
c010db47:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c010db4e:	e8 04 01 00 00       	call   c010dc57 <cmos_read_byte>
c010db53:	8b 55 08             	mov    0x8(%ebp),%edx
c010db56:	88 42 04             	mov    %al,0x4(%edx)
    cmos->hardware.shutdown_status_byte =        cmos_read_byte(0x0F);
c010db59:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c010db60:	e8 f2 00 00 00       	call   c010dc57 <cmos_read_byte>
c010db65:	8b 55 08             	mov    0x8(%ebp),%edx
c010db68:	88 42 05             	mov    %al,0x5(%edx)
    cmos->hardware.floppy_disk_type =            cmos_read_byte(0x10);
c010db6b:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c010db72:	e8 e0 00 00 00       	call   c010dc57 <cmos_read_byte>
c010db77:	8b 55 08             	mov    0x8(%ebp),%edx
c010db7a:	88 42 06             	mov    %al,0x6(%edx)
    cmos->hardware.hd_type =                     cmos_read_byte(0x12);
c010db7d:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
c010db84:	e8 ce 00 00 00       	call   c010dc57 <cmos_read_byte>
c010db89:	8b 55 08             	mov    0x8(%ebp),%edx
c010db8c:	88 42 07             	mov    %al,0x7(%edx)
    cmos->hardware.device_byte =                 cmos_read_byte(0x14);
c010db8f:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c010db96:	e8 bc 00 00 00       	call   c010dc57 <cmos_read_byte>
c010db9b:	8b 55 08             	mov    0x8(%ebp),%edx
c010db9e:	88 42 08             	mov    %al,0x8(%edx)

    cmos->hardware.basememory_size_low =         cmos_read_byte(0x15);
c010dba1:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c010dba8:	e8 aa 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dbad:	8b 55 08             	mov    0x8(%ebp),%edx
c010dbb0:	88 42 09             	mov    %al,0x9(%edx)
    cmos->hardware.basememory_size_high =        cmos_read_byte(0x16);
c010dbb3:	c7 04 24 16 00 00 00 	movl   $0x16,(%esp)
c010dbba:	e8 98 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dbbf:	8b 55 08             	mov    0x8(%ebp),%edx
c010dbc2:	88 42 0a             	mov    %al,0xa(%edx)
    cmos->hardware.expandablememory_size_low =   cmos_read_byte(0x17);
c010dbc5:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
c010dbcc:	e8 86 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dbd1:	8b 55 08             	mov    0x8(%ebp),%edx
c010dbd4:	88 42 0b             	mov    %al,0xb(%edx)
    cmos->hardware.expandablememory_size_high =  cmos_read_byte(0x18);
c010dbd7:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
c010dbde:	e8 74 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dbe3:	8b 55 08             	mov    0x8(%ebp),%edx
c010dbe6:	88 42 0c             	mov    %al,0xc(%edx)
    cmos->hardware.extension_byte_hd1 =          cmos_read_byte(0x19);
c010dbe9:	c7 04 24 19 00 00 00 	movl   $0x19,(%esp)
c010dbf0:	e8 62 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dbf5:	8b 55 08             	mov    0x8(%ebp),%edx
c010dbf8:	88 42 0d             	mov    %al,0xd(%edx)
    cmos->hardware.extension_byte_hd2 =          cmos_read_byte(0x1A);
c010dbfb:	c7 04 24 1a 00 00 00 	movl   $0x1a,(%esp)
c010dc02:	e8 50 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dc07:	8b 55 08             	mov    0x8(%ebp),%edx
c010dc0a:	88 42 0e             	mov    %al,0xe(%edx)

    cmos->hardware.cmos_magic_low =              cmos_read_byte(0x2E);
c010dc0d:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
c010dc14:	e8 3e 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dc19:	8b 55 08             	mov    0x8(%ebp),%edx
c010dc1c:	88 42 0f             	mov    %al,0xf(%edx)
    cmos->hardware.cmos_magic_high =             cmos_read_byte(0x2F);
c010dc1f:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
c010dc26:	e8 2c 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dc2b:	8b 55 08             	mov    0x8(%ebp),%edx
c010dc2e:	88 42 10             	mov    %al,0x10(%edx)

    cmos->hardware.extendedmemory_low =          cmos_read_byte(0x30);
c010dc31:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
c010dc38:	e8 1a 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dc3d:	8b 55 08             	mov    0x8(%ebp),%edx
c010dc40:	88 42 11             	mov    %al,0x11(%edx)
    cmos->hardware.extendedmenory_high =         cmos_read_byte(0x31);
c010dc43:	c7 04 24 31 00 00 00 	movl   $0x31,(%esp)
c010dc4a:	e8 08 00 00 00       	call   c010dc57 <cmos_read_byte>
c010dc4f:	8b 55 08             	mov    0x8(%ebp),%edx
c010dc52:	88 42 12             	mov    %al,0x12(%edx)
}
c010dc55:	c9                   	leave  
c010dc56:	c3                   	ret    

c010dc57 <cmos_read_byte>:
 * @brief Reads a byte from CMOS.
 * @param offset Offset in the CMOS
 * @return Read value from CMOS
 */
uint8_t cmos_read_byte(uint8_t offset)
{
c010dc57:	55                   	push   %ebp
c010dc58:	89 e5                	mov    %esp,%ebp
c010dc5a:	83 ec 1c             	sub    $0x1c,%esp
c010dc5d:	8b 45 08             	mov    0x8(%ebp),%eax
c010dc60:	88 45 ec             	mov    %al,-0x14(%ebp)
    uint8_t tmp = inb(CMOS_ADDRESS_PORT);
c010dc63:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c010dc6a:	e8 43 fe ff ff       	call   c010dab2 <inb>
c010dc6f:	88 45 ff             	mov    %al,-0x1(%ebp)
    outb(CMOS_ADDRESS_PORT, (tmp & 0x80) | (offset & 0x7F));
c010dc72:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c010dc76:	89 c2                	mov    %eax,%edx
c010dc78:	83 e2 80             	and    $0xffffff80,%edx
c010dc7b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c010dc7f:	83 e0 7f             	and    $0x7f,%eax
c010dc82:	09 d0                	or     %edx,%eax
c010dc84:	0f b6 c0             	movzbl %al,%eax
c010dc87:	89 44 24 04          	mov    %eax,0x4(%esp)
c010dc8b:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c010dc92:	e8 45 fe ff ff       	call   c010dadc <outb>
    return inb(CMOS_DATA_PORT);
c010dc97:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
c010dc9e:	e8 0f fe ff ff       	call   c010dab2 <inb>
}
c010dca3:	c9                   	leave  
c010dca4:	c3                   	ret    

c010dca5 <cmos_write_byte>:
 * @param offset Offset in the CMOS
 * @param value Value which is written into the CMOS
 * @return void
 */
void cmos_write_byte(uint8_t offset, uint8_t value)
{
c010dca5:	55                   	push   %ebp
c010dca6:	89 e5                	mov    %esp,%ebp
c010dca8:	83 ec 20             	sub    $0x20,%esp
c010dcab:	8b 55 08             	mov    0x8(%ebp),%edx
c010dcae:	8b 45 0c             	mov    0xc(%ebp),%eax
c010dcb1:	88 55 ec             	mov    %dl,-0x14(%ebp)
c010dcb4:	88 45 e8             	mov    %al,-0x18(%ebp)
    uint8_t tmp = inb(CMOS_ADDRESS_PORT);
c010dcb7:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c010dcbe:	e8 ef fd ff ff       	call   c010dab2 <inb>
c010dcc3:	88 45 ff             	mov    %al,-0x1(%ebp)
    outb(CMOS_ADDRESS_PORT, (tmp & 0x80) | (offset & 0x7F));
c010dcc6:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c010dcca:	89 c2                	mov    %eax,%edx
c010dccc:	83 e2 80             	and    $0xffffff80,%edx
c010dccf:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c010dcd3:	83 e0 7f             	and    $0x7f,%eax
c010dcd6:	09 d0                	or     %edx,%eax
c010dcd8:	0f b6 c0             	movzbl %al,%eax
c010dcdb:	89 44 24 04          	mov    %eax,0x4(%esp)
c010dcdf:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c010dce6:	e8 f1 fd ff ff       	call   c010dadc <outb>
    outb(CMOS_DATA_PORT, value);
c010dceb:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c010dcef:	89 44 24 04          	mov    %eax,0x4(%esp)
c010dcf3:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
c010dcfa:	e8 dd fd ff ff       	call   c010dadc <outb>
}
c010dcff:	c9                   	leave  
c010dd00:	c3                   	ret    

c010dd01 <halt>:

/**
 *  @brief Stops the execution of the kernel and disables interrupts.
 */
void halt(void)
{
c010dd01:	55                   	push   %ebp
c010dd02:	89 e5                	mov    %esp,%ebp
    while (1)
    {
        asm volatile("cli; hlt");
c010dd04:	fa                   	cli    
c010dd05:	f4                   	hlt    
    }
c010dd06:	eb fc                	jmp    c010dd04 <halt+0x3>

c010dd08 <disable_irqs>:

/**
 *  @brief Disables interrupts.
 */
void disable_irqs(void)
{
c010dd08:	55                   	push   %ebp
c010dd09:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c010dd0b:	fa                   	cli    
}
c010dd0c:	5d                   	pop    %ebp
c010dd0d:	c3                   	ret    

c010dd0e <enable_irqs>:

/**
 *  @brief Enables interrupts.
 */
void enable_irqs(void)
{
c010dd0e:	55                   	push   %ebp
c010dd0f:	89 e5                	mov    %esp,%ebp
    asm volatile("sti");
c010dd11:	fb                   	sti    
}
c010dd12:	5d                   	pop    %ebp
c010dd13:	c3                   	ret    

c010dd14 <try_lock>:
 *  @brief Tries to lock a atomic mutex.
 *  @param m The mutex to be locked.
 *  @return true = sucess; false = already locked
 */
int try_lock(mutex *m)
{
c010dd14:	55                   	push   %ebp
c010dd15:	89 e5                	mov    %esp,%ebp
c010dd17:	57                   	push   %edi
c010dd18:	53                   	push   %ebx
c010dd19:	83 ec 14             	sub    $0x14,%esp
    int r;
    asm(
c010dd1c:	8b 7d 08             	mov    0x8(%ebp),%edi
c010dd1f:	89 7d e4             	mov    %edi,-0x1c(%ebp)
c010dd22:	8b 7d e4             	mov    -0x1c(%ebp),%edi
c010dd25:	b8 01 00 00 00       	mov    $0x1,%eax
c010dd2a:	87 07                	xchg   %eax,(%edi)
c010dd2c:	89 c3                	mov    %eax,%ebx
c010dd2e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
        "mov $1, %%eax;"
        "xchg %%eax,(%1);"
        : "=a"(r) : "D" (m)
    );
    return !r;
c010dd31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010dd35:	0f 94 c0             	sete   %al
c010dd38:	0f b6 c0             	movzbl %al,%eax
}
c010dd3b:	83 c4 14             	add    $0x14,%esp
c010dd3e:	5b                   	pop    %ebx
c010dd3f:	5f                   	pop    %edi
c010dd40:	5d                   	pop    %ebp
c010dd41:	c3                   	ret    

c010dd42 <lock>:
/**
 *  @brief Trys locking a atomic mutex until it is lockable.
 *  @param m The mutex to be locked.
 */
void lock(mutex *m)
{
c010dd42:	55                   	push   %ebp
c010dd43:	89 e5                	mov    %esp,%ebp
c010dd45:	83 ec 04             	sub    $0x4,%esp
    while(!try_lock(m));
c010dd48:	90                   	nop
c010dd49:	8b 45 08             	mov    0x8(%ebp),%eax
c010dd4c:	89 04 24             	mov    %eax,(%esp)
c010dd4f:	e8 c0 ff ff ff       	call   c010dd14 <try_lock>
c010dd54:	85 c0                	test   %eax,%eax
c010dd56:	74 f1                	je     c010dd49 <lock+0x7>
}
c010dd58:	c9                   	leave  
c010dd59:	c3                   	ret    

c010dd5a <unlock>:
/**
 * @brief Unlocks a atomic mutex.
 * @param m The mutex to be unlocked.
 */
void unlock(mutex *m)
{
c010dd5a:	55                   	push   %ebp
c010dd5b:	89 e5                	mov    %esp,%ebp
    *m = false;
c010dd5d:	8b 45 08             	mov    0x8(%ebp),%eax
c010dd60:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c010dd66:	5d                   	pop    %ebp
c010dd67:	c3                   	ret    

c010dd68 <outb>:
    asm volatile("inl %1, %0" : "=a" (result) : "Nd" (port));
    return result;
}

static inline void outb(uint16_t port, uint8_t value)
{
c010dd68:	55                   	push   %ebp
c010dd69:	89 e5                	mov    %esp,%ebp
c010dd6b:	83 ec 08             	sub    $0x8,%esp
c010dd6e:	8b 55 08             	mov    0x8(%ebp),%edx
c010dd71:	8b 45 0c             	mov    0xc(%ebp),%eax
c010dd74:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010dd78:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile("outb %1, %0" : : "Nd" (port), "a" (value));
c010dd7b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c010dd7f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c010dd83:	ee                   	out    %al,(%dx)
}
c010dd84:	c9                   	leave  
c010dd85:	c3                   	ret    

c010dd86 <lidt>:
/**
 *  @brief Loads IDT.
 *  @param irq nuber of the last defined Descriptor
 */
void lidt(uint16_t irq)
{
c010dd86:	55                   	push   %ebp
c010dd87:	89 e5                	mov    %esp,%ebp
c010dd89:	83 ec 04             	sub    $0x4,%esp
c010dd8c:	8b 45 08             	mov    0x8(%ebp),%eax
c010dd8f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idtp.limit = (8 * irq)-1;
c010dd93:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010dd97:	c1 e0 03             	shl    $0x3,%eax
c010dd9a:	83 e8 01             	sub    $0x1,%eax
c010dd9d:	66 a3 60 b8 11 c0    	mov    %ax,0xc011b860
    idtp.base = IDT;
c010dda3:	c7 05 62 b8 11 c0 60 	movl   $0xc011b060,0xc011b862
c010ddaa:	b0 11 c0 
    asm volatile("lidt %0" : : "m" (idtp));
c010ddad:	0f 01 1d 60 b8 11 c0 	lidtl  0xc011b860
}
c010ddb4:	c9                   	leave  
c010ddb5:	c3                   	ret    

c010ddb6 <EOI>:
/**
 *  @brief Sends End of Interrupt Signal to the PIC.
 *  @param irq number of the runnig interrupt
 */
void EOI(int irq)
{
c010ddb6:	55                   	push   %ebp
c010ddb7:	89 e5                	mov    %esp,%ebp
c010ddb9:	83 ec 08             	sub    $0x8,%esp
    outb(0x20, 0x20);
c010ddbc:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c010ddc3:	00 
c010ddc4:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c010ddcb:	e8 98 ff ff ff       	call   c010dd68 <outb>
    if (irq >= 8)
c010ddd0:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
c010ddd4:	7e 14                	jle    c010ddea <EOI+0x34>
    {
        outb(0xA0, 0x20);
c010ddd6:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c010dddd:	00 
c010ddde:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
c010dde5:	e8 7e ff ff ff       	call   c010dd68 <outb>
    }
}
c010ddea:	c9                   	leave  
c010ddeb:	c3                   	ret    

c010ddec <pic_mask_irqs>:
/**
 *  @brief Blocks hardware IRQs.
 *  @param mask Number of the IRQ which should be blocked
 */
void pic_mask_irqs(uint16_t mask)
{
c010ddec:	55                   	push   %ebp
c010dded:	89 e5                	mov    %esp,%ebp
c010ddef:	83 ec 0c             	sub    $0xc,%esp
c010ddf2:	8b 45 08             	mov    0x8(%ebp),%eax
c010ddf5:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    outb(0x21, (uint8_t) mask);
c010ddf9:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010ddfd:	0f b6 c0             	movzbl %al,%eax
c010de00:	89 44 24 04          	mov    %eax,0x4(%esp)
c010de04:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010de0b:	e8 58 ff ff ff       	call   c010dd68 <outb>
    outb(0xA1, (uint8_t) mask >> 8);
c010de10:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010de14:	0f b6 c0             	movzbl %al,%eax
c010de17:	c1 f8 08             	sar    $0x8,%eax
c010de1a:	0f b6 c0             	movzbl %al,%eax
c010de1d:	89 44 24 04          	mov    %eax,0x4(%esp)
c010de21:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c010de28:	e8 3b ff ff ff       	call   c010dd68 <outb>
}
c010de2d:	c9                   	leave  
c010de2e:	c3                   	ret    

c010de2f <Set_IDT_Entry>:
 *  @param selector Baseadress of the ISR function
 *  @param type Interrupt type
 *  @param dpl Descriptor previleg level (kernelmode usermode)
 */
void Set_IDT_Entry(int i, uint32_t offset, uint16_t selector, uint8_t type, int dpl)
{
c010de2f:	55                   	push   %ebp
c010de30:	89 e5                	mov    %esp,%ebp
c010de32:	83 ec 18             	sub    $0x18,%esp
c010de35:	8b 55 10             	mov    0x10(%ebp),%edx
c010de38:	8b 45 14             	mov    0x14(%ebp),%eax
c010de3b:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
c010de3f:	88 45 e8             	mov    %al,-0x18(%ebp)
    struct IDT_Entry ent;

    ent.offset_low = offset&0x0000ffff;
c010de42:	8b 45 0c             	mov    0xc(%ebp),%eax
c010de45:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    ent.selector = selector;
c010de49:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c010de4d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    ent.ist = 0;
c010de51:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c010de55:	83 e0 f8             	and    $0xfffffff8,%eax
c010de58:	88 45 fc             	mov    %al,-0x4(%ebp)
    ent.reserved = 0;
c010de5b:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c010de5f:	83 e0 07             	and    $0x7,%eax
c010de62:	88 45 fc             	mov    %al,-0x4(%ebp)
    ent.type = type;
c010de65:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c010de69:	83 e0 07             	and    $0x7,%eax
c010de6c:	89 c2                	mov    %eax,%edx
c010de6e:	83 e2 07             	and    $0x7,%edx
c010de71:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
c010de75:	83 e0 f8             	and    $0xfffffff8,%eax
c010de78:	09 d0                	or     %edx,%eax
c010de7a:	88 45 fd             	mov    %al,-0x3(%ebp)
    ent.d = 1;
c010de7d:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
c010de81:	83 e0 e7             	and    $0xffffffe7,%eax
c010de84:	83 c8 08             	or     $0x8,%eax
c010de87:	88 45 fd             	mov    %al,-0x3(%ebp)
    ent.dpl = dpl&3;
c010de8a:	8b 45 18             	mov    0x18(%ebp),%eax
c010de8d:	83 e0 03             	and    $0x3,%eax
c010de90:	83 e0 03             	and    $0x3,%eax
c010de93:	89 c2                	mov    %eax,%edx
c010de95:	c1 e2 05             	shl    $0x5,%edx
c010de98:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
c010de9c:	83 e0 9f             	and    $0xffffff9f,%eax
c010de9f:	09 d0                	or     %edx,%eax
c010dea1:	88 45 fd             	mov    %al,-0x3(%ebp)
    ent.present = 1;
c010dea4:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
c010dea8:	83 c8 80             	or     $0xffffff80,%eax
c010deab:	88 45 fd             	mov    %al,-0x3(%ebp)
    ent.offset_high = (offset&0xffff0000)>>16;
c010deae:	8b 45 0c             	mov    0xc(%ebp),%eax
c010deb1:	c1 e8 10             	shr    $0x10,%eax
c010deb4:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

    IDT[i] = ent;
c010deb8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010debb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010debe:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010dec1:	89 04 cd 60 b0 11 c0 	mov    %eax,-0x3fee4fa0(,%ecx,8)
c010dec8:	89 14 cd 64 b0 11 c0 	mov    %edx,-0x3fee4f9c(,%ecx,8)
}
c010decf:	c9                   	leave  
c010ded0:	c3                   	ret    

c010ded1 <irq_handler>:
 *  @brief General IRQ Handler
 *  @param pointer to cpu_state struct of the interrupted Process
 *  @return pointer to cpu_state struct of the interrupted Process
 */
struct cpu_state* irq_handler(struct cpu_state* cpu)
{
c010ded1:	55                   	push   %ebp
c010ded2:	89 e5                	mov    %esp,%ebp
c010ded4:	83 ec 28             	sub    $0x28,%esp
    intr_t irqnum = cpu->intr;
c010ded7:	8b 45 08             	mov    0x8(%ebp),%eax
c010deda:	8b 40 2c             	mov    0x2c(%eax),%eax
c010dedd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //Taskscheduler
    if(irqnum == 32)
c010dee0:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
c010dee4:	75 24                	jne    c010df0a <irq_handler+0x39>
    {
        sync_sys_clock();
c010dee6:	e8 57 ee ff ff       	call   c010cd42 <sync_sys_clock>
        cpu = task_schedule(cpu);
c010deeb:	8b 45 08             	mov    0x8(%ebp),%eax
c010deee:	89 04 24             	mov    %eax,(%esp)
c010def1:	e8 70 6c ff ff       	call   c0104b66 <task_schedule>
c010def6:	89 45 08             	mov    %eax,0x8(%ebp)
        EOI(0);
c010def9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010df00:	e8 b1 fe ff ff       	call   c010ddb6 <EOI>
c010df05:	e9 8f 00 00 00       	jmp    c010df99 <irq_handler+0xc8>
    }
    //Exceptions and IRQs
    else if(irqnum < 46)
c010df0a:	83 7d f4 2d          	cmpl   $0x2d,-0xc(%ebp)
c010df0e:	77 54                	ja     c010df64 <irq_handler+0x93>
    {
        if (!handle_interupts(&cpu))
c010df10:	8d 45 08             	lea    0x8(%ebp),%eax
c010df13:	89 04 24             	mov    %eax,(%esp)
c010df16:	e8 fc d3 ff ff       	call   c010b317 <handle_interupts>
c010df1b:	85 c0                	test   %eax,%eax
c010df1d:	75 22                	jne    c010df41 <irq_handler+0x70>
        {
            if(irqnum == 0xe)
c010df1f:	83 7d f4 0e          	cmpl   $0xe,-0xc(%ebp)
c010df23:	75 0b                	jne    c010df30 <irq_handler+0x5f>
                page_fault_handler(&cpu);
c010df25:	8d 45 08             	lea    0x8(%ebp),%eax
c010df28:	89 04 24             	mov    %eax,(%esp)
c010df2b:	e8 ba fa ff ff       	call   c010d9ea <page_fault_handler>
            if(irqnum < 32)
c010df30:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c010df34:	77 0b                	ja     c010df41 <irq_handler+0x70>
                exc_panic(cpu);
c010df36:	8b 45 08             	mov    0x8(%ebp),%eax
c010df39:	89 04 24             	mov    %eax,(%esp)
c010df3c:	e8 05 0c 00 00       	call   c010eb46 <exc_panic>
        }

        if(irqnum > 32)
c010df41:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
c010df45:	76 10                	jbe    c010df57 <irq_handler+0x86>
            EOI(irqnum-IRQ_OFFSET);
c010df47:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010df4a:	83 e8 20             	sub    $0x20,%eax
c010df4d:	89 04 24             	mov    %eax,(%esp)
c010df50:	e8 61 fe ff ff       	call   c010ddb6 <EOI>
c010df55:	eb 42                	jmp    c010df99 <irq_handler+0xc8>
        else
            EOI(irqnum);
c010df57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010df5a:	89 04 24             	mov    %eax,(%esp)
c010df5d:	e8 54 fe ff ff       	call   c010ddb6 <EOI>
c010df62:	eb 35                	jmp    c010df99 <irq_handler+0xc8>
    }
    //universe syscall
    else if(irqnum == 0x70)
c010df64:	83 7d f4 70          	cmpl   $0x70,-0xc(%ebp)
c010df68:	75 0d                	jne    c010df77 <irq_handler+0xa6>
        universe_syscall_handler(&cpu);
c010df6a:	8d 45 08             	lea    0x8(%ebp),%eax
c010df6d:	89 04 24             	mov    %eax,(%esp)
c010df70:	e8 75 b6 ff ff       	call   c01095ea <universe_syscall_handler>
c010df75:	eb 22                	jmp    c010df99 <irq_handler+0xc8>

    //linux syscall
    else if(irqnum == 0x80)
c010df77:	81 7d f4 80 00 00 00 	cmpl   $0x80,-0xc(%ebp)
c010df7e:	75 0d                	jne    c010df8d <irq_handler+0xbc>
        linux_syscall_handler(&cpu);
c010df80:	8d 45 08             	lea    0x8(%ebp),%eax
c010df83:	89 04 24             	mov    %eax,(%esp)
c010df86:	e8 20 b6 ff ff       	call   c01095ab <linux_syscall_handler>
c010df8b:	eb 0c                	jmp    c010df99 <irq_handler+0xc8>

    //unspecified ISRs
    else
        panic("A unspecified ISR was called.");
c010df8d:	c7 04 24 7f 10 11 c0 	movl   $0xc011107f,(%esp)
c010df94:	e8 b7 41 ff ff       	call   c0102150 <panic>

    return cpu;
c010df99:	8b 45 08             	mov    0x8(%ebp),%eax
}
c010df9c:	c9                   	leave  
c010df9d:	c3                   	ret    

c010df9e <remap_pic>:

/**
 *  @brief Remaps IRQs to irqnum 31.
 */
void remap_pic(void)
{
c010df9e:	55                   	push   %ebp
c010df9f:	89 e5                	mov    %esp,%ebp
c010dfa1:	83 ec 08             	sub    $0x8,%esp
    outb(0x20, 0x11);
c010dfa4:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
c010dfab:	00 
c010dfac:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c010dfb3:	e8 b0 fd ff ff       	call   c010dd68 <outb>
    outb(0xA0, 0x11);
c010dfb8:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
c010dfbf:	00 
c010dfc0:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
c010dfc7:	e8 9c fd ff ff       	call   c010dd68 <outb>
    outb(0x21, 32);
c010dfcc:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c010dfd3:	00 
c010dfd4:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010dfdb:	e8 88 fd ff ff       	call   c010dd68 <outb>
    outb(0xA1, 32+8);
c010dfe0:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
c010dfe7:	00 
c010dfe8:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c010dfef:	e8 74 fd ff ff       	call   c010dd68 <outb>
    outb(0x21, 0x04);
c010dff4:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
c010dffb:	00 
c010dffc:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010e003:	e8 60 fd ff ff       	call   c010dd68 <outb>
    outb(0xA1, 2);
c010e008:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c010e00f:	00 
c010e010:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c010e017:	e8 4c fd ff ff       	call   c010dd68 <outb>
    outb(0x21, 0x01);
c010e01c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c010e023:	00 
c010e024:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010e02b:	e8 38 fd ff ff       	call   c010dd68 <outb>
    outb(0xA1, 0x01);
c010e030:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c010e037:	00 
c010e038:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c010e03f:	e8 24 fd ff ff       	call   c010dd68 <outb>
    outb(0x21, 0x00);
c010e044:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010e04b:	00 
c010e04c:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010e053:	e8 10 fd ff ff       	call   c010dd68 <outb>
    outb(0xA1, 0x00);
c010e058:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010e05f:	00 
c010e060:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c010e067:	e8 fc fc ff ff       	call   c010dd68 <outb>
}
c010e06c:	c9                   	leave  
c010e06d:	c3                   	ret    

c010e06e <INIT_IDT>:

/**
 * @brief Initializes IDT wit exceptions and basical ISRs.
 */
void INIT_IDT(void)
{
c010e06e:	55                   	push   %ebp
c010e06f:	89 e5                	mov    %esp,%ebp
c010e071:	83 ec 24             	sub    $0x24,%esp
    //remap IRQs
    remap_pic();
c010e074:	e8 25 ff ff ff       	call   c010df9e <remap_pic>

    //Exceptions
    int i;
    for(i = 0; i < 256; i++)
c010e079:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010e080:	eb 30                	jmp    c010e0b2 <INIT_IDT+0x44>
    {
        Set_IDT_Entry(i, (uint32_t)&isr_default,0x08,INTERRUPT_GATE, 0  );
c010e082:	b8 5f fc 10 c0       	mov    $0xc010fc5f,%eax
c010e087:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e08e:	00 
c010e08f:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e096:	00 
c010e097:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e09e:	00 
c010e09f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e0a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010e0a6:	89 04 24             	mov    %eax,(%esp)
c010e0a9:	e8 81 fd ff ff       	call   c010de2f <Set_IDT_Entry>
    //remap IRQs
    remap_pic();

    //Exceptions
    int i;
    for(i = 0; i < 256; i++)
c010e0ae:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010e0b2:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c010e0b9:	7e c7                	jle    c010e082 <INIT_IDT+0x14>
    {
        Set_IDT_Entry(i, (uint32_t)&isr_default,0x08,INTERRUPT_GATE, 0  );
    }

    Set_IDT_Entry(0,(uint32_t)isr_0,0x08,INTERRUPT_GATE, 0  );
c010e0bb:	b8 50 fb 10 c0       	mov    $0xc010fb50,%eax
c010e0c0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e0c7:	00 
c010e0c8:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e0cf:	00 
c010e0d0:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e0d7:	00 
c010e0d8:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e0dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010e0e3:	e8 47 fd ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(1,(uint32_t)isr_1,0x08,INTERRUPT_GATE, 0  );
c010e0e8:	b8 59 fb 10 c0       	mov    $0xc010fb59,%eax
c010e0ed:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e0f4:	00 
c010e0f5:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e0fc:	00 
c010e0fd:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e104:	00 
c010e105:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e109:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c010e110:	e8 1a fd ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(2,(uint32_t)isr_2,0x08,INTERRUPT_GATE, 0  );
c010e115:	b8 62 fb 10 c0       	mov    $0xc010fb62,%eax
c010e11a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e121:	00 
c010e122:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e129:	00 
c010e12a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e131:	00 
c010e132:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e136:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c010e13d:	e8 ed fc ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(3,(uint32_t)isr_3,0x08,INTERRUPT_GATE, 0  );
c010e142:	b8 6b fb 10 c0       	mov    $0xc010fb6b,%eax
c010e147:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e14e:	00 
c010e14f:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e156:	00 
c010e157:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e15e:	00 
c010e15f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e163:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c010e16a:	e8 c0 fc ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(4,(uint32_t)isr_4,0x08,INTERRUPT_GATE, 0  );
c010e16f:	b8 74 fb 10 c0       	mov    $0xc010fb74,%eax
c010e174:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e17b:	00 
c010e17c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e183:	00 
c010e184:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e18b:	00 
c010e18c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e190:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c010e197:	e8 93 fc ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(5,(uint32_t)isr_5,0x08,INTERRUPT_GATE, 0  );
c010e19c:	b8 7d fb 10 c0       	mov    $0xc010fb7d,%eax
c010e1a1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e1a8:	00 
c010e1a9:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e1b0:	00 
c010e1b1:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e1b8:	00 
c010e1b9:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e1bd:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c010e1c4:	e8 66 fc ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(6,(uint32_t)isr_6,0x08,INTERRUPT_GATE, 0  );
c010e1c9:	b8 86 fb 10 c0       	mov    $0xc010fb86,%eax
c010e1ce:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e1d5:	00 
c010e1d6:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e1dd:	00 
c010e1de:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e1e5:	00 
c010e1e6:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e1ea:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c010e1f1:	e8 39 fc ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(7,(uint32_t)isr_7,0x08,INTERRUPT_GATE, 0  );
c010e1f6:	b8 8f fb 10 c0       	mov    $0xc010fb8f,%eax
c010e1fb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e202:	00 
c010e203:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e20a:	00 
c010e20b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e212:	00 
c010e213:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e217:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c010e21e:	e8 0c fc ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(8,(uint32_t)isr_8,0x08,INTERRUPT_GATE, 0  );
c010e223:	b8 98 fb 10 c0       	mov    $0xc010fb98,%eax
c010e228:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e22f:	00 
c010e230:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e237:	00 
c010e238:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e23f:	00 
c010e240:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e244:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
c010e24b:	e8 df fb ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(9,(uint32_t)isr_9,0x08,INTERRUPT_GATE, 0  );
c010e250:	b8 9f fb 10 c0       	mov    $0xc010fb9f,%eax
c010e255:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e25c:	00 
c010e25d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e264:	00 
c010e265:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e26c:	00 
c010e26d:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e271:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
c010e278:	e8 b2 fb ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(10,(uint32_t)isr_10,0x08,INTERRUPT_GATE, 0  );
c010e27d:	b8 a8 fb 10 c0       	mov    $0xc010fba8,%eax
c010e282:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e289:	00 
c010e28a:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e291:	00 
c010e292:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e299:	00 
c010e29a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e29e:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c010e2a5:	e8 85 fb ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(11,(uint32_t)isr_11,0x08,INTERRUPT_GATE, 0  );
c010e2aa:	b8 af fb 10 c0       	mov    $0xc010fbaf,%eax
c010e2af:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e2b6:	00 
c010e2b7:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e2be:	00 
c010e2bf:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e2c6:	00 
c010e2c7:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e2cb:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
c010e2d2:	e8 58 fb ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(12,(uint32_t)isr_12,0x08,INTERRUPT_GATE, 0  );
c010e2d7:	b8 b6 fb 10 c0       	mov    $0xc010fbb6,%eax
c010e2dc:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e2e3:	00 
c010e2e4:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e2eb:	00 
c010e2ec:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e2f3:	00 
c010e2f4:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e2f8:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c010e2ff:	e8 2b fb ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(13,(uint32_t)isr_13,0x08,INTERRUPT_GATE, 0  );
c010e304:	b8 bd fb 10 c0       	mov    $0xc010fbbd,%eax
c010e309:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e310:	00 
c010e311:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e318:	00 
c010e319:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e320:	00 
c010e321:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e325:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
c010e32c:	e8 fe fa ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(14,(uint32_t)isr_14,0x08,INTERRUPT_GATE, 0  );
c010e331:	b8 c4 fb 10 c0       	mov    $0xc010fbc4,%eax
c010e336:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e33d:	00 
c010e33e:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e345:	00 
c010e346:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e34d:	00 
c010e34e:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e352:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c010e359:	e8 d1 fa ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(15,(uint32_t)isr_15,0x08,INTERRUPT_GATE, 0  );
c010e35e:	b8 cb fb 10 c0       	mov    $0xc010fbcb,%eax
c010e363:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e36a:	00 
c010e36b:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e372:	00 
c010e373:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e37a:	00 
c010e37b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e37f:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c010e386:	e8 a4 fa ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(16,(uint32_t)isr_16,0x08,INTERRUPT_GATE, 0  );
c010e38b:	b8 d4 fb 10 c0       	mov    $0xc010fbd4,%eax
c010e390:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e397:	00 
c010e398:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e39f:	00 
c010e3a0:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e3a7:	00 
c010e3a8:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e3ac:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
c010e3b3:	e8 77 fa ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(17,(uint32_t)isr_17,0x08,INTERRUPT_GATE, 0  );
c010e3b8:	b8 dd fb 10 c0       	mov    $0xc010fbdd,%eax
c010e3bd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e3c4:	00 
c010e3c5:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e3cc:	00 
c010e3cd:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e3d4:	00 
c010e3d5:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e3d9:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
c010e3e0:	e8 4a fa ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(18,(uint32_t)isr_18,0x08,INTERRUPT_GATE, 0  );
c010e3e5:	b8 e4 fb 10 c0       	mov    $0xc010fbe4,%eax
c010e3ea:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e3f1:	00 
c010e3f2:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e3f9:	00 
c010e3fa:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e401:	00 
c010e402:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e406:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
c010e40d:	e8 1d fa ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(19,(uint32_t)isr_19,0x08,INTERRUPT_GATE, 0  );
c010e412:	b8 ed fb 10 c0       	mov    $0xc010fbed,%eax
c010e417:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e41e:	00 
c010e41f:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e426:	00 
c010e427:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e42e:	00 
c010e42f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e433:	c7 04 24 13 00 00 00 	movl   $0x13,(%esp)
c010e43a:	e8 f0 f9 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(20,(uint32_t)isr_20,0x08,INTERRUPT_GATE, 0  );
c010e43f:	b8 f6 fb 10 c0       	mov    $0xc010fbf6,%eax
c010e444:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e44b:	00 
c010e44c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e453:	00 
c010e454:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e45b:	00 
c010e45c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e460:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
c010e467:	e8 c3 f9 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(21,(uint32_t)isr_21,0x08,INTERRUPT_GATE, 0  );
c010e46c:	b8 ff fb 10 c0       	mov    $0xc010fbff,%eax
c010e471:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e478:	00 
c010e479:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e480:	00 
c010e481:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e488:	00 
c010e489:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e48d:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
c010e494:	e8 96 f9 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(22,(uint32_t)isr_22,0x08,INTERRUPT_GATE, 0  );
c010e499:	b8 08 fc 10 c0       	mov    $0xc010fc08,%eax
c010e49e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e4a5:	00 
c010e4a6:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e4ad:	00 
c010e4ae:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e4b5:	00 
c010e4b6:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e4ba:	c7 04 24 16 00 00 00 	movl   $0x16,(%esp)
c010e4c1:	e8 69 f9 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(23,(uint32_t)isr_23,0x08,INTERRUPT_GATE, 0  );
c010e4c6:	b8 11 fc 10 c0       	mov    $0xc010fc11,%eax
c010e4cb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e4d2:	00 
c010e4d3:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e4da:	00 
c010e4db:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e4e2:	00 
c010e4e3:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e4e7:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
c010e4ee:	e8 3c f9 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(24,(uint32_t)isr_24,0x08,INTERRUPT_GATE, 0  );
c010e4f3:	b8 1a fc 10 c0       	mov    $0xc010fc1a,%eax
c010e4f8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e4ff:	00 
c010e500:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e507:	00 
c010e508:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e50f:	00 
c010e510:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e514:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
c010e51b:	e8 0f f9 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(25,(uint32_t)isr_25,0x08,INTERRUPT_GATE, 0  );
c010e520:	b8 23 fc 10 c0       	mov    $0xc010fc23,%eax
c010e525:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e52c:	00 
c010e52d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e534:	00 
c010e535:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e53c:	00 
c010e53d:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e541:	c7 04 24 19 00 00 00 	movl   $0x19,(%esp)
c010e548:	e8 e2 f8 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(26,(uint32_t)isr_26,0x08,INTERRUPT_GATE, 0  );
c010e54d:	b8 2c fc 10 c0       	mov    $0xc010fc2c,%eax
c010e552:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e559:	00 
c010e55a:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e561:	00 
c010e562:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e569:	00 
c010e56a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e56e:	c7 04 24 1a 00 00 00 	movl   $0x1a,(%esp)
c010e575:	e8 b5 f8 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(27,(uint32_t)isr_27,0x08,INTERRUPT_GATE, 0  );
c010e57a:	b8 35 fc 10 c0       	mov    $0xc010fc35,%eax
c010e57f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e586:	00 
c010e587:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e58e:	00 
c010e58f:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e596:	00 
c010e597:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e59b:	c7 04 24 1b 00 00 00 	movl   $0x1b,(%esp)
c010e5a2:	e8 88 f8 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(28,(uint32_t)isr_28,0x08,INTERRUPT_GATE, 0  );
c010e5a7:	b8 3e fc 10 c0       	mov    $0xc010fc3e,%eax
c010e5ac:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e5b3:	00 
c010e5b4:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e5bb:	00 
c010e5bc:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e5c3:	00 
c010e5c4:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e5c8:	c7 04 24 1c 00 00 00 	movl   $0x1c,(%esp)
c010e5cf:	e8 5b f8 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(29,(uint32_t)isr_29,0x08,INTERRUPT_GATE, 0  );
c010e5d4:	b8 47 fc 10 c0       	mov    $0xc010fc47,%eax
c010e5d9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e5e0:	00 
c010e5e1:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e5e8:	00 
c010e5e9:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e5f0:	00 
c010e5f1:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e5f5:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
c010e5fc:	e8 2e f8 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(30,(uint32_t)isr_30,0x08,INTERRUPT_GATE, 0  );
c010e601:	b8 50 fc 10 c0       	mov    $0xc010fc50,%eax
c010e606:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e60d:	00 
c010e60e:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e615:	00 
c010e616:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e61d:	00 
c010e61e:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e622:	c7 04 24 1e 00 00 00 	movl   $0x1e,(%esp)
c010e629:	e8 01 f8 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(31,(uint32_t)isr_31,0x08,INTERRUPT_GATE, 0  );
c010e62e:	b8 59 fc 10 c0       	mov    $0xc010fc59,%eax
c010e633:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e63a:	00 
c010e63b:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e642:	00 
c010e643:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e64a:	00 
c010e64b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e64f:	c7 04 24 1f 00 00 00 	movl   $0x1f,(%esp)
c010e656:	e8 d4 f7 ff ff       	call   c010de2f <Set_IDT_Entry>

    //IRQs
    Set_IDT_Entry(32,(uint32_t)isr_32,0x08,INTERRUPT_GATE, 0  );
c010e65b:	b8 65 fc 10 c0       	mov    $0xc010fc65,%eax
c010e660:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e667:	00 
c010e668:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e66f:	00 
c010e670:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e677:	00 
c010e678:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e67c:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c010e683:	e8 a7 f7 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(33,(uint32_t)isr_33,0x08,INTERRUPT_GATE, 0  );
c010e688:	b8 6b fc 10 c0       	mov    $0xc010fc6b,%eax
c010e68d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e694:	00 
c010e695:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e69c:	00 
c010e69d:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e6a4:	00 
c010e6a5:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e6a9:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c010e6b0:	e8 7a f7 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(34,(uint32_t)isr_34,0x08,INTERRUPT_GATE, 0  );
c010e6b5:	b8 71 fc 10 c0       	mov    $0xc010fc71,%eax
c010e6ba:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e6c1:	00 
c010e6c2:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e6c9:	00 
c010e6ca:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e6d1:	00 
c010e6d2:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e6d6:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
c010e6dd:	e8 4d f7 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(35,(uint32_t)isr_35,0x08,INTERRUPT_GATE, 0  );
c010e6e2:	b8 77 fc 10 c0       	mov    $0xc010fc77,%eax
c010e6e7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e6ee:	00 
c010e6ef:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e6f6:	00 
c010e6f7:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e6fe:	00 
c010e6ff:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e703:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
c010e70a:	e8 20 f7 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(36,(uint32_t)isr_36,0x08,INTERRUPT_GATE, 0  );
c010e70f:	b8 7d fc 10 c0       	mov    $0xc010fc7d,%eax
c010e714:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e71b:	00 
c010e71c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e723:	00 
c010e724:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e72b:	00 
c010e72c:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e730:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
c010e737:	e8 f3 f6 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(37,(uint32_t)isr_37,0x08,INTERRUPT_GATE, 0  );
c010e73c:	b8 83 fc 10 c0       	mov    $0xc010fc83,%eax
c010e741:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e748:	00 
c010e749:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e750:	00 
c010e751:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e758:	00 
c010e759:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e75d:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
c010e764:	e8 c6 f6 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(38,(uint32_t)isr_38,0x08,INTERRUPT_GATE, 0  );
c010e769:	b8 89 fc 10 c0       	mov    $0xc010fc89,%eax
c010e76e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e775:	00 
c010e776:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e77d:	00 
c010e77e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e785:	00 
c010e786:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e78a:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
c010e791:	e8 99 f6 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(39,(uint32_t)isr_39,0x08,INTERRUPT_GATE, 0  );
c010e796:	b8 8f fc 10 c0       	mov    $0xc010fc8f,%eax
c010e79b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e7a2:	00 
c010e7a3:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e7aa:	00 
c010e7ab:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e7b2:	00 
c010e7b3:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e7b7:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
c010e7be:	e8 6c f6 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(40,(uint32_t)isr_40,0x08,INTERRUPT_GATE, 0  );
c010e7c3:	b8 95 fc 10 c0       	mov    $0xc010fc95,%eax
c010e7c8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e7cf:	00 
c010e7d0:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e7d7:	00 
c010e7d8:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e7df:	00 
c010e7e0:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e7e4:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
c010e7eb:	e8 3f f6 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(41,(uint32_t)isr_41,0x08,INTERRUPT_GATE, 0  );
c010e7f0:	b8 9b fc 10 c0       	mov    $0xc010fc9b,%eax
c010e7f5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e7fc:	00 
c010e7fd:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e804:	00 
c010e805:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e80c:	00 
c010e80d:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e811:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c010e818:	e8 12 f6 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(42,(uint32_t)isr_42,0x08,INTERRUPT_GATE, 0  );
c010e81d:	b8 a1 fc 10 c0       	mov    $0xc010fca1,%eax
c010e822:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e829:	00 
c010e82a:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e831:	00 
c010e832:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e839:	00 
c010e83a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e83e:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
c010e845:	e8 e5 f5 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(43,(uint32_t)isr_43,0x08,INTERRUPT_GATE, 0  );
c010e84a:	b8 a7 fc 10 c0       	mov    $0xc010fca7,%eax
c010e84f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e856:	00 
c010e857:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e85e:	00 
c010e85f:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e866:	00 
c010e867:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e86b:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
c010e872:	e8 b8 f5 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(44,(uint32_t)isr_44,0x08,INTERRUPT_GATE, 0  );
c010e877:	b8 ad fc 10 c0       	mov    $0xc010fcad,%eax
c010e87c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e883:	00 
c010e884:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e88b:	00 
c010e88c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e893:	00 
c010e894:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e898:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
c010e89f:	e8 8b f5 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(45,(uint32_t)isr_45,0x08,INTERRUPT_GATE, 0  );
c010e8a4:	b8 b3 fc 10 c0       	mov    $0xc010fcb3,%eax
c010e8a9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e8b0:	00 
c010e8b1:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e8b8:	00 
c010e8b9:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e8c0:	00 
c010e8c1:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e8c5:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
c010e8cc:	e8 5e f5 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(46,(uint32_t)isr_46,0x08,INTERRUPT_GATE, 0  );
c010e8d1:	b8 b9 fc 10 c0       	mov    $0xc010fcb9,%eax
c010e8d6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e8dd:	00 
c010e8de:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e8e5:	00 
c010e8e6:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e8ed:	00 
c010e8ee:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e8f2:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
c010e8f9:	e8 31 f5 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(47,(uint32_t)isr_47,0x08,INTERRUPT_GATE, 0  );
c010e8fe:	b8 bf fc 10 c0       	mov    $0xc010fcbf,%eax
c010e903:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010e90a:	00 
c010e90b:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e912:	00 
c010e913:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e91a:	00 
c010e91b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e91f:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
c010e926:	e8 04 f5 ff ff       	call   c010de2f <Set_IDT_Entry>

    //Syscalls
    Set_IDT_Entry(0x70,(uint32_t)isr_112,0x08,INTERRUPT_GATE, 3  ); //Universe syscall interface
c010e92b:	b8 c5 fc 10 c0       	mov    $0xc010fcc5,%eax
c010e930:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
c010e937:	00 
c010e938:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e93f:	00 
c010e940:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e947:	00 
c010e948:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e94c:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
c010e953:	e8 d7 f4 ff ff       	call   c010de2f <Set_IDT_Entry>
    Set_IDT_Entry(0x80,(uint32_t)isr_128,0x08,INTERRUPT_GATE, 3  ); //Linux syscall interface
c010e958:	b8 cb fc 10 c0       	mov    $0xc010fccb,%eax
c010e95d:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
c010e964:	00 
c010e965:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
c010e96c:	00 
c010e96d:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
c010e974:	00 
c010e975:	89 44 24 04          	mov    %eax,0x4(%esp)
c010e979:	c7 04 24 80 00 00 00 	movl   $0x80,(%esp)
c010e980:	e8 aa f4 ff ff       	call   c010de2f <Set_IDT_Entry>

    lidt(0xFF);
c010e985:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
c010e98c:	e8 f5 f3 ff ff       	call   c010dd86 <lidt>
}
c010e991:	c9                   	leave  
c010e992:	c3                   	ret    

c010e993 <cpu_dump>:
 *  @param cpu The state to be dumped.
 *  @param str String buffer to dump in.
 *  @return Number of written characters.
 */
int cpu_dump(struct cpu_state *cpu, char *str)
{
c010e993:	55                   	push   %ebp
c010e994:	89 e5                	mov    %esp,%ebp
c010e996:	53                   	push   %ebx
c010e997:	83 ec 24             	sub    $0x24,%esp
    int len = 0;
c010e99a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    len += sprintf(str + len, "EAX:  %#010X    EBX:     %#010X\n",  cpu->eax,   cpu->ebx);
c010e9a1:	8b 45 08             	mov    0x8(%ebp),%eax
c010e9a4:	8b 50 1c             	mov    0x1c(%eax),%edx
c010e9a7:	8b 45 08             	mov    0x8(%ebp),%eax
c010e9aa:	8b 40 28             	mov    0x28(%eax),%eax
c010e9ad:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010e9b0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010e9b3:	01 d9                	add    %ebx,%ecx
c010e9b5:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010e9b9:	89 44 24 08          	mov    %eax,0x8(%esp)
c010e9bd:	c7 44 24 04 a0 10 11 	movl   $0xc01110a0,0x4(%esp)
c010e9c4:	c0 
c010e9c5:	89 0c 24             	mov    %ecx,(%esp)
c010e9c8:	e8 c1 4c ff ff       	call   c010368e <sprintf>
c010e9cd:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "ECX:  %#010X    EDX:     %#010X\n",  cpu->ecx,   cpu->edx);
c010e9d0:	8b 45 08             	mov    0x8(%ebp),%eax
c010e9d3:	8b 50 20             	mov    0x20(%eax),%edx
c010e9d6:	8b 45 08             	mov    0x8(%ebp),%eax
c010e9d9:	8b 40 24             	mov    0x24(%eax),%eax
c010e9dc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010e9df:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010e9e2:	01 d9                	add    %ebx,%ecx
c010e9e4:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010e9e8:	89 44 24 08          	mov    %eax,0x8(%esp)
c010e9ec:	c7 44 24 04 c4 10 11 	movl   $0xc01110c4,0x4(%esp)
c010e9f3:	c0 
c010e9f4:	89 0c 24             	mov    %ecx,(%esp)
c010e9f7:	e8 92 4c ff ff       	call   c010368e <sprintf>
c010e9fc:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "ESI:  %#010X    EDI:     %#010X\n",  cpu->esi,   cpu->edi);
c010e9ff:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea02:	8b 50 10             	mov    0x10(%eax),%edx
c010ea05:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea08:	8b 40 14             	mov    0x14(%eax),%eax
c010ea0b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010ea0e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010ea11:	01 d9                	add    %ebx,%ecx
c010ea13:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010ea17:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ea1b:	c7 44 24 04 e8 10 11 	movl   $0xc01110e8,0x4(%esp)
c010ea22:	c0 
c010ea23:	89 0c 24             	mov    %ecx,(%esp)
c010ea26:	e8 63 4c ff ff       	call   c010368e <sprintf>
c010ea2b:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "ESP:  %#010X    EBP:     %#010X\n",  cpu->esp,   cpu->ebp);
c010ea2e:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea31:	8b 50 18             	mov    0x18(%eax),%edx
c010ea34:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea37:	8b 40 40             	mov    0x40(%eax),%eax
c010ea3a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010ea3d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010ea40:	01 d9                	add    %ebx,%ecx
c010ea42:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010ea46:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ea4a:	c7 44 24 04 0c 11 11 	movl   $0xc011110c,0x4(%esp)
c010ea51:	c0 
c010ea52:	89 0c 24             	mov    %ecx,(%esp)
c010ea55:	e8 34 4c ff ff       	call   c010368e <sprintf>
c010ea5a:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "CS:   %#010X    DS:      %#010X\n",  cpu->cs,    cpu->ds);
c010ea5d:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea60:	8b 50 0c             	mov    0xc(%eax),%edx
c010ea63:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea66:	8b 40 38             	mov    0x38(%eax),%eax
c010ea69:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010ea6c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010ea6f:	01 d9                	add    %ebx,%ecx
c010ea71:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010ea75:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ea79:	c7 44 24 04 30 11 11 	movl   $0xc0111130,0x4(%esp)
c010ea80:	c0 
c010ea81:	89 0c 24             	mov    %ecx,(%esp)
c010ea84:	e8 05 4c ff ff       	call   c010368e <sprintf>
c010ea89:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "SS:   %#010X    ES:      %#010X\n",  cpu->ss,    cpu->es);
c010ea8c:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea8f:	8b 50 08             	mov    0x8(%eax),%edx
c010ea92:	8b 45 08             	mov    0x8(%ebp),%eax
c010ea95:	8b 40 44             	mov    0x44(%eax),%eax
c010ea98:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010ea9b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010ea9e:	01 d9                	add    %ebx,%ecx
c010eaa0:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010eaa4:	89 44 24 08          	mov    %eax,0x8(%esp)
c010eaa8:	c7 44 24 04 54 11 11 	movl   $0xc0111154,0x4(%esp)
c010eaaf:	c0 
c010eab0:	89 0c 24             	mov    %ecx,(%esp)
c010eab3:	e8 d6 4b ff ff       	call   c010368e <sprintf>
c010eab8:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "GS:   %#010X    FS:      %#010X\n",  cpu->gs,    cpu->fs);
c010eabb:	8b 45 08             	mov    0x8(%ebp),%eax
c010eabe:	8b 50 04             	mov    0x4(%eax),%edx
c010eac1:	8b 45 08             	mov    0x8(%ebp),%eax
c010eac4:	8b 00                	mov    (%eax),%eax
c010eac6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010eac9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010eacc:	01 d9                	add    %ebx,%ecx
c010eace:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010ead2:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ead6:	c7 44 24 04 78 11 11 	movl   $0xc0111178,0x4(%esp)
c010eadd:	c0 
c010eade:	89 0c 24             	mov    %ecx,(%esp)
c010eae1:	e8 a8 4b ff ff       	call   c010368e <sprintf>
c010eae6:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "EIP:  %#010X    EFLAGS:  %#010X\n",  cpu->eip,   cpu->eflags);
c010eae9:	8b 45 08             	mov    0x8(%ebp),%eax
c010eaec:	8b 50 3c             	mov    0x3c(%eax),%edx
c010eaef:	8b 45 08             	mov    0x8(%ebp),%eax
c010eaf2:	8b 40 34             	mov    0x34(%eax),%eax
c010eaf5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c010eaf8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010eafb:	01 d9                	add    %ebx,%ecx
c010eafd:	89 54 24 0c          	mov    %edx,0xc(%esp)
c010eb01:	89 44 24 08          	mov    %eax,0x8(%esp)
c010eb05:	c7 44 24 04 9c 11 11 	movl   $0xc011119c,0x4(%esp)
c010eb0c:	c0 
c010eb0d:	89 0c 24             	mov    %ecx,(%esp)
c010eb10:	e8 79 4b ff ff       	call   c010368e <sprintf>
c010eb15:	01 45 f4             	add    %eax,-0xc(%ebp)
    len += sprintf(str + len, "ERRORCODE:  %#010X\n",  cpu->error);
c010eb18:	8b 45 08             	mov    0x8(%ebp),%eax
c010eb1b:	8b 40 30             	mov    0x30(%eax),%eax
c010eb1e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010eb21:	8b 55 0c             	mov    0xc(%ebp),%edx
c010eb24:	01 ca                	add    %ecx,%edx
c010eb26:	89 44 24 08          	mov    %eax,0x8(%esp)
c010eb2a:	c7 44 24 04 bd 11 11 	movl   $0xc01111bd,0x4(%esp)
c010eb31:	c0 
c010eb32:	89 14 24             	mov    %edx,(%esp)
c010eb35:	e8 54 4b ff ff       	call   c010368e <sprintf>
c010eb3a:	01 45 f4             	add    %eax,-0xc(%ebp)

    return len;
c010eb3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010eb40:	83 c4 24             	add    $0x24,%esp
c010eb43:	5b                   	pop    %ebx
c010eb44:	5d                   	pop    %ebp
c010eb45:	c3                   	ret    

c010eb46 <exc_panic>:
 *  @brief Prints panic screen for CPU exceptions.
 *  just used in case of untreated exceptions.
 *  @param cpu The cpu state given by the exception.
 */
void exc_panic(struct cpu_state* cpu)
{
c010eb46:	55                   	push   %ebp
c010eb47:	89 e5                	mov    %esp,%ebp
c010eb49:	81 ec 28 02 00 00    	sub    $0x228,%esp
    char message[512];
    char *exception = exception_messages[cpu->intr];
c010eb4f:	8b 45 08             	mov    0x8(%ebp),%eax
c010eb52:	8b 40 2c             	mov    0x2c(%eax),%eax
c010eb55:	8b 04 85 40 21 11 c0 	mov    -0x3feedec0(,%eax,4),%eax
c010eb5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int len = 0;
c010eb5f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    len = sprintf(message, "%s\n\n", exception);
c010eb66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010eb69:	89 44 24 08          	mov    %eax,0x8(%esp)
c010eb6d:	c7 44 24 04 d1 11 11 	movl   $0xc01111d1,0x4(%esp)
c010eb74:	c0 
c010eb75:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c010eb7b:	89 04 24             	mov    %eax,(%esp)
c010eb7e:	e8 0b 4b ff ff       	call   c010368e <sprintf>
c010eb83:	89 45 f0             	mov    %eax,-0x10(%ebp)
    cpu_dump(cpu, message + len);
c010eb86:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010eb89:	8d 95 f0 fd ff ff    	lea    -0x210(%ebp),%edx
c010eb8f:	01 d0                	add    %edx,%eax
c010eb91:	89 44 24 04          	mov    %eax,0x4(%esp)
c010eb95:	8b 45 08             	mov    0x8(%ebp),%eax
c010eb98:	89 04 24             	mov    %eax,(%esp)
c010eb9b:	e8 f3 fd ff ff       	call   c010e993 <cpu_dump>

    panic(message);
c010eba0:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c010eba6:	89 04 24             	mov    %eax,(%esp)
c010eba9:	e8 a2 35 ff ff       	call   c0102150 <panic>
}
c010ebae:	c9                   	leave  
c010ebaf:	c3                   	ret    

c010ebb0 <pd_dump>:
 * Only works wehne every PD is mapped in in kernelspace Area
 * @param pointer to the phys. pd frame
 * @return void
 */
void pd_dump(arch_vmm_context_t *context)
{
c010ebb0:	55                   	push   %ebp
c010ebb1:	89 e5                	mov    %esp,%ebp
c010ebb3:	83 ec 48             	sub    $0x48,%esp
    int pdi, pti, phys_base, virt_base, size, sec = 0;
c010ebb6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    uint32_t *pt;
    uint32_t *pd = context->entries;
c010ebbd:	8b 45 08             	mov    0x8(%ebp),%eax
c010ebc0:	8b 00                	mov    (%eax),%eax
c010ebc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    for( pdi = 0; pdi < PD_LENGTH; pdi++ )
c010ebc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010ebcc:	e9 1f 02 00 00       	jmp    c010edf0 <pd_dump+0x240>
    {
        if(sec && (pd[pdi] & 1) == 0)
c010ebd1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010ebd5:	74 63                	je     c010ec3a <pd_dump+0x8a>
c010ebd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ebda:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010ebe1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010ebe4:	01 d0                	add    %edx,%eax
c010ebe6:	8b 00                	mov    (%eax),%eax
c010ebe8:	83 e0 01             	and    $0x1,%eax
c010ebeb:	85 c0                	test   %eax,%eax
c010ebed:	75 4b                	jne    c010ec3a <pd_dump+0x8a>
        {
            printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c010ebef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ebf2:	89 c2                	mov    %eax,%edx
c010ebf4:	c1 e2 0c             	shl    $0xc,%edx
c010ebf7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ebfa:	01 d0                	add    %edx,%eax
c010ebfc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010ebff:	89 d1                	mov    %edx,%ecx
c010ec01:	c1 e1 0c             	shl    $0xc,%ecx
c010ec04:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010ec07:	01 ca                	add    %ecx,%edx
c010ec09:	89 44 24 10          	mov    %eax,0x10(%esp)
c010ec0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ec10:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010ec14:	89 54 24 08          	mov    %edx,0x8(%esp)
c010ec18:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ec1b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ec1f:	c7 04 24 d8 11 11 c0 	movl   $0xc01111d8,(%esp)
c010ec26:	e8 f6 49 ff ff       	call   c0103621 <printf>
            sec = 0;
c010ec2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        }

        while( (pd[pdi] & 1) == 0 )
c010ec32:	eb 06                	jmp    c010ec3a <pd_dump+0x8a>
        {
            pdi++;
c010ec34:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010ec38:	eb 01                	jmp    c010ec3b <pd_dump+0x8b>
        {
            printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
            sec = 0;
        }

        while( (pd[pdi] & 1) == 0 )
c010ec3a:	90                   	nop
c010ec3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ec3e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010ec45:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010ec48:	01 d0                	add    %edx,%eax
c010ec4a:	8b 00                	mov    (%eax),%eax
c010ec4c:	83 e0 01             	and    $0x1,%eax
c010ec4f:	85 c0                	test   %eax,%eax
c010ec51:	74 e1                	je     c010ec34 <pd_dump+0x84>
        {
            pdi++;
        }

        pt = pt_get(context, pdi);
c010ec53:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ec56:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ec5a:	8b 45 08             	mov    0x8(%ebp),%eax
c010ec5d:	89 04 24             	mov    %eax,(%esp)
c010ec60:	e8 38 e8 ff ff       	call   c010d49d <pt_get>
c010ec65:	89 45 d8             	mov    %eax,-0x28(%ebp)

        for( pti = 0; pti < PT_LENGTH; pti++ )
c010ec68:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010ec6f:	e9 6b 01 00 00       	jmp    c010eddf <pd_dump+0x22f>
        {
            if(sec && (pt[pti] & 1) == 0)
c010ec74:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010ec78:	74 63                	je     c010ecdd <pd_dump+0x12d>
c010ec7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ec7d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010ec84:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010ec87:	01 d0                	add    %edx,%eax
c010ec89:	8b 00                	mov    (%eax),%eax
c010ec8b:	83 e0 01             	and    $0x1,%eax
c010ec8e:	85 c0                	test   %eax,%eax
c010ec90:	75 4b                	jne    c010ecdd <pd_dump+0x12d>
            {
                printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c010ec92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ec95:	89 c2                	mov    %eax,%edx
c010ec97:	c1 e2 0c             	shl    $0xc,%edx
c010ec9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ec9d:	01 d0                	add    %edx,%eax
c010ec9f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010eca2:	89 d1                	mov    %edx,%ecx
c010eca4:	c1 e1 0c             	shl    $0xc,%ecx
c010eca7:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010ecaa:	01 ca                	add    %ecx,%edx
c010ecac:	89 44 24 10          	mov    %eax,0x10(%esp)
c010ecb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ecb3:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010ecb7:	89 54 24 08          	mov    %edx,0x8(%esp)
c010ecbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ecbe:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ecc2:	c7 04 24 d8 11 11 c0 	movl   $0xc01111d8,(%esp)
c010ecc9:	e8 53 49 ff ff       	call   c0103621 <printf>
                sec = 0;
c010ecce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
            }

            while( (pt[pti] & 1) == 0 )
c010ecd5:	eb 06                	jmp    c010ecdd <pd_dump+0x12d>
            {
                pti++;
c010ecd7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010ecdb:	eb 01                	jmp    c010ecde <pd_dump+0x12e>
            {
                printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
                sec = 0;
            }

            while( (pt[pti] & 1) == 0 )
c010ecdd:	90                   	nop
c010ecde:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ece1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010ece8:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010eceb:	01 d0                	add    %edx,%eax
c010eced:	8b 00                	mov    (%eax),%eax
c010ecef:	83 e0 01             	and    $0x1,%eax
c010ecf2:	85 c0                	test   %eax,%eax
c010ecf4:	74 e1                	je     c010ecd7 <pd_dump+0x127>
            {
                pti++;
            }
            if(sec == 0)
c010ecf6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010ecfa:	75 3f                	jne    c010ed3b <pd_dump+0x18b>
            {
                sec = 1;
c010ecfc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
                phys_base = ((pt[pti] | 0xfff) ^ 0xfff);
c010ed03:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ed06:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010ed0d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010ed10:	01 d0                	add    %edx,%eax
c010ed12:	8b 00                	mov    (%eax),%eax
c010ed14:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010ed19:	89 45 ec             	mov    %eax,-0x14(%ebp)
                virt_base = (pdi << 22) | (pti << 12);
c010ed1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ed1f:	89 c2                	mov    %eax,%edx
c010ed21:	c1 e2 16             	shl    $0x16,%edx
c010ed24:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ed27:	c1 e0 0c             	shl    $0xc,%eax
c010ed2a:	09 d0                	or     %edx,%eax
c010ed2c:	89 45 e8             	mov    %eax,-0x18(%ebp)
                size = 0;
c010ed2f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010ed36:	e9 a0 00 00 00       	jmp    c010eddb <pd_dump+0x22b>

            }
            else
            {
                if( (phys_base + (4096 * (size+1) )) == ( (pt[pti] | 0xfff) ^ 0xfff) )
c010ed3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ed3e:	83 c0 01             	add    $0x1,%eax
c010ed41:	89 c2                	mov    %eax,%edx
c010ed43:	c1 e2 0c             	shl    $0xc,%edx
c010ed46:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ed49:	01 d0                	add    %edx,%eax
c010ed4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010ed4e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c010ed55:	8b 55 d8             	mov    -0x28(%ebp),%edx
c010ed58:	01 ca                	add    %ecx,%edx
c010ed5a:	8b 12                	mov    (%edx),%edx
c010ed5c:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c010ed62:	39 d0                	cmp    %edx,%eax
c010ed64:	75 06                	jne    c010ed6c <pd_dump+0x1bc>
                {
                    size++;
c010ed66:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010ed6a:	eb 6f                	jmp    c010eddb <pd_dump+0x22b>
                }
                else
                {
                    printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c010ed6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ed6f:	89 c2                	mov    %eax,%edx
c010ed71:	c1 e2 0c             	shl    $0xc,%edx
c010ed74:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ed77:	01 d0                	add    %edx,%eax
c010ed79:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010ed7c:	89 d1                	mov    %edx,%ecx
c010ed7e:	c1 e1 0c             	shl    $0xc,%ecx
c010ed81:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010ed84:	01 ca                	add    %ecx,%edx
c010ed86:	89 44 24 10          	mov    %eax,0x10(%esp)
c010ed8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ed8d:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010ed91:	89 54 24 08          	mov    %edx,0x8(%esp)
c010ed95:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ed98:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ed9c:	c7 04 24 d8 11 11 c0 	movl   $0xc01111d8,(%esp)
c010eda3:	e8 79 48 ff ff       	call   c0103621 <printf>
                    phys_base = ((pt[pti] | 0xfff) ^ 0xfff);
c010eda8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010edab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010edb2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010edb5:	01 d0                	add    %edx,%eax
c010edb7:	8b 00                	mov    (%eax),%eax
c010edb9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010edbe:	89 45 ec             	mov    %eax,-0x14(%ebp)
                    virt_base = (pdi << 22) | (pti << 12);
c010edc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010edc4:	89 c2                	mov    %eax,%edx
c010edc6:	c1 e2 16             	shl    $0x16,%edx
c010edc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010edcc:	c1 e0 0c             	shl    $0xc,%eax
c010edcf:	09 d0                	or     %edx,%eax
c010edd1:	89 45 e8             	mov    %eax,-0x18(%ebp)
                    size = 0;
c010edd4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            pdi++;
        }

        pt = pt_get(context, pdi);

        for( pti = 0; pti < PT_LENGTH; pti++ )
c010eddb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010eddf:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010ede6:	0f 8e 88 fe ff ff    	jle    c010ec74 <pd_dump+0xc4>
void pd_dump(arch_vmm_context_t *context)
{
    int pdi, pti, phys_base, virt_base, size, sec = 0;
    uint32_t *pt;
    uint32_t *pd = context->entries;
    for( pdi = 0; pdi < PD_LENGTH; pdi++ )
c010edec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010edf0:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010edf7:	0f 8e d4 fd ff ff    	jle    c010ebd1 <pd_dump+0x21>
            }
        }

    }

    if(sec)
c010edfd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010ee01:	74 3c                	je     c010ee3f <pd_dump+0x28f>
    {
        printf("%#010X - %#010X => %#010X - %#010X\n", phys_base, phys_base + (4096 * size), virt_base, virt_base + (4096 * size));
c010ee03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ee06:	89 c2                	mov    %eax,%edx
c010ee08:	c1 e2 0c             	shl    $0xc,%edx
c010ee0b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ee0e:	01 d0                	add    %edx,%eax
c010ee10:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010ee13:	89 d1                	mov    %edx,%ecx
c010ee15:	c1 e1 0c             	shl    $0xc,%ecx
c010ee18:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010ee1b:	01 ca                	add    %ecx,%edx
c010ee1d:	89 44 24 10          	mov    %eax,0x10(%esp)
c010ee21:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ee24:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010ee28:	89 54 24 08          	mov    %edx,0x8(%esp)
c010ee2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ee2f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ee33:	c7 04 24 d8 11 11 c0 	movl   $0xc01111d8,(%esp)
c010ee3a:	e8 e2 47 ff ff       	call   c0103621 <printf>
    }
}
c010ee3f:	c9                   	leave  
c010ee40:	c3                   	ret    

c010ee41 <pd_dump2>:



void pd_dump2(arch_vmm_context_t *context)
{
c010ee41:	55                   	push   %ebp
c010ee42:	89 e5                	mov    %esp,%ebp
c010ee44:	83 ec 58             	sub    $0x58,%esp

#define START 	virt_begin = (pd_index * 1024 + pt_index) * 4096; \
		phys_begin = paddr; \
		size = 1;

    int pd_index = 0;
c010ee47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int pt_index = 0;
c010ee4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    uint32_t *pd = context->entries;
c010ee55:	8b 45 08             	mov    0x8(%ebp),%eax
c010ee58:	8b 00                	mov    (%eax),%eax
c010ee5a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint32_t *pt = NULL;
c010ee5d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    uint32_t virt_begin = 0;
c010ee64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    uint32_t phys_begin = 0;
c010ee6b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    int size = 0;
c010ee72:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    uint32_t entry = 0;
c010ee79:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    uint32_t paddr = 0;
c010ee80:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

    for(pd_index = 0; pd_index < 1024; pd_index++)
c010ee87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010ee8e:	e9 2b 02 00 00       	jmp    c010f0be <pd_dump2+0x27d>
    {
        if(pd[pd_index] & VMM_PRESENT)
c010ee93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ee96:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010ee9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010eea0:	01 d0                	add    %edx,%eax
c010eea2:	8b 00                	mov    (%eax),%eax
c010eea4:	83 e0 01             	and    $0x1,%eax
c010eea7:	85 c0                	test   %eax,%eax
c010eea9:	0f 84 9a 01 00 00    	je     c010f049 <pd_dump2+0x208>
        {
            pt = pt_get(context, pd_index);
c010eeaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010eeb2:	89 44 24 04          	mov    %eax,0x4(%esp)
c010eeb6:	8b 45 08             	mov    0x8(%ebp),%eax
c010eeb9:	89 04 24             	mov    %eax,(%esp)
c010eebc:	e8 dc e5 ff ff       	call   c010d49d <pt_get>
c010eec1:	89 45 dc             	mov    %eax,-0x24(%ebp)

            for(pt_index = 0; pt_index < 1024; pt_index++)
c010eec4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010eecb:	e9 6a 01 00 00       	jmp    c010f03a <pd_dump2+0x1f9>
            {
                entry = pt[pt_index];
c010eed0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010eed3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010eeda:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010eedd:	01 d0                	add    %edx,%eax
c010eedf:	8b 00                	mov    (%eax),%eax
c010eee1:	89 45 d8             	mov    %eax,-0x28(%ebp)
                if(entry & VMM_PRESENT)
c010eee4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010eee7:	83 e0 01             	and    $0x1,%eax
c010eeea:	85 c0                	test   %eax,%eax
c010eeec:	0f 84 d3 00 00 00    	je     c010efc5 <pd_dump2+0x184>
                {
                    paddr = pt[pt_index] & ~0xfff;
c010eef2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010eef5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010eefc:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010eeff:	01 d0                	add    %edx,%eax
c010ef01:	8b 00                	mov    (%eax),%eax
c010ef03:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010ef08:	89 45 d4             	mov    %eax,-0x2c(%ebp)

                    if(size == 0)
c010ef0b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c010ef0f:	75 25                	jne    c010ef36 <pd_dump2+0xf5>
                    {
                        START
c010ef11:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ef14:	89 c2                	mov    %eax,%edx
c010ef16:	c1 e2 0a             	shl    $0xa,%edx
c010ef19:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ef1c:	01 d0                	add    %edx,%eax
c010ef1e:	c1 e0 0c             	shl    $0xc,%eax
c010ef21:	89 45 ec             	mov    %eax,-0x14(%ebp)
c010ef24:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010ef27:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010ef2a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
c010ef31:	e9 00 01 00 00       	jmp    c010f036 <pd_dump2+0x1f5>
                    }
                    else
                    {
                        if(paddr != phys_begin + size*4096)
c010ef36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ef39:	c1 e0 0c             	shl    $0xc,%eax
c010ef3c:	89 c2                	mov    %eax,%edx
c010ef3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ef41:	01 d0                	add    %edx,%eax
c010ef43:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
c010ef46:	74 77                	je     c010efbf <pd_dump2+0x17e>
                        {
                            END
c010ef48:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c010ef4c:	0f 8e e4 00 00 00    	jle    c010f036 <pd_dump2+0x1f5>
c010ef52:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
c010ef56:	75 1c                	jne    c010ef74 <pd_dump2+0x133>
c010ef58:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ef5b:	89 44 24 08          	mov    %eax,0x8(%esp)
c010ef5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ef62:	89 44 24 04          	mov    %eax,0x4(%esp)
c010ef66:	c7 04 24 fc 11 11 c0 	movl   $0xc01111fc,(%esp)
c010ef6d:	e8 af 46 ff ff       	call   c0103621 <printf>
c010ef72:	eb 42                	jmp    c010efb6 <pd_dump2+0x175>
c010ef74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ef77:	83 e8 01             	sub    $0x1,%eax
c010ef7a:	c1 e0 0c             	shl    $0xc,%eax
c010ef7d:	89 c2                	mov    %eax,%edx
c010ef7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ef82:	01 d0                	add    %edx,%eax
c010ef84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010ef87:	83 ea 01             	sub    $0x1,%edx
c010ef8a:	c1 e2 0c             	shl    $0xc,%edx
c010ef8d:	89 d1                	mov    %edx,%ecx
c010ef8f:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010ef92:	01 ca                	add    %ecx,%edx
c010ef94:	89 44 24 10          	mov    %eax,0x10(%esp)
c010ef98:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ef9b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010ef9f:	89 54 24 08          	mov    %edx,0x8(%esp)
c010efa3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010efa6:	89 44 24 04          	mov    %eax,0x4(%esp)
c010efaa:	c7 04 24 d8 11 11 c0 	movl   $0xc01111d8,(%esp)
c010efb1:	e8 6b 46 ff ff       	call   c0103621 <printf>
c010efb6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010efbd:	eb 77                	jmp    c010f036 <pd_dump2+0x1f5>
                        }
                        else
                        {
                            size++;
c010efbf:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010efc3:	eb 71                	jmp    c010f036 <pd_dump2+0x1f5>
                        }
                    }
                }
                else
                {
                    END
c010efc5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c010efc9:	7e 6b                	jle    c010f036 <pd_dump2+0x1f5>
c010efcb:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
c010efcf:	75 1c                	jne    c010efed <pd_dump2+0x1ac>
c010efd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010efd4:	89 44 24 08          	mov    %eax,0x8(%esp)
c010efd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010efdb:	89 44 24 04          	mov    %eax,0x4(%esp)
c010efdf:	c7 04 24 fc 11 11 c0 	movl   $0xc01111fc,(%esp)
c010efe6:	e8 36 46 ff ff       	call   c0103621 <printf>
c010efeb:	eb 42                	jmp    c010f02f <pd_dump2+0x1ee>
c010efed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010eff0:	83 e8 01             	sub    $0x1,%eax
c010eff3:	c1 e0 0c             	shl    $0xc,%eax
c010eff6:	89 c2                	mov    %eax,%edx
c010eff8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010effb:	01 d0                	add    %edx,%eax
c010effd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010f000:	83 ea 01             	sub    $0x1,%edx
c010f003:	c1 e2 0c             	shl    $0xc,%edx
c010f006:	89 d1                	mov    %edx,%ecx
c010f008:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010f00b:	01 ca                	add    %ecx,%edx
c010f00d:	89 44 24 10          	mov    %eax,0x10(%esp)
c010f011:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010f014:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010f018:	89 54 24 08          	mov    %edx,0x8(%esp)
c010f01c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f01f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f023:	c7 04 24 d8 11 11 c0 	movl   $0xc01111d8,(%esp)
c010f02a:	e8 f2 45 ff ff       	call   c0103621 <printf>
c010f02f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    {
        if(pd[pd_index] & VMM_PRESENT)
        {
            pt = pt_get(context, pd_index);

            for(pt_index = 0; pt_index < 1024; pt_index++)
c010f036:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010f03a:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010f041:	0f 8e 89 fe ff ff    	jle    c010eed0 <pd_dump2+0x8f>
c010f047:	eb 71                	jmp    c010f0ba <pd_dump2+0x279>
                }
            }
        }
        else
        {
            END
c010f049:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c010f04d:	7e 6b                	jle    c010f0ba <pd_dump2+0x279>
c010f04f:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
c010f053:	75 1c                	jne    c010f071 <pd_dump2+0x230>
c010f055:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010f058:	89 44 24 08          	mov    %eax,0x8(%esp)
c010f05c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f05f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f063:	c7 04 24 fc 11 11 c0 	movl   $0xc01111fc,(%esp)
c010f06a:	e8 b2 45 ff ff       	call   c0103621 <printf>
c010f06f:	eb 42                	jmp    c010f0b3 <pd_dump2+0x272>
c010f071:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010f074:	83 e8 01             	sub    $0x1,%eax
c010f077:	c1 e0 0c             	shl    $0xc,%eax
c010f07a:	89 c2                	mov    %eax,%edx
c010f07c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010f07f:	01 d0                	add    %edx,%eax
c010f081:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010f084:	83 ea 01             	sub    $0x1,%edx
c010f087:	c1 e2 0c             	shl    $0xc,%edx
c010f08a:	89 d1                	mov    %edx,%ecx
c010f08c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010f08f:	01 ca                	add    %ecx,%edx
c010f091:	89 44 24 10          	mov    %eax,0x10(%esp)
c010f095:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010f098:	89 44 24 0c          	mov    %eax,0xc(%esp)
c010f09c:	89 54 24 08          	mov    %edx,0x8(%esp)
c010f0a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f0a3:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f0a7:	c7 04 24 d8 11 11 c0 	movl   $0xc01111d8,(%esp)
c010f0ae:	e8 6e 45 ff ff       	call   c0103621 <printf>
c010f0b3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    int size = 0;

    uint32_t entry = 0;
    uint32_t paddr = 0;

    for(pd_index = 0; pd_index < 1024; pd_index++)
c010f0ba:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f0be:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010f0c5:	0f 8e c8 fd ff ff    	jle    c010ee93 <pd_dump2+0x52>
        else
        {
            END
        }
    }
}
c010f0cb:	c9                   	leave  
c010f0cc:	c3                   	ret    

c010f0cd <pmm_count_free_pages>:
/**
 * @brief Returns the number of free pages.
 * @return number of free pages
 */
int pmm_count_free_pages(void)
{
c010f0cd:	55                   	push   %ebp
c010f0ce:	89 e5                	mov    %esp,%ebp
c010f0d0:	56                   	push   %esi
c010f0d1:	53                   	push   %ebx
c010f0d2:	83 ec 10             	sub    $0x10,%esp
    int free_pages = 0;
c010f0d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int i, z;

    for (i = 0; i < PMM_MMAP_SIZE; i++)
c010f0dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010f0e3:	eb 3b                	jmp    c010f120 <pmm_count_free_pages+0x53>
    {
        for (z = 0; z < 32; z++)
c010f0e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c010f0ec:	eb 28                	jmp    c010f116 <pmm_count_free_pages+0x49>
        {
            if (pmm_mmap[i] & (1 << z))
c010f0ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010f0f1:	8b 14 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%edx
c010f0f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f0fb:	bb 01 00 00 00       	mov    $0x1,%ebx
c010f100:	89 de                	mov    %ebx,%esi
c010f102:	89 c1                	mov    %eax,%ecx
c010f104:	d3 e6                	shl    %cl,%esi
c010f106:	89 f0                	mov    %esi,%eax
c010f108:	21 d0                	and    %edx,%eax
c010f10a:	85 c0                	test   %eax,%eax
c010f10c:	74 04                	je     c010f112 <pmm_count_free_pages+0x45>
            {
                free_pages++;
c010f10e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    int free_pages = 0;
    int i, z;

    for (i = 0; i < PMM_MMAP_SIZE; i++)
    {
        for (z = 0; z < 32; z++)
c010f112:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c010f116:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
c010f11a:	7e d2                	jle    c010f0ee <pmm_count_free_pages+0x21>
int pmm_count_free_pages(void)
{
    int free_pages = 0;
    int i, z;

    for (i = 0; i < PMM_MMAP_SIZE; i++)
c010f11c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010f120:	81 7d f0 ff 7f 00 00 	cmpl   $0x7fff,-0x10(%ebp)
c010f127:	7e bc                	jle    c010f0e5 <pmm_count_free_pages+0x18>
            {
                free_pages++;
            }
        }
    }
    return free_pages;
c010f129:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010f12c:	83 c4 10             	add    $0x10,%esp
c010f12f:	5b                   	pop    %ebx
c010f130:	5e                   	pop    %esi
c010f131:	5d                   	pop    %ebp
c010f132:	c3                   	ret    

c010f133 <pmm_check_page>:
 * @brief Checs if the page is already in use or not.
 * @param page the pysical base adress of the page
 * @return 0 = page is already taken; 1 = Page is free
 */
int pmm_check_page(paddr_t page)
{
c010f133:	55                   	push   %ebp
c010f134:	89 e5                	mov    %esp,%ebp
c010f136:	56                   	push   %esi
c010f137:	53                   	push   %ebx
    return pmm_mmap[page / PAGE_SIZE / 32] & (1 << ((page / PAGE_SIZE) & 31));
c010f138:	8b 45 08             	mov    0x8(%ebp),%eax
c010f13b:	c1 e8 11             	shr    $0x11,%eax
c010f13e:	8b 14 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%edx
c010f145:	8b 45 08             	mov    0x8(%ebp),%eax
c010f148:	c1 e8 0c             	shr    $0xc,%eax
c010f14b:	83 e0 1f             	and    $0x1f,%eax
c010f14e:	bb 01 00 00 00       	mov    $0x1,%ebx
c010f153:	89 de                	mov    %ebx,%esi
c010f155:	89 c1                	mov    %eax,%ecx
c010f157:	d3 e6                	shl    %cl,%esi
c010f159:	89 f0                	mov    %esi,%eax
c010f15b:	21 d0                	and    %edx,%eax
}
c010f15d:	5b                   	pop    %ebx
c010f15e:	5e                   	pop    %esi
c010f15f:	5d                   	pop    %ebp
c010f160:	c3                   	ret    

c010f161 <pmm_check_page_range>:
 * @param page the pysical base adress of the page
 * @param range number of pages to be checked
 * @return 0 = page is already taken; 1 = Page is free
 */
int pmm_check_page_range(paddr_t page, size_t range)
{
c010f161:	55                   	push   %ebp
c010f162:	89 e5                	mov    %esp,%ebp
c010f164:	83 ec 14             	sub    $0x14,%esp
    int r = 1;
c010f167:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    size_t i;
    for(i=0; i < range; i++)
c010f16e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c010f175:	eb 19                	jmp    c010f190 <pmm_check_page_range+0x2f>
    {
        r &= pmm_check_page(page);
c010f177:	8b 45 08             	mov    0x8(%ebp),%eax
c010f17a:	89 04 24             	mov    %eax,(%esp)
c010f17d:	e8 b1 ff ff ff       	call   c010f133 <pmm_check_page>
c010f182:	21 45 fc             	and    %eax,-0x4(%ebp)
        page += PAGE_SIZE;
c010f185:	81 45 08 00 10 00 00 	addl   $0x1000,0x8(%ebp)
 */
int pmm_check_page_range(paddr_t page, size_t range)
{
    int r = 1;
    size_t i;
    for(i=0; i < range; i++)
c010f18c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c010f190:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010f193:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010f196:	72 df                	jb     c010f177 <pmm_check_page_range+0x16>
    {
        r &= pmm_check_page(page);
        page += PAGE_SIZE;
    }
    return r;
c010f198:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010f19b:	c9                   	leave  
c010f19c:	c3                   	ret    

c010f19d <pmm_mark_page_as_free>:
/**
 * @brief Mark page als free.
 * @param page pointer on the begin of the page which should be marked as free.
 */
void pmm_mark_page_as_free(paddr_t page)
{
c010f19d:	55                   	push   %ebp
c010f19e:	89 e5                	mov    %esp,%ebp
c010f1a0:	57                   	push   %edi
c010f1a1:	56                   	push   %esi
c010f1a2:	53                   	push   %ebx
    //TODO: should that be possible from the entire kernel?
    pmm_mmap[page / PAGE_SIZE / 32] |= 1 << ((page / PAGE_SIZE) & 31);
c010f1a3:	8b 45 08             	mov    0x8(%ebp),%eax
c010f1a6:	c1 e8 11             	shr    $0x11,%eax
c010f1a9:	8b 1c 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%ebx
c010f1b0:	8b 55 08             	mov    0x8(%ebp),%edx
c010f1b3:	c1 ea 0c             	shr    $0xc,%edx
c010f1b6:	83 e2 1f             	and    $0x1f,%edx
c010f1b9:	be 01 00 00 00       	mov    $0x1,%esi
c010f1be:	89 f7                	mov    %esi,%edi
c010f1c0:	89 d1                	mov    %edx,%ecx
c010f1c2:	d3 e7                	shl    %cl,%edi
c010f1c4:	89 fa                	mov    %edi,%edx
c010f1c6:	09 da                	or     %ebx,%edx
c010f1c8:	89 14 85 60 f0 11 c0 	mov    %edx,-0x3fee0fa0(,%eax,4)
}
c010f1cf:	5b                   	pop    %ebx
c010f1d0:	5e                   	pop    %esi
c010f1d1:	5f                   	pop    %edi
c010f1d2:	5d                   	pop    %ebp
c010f1d3:	c3                   	ret    

c010f1d4 <pmm_mark_page_range_as_free>:
 * @brief Mark num pages as free.
 * @param page pointer on the begin of the first page.
 * @param num number of the pages which should be marked as free.
 */
void pmm_mark_page_range_as_free(paddr_t page, unsigned int num)
{
c010f1d4:	55                   	push   %ebp
c010f1d5:	89 e5                	mov    %esp,%ebp
c010f1d7:	83 ec 28             	sub    $0x28,%esp
    int i;

    if (!num)
c010f1da:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010f1de:	75 0c                	jne    c010f1ec <pmm_mark_page_range_as_free+0x18>
        panic("PMM: pmm_mark_page_range_as_free(): num is zero");
c010f1e0:	c7 04 24 10 12 11 c0 	movl   $0xc0111210,(%esp)
c010f1e7:	e8 64 2f ff ff       	call   c0102150 <panic>

    if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
c010f1ec:	8b 45 08             	mov    0x8(%ebp),%eax
c010f1ef:	89 c2                	mov    %eax,%edx
c010f1f1:	c1 ea 0c             	shr    $0xc,%edx
c010f1f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c010f1f7:	01 d0                	add    %edx,%eax
c010f1f9:	3d 00 00 10 00       	cmp    $0x100000,%eax
c010f1fe:	76 0c                	jbe    c010f20c <pmm_mark_page_range_as_free+0x38>
        panic("PMM: pmm_mark_page_range_as_free(): marking the given\n"
c010f200:	c7 04 24 40 12 11 c0 	movl   $0xc0111240,(%esp)
c010f207:	e8 44 2f ff ff       	call   c0102150 <panic>
              "pages as free would cause a buffer overrun");


    for (i = 0; i < num; i++)
c010f20c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010f213:	eb 19                	jmp    c010f22e <pmm_mark_page_range_as_free+0x5a>
    {
        pmm_mark_page_as_free(page + i * PAGE_SIZE);
c010f215:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f218:	c1 e0 0c             	shl    $0xc,%eax
c010f21b:	89 c2                	mov    %eax,%edx
c010f21d:	8b 45 08             	mov    0x8(%ebp),%eax
c010f220:	01 d0                	add    %edx,%eax
c010f222:	89 04 24             	mov    %eax,(%esp)
c010f225:	e8 73 ff ff ff       	call   c010f19d <pmm_mark_page_as_free>
    if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
        panic("PMM: pmm_mark_page_range_as_free(): marking the given\n"
              "pages as free would cause a buffer overrun");


    for (i = 0; i < num; i++)
c010f22a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f22e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f231:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010f234:	72 df                	jb     c010f215 <pmm_mark_page_range_as_free+0x41>
    {
        pmm_mark_page_as_free(page + i * PAGE_SIZE);
    }
}
c010f236:	c9                   	leave  
c010f237:	c3                   	ret    

c010f238 <pmm_mark_page_as_used>:
/**
 * @brief Mark page as used.
 * @param page pointer on the begin of the first page.
 */
void pmm_mark_page_as_used(paddr_t page)
{
c010f238:	55                   	push   %ebp
c010f239:	89 e5                	mov    %esp,%ebp
c010f23b:	57                   	push   %edi
c010f23c:	56                   	push   %esi
c010f23d:	53                   	push   %ebx
    pmm_mmap[page / PAGE_SIZE / 32] &= ~(1 << ((page / PAGE_SIZE) & 31));
c010f23e:	8b 45 08             	mov    0x8(%ebp),%eax
c010f241:	c1 e8 11             	shr    $0x11,%eax
c010f244:	8b 1c 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%ebx
c010f24b:	8b 55 08             	mov    0x8(%ebp),%edx
c010f24e:	c1 ea 0c             	shr    $0xc,%edx
c010f251:	83 e2 1f             	and    $0x1f,%edx
c010f254:	be 01 00 00 00       	mov    $0x1,%esi
c010f259:	89 f7                	mov    %esi,%edi
c010f25b:	89 d1                	mov    %edx,%ecx
c010f25d:	d3 e7                	shl    %cl,%edi
c010f25f:	89 fa                	mov    %edi,%edx
c010f261:	f7 d2                	not    %edx
c010f263:	21 da                	and    %ebx,%edx
c010f265:	89 14 85 60 f0 11 c0 	mov    %edx,-0x3fee0fa0(,%eax,4)
}
c010f26c:	5b                   	pop    %ebx
c010f26d:	5e                   	pop    %esi
c010f26e:	5f                   	pop    %edi
c010f26f:	5d                   	pop    %ebp
c010f270:	c3                   	ret    

c010f271 <pmm_mark_page_range_as_used>:
 * @brief Mark num pages as used.
 * @param page pointer on the begin of the first page.
 * @param num number of the pages which should be marked as free.
 */
void pmm_mark_page_range_as_used(paddr_t page, unsigned int num)
{
c010f271:	55                   	push   %ebp
c010f272:	89 e5                	mov    %esp,%ebp
c010f274:	83 ec 28             	sub    $0x28,%esp
    int i;

    if (!num)
c010f277:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010f27b:	75 0c                	jne    c010f289 <pmm_mark_page_range_as_used+0x18>
        panic("PMM: pmm_mark_page_range_as_used(): num is zero");
c010f27d:	c7 04 24 a4 12 11 c0 	movl   $0xc01112a4,(%esp)
c010f284:	e8 c7 2e ff ff       	call   c0102150 <panic>

    /*
     * PMM is broken, see comment in PMM_INIT
     */
    if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
c010f289:	8b 45 08             	mov    0x8(%ebp),%eax
c010f28c:	89 c2                	mov    %eax,%edx
c010f28e:	c1 ea 0c             	shr    $0xc,%edx
c010f291:	8b 45 0c             	mov    0xc(%ebp),%eax
c010f294:	01 d0                	add    %edx,%eax
c010f296:	3d 00 00 10 00       	cmp    $0x100000,%eax
c010f29b:	76 0c                	jbe    c010f2a9 <pmm_mark_page_range_as_used+0x38>
        panic("PMM: pmm_mark_page_range_as_used(): marking the given\n"
c010f29d:	c7 04 24 d4 12 11 c0 	movl   $0xc01112d4,(%esp)
c010f2a4:	e8 a7 2e ff ff       	call   c0102150 <panic>
              "pages as used would cause a buffer overrun");

    for (i = 0; i < num; i++)
c010f2a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010f2b0:	eb 19                	jmp    c010f2cb <pmm_mark_page_range_as_used+0x5a>
    {
        pmm_mark_page_as_used(page + i * PAGE_SIZE);
c010f2b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f2b5:	c1 e0 0c             	shl    $0xc,%eax
c010f2b8:	89 c2                	mov    %eax,%edx
c010f2ba:	8b 45 08             	mov    0x8(%ebp),%eax
c010f2bd:	01 d0                	add    %edx,%eax
c010f2bf:	89 04 24             	mov    %eax,(%esp)
c010f2c2:	e8 71 ff ff ff       	call   c010f238 <pmm_mark_page_as_used>
     */
    if (page / PAGE_SIZE + num > PMM_MMAP_SIZE * 32)
        panic("PMM: pmm_mark_page_range_as_used(): marking the given\n"
              "pages as used would cause a buffer overrun");

    for (i = 0; i < num; i++)
c010f2c7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f2cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f2ce:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010f2d1:	72 df                	jb     c010f2b2 <pmm_mark_page_range_as_used+0x41>
    {
        pmm_mark_page_as_used(page + i * PAGE_SIZE);
    }
}
c010f2d3:	c9                   	leave  
c010f2d4:	c3                   	ret    

c010f2d5 <pmm_find_free_page>:
 * @brief Search for a free page and returns a pointer on the begin.
 * @param lower_limit minimus size of the page.
 * @return If the search is succesful this method returns a pointer on the begin on this page.
 */
paddr_t pmm_find_free_page(unsigned long lower_limit)
{
c010f2d5:	55                   	push   %ebp
c010f2d6:	89 e5                	mov    %esp,%ebp
c010f2d8:	56                   	push   %esi
c010f2d9:	53                   	push   %ebx
c010f2da:	83 ec 20             	sub    $0x20,%esp
    uint32_t i, z;
    paddr_t page = 0;
c010f2dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    i = lower_limit / PAGE_SIZE / 32;
c010f2e4:	8b 45 08             	mov    0x8(%ebp),%eax
c010f2e7:	c1 e8 11             	shr    $0x11,%eax
c010f2ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (pmm_mmap[i] & (0xffffffff << (( lower_limit / PAGE_SIZE) % 32)))
c010f2ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f2f0:	8b 04 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%eax
c010f2f7:	8b 55 08             	mov    0x8(%ebp),%edx
c010f2fa:	c1 ea 0c             	shr    $0xc,%edx
c010f2fd:	83 e2 1f             	and    $0x1f,%edx
c010f300:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c010f305:	89 de                	mov    %ebx,%esi
c010f307:	89 d1                	mov    %edx,%ecx
c010f309:	d3 e6                	shl    %cl,%esi
c010f30b:	89 f2                	mov    %esi,%edx
c010f30d:	21 d0                	and    %edx,%eax
c010f30f:	85 c0                	test   %eax,%eax
c010f311:	74 45                	je     c010f358 <pmm_find_free_page+0x83>
    {
        z = bit_scan_forward(pmm_mmap[i] & (0xffffffff << ((lower_limit / PAGE_SIZE) % 32)));
c010f313:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f316:	8b 04 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%eax
c010f31d:	8b 55 08             	mov    0x8(%ebp),%edx
c010f320:	c1 ea 0c             	shr    $0xc,%edx
c010f323:	83 e2 1f             	and    $0x1f,%edx
c010f326:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c010f32b:	89 de                	mov    %ebx,%esi
c010f32d:	89 d1                	mov    %edx,%ecx
c010f32f:	d3 e6                	shl    %cl,%esi
c010f331:	89 f2                	mov    %esi,%edx
c010f333:	21 d0                	and    %edx,%eax
c010f335:	89 04 24             	mov    %eax,(%esp)
c010f338:	e8 1a 2d ff ff       	call   c0102057 <bit_scan_forward>
c010f33d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        page = (i * 32 + z) * PAGE_SIZE;
c010f340:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f343:	89 c2                	mov    %eax,%edx
c010f345:	c1 e2 05             	shl    $0x5,%edx
c010f348:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f34b:	01 d0                	add    %edx,%eax
c010f34d:	c1 e0 0c             	shl    $0xc,%eax
c010f350:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return page;
c010f353:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010f356:	eb 53                	jmp    c010f3ab <pmm_find_free_page+0xd6>
    }

    for (i++; i < PMM_MMAP_SIZE; i++)
c010f358:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f35c:	eb 3f                	jmp    c010f39d <pmm_find_free_page+0xc8>
    {
        if (pmm_mmap[i])
c010f35e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f361:	8b 04 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%eax
c010f368:	85 c0                	test   %eax,%eax
c010f36a:	74 2d                	je     c010f399 <pmm_find_free_page+0xc4>
        {
            z = bit_scan_forward(pmm_mmap[i]);
c010f36c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f36f:	8b 04 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%eax
c010f376:	89 04 24             	mov    %eax,(%esp)
c010f379:	e8 d9 2c ff ff       	call   c0102057 <bit_scan_forward>
c010f37e:	89 45 ec             	mov    %eax,-0x14(%ebp)
            page = (i * 32 + z) * PAGE_SIZE;
c010f381:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f384:	89 c2                	mov    %eax,%edx
c010f386:	c1 e2 05             	shl    $0x5,%edx
c010f389:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f38c:	01 d0                	add    %edx,%eax
c010f38e:	c1 e0 0c             	shl    $0xc,%eax
c010f391:	89 45 f0             	mov    %eax,-0x10(%ebp)
            return page;
c010f394:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010f397:	eb 12                	jmp    c010f3ab <pmm_find_free_page+0xd6>
        z = bit_scan_forward(pmm_mmap[i] & (0xffffffff << ((lower_limit / PAGE_SIZE) % 32)));
        page = (i * 32 + z) * PAGE_SIZE;
        return page;
    }

    for (i++; i < PMM_MMAP_SIZE; i++)
c010f399:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f39d:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
c010f3a4:	76 b8                	jbe    c010f35e <pmm_find_free_page+0x89>
            return page;
        }
    }

    /* checked in the alloc functions */
    return -1;
c010f3a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c010f3ab:	83 c4 20             	add    $0x20,%esp
c010f3ae:	5b                   	pop    %ebx
c010f3af:	5e                   	pop    %esi
c010f3b0:	5d                   	pop    %ebp
c010f3b1:	c3                   	ret    

c010f3b2 <pmm_find_free_page_range>:
 * @param num Number of pages.
 * @return Pointer on begin of the first page.
 * If succesful this method will return a pointer on the begin of the first free page.
 */
paddr_t pmm_find_free_page_range(unsigned long lower_limit, unsigned int num)
{
c010f3b2:	55                   	push   %ebp
c010f3b3:	89 e5                	mov    %esp,%ebp
c010f3b5:	56                   	push   %esi
c010f3b6:	53                   	push   %ebx
c010f3b7:	83 ec 20             	sub    $0x20,%esp
    uint32_t i, z;
    uint32_t found = 0;
c010f3ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    paddr_t page = 0;
c010f3c1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

    if (!num)
c010f3c8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010f3cc:	75 0c                	jne    c010f3da <pmm_find_free_page_range+0x28>
        panic("PMM: searching 0 pages (find_free_page_range())");
c010f3ce:	c7 04 24 38 13 11 c0 	movl   $0xc0111338,(%esp)
c010f3d5:	e8 76 2d ff ff       	call   c0102150 <panic>

    for (i = lower_limit / PAGE_SIZE / 32; i < PMM_MMAP_SIZE; i++)
c010f3da:	8b 45 08             	mov    0x8(%ebp),%eax
c010f3dd:	c1 e8 11             	shr    $0x11,%eax
c010f3e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010f3e3:	e9 b3 00 00 00       	jmp    c010f49b <pmm_find_free_page_range+0xe9>
    {
        if (pmm_mmap[i] == 0)
c010f3e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f3eb:	8b 04 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%eax
c010f3f2:	85 c0                	test   %eax,%eax
c010f3f4:	75 0c                	jne    c010f402 <pmm_find_free_page_range+0x50>
        {
            found = 0;
c010f3f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            continue;
c010f3fd:	e9 95 00 00 00       	jmp    c010f497 <pmm_find_free_page_range+0xe5>
        }

        if (pmm_mmap[i] == 0xffffffff)
c010f402:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f405:	8b 04 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%eax
c010f40c:	83 f8 ff             	cmp    $0xffffffff,%eax
c010f40f:	75 15                	jne    c010f426 <pmm_find_free_page_range+0x74>
        {
            if (found == 0)
c010f411:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010f415:	75 09                	jne    c010f420 <pmm_find_free_page_range+0x6e>
            {
                page = (i * 32) * PAGE_SIZE; //
c010f417:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f41a:	c1 e0 11             	shl    $0x11,%eax
c010f41d:	89 45 e8             	mov    %eax,-0x18(%ebp)
            }
            found += 32;
c010f420:	83 45 ec 20          	addl   $0x20,-0x14(%ebp)
c010f424:	eb 64                	jmp    c010f48a <pmm_find_free_page_range+0xd8>

        }
        else
        {
            for (z = 0; z < 32; z++)
c010f426:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010f42d:	eb 55                	jmp    c010f484 <pmm_find_free_page_range+0xd2>
            {
                if (pmm_mmap[i] & (1 << z))
c010f42f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f432:	8b 14 85 60 f0 11 c0 	mov    -0x3fee0fa0(,%eax,4),%edx
c010f439:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010f43c:	bb 01 00 00 00       	mov    $0x1,%ebx
c010f441:	89 de                	mov    %ebx,%esi
c010f443:	89 c1                	mov    %eax,%ecx
c010f445:	d3 e6                	shl    %cl,%esi
c010f447:	89 f0                	mov    %esi,%eax
c010f449:	21 d0                	and    %edx,%eax
c010f44b:	85 c0                	test   %eax,%eax
c010f44d:	74 2a                	je     c010f479 <pmm_find_free_page_range+0xc7>
                {
                    if (found == 0)
c010f44f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010f453:	75 13                	jne    c010f468 <pmm_find_free_page_range+0xb6>
                    {
                        page = (i * 32 + z) * PAGE_SIZE;
c010f455:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f458:	89 c2                	mov    %eax,%edx
c010f45a:	c1 e2 05             	shl    $0x5,%edx
c010f45d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010f460:	01 d0                	add    %edx,%eax
c010f462:	c1 e0 0c             	shl    $0xc,%eax
c010f465:	89 45 e8             	mov    %eax,-0x18(%ebp)
                    }
                    found++;
c010f468:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)

                    if (found >= num)
c010f46c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f46f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010f472:	72 0c                	jb     c010f480 <pmm_find_free_page_range+0xce>
                    {
                        return page;
c010f474:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010f477:	eb 34                	jmp    c010f4ad <pmm_find_free_page_range+0xfb>
                    }
                }
                else
                {
                    found = 0;
c010f479:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            found += 32;

        }
        else
        {
            for (z = 0; z < 32; z++)
c010f480:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010f484:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c010f488:	76 a5                	jbe    c010f42f <pmm_find_free_page_range+0x7d>
                    found = 0;
                }
            }
        }

        if (found >= num)
c010f48a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f48d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010f490:	72 05                	jb     c010f497 <pmm_find_free_page_range+0xe5>
        {
            return page;
c010f492:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010f495:	eb 16                	jmp    c010f4ad <pmm_find_free_page_range+0xfb>
    paddr_t page = 0;

    if (!num)
        panic("PMM: searching 0 pages (find_free_page_range())");

    for (i = lower_limit / PAGE_SIZE / 32; i < PMM_MMAP_SIZE; i++)
c010f497:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f49b:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
c010f4a2:	0f 86 40 ff ff ff    	jbe    c010f3e8 <pmm_find_free_page_range+0x36>
        {
            return page;
        }
    }

    return -1; /* checked in the alloc functions */
c010f4a8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c010f4ad:	83 c4 20             	add    $0x20,%esp
c010f4b0:	5b                   	pop    %ebx
c010f4b1:	5e                   	pop    %esi
c010f4b2:	5d                   	pop    %ebp
c010f4b3:	c3                   	ret    

c010f4b4 <pmm_alloc_page>:
/**
 * @brief Reserve a page and mark this page as used.
 * @return Pointer on the begin of the page.
 */
paddr_t pmm_alloc_page(void)
{
c010f4b4:	55                   	push   %ebp
c010f4b5:	89 e5                	mov    %esp,%ebp
c010f4b7:	83 ec 28             	sub    $0x28,%esp
    paddr_t page = pmm_find_free_page(PMM_DMA_LIMIT);
c010f4ba:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
c010f4c1:	e8 0f fe ff ff       	call   c010f2d5 <pmm_find_free_page>
c010f4c6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (page & (PAGE_SIZE - 1))
c010f4c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f4cc:	25 ff 0f 00 00       	and    $0xfff,%eax
c010f4d1:	85 c0                	test   %eax,%eax
c010f4d3:	74 0c                	je     c010f4e1 <pmm_alloc_page+0x2d>
    {
        panic("PMM: pmm_alloc_page(): no pages left");
c010f4d5:	c7 04 24 68 13 11 c0 	movl   $0xc0111368,(%esp)
c010f4dc:	e8 6f 2c ff ff       	call   c0102150 <panic>
    }
    pmm_mark_page_as_used(page);
c010f4e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f4e4:	89 04 24             	mov    %eax,(%esp)
c010f4e7:	e8 4c fd ff ff       	call   c010f238 <pmm_mark_page_as_used>

    return page;
c010f4ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010f4ef:	c9                   	leave  
c010f4f0:	c3                   	ret    

c010f4f1 <pmm_alloc_page_limit>:
 * @brief Reserve a page not under a entered address
 * @param lower_limit the lower limit
 * @return Pointer on the begin of the allocated page.
 */
paddr_t pmm_alloc_page_limit(paddr_t lower_limit)
{
c010f4f1:	55                   	push   %ebp
c010f4f2:	89 e5                	mov    %esp,%ebp
c010f4f4:	83 ec 28             	sub    $0x28,%esp
    paddr_t page = pmm_find_free_page(lower_limit);
c010f4f7:	8b 45 08             	mov    0x8(%ebp),%eax
c010f4fa:	89 04 24             	mov    %eax,(%esp)
c010f4fd:	e8 d3 fd ff ff       	call   c010f2d5 <pmm_find_free_page>
c010f502:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (page & (PAGE_SIZE - 1))
c010f505:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f508:	25 ff 0f 00 00       	and    $0xfff,%eax
c010f50d:	85 c0                	test   %eax,%eax
c010f50f:	74 0c                	je     c010f51d <pmm_alloc_page_limit+0x2c>
    {
        panic("PMM: pmm_alloc_page_limit(): no pages left");
c010f511:	c7 04 24 90 13 11 c0 	movl   $0xc0111390,(%esp)
c010f518:	e8 33 2c ff ff       	call   c0102150 <panic>
    }

    pmm_mark_page_as_used(page);
c010f51d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f520:	89 04 24             	mov    %eax,(%esp)
c010f523:	e8 10 fd ff ff       	call   c010f238 <pmm_mark_page_as_used>
    return page;
c010f528:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010f52b:	c9                   	leave  
c010f52c:	c3                   	ret    

c010f52d <pmm_alloc_dma_page_range>:
 * @brief Reserve num DMA-Pages.
 * @param num the number of pages to be allocated
 * @return Pointer on the begin of the first page.
 */
paddr_t pmm_alloc_dma_page_range(unsigned int num)
{
c010f52d:	55                   	push   %ebp
c010f52e:	89 e5                	mov    %esp,%ebp
c010f530:	83 ec 28             	sub    $0x28,%esp
    if (!num)
c010f533:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010f537:	75 0c                	jne    c010f545 <pmm_alloc_dma_page_range+0x18>
        panic("PMM: pmm_alloc_dma_page_range(): num zero");
c010f539:	c7 04 24 bc 13 11 c0 	movl   $0xc01113bc,(%esp)
c010f540:	e8 0b 2c ff ff       	call   c0102150 <panic>
    paddr_t page = pmm_find_free_page_range(0, num);
c010f545:	8b 45 08             	mov    0x8(%ebp),%eax
c010f548:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f54c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010f553:	e8 5a fe ff ff       	call   c010f3b2 <pmm_find_free_page_range>
c010f558:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (page & (PAGE_SIZE - 1) || page >= PMM_DMA_LIMIT)
c010f55b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f55e:	25 ff 0f 00 00       	and    $0xfff,%eax
c010f563:	85 c0                	test   %eax,%eax
c010f565:	75 09                	jne    c010f570 <pmm_alloc_dma_page_range+0x43>
c010f567:	81 7d f4 ff ff ff 00 	cmpl   $0xffffff,-0xc(%ebp)
c010f56e:	76 0c                	jbe    c010f57c <pmm_alloc_dma_page_range+0x4f>
    {
        panic("PMM: pmm_alloc_dma_page_range(): no DMA memory left");
c010f570:	c7 04 24 e8 13 11 c0 	movl   $0xc01113e8,(%esp)
c010f577:	e8 d4 2b ff ff       	call   c0102150 <panic>
    }
    pmm_mark_page_range_as_used(page, num);
c010f57c:	8b 45 08             	mov    0x8(%ebp),%eax
c010f57f:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f583:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f586:	89 04 24             	mov    %eax,(%esp)
c010f589:	e8 e3 fc ff ff       	call   c010f271 <pmm_mark_page_range_as_used>
    return page;
c010f58e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010f591:	c9                   	leave  
c010f592:	c3                   	ret    

c010f593 <pmm_alloc_page_range>:
/**
 * @brief Reserve num pages.
 * @return Pointer on the begin of the first page.
 */
paddr_t pmm_alloc_page_range(unsigned int num)
{
c010f593:	55                   	push   %ebp
c010f594:	89 e5                	mov    %esp,%ebp
c010f596:	83 ec 28             	sub    $0x28,%esp
    if (!num)
c010f599:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010f59d:	75 0c                	jne    c010f5ab <pmm_alloc_page_range+0x18>
        panic("PMM: pmm_alloc_page_range(): num zero");
c010f59f:	c7 04 24 1c 14 11 c0 	movl   $0xc011141c,(%esp)
c010f5a6:	e8 a5 2b ff ff       	call   c0102150 <panic>
    paddr_t page = pmm_find_free_page_range(PMM_DMA_LIMIT, num);
c010f5ab:	8b 45 08             	mov    0x8(%ebp),%eax
c010f5ae:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f5b2:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
c010f5b9:	e8 f4 fd ff ff       	call   c010f3b2 <pmm_find_free_page_range>
c010f5be:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (page & (PAGE_SIZE - 1))
c010f5c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f5c4:	25 ff 0f 00 00       	and    $0xfff,%eax
c010f5c9:	85 c0                	test   %eax,%eax
c010f5cb:	74 0c                	je     c010f5d9 <pmm_alloc_page_range+0x46>
    {
        panic("PMM: pmm_alloc_page_range(): no memory left");
c010f5cd:	c7 04 24 44 14 11 c0 	movl   $0xc0111444,(%esp)
c010f5d4:	e8 77 2b ff ff       	call   c0102150 <panic>
    }
    pmm_mark_page_range_as_used(page, num);
c010f5d9:	8b 45 08             	mov    0x8(%ebp),%eax
c010f5dc:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f5e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f5e3:	89 04 24             	mov    %eax,(%esp)
c010f5e6:	e8 86 fc ff ff       	call   c010f271 <pmm_mark_page_range_as_used>
    return page;
c010f5eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010f5ee:	c9                   	leave  
c010f5ef:	c3                   	ret    

c010f5f0 <INIT_PMM>:
 * @brief Initiates the PMM module.
 * @param mb_info the multiboot info struct for module protection
 */

void INIT_PMM(struct multiboot_struct *mb_info)
{
c010f5f0:	55                   	push   %ebp
c010f5f1:	89 e5                	mov    %esp,%ebp
c010f5f3:	83 ec 48             	sub    $0x48,%esp
    int i;
    for (i = 0; i < PMM_MMAP_SIZE; i++)
c010f5f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010f5fd:	eb 12                	jmp    c010f611 <INIT_PMM+0x21>
    {
        pmm_mmap[i] = 0;
c010f5ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f602:	c7 04 85 60 f0 11 c0 	movl   $0x0,-0x3fee0fa0(,%eax,4)
c010f609:	00 00 00 00 
 */

void INIT_PMM(struct multiboot_struct *mb_info)
{
    int i;
    for (i = 0; i < PMM_MMAP_SIZE; i++)
c010f60d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f611:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
c010f618:	7e e5                	jle    c010f5ff <INIT_PMM+0xf>
    {
        pmm_mmap[i] = 0;
    }

    mb_info->mmap_addr += MEMORY_LAYOUT_KERNEL_START;
c010f61a:	8b 45 08             	mov    0x8(%ebp),%eax
c010f61d:	8b 40 30             	mov    0x30(%eax),%eax
c010f620:	8d 90 00 00 00 c0    	lea    -0x40000000(%eax),%edx
c010f626:	8b 45 08             	mov    0x8(%ebp),%eax
c010f629:	89 50 30             	mov    %edx,0x30(%eax)
    mb_info->mods_addr += MEMORY_LAYOUT_KERNEL_START;
c010f62c:	8b 45 08             	mov    0x8(%ebp),%eax
c010f62f:	8b 40 18             	mov    0x18(%eax),%eax
c010f632:	8d 90 00 00 00 c0    	lea    -0x40000000(%eax),%edx
c010f638:	8b 45 08             	mov    0x8(%ebp),%eax
c010f63b:	89 50 18             	mov    %edx,0x18(%eax)

    struct mmap_entry *mmap = (struct mmap_entry *)mb_info->mmap_addr;
c010f63e:	8b 45 08             	mov    0x8(%ebp),%eax
c010f641:	8b 40 30             	mov    0x30(%eax),%eax
c010f644:	89 45 ec             	mov    %eax,-0x14(%ebp)

    int len = 0;
c010f647:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for(i = 0; len < mb_info->mmap_length; i++)
c010f64e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010f655:	e9 90 00 00 00       	jmp    c010f6ea <INIT_PMM+0xfa>
    {
        len += mmap[i].size +4;
c010f65a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010f65d:	89 d0                	mov    %edx,%eax
c010f65f:	01 c0                	add    %eax,%eax
c010f661:	01 d0                	add    %edx,%eax
c010f663:	c1 e0 03             	shl    $0x3,%eax
c010f666:	89 c2                	mov    %eax,%edx
c010f668:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f66b:	01 d0                	add    %edx,%eax
c010f66d:	8b 10                	mov    (%eax),%edx
c010f66f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010f672:	01 d0                	add    %edx,%eax
c010f674:	83 c0 04             	add    $0x4,%eax
c010f677:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(mmap[i].Type == 1)
c010f67a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010f67d:	89 d0                	mov    %edx,%eax
c010f67f:	01 c0                	add    %eax,%eax
c010f681:	01 d0                	add    %edx,%eax
c010f683:	c1 e0 03             	shl    $0x3,%eax
c010f686:	89 c2                	mov    %eax,%edx
c010f688:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f68b:	01 d0                	add    %edx,%eax
c010f68d:	8b 40 14             	mov    0x14(%eax),%eax
c010f690:	83 f8 01             	cmp    $0x1,%eax
c010f693:	75 51                	jne    c010f6e6 <INIT_PMM+0xf6>
        {
            uintptr_t addr = mmap[i].BaseAddr;
c010f695:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010f698:	89 d0                	mov    %edx,%eax
c010f69a:	01 c0                	add    %eax,%eax
c010f69c:	01 d0                	add    %edx,%eax
c010f69e:	c1 e0 03             	shl    $0x3,%eax
c010f6a1:	89 c2                	mov    %eax,%edx
c010f6a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f6a6:	01 d0                	add    %edx,%eax
c010f6a8:	8b 50 08             	mov    0x8(%eax),%edx
c010f6ab:	8b 40 04             	mov    0x4(%eax),%eax
c010f6ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
            int pages = mmap[i].Length / PAGE_SIZE;
c010f6b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010f6b4:	89 d0                	mov    %edx,%eax
c010f6b6:	01 c0                	add    %eax,%eax
c010f6b8:	01 d0                	add    %edx,%eax
c010f6ba:	c1 e0 03             	shl    $0x3,%eax
c010f6bd:	89 c2                	mov    %eax,%edx
c010f6bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010f6c2:	01 d0                	add    %edx,%eax
c010f6c4:	8b 50 10             	mov    0x10(%eax),%edx
c010f6c7:	8b 40 0c             	mov    0xc(%eax),%eax
c010f6ca:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
c010f6ce:	c1 ea 0c             	shr    $0xc,%edx
c010f6d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            pmm_mark_page_range_as_free(addr, pages);
c010f6d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010f6d7:	89 44 24 04          	mov    %eax,0x4(%esp)
c010f6db:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010f6de:	89 04 24             	mov    %eax,(%esp)
c010f6e1:	e8 ee fa ff ff       	call   c010f1d4 <pmm_mark_page_range_as_free>
    mb_info->mods_addr += MEMORY_LAYOUT_KERNEL_START;

    struct mmap_entry *mmap = (struct mmap_entry *)mb_info->mmap_addr;

    int len = 0;
    for(i = 0; len < mb_info->mmap_length; i++)
c010f6e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f6ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010f6ed:	8b 45 08             	mov    0x8(%ebp),%eax
c010f6f0:	8b 40 2c             	mov    0x2c(%eax),%eax
c010f6f3:	39 c2                	cmp    %eax,%edx
c010f6f5:	0f 82 5f ff ff ff    	jb     c010f65a <INIT_PMM+0x6a>
            pmm_mark_page_range_as_free(addr, pages);
        }
    }

    //protect Memory structures
    pmm_mark_page_as_used(0); //IVT+BDA
c010f6fb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c010f702:	e8 31 fb ff ff       	call   c010f238 <pmm_mark_page_as_used>

    uint16_t* EBDA_p = (void *)0x040E;
c010f707:	c7 45 e0 0e 04 00 00 	movl   $0x40e,-0x20(%ebp)
    pmm_mark_page_as_used((paddr_t)EBDA_p[0] << 4); //EBDA
c010f70e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010f711:	0f b7 00             	movzwl (%eax),%eax
c010f714:	0f b7 c0             	movzwl %ax,%eax
c010f717:	c1 e0 04             	shl    $0x4,%eax
c010f71a:	89 04 24             	mov    %eax,(%esp)
c010f71d:	e8 16 fb ff ff       	call   c010f238 <pmm_mark_page_as_used>

    uint16_t* BDA_size = (uint16_t*)0x0413;
c010f722:	c7 45 dc 13 04 00 00 	movl   $0x413,-0x24(%ebp)
    pmm_mark_page_as_used((BDA_size[0] / 4) * 1024); //FPS (maybe)
c010f729:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010f72c:	0f b7 00             	movzwl (%eax),%eax
c010f72f:	66 c1 e8 02          	shr    $0x2,%ax
c010f733:	0f b7 c0             	movzwl %ax,%eax
c010f736:	c1 e0 0a             	shl    $0xa,%eax
c010f739:	89 04 24             	mov    %eax,(%esp)
c010f73c:	e8 f7 fa ff ff       	call   c010f238 <pmm_mark_page_as_used>
    pmm_mark_page_range_as_used(0xA0000, 96); //0xA0000 - 0xFFFFF ROM-AREA
c010f741:	c7 44 24 04 60 00 00 	movl   $0x60,0x4(%esp)
c010f748:	00 
c010f749:	c7 04 24 00 00 0a 00 	movl   $0xa0000,(%esp)
c010f750:	e8 1c fb ff ff       	call   c010f271 <pmm_mark_page_range_as_used>


    //multiboot structures
    struct mods_add *mods = (void*)mb_info->mods_addr;
c010f755:	8b 45 08             	mov    0x8(%ebp),%eax
c010f758:	8b 40 18             	mov    0x18(%eax),%eax
c010f75b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    pmm_mark_page_as_used((paddr_t)mb_info - MEMORY_LAYOUT_KERNEL_START);
c010f75e:	8b 45 08             	mov    0x8(%ebp),%eax
c010f761:	05 00 00 00 40       	add    $0x40000000,%eax
c010f766:	89 04 24             	mov    %eax,(%esp)
c010f769:	e8 ca fa ff ff       	call   c010f238 <pmm_mark_page_as_used>
    pmm_mark_page_as_used((paddr_t)mods    - MEMORY_LAYOUT_KERNEL_START);
c010f76e:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010f771:	05 00 00 00 40       	add    $0x40000000,%eax
c010f776:	89 04 24             	mov    %eax,(%esp)
c010f779:	e8 ba fa ff ff       	call   c010f238 <pmm_mark_page_as_used>

    //multiboot modules
    for (i = 0; i < mb_info->mods_count; i++)
c010f77e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010f785:	eb 75                	jmp    c010f7fc <INIT_PMM+0x20c>
    {
        uint32_t size = mods[i].mod_end - mods[i].mod_start;
c010f787:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f78a:	89 c2                	mov    %eax,%edx
c010f78c:	c1 e2 04             	shl    $0x4,%edx
c010f78f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010f792:	01 d0                	add    %edx,%eax
c010f794:	8b 50 04             	mov    0x4(%eax),%edx
c010f797:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f79a:	89 c1                	mov    %eax,%ecx
c010f79c:	c1 e1 04             	shl    $0x4,%ecx
c010f79f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010f7a2:	01 c8                	add    %ecx,%eax
c010f7a4:	8b 00                	mov    (%eax),%eax
c010f7a6:	89 d1                	mov    %edx,%ecx
c010f7a8:	29 c1                	sub    %eax,%ecx
c010f7aa:	89 c8                	mov    %ecx,%eax
c010f7ac:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        int pages = NUM_PAGES(size);
c010f7af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010f7b2:	05 ff 0f 00 00       	add    $0xfff,%eax
c010f7b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010f7bc:	c1 e8 0c             	shr    $0xc,%eax
c010f7bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
        pmm_mark_page_range_as_used((paddr_t) mods[i].mod_start, pages);
c010f7c2:	8b 55 d0             	mov    -0x30(%ebp),%edx
c010f7c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f7c8:	89 c1                	mov    %eax,%ecx
c010f7ca:	c1 e1 04             	shl    $0x4,%ecx
c010f7cd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010f7d0:	01 c8                	add    %ecx,%eax
c010f7d2:	8b 00                	mov    (%eax),%eax
c010f7d4:	89 54 24 04          	mov    %edx,0x4(%esp)
c010f7d8:	89 04 24             	mov    %eax,(%esp)
c010f7db:	e8 91 fa ff ff       	call   c010f271 <pmm_mark_page_range_as_used>
        pmm_mark_page_as_used((paddr_t) mods[i].string);
c010f7e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f7e3:	89 c2                	mov    %eax,%edx
c010f7e5:	c1 e2 04             	shl    $0x4,%edx
c010f7e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010f7eb:	01 d0                	add    %edx,%eax
c010f7ed:	8b 40 08             	mov    0x8(%eax),%eax
c010f7f0:	89 04 24             	mov    %eax,(%esp)
c010f7f3:	e8 40 fa ff ff       	call   c010f238 <pmm_mark_page_as_used>
    struct mods_add *mods = (void*)mb_info->mods_addr;
    pmm_mark_page_as_used((paddr_t)mb_info - MEMORY_LAYOUT_KERNEL_START);
    pmm_mark_page_as_used((paddr_t)mods    - MEMORY_LAYOUT_KERNEL_START);

    //multiboot modules
    for (i = 0; i < mb_info->mods_count; i++)
c010f7f8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f7fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010f7ff:	8b 45 08             	mov    0x8(%ebp),%eax
c010f802:	8b 40 14             	mov    0x14(%eax),%eax
c010f805:	39 c2                	cmp    %eax,%edx
c010f807:	0f 82 7a ff ff ff    	jb     c010f787 <INIT_PMM+0x197>
        int pages = NUM_PAGES(size);
        pmm_mark_page_range_as_used((paddr_t) mods[i].mod_start, pages);
        pmm_mark_page_as_used((paddr_t) mods[i].string);
    }

    if (! (mb_info->flags & 0x1))
c010f80d:	8b 45 08             	mov    0x8(%ebp),%eax
c010f810:	8b 00                	mov    (%eax),%eax
c010f812:	83 e0 01             	and    $0x1,%eax
c010f815:	85 c0                	test   %eax,%eax
c010f817:	75 0c                	jne    c010f825 <INIT_PMM+0x235>
    {
        panic("PMM_INIT: no ram info in multiboot structure");
c010f819:	c7 04 24 70 14 11 c0 	movl   $0xc0111470,(%esp)
c010f820:	e8 2b 29 ff ff       	call   c0102150 <panic>
    }

}
c010f825:	c9                   	leave  
c010f826:	c3                   	ret    

c010f827 <INIT_PREV>:

/**
 * @brief INIT function for x86 segment/previleg level system
 */
void INIT_PREV(void)
{
c010f827:	55                   	push   %ebp
c010f828:	89 e5                	mov    %esp,%ebp
c010f82a:	83 ec 38             	sub    $0x38,%esp
    //NULL Descriptor
    gdt_set_entry(GDT, 0, 0, 0, 0, NULL_DESC, 0);
c010f82d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c010f834:	00 
c010f835:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c010f83c:	00 
c010f83d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010f844:	00 
c010f845:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c010f84c:	00 
c010f84d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010f854:	00 
c010f855:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010f85c:	00 
c010f85d:	c7 04 24 80 b8 11 c0 	movl   $0xc011b880,(%esp)
c010f864:	e8 91 01 00 00       	call   c010f9fa <gdt_set_entry>

    //Ring 0 Descriptors
    gdt_set_entry(GDT, 1, 0, 0xFFFFF, KERNELMODE, CODE_DESC, BITS32 | GRAN4K | READABLE | PRESENT);
c010f869:	c7 44 24 18 c0 82 00 	movl   $0x82c0,0x18(%esp)
c010f870:	00 
c010f871:	c7 44 24 14 18 00 00 	movl   $0x18,0x14(%esp)
c010f878:	00 
c010f879:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010f880:	00 
c010f881:	c7 44 24 0c ff ff 0f 	movl   $0xfffff,0xc(%esp)
c010f888:	00 
c010f889:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010f890:	00 
c010f891:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c010f898:	00 
c010f899:	c7 04 24 80 b8 11 c0 	movl   $0xc011b880,(%esp)
c010f8a0:	e8 55 01 00 00       	call   c010f9fa <gdt_set_entry>
    gdt_set_entry(GDT, 2, 0, 0xFFFFF, KERNELMODE, DATA_DESC, BITS32 | GRAN4K | WRITEABLE | PRESENT);
c010f8a5:	c7 44 24 18 c0 82 00 	movl   $0x82c0,0x18(%esp)
c010f8ac:	00 
c010f8ad:	c7 44 24 14 10 00 00 	movl   $0x10,0x14(%esp)
c010f8b4:	00 
c010f8b5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010f8bc:	00 
c010f8bd:	c7 44 24 0c ff ff 0f 	movl   $0xfffff,0xc(%esp)
c010f8c4:	00 
c010f8c5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010f8cc:	00 
c010f8cd:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c010f8d4:	00 
c010f8d5:	c7 04 24 80 b8 11 c0 	movl   $0xc011b880,(%esp)
c010f8dc:	e8 19 01 00 00       	call   c010f9fa <gdt_set_entry>

    //Ring 3 Descriptors
    gdt_set_entry(GDT, 3, 0, 0xFFFFF, USERMODE, CODE_DESC, BITS32 | GRAN4K | READABLE | PRESENT);
c010f8e1:	c7 44 24 18 c0 82 00 	movl   $0x82c0,0x18(%esp)
c010f8e8:	00 
c010f8e9:	c7 44 24 14 18 00 00 	movl   $0x18,0x14(%esp)
c010f8f0:	00 
c010f8f1:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
c010f8f8:	00 
c010f8f9:	c7 44 24 0c ff ff 0f 	movl   $0xfffff,0xc(%esp)
c010f900:	00 
c010f901:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010f908:	00 
c010f909:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c010f910:	00 
c010f911:	c7 04 24 80 b8 11 c0 	movl   $0xc011b880,(%esp)
c010f918:	e8 dd 00 00 00       	call   c010f9fa <gdt_set_entry>
    gdt_set_entry(GDT, 4, 0, 0xFFFFF, USERMODE, DATA_DESC, BITS32 | GRAN4K | WRITEABLE | PRESENT);
c010f91d:	c7 44 24 18 c0 82 00 	movl   $0x82c0,0x18(%esp)
c010f924:	00 
c010f925:	c7 44 24 14 10 00 00 	movl   $0x10,0x14(%esp)
c010f92c:	00 
c010f92d:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
c010f934:	00 
c010f935:	c7 44 24 0c ff ff 0f 	movl   $0xfffff,0xc(%esp)
c010f93c:	00 
c010f93d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c010f944:	00 
c010f945:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
c010f94c:	00 
c010f94d:	c7 04 24 80 b8 11 c0 	movl   $0xc011b880,(%esp)
c010f954:	e8 a1 00 00 00       	call   c010f9fa <gdt_set_entry>

    //TSS descriptor
    gdt_set_entry(GDT, 5, (paddr_t)&tss, sizeof(tss), KERNELMODE, TSS_DESC, GRAN4K | PRESENT);
c010f959:	b8 c0 21 11 c0       	mov    $0xc01121c0,%eax
c010f95e:	c7 44 24 18 80 80 00 	movl   $0x8080,0x18(%esp)
c010f965:	00 
c010f966:	c7 44 24 14 09 00 00 	movl   $0x9,0x14(%esp)
c010f96d:	00 
c010f96e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c010f975:	00 
c010f976:	c7 44 24 0c 66 20 00 	movl   $0x2066,0xc(%esp)
c010f97d:	00 
c010f97e:	89 44 24 08          	mov    %eax,0x8(%esp)
c010f982:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
c010f989:	00 
c010f98a:	c7 04 24 80 b8 11 c0 	movl   $0xc011b880,(%esp)
c010f991:	e8 64 00 00 00       	call   c010f9fa <gdt_set_entry>
    //load the new table
    gdt_load(GDT,5);
c010f996:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
c010f99d:	00 
c010f99e:	c7 04 24 80 b8 11 c0 	movl   $0xc011b880,(%esp)
c010f9a5:	e8 04 01 00 00       	call   c010faae <gdt_load>

    //jump into the new segments
    asm volatile(
c010f9aa:	66 b8 10 00          	mov    $0x10,%ax
c010f9ae:	8e d8                	mov    %eax,%ds
c010f9b0:	8e c0                	mov    %eax,%es
c010f9b2:	8e e0                	mov    %eax,%fs
c010f9b4:	8e e8                	mov    %eax,%gs
c010f9b6:	8e d0                	mov    %eax,%ss
c010f9b8:	ea bf f9 10 c0 08 00 	ljmp   $0x8,$0xc010f9bf

c010f9bf <.1>:
        ".1:;"
    );


    //initiate the i/o bitmap
    tss.iobmp_offset =(uint32_t)(((uint32_t)&tss.iobmp) - ((uint32_t)&tss)); // calculate real adressoffset
c010f9bf:	c7 05 26 22 11 c0 6a 	movl   $0x6a,0xc0112226
c010f9c6:	00 00 00 
    size_t i;
    for(i=0; i<2048; i++)
c010f9c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010f9d0:	eb 15                	jmp    c010f9e7 <.1+0x28>
        tss.iobmp[i]=0xFFFFFFFF;
c010f9d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010f9d5:	83 c0 18             	add    $0x18,%eax
c010f9d8:	c7 04 85 ca 21 11 c0 	movl   $0xffffffff,-0x3feede36(,%eax,4)
c010f9df:	ff ff ff ff 


    //initiate the i/o bitmap
    tss.iobmp_offset =(uint32_t)(((uint32_t)&tss.iobmp) - ((uint32_t)&tss)); // calculate real adressoffset
    size_t i;
    for(i=0; i<2048; i++)
c010f9e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010f9e7:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c010f9ee:	76 e2                	jbe    c010f9d2 <.1+0x13>
        tss.iobmp[i]=0xFFFFFFFF;

    // load the TSS
    asm volatile("ltr %%ax" : : "a" (5 << 3));
c010f9f0:	b8 28 00 00 00       	mov    $0x28,%eax
c010f9f5:	0f 00 d8             	ltr    %ax
}
c010f9f8:	c9                   	leave  
c010f9f9:	c3                   	ret    

c010f9fa <gdt_set_entry>:
 * @param prev Previleg level of the memory segment
 * @param type The Descriptor type
 * @param flags Descriptor flags
 */
void gdt_set_entry(struct gdt_entry *gdt, uint16_t entry, paddr_t base, size_t size, privilege_t prev, gdt_seg_type type, gdt_flag_type flags)
{
c010f9fa:	55                   	push   %ebp
c010f9fb:	89 e5                	mov    %esp,%ebp
c010f9fd:	83 ec 04             	sub    $0x4,%esp
c010fa00:	8b 45 0c             	mov    0xc(%ebp),%eax
c010fa03:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt[entry].limit_low =      (uint16_t) size;
c010fa07:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010fa0b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c010fa12:	8b 45 08             	mov    0x8(%ebp),%eax
c010fa15:	01 c2                	add    %eax,%edx
c010fa17:	8b 45 14             	mov    0x14(%ebp),%eax
c010fa1a:	66 89 02             	mov    %ax,(%edx)
    gdt[entry].Base_low =       (uint16_t) base;
c010fa1d:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010fa21:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c010fa28:	8b 45 08             	mov    0x8(%ebp),%eax
c010fa2b:	01 c2                	add    %eax,%edx
c010fa2d:	8b 45 10             	mov    0x10(%ebp),%eax
c010fa30:	66 89 42 02          	mov    %ax,0x2(%edx)
    gdt[entry].Base_middle =    (uint8_t) (base >> 16);
c010fa34:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010fa38:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c010fa3f:	8b 45 08             	mov    0x8(%ebp),%eax
c010fa42:	01 c2                	add    %eax,%edx
c010fa44:	8b 45 10             	mov    0x10(%ebp),%eax
c010fa47:	c1 e8 10             	shr    $0x10,%eax
c010fa4a:	88 42 04             	mov    %al,0x4(%edx)
    gdt[entry].Access =         (uint8_t) (flags >> 8) | (prev << 5) |type;
c010fa4d:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010fa51:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c010fa58:	8b 45 08             	mov    0x8(%ebp),%eax
c010fa5b:	01 c2                	add    %eax,%edx
c010fa5d:	8b 45 20             	mov    0x20(%ebp),%eax
c010fa60:	c1 e8 08             	shr    $0x8,%eax
c010fa63:	8b 4d 18             	mov    0x18(%ebp),%ecx
c010fa66:	c1 e1 05             	shl    $0x5,%ecx
c010fa69:	09 c1                	or     %eax,%ecx
c010fa6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
c010fa6e:	09 c8                	or     %ecx,%eax
c010fa70:	88 42 05             	mov    %al,0x5(%edx)
    gdt[entry].limit_Flags=     (uint8_t)  flags | (uint8_t)(size >> 16);
c010fa73:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010fa77:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c010fa7e:	8b 45 08             	mov    0x8(%ebp),%eax
c010fa81:	01 c2                	add    %eax,%edx
c010fa83:	8b 45 20             	mov    0x20(%ebp),%eax
c010fa86:	89 c1                	mov    %eax,%ecx
c010fa88:	8b 45 14             	mov    0x14(%ebp),%eax
c010fa8b:	c1 e8 10             	shr    $0x10,%eax
c010fa8e:	09 c8                	or     %ecx,%eax
c010fa90:	88 42 06             	mov    %al,0x6(%edx)
    gdt[entry].base_high =      (uint8_t) (base >> 24);
c010fa93:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c010fa97:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c010fa9e:	8b 45 08             	mov    0x8(%ebp),%eax
c010faa1:	01 c2                	add    %eax,%edx
c010faa3:	8b 45 10             	mov    0x10(%ebp),%eax
c010faa6:	c1 e8 18             	shr    $0x18,%eax
c010faa9:	88 42 07             	mov    %al,0x7(%edx)
}
c010faac:	c9                   	leave  
c010faad:	c3                   	ret    

c010faae <gdt_load>:
 *  @brief Load GDT into register
 *  @param gdt GDT to be loaded
 *  @param last_entry last set GDT entry
 */
void gdt_load(struct gdt_entry *gdt, uint16_t last_entry)
{
c010faae:	55                   	push   %ebp
c010faaf:	89 e5                	mov    %esp,%ebp
c010fab1:	83 ec 14             	sub    $0x14,%esp
c010fab4:	8b 45 0c             	mov    0xc(%ebp),%eax
c010fab7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    struct gdtpt gdtp;
    gdtp.limit = ((last_entry + 1) * 8) - 1;
c010fabb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c010fabf:	83 c0 01             	add    $0x1,%eax
c010fac2:	c1 e0 03             	shl    $0x3,%eax
c010fac5:	83 e8 01             	sub    $0x1,%eax
c010fac8:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    gdtp.base = gdt;
c010facc:	8b 45 08             	mov    0x8(%ebp),%eax
c010facf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    asm volatile("lgdt %0"::"m" (gdtp));
c010fad2:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
c010fad6:	c9                   	leave  
c010fad7:	c3                   	ret    

c010fad8 <set_kernelstack>:
/**
 * @brief set the kernel stack for syscalls
 * @param adress of the kernel stack
 */
void set_kernelstack(void *stack)
{
c010fad8:	55                   	push   %ebp
c010fad9:	89 e5                	mov    %esp,%ebp
    tss.esp0 = (uint32_t)stack;
c010fadb:	8b 45 08             	mov    0x8(%ebp),%eax
c010fade:	a3 c4 21 11 c0       	mov    %eax,0xc01121c4
}
c010fae3:	5d                   	pop    %ebp
c010fae4:	c3                   	ret    

c010fae5 <set_iobmp>:
/**
 * @brief sets the IO Access bitmap of context
 * @param context the thread context which acces bitmap should be set as current
 */
void set_iobmp(struct arch_thread_context *context)
{
c010fae5:	55                   	push   %ebp
c010fae6:	89 e5                	mov    %esp,%ebp
c010fae8:	83 ec 18             	sub    $0x18,%esp
    memcpy(tss.iobmp, context->ports.iobmp, sizeof(tss.iobmp));
c010faeb:	8b 45 08             	mov    0x8(%ebp),%eax
c010faee:	83 c0 14             	add    $0x14,%eax
c010faf1:	c7 44 24 08 fc 1f 00 	movl   $0x1ffc,0x8(%esp)
c010faf8:	00 
c010faf9:	89 44 24 04          	mov    %eax,0x4(%esp)
c010fafd:	c7 04 24 2a 22 11 c0 	movl   $0xc011222a,(%esp)
c010fb04:	e8 9a 37 ff ff       	call   c01032a3 <memcpy>
}
c010fb09:	c9                   	leave  
c010fb0a:	c3                   	ret    
c010fb0b:	66 90                	xchg   %ax,%ax
c010fb0d:	66 90                	xchg   %ax,%ax
c010fb0f:	90                   	nop

c010fb10 <start>:
c010fb10:	b9 00 50 11 00       	mov    $0x115000,%ecx
c010fb15:	0f 22 d9             	mov    %ecx,%cr3
c010fb18:	0f 20 e1             	mov    %cr4,%ecx
c010fb1b:	83 c9 10             	or     $0x10,%ecx
c010fb1e:	0f 22 e1             	mov    %ecx,%cr4
c010fb21:	0f 20 c1             	mov    %cr0,%ecx
c010fb24:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
c010fb2a:	0f 22 c1             	mov    %ecx,%cr0
c010fb2d:	8d 0d 35 fb 10 c0    	lea    0xc010fb35,%ecx
c010fb33:	ff e1                	jmp    *%ecx

c010fb35 <higherhalf>:
c010fb35:	bc 00 d0 11 c0       	mov    $0xc011d000,%esp
c010fb3a:	81 c3 00 00 00 c0    	add    $0xc0000000,%ebx
c010fb40:	6a 00                	push   $0x0
c010fb42:	6a 00                	push   $0x0
c010fb44:	50                   	push   %eax
c010fb45:	53                   	push   %ebx
c010fb46:	e8 fd 3f ff ff       	call   c0103b48 <init>
c010fb4b:	eb fe                	jmp    c010fb4b <higherhalf+0x16>
c010fb4d:	66 90                	xchg   %ax,%ax
c010fb4f:	90                   	nop

c010fb50 <isr_0>:
c010fb50:	6a 00                	push   $0x0
c010fb52:	6a 00                	push   $0x0
c010fb54:	e9 81 01 00 00       	jmp    c010fcda <isr_save>

c010fb59 <isr_1>:
c010fb59:	6a 00                	push   $0x0
c010fb5b:	6a 01                	push   $0x1
c010fb5d:	e9 78 01 00 00       	jmp    c010fcda <isr_save>

c010fb62 <isr_2>:
c010fb62:	6a 00                	push   $0x0
c010fb64:	6a 02                	push   $0x2
c010fb66:	e9 6f 01 00 00       	jmp    c010fcda <isr_save>

c010fb6b <isr_3>:
c010fb6b:	6a 00                	push   $0x0
c010fb6d:	6a 03                	push   $0x3
c010fb6f:	e9 66 01 00 00       	jmp    c010fcda <isr_save>

c010fb74 <isr_4>:
c010fb74:	6a 00                	push   $0x0
c010fb76:	6a 04                	push   $0x4
c010fb78:	e9 5d 01 00 00       	jmp    c010fcda <isr_save>

c010fb7d <isr_5>:
c010fb7d:	6a 00                	push   $0x0
c010fb7f:	6a 05                	push   $0x5
c010fb81:	e9 54 01 00 00       	jmp    c010fcda <isr_save>

c010fb86 <isr_6>:
c010fb86:	6a 00                	push   $0x0
c010fb88:	6a 06                	push   $0x6
c010fb8a:	e9 4b 01 00 00       	jmp    c010fcda <isr_save>

c010fb8f <isr_7>:
c010fb8f:	6a 00                	push   $0x0
c010fb91:	6a 07                	push   $0x7
c010fb93:	e9 42 01 00 00       	jmp    c010fcda <isr_save>

c010fb98 <isr_8>:
c010fb98:	6a 08                	push   $0x8
c010fb9a:	e9 3b 01 00 00       	jmp    c010fcda <isr_save>

c010fb9f <isr_9>:
c010fb9f:	6a 00                	push   $0x0
c010fba1:	6a 09                	push   $0x9
c010fba3:	e9 32 01 00 00       	jmp    c010fcda <isr_save>

c010fba8 <isr_10>:
c010fba8:	6a 0a                	push   $0xa
c010fbaa:	e9 2b 01 00 00       	jmp    c010fcda <isr_save>

c010fbaf <isr_11>:
c010fbaf:	6a 0b                	push   $0xb
c010fbb1:	e9 24 01 00 00       	jmp    c010fcda <isr_save>

c010fbb6 <isr_12>:
c010fbb6:	6a 0c                	push   $0xc
c010fbb8:	e9 1d 01 00 00       	jmp    c010fcda <isr_save>

c010fbbd <isr_13>:
c010fbbd:	6a 0d                	push   $0xd
c010fbbf:	e9 16 01 00 00       	jmp    c010fcda <isr_save>

c010fbc4 <isr_14>:
c010fbc4:	6a 0e                	push   $0xe
c010fbc6:	e9 0f 01 00 00       	jmp    c010fcda <isr_save>

c010fbcb <isr_15>:
c010fbcb:	6a 00                	push   $0x0
c010fbcd:	6a 0f                	push   $0xf
c010fbcf:	e9 06 01 00 00       	jmp    c010fcda <isr_save>

c010fbd4 <isr_16>:
c010fbd4:	6a 00                	push   $0x0
c010fbd6:	6a 10                	push   $0x10
c010fbd8:	e9 fd 00 00 00       	jmp    c010fcda <isr_save>

c010fbdd <isr_17>:
c010fbdd:	6a 11                	push   $0x11
c010fbdf:	e9 f6 00 00 00       	jmp    c010fcda <isr_save>

c010fbe4 <isr_18>:
c010fbe4:	6a 00                	push   $0x0
c010fbe6:	6a 12                	push   $0x12
c010fbe8:	e9 ed 00 00 00       	jmp    c010fcda <isr_save>

c010fbed <isr_19>:
c010fbed:	6a 00                	push   $0x0
c010fbef:	6a 13                	push   $0x13
c010fbf1:	e9 e4 00 00 00       	jmp    c010fcda <isr_save>

c010fbf6 <isr_20>:
c010fbf6:	6a 00                	push   $0x0
c010fbf8:	6a 14                	push   $0x14
c010fbfa:	e9 db 00 00 00       	jmp    c010fcda <isr_save>

c010fbff <isr_21>:
c010fbff:	6a 00                	push   $0x0
c010fc01:	6a 15                	push   $0x15
c010fc03:	e9 d2 00 00 00       	jmp    c010fcda <isr_save>

c010fc08 <isr_22>:
c010fc08:	6a 00                	push   $0x0
c010fc0a:	6a 16                	push   $0x16
c010fc0c:	e9 c9 00 00 00       	jmp    c010fcda <isr_save>

c010fc11 <isr_23>:
c010fc11:	6a 00                	push   $0x0
c010fc13:	6a 17                	push   $0x17
c010fc15:	e9 c0 00 00 00       	jmp    c010fcda <isr_save>

c010fc1a <isr_24>:
c010fc1a:	6a 00                	push   $0x0
c010fc1c:	6a 18                	push   $0x18
c010fc1e:	e9 b7 00 00 00       	jmp    c010fcda <isr_save>

c010fc23 <isr_25>:
c010fc23:	6a 00                	push   $0x0
c010fc25:	6a 19                	push   $0x19
c010fc27:	e9 ae 00 00 00       	jmp    c010fcda <isr_save>

c010fc2c <isr_26>:
c010fc2c:	6a 00                	push   $0x0
c010fc2e:	6a 1a                	push   $0x1a
c010fc30:	e9 a5 00 00 00       	jmp    c010fcda <isr_save>

c010fc35 <isr_27>:
c010fc35:	6a 00                	push   $0x0
c010fc37:	6a 1b                	push   $0x1b
c010fc39:	e9 9c 00 00 00       	jmp    c010fcda <isr_save>

c010fc3e <isr_28>:
c010fc3e:	6a 00                	push   $0x0
c010fc40:	6a 1c                	push   $0x1c
c010fc42:	e9 93 00 00 00       	jmp    c010fcda <isr_save>

c010fc47 <isr_29>:
c010fc47:	6a 00                	push   $0x0
c010fc49:	6a 1d                	push   $0x1d
c010fc4b:	e9 8a 00 00 00       	jmp    c010fcda <isr_save>

c010fc50 <isr_30>:
c010fc50:	6a 00                	push   $0x0
c010fc52:	6a 1e                	push   $0x1e
c010fc54:	e9 81 00 00 00       	jmp    c010fcda <isr_save>

c010fc59 <isr_31>:
c010fc59:	6a 00                	push   $0x0
c010fc5b:	6a 1f                	push   $0x1f
c010fc5d:	eb 7b                	jmp    c010fcda <isr_save>

c010fc5f <isr_default>:
c010fc5f:	6a ff                	push   $0xffffffff
c010fc61:	6a ff                	push   $0xffffffff
c010fc63:	eb 75                	jmp    c010fcda <isr_save>

c010fc65 <isr_32>:
c010fc65:	6a 00                	push   $0x0
c010fc67:	6a 20                	push   $0x20
c010fc69:	eb 6f                	jmp    c010fcda <isr_save>

c010fc6b <isr_33>:
c010fc6b:	6a 00                	push   $0x0
c010fc6d:	6a 21                	push   $0x21
c010fc6f:	eb 69                	jmp    c010fcda <isr_save>

c010fc71 <isr_34>:
c010fc71:	6a 00                	push   $0x0
c010fc73:	6a 22                	push   $0x22
c010fc75:	eb 63                	jmp    c010fcda <isr_save>

c010fc77 <isr_35>:
c010fc77:	6a 00                	push   $0x0
c010fc79:	6a 23                	push   $0x23
c010fc7b:	eb 5d                	jmp    c010fcda <isr_save>

c010fc7d <isr_36>:
c010fc7d:	6a 00                	push   $0x0
c010fc7f:	6a 24                	push   $0x24
c010fc81:	eb 57                	jmp    c010fcda <isr_save>

c010fc83 <isr_37>:
c010fc83:	6a 00                	push   $0x0
c010fc85:	6a 25                	push   $0x25
c010fc87:	eb 51                	jmp    c010fcda <isr_save>

c010fc89 <isr_38>:
c010fc89:	6a 00                	push   $0x0
c010fc8b:	6a 26                	push   $0x26
c010fc8d:	eb 4b                	jmp    c010fcda <isr_save>

c010fc8f <isr_39>:
c010fc8f:	6a 00                	push   $0x0
c010fc91:	6a 27                	push   $0x27
c010fc93:	eb 45                	jmp    c010fcda <isr_save>

c010fc95 <isr_40>:
c010fc95:	6a 00                	push   $0x0
c010fc97:	6a 28                	push   $0x28
c010fc99:	eb 3f                	jmp    c010fcda <isr_save>

c010fc9b <isr_41>:
c010fc9b:	6a 00                	push   $0x0
c010fc9d:	6a 29                	push   $0x29
c010fc9f:	eb 39                	jmp    c010fcda <isr_save>

c010fca1 <isr_42>:
c010fca1:	6a 00                	push   $0x0
c010fca3:	6a 2a                	push   $0x2a
c010fca5:	eb 33                	jmp    c010fcda <isr_save>

c010fca7 <isr_43>:
c010fca7:	6a 00                	push   $0x0
c010fca9:	6a 2b                	push   $0x2b
c010fcab:	eb 2d                	jmp    c010fcda <isr_save>

c010fcad <isr_44>:
c010fcad:	6a 00                	push   $0x0
c010fcaf:	6a 2c                	push   $0x2c
c010fcb1:	eb 27                	jmp    c010fcda <isr_save>

c010fcb3 <isr_45>:
c010fcb3:	6a 00                	push   $0x0
c010fcb5:	6a 2d                	push   $0x2d
c010fcb7:	eb 21                	jmp    c010fcda <isr_save>

c010fcb9 <isr_46>:
c010fcb9:	6a 00                	push   $0x0
c010fcbb:	6a 2e                	push   $0x2e
c010fcbd:	eb 1b                	jmp    c010fcda <isr_save>

c010fcbf <isr_47>:
c010fcbf:	6a 00                	push   $0x0
c010fcc1:	6a 2f                	push   $0x2f
c010fcc3:	eb 15                	jmp    c010fcda <isr_save>

c010fcc5 <isr_112>:
c010fcc5:	6a 00                	push   $0x0
c010fcc7:	6a 70                	push   $0x70
c010fcc9:	eb 0f                	jmp    c010fcda <isr_save>

c010fccb <isr_128>:
c010fccb:	6a 00                	push   $0x0
c010fccd:	68 80 00 00 00       	push   $0x80
c010fcd2:	eb 06                	jmp    c010fcda <isr_save>

c010fcd4 <isr_pci>:
c010fcd4:	6a 00                	push   $0x0
c010fcd6:	6a 32                	push   $0x32
c010fcd8:	eb 00                	jmp    c010fcda <isr_save>

c010fcda <isr_save>:
c010fcda:	50                   	push   %eax
c010fcdb:	51                   	push   %ecx
c010fcdc:	52                   	push   %edx
c010fcdd:	53                   	push   %ebx
c010fcde:	55                   	push   %ebp
c010fcdf:	56                   	push   %esi
c010fce0:	57                   	push   %edi
c010fce1:	1e                   	push   %ds
c010fce2:	06                   	push   %es
c010fce3:	0f a0                	push   %fs
c010fce5:	0f a8                	push   %gs
c010fce7:	66 ba 10 00          	mov    $0x10,%dx
c010fceb:	8e da                	mov    %edx,%ds
c010fced:	8e c2                	mov    %edx,%es
c010fcef:	8e e2                	mov    %edx,%fs
c010fcf1:	8e ea                	mov    %edx,%gs
c010fcf3:	89 e2                	mov    %esp,%edx
c010fcf5:	bc ff ff ff ff       	mov    $0xffffffff,%esp
c010fcfa:	52                   	push   %edx
c010fcfb:	e8 d1 e1 ff ff       	call   c010ded1 <irq_handler>
c010fd00:	89 c4                	mov    %eax,%esp
c010fd02:	0f a9                	pop    %gs
c010fd04:	0f a1                	pop    %fs
c010fd06:	07                   	pop    %es
c010fd07:	1f                   	pop    %ds
c010fd08:	5f                   	pop    %edi
c010fd09:	5e                   	pop    %esi
c010fd0a:	5d                   	pop    %ebp
c010fd0b:	5b                   	pop    %ebx
c010fd0c:	5a                   	pop    %edx
c010fd0d:	59                   	pop    %ecx
c010fd0e:	58                   	pop    %eax
c010fd0f:	83 c4 08             	add    $0x8,%esp
c010fd12:	cf                   	iret   
